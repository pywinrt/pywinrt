// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.UI.Notifications.h"


namespace py::cpp::Windows::UI::Notifications
{
    struct module_state
    {
        PyObject* type_AdaptiveNotificationContentKind;
        PyObject* type_BadgeTemplateType;
        PyObject* type_NotificationKinds;
        PyObject* type_NotificationMirroring;
        PyObject* type_NotificationSetting;
        PyObject* type_NotificationUpdateResult;
        PyObject* type_PeriodicUpdateRecurrence;
        PyObject* type_TileFlyoutTemplateType;
        PyObject* type_TileTemplateType;
        PyObject* type_ToastDismissalReason;
        PyObject* type_ToastHistoryChangedType;
        PyObject* type_ToastNotificationMode;
        PyObject* type_ToastNotificationPriority;
        PyObject* type_ToastTemplateType;
        PyObject* type_UserNotificationChangedKind;
        PyTypeObject* type_AdaptiveNotificationText;
        PyTypeObject* type_BadgeNotification;
        PyTypeObject* type_BadgeUpdateManager;
        PyTypeObject* type_BadgeUpdateManagerForUser;
        PyTypeObject* type_BadgeUpdater;
        PyTypeObject* type_KnownAdaptiveNotificationHints;
        PyTypeObject* type_KnownAdaptiveNotificationTextStyles;
        PyTypeObject* type_KnownNotificationBindings;
        PyTypeObject* type_Notification;
        PyTypeObject* type_NotificationBinding;
        PyTypeObject* type_NotificationData;
        PyTypeObject* type_NotificationVisual;
        PyTypeObject* type_ScheduledTileNotification;
        PyTypeObject* type_ScheduledToastNotification;
        PyTypeObject* type_ScheduledToastNotificationShowingEventArgs;
        PyTypeObject* type_ShownTileNotification;
        PyTypeObject* type_TileFlyoutNotification;
        PyTypeObject* type_TileFlyoutUpdateManager;
        PyTypeObject* type_TileFlyoutUpdater;
        PyTypeObject* type_TileNotification;
        PyTypeObject* type_TileUpdateManager;
        PyTypeObject* type_TileUpdateManagerForUser;
        PyTypeObject* type_TileUpdater;
        PyTypeObject* type_ToastActivatedEventArgs;
        PyTypeObject* type_ToastCollection;
        PyTypeObject* type_ToastCollectionManager;
        PyTypeObject* type_ToastDismissedEventArgs;
        PyTypeObject* type_ToastFailedEventArgs;
        PyTypeObject* type_ToastNotification;
        PyTypeObject* type_ToastNotificationActionTriggerDetail;
        PyTypeObject* type_ToastNotificationHistory;
        PyTypeObject* type_ToastNotificationHistoryChangedTriggerDetail;
        PyTypeObject* type_ToastNotificationManager;
        PyTypeObject* type_ToastNotificationManagerForUser;
        PyTypeObject* type_ToastNotifier;
        PyTypeObject* type_UserNotification;
        PyTypeObject* type_UserNotificationChangedEventArgs;
        PyTypeObject* type_IAdaptiveNotificationContent;
    };

    static PyObject* register_AdaptiveNotificationContentKind(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_AdaptiveNotificationContentKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AdaptiveNotificationContentKind = type;
        Py_INCREF(state->type_AdaptiveNotificationContentKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_BadgeTemplateType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_BadgeTemplateType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_BadgeTemplateType = type;
        Py_INCREF(state->type_BadgeTemplateType);


        Py_RETURN_NONE;
    }

    static PyObject* register_NotificationKinds(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_NotificationKinds)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_NotificationKinds = type;
        Py_INCREF(state->type_NotificationKinds);


        Py_RETURN_NONE;
    }

    static PyObject* register_NotificationMirroring(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_NotificationMirroring)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_NotificationMirroring = type;
        Py_INCREF(state->type_NotificationMirroring);


        Py_RETURN_NONE;
    }

    static PyObject* register_NotificationSetting(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_NotificationSetting)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_NotificationSetting = type;
        Py_INCREF(state->type_NotificationSetting);


        Py_RETURN_NONE;
    }

    static PyObject* register_NotificationUpdateResult(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_NotificationUpdateResult)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_NotificationUpdateResult = type;
        Py_INCREF(state->type_NotificationUpdateResult);


        Py_RETURN_NONE;
    }

    static PyObject* register_PeriodicUpdateRecurrence(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_PeriodicUpdateRecurrence)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PeriodicUpdateRecurrence = type;
        Py_INCREF(state->type_PeriodicUpdateRecurrence);


        Py_RETURN_NONE;
    }

    static PyObject* register_TileFlyoutTemplateType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_TileFlyoutTemplateType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_TileFlyoutTemplateType = type;
        Py_INCREF(state->type_TileFlyoutTemplateType);


        Py_RETURN_NONE;
    }

    static PyObject* register_TileTemplateType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_TileTemplateType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_TileTemplateType = type;
        Py_INCREF(state->type_TileTemplateType);


        Py_RETURN_NONE;
    }

    static PyObject* register_ToastDismissalReason(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_ToastDismissalReason)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ToastDismissalReason = type;
        Py_INCREF(state->type_ToastDismissalReason);


        Py_RETURN_NONE;
    }

    static PyObject* register_ToastHistoryChangedType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_ToastHistoryChangedType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ToastHistoryChangedType = type;
        Py_INCREF(state->type_ToastHistoryChangedType);


        Py_RETURN_NONE;
    }

    static PyObject* register_ToastNotificationMode(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_ToastNotificationMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ToastNotificationMode = type;
        Py_INCREF(state->type_ToastNotificationMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_ToastNotificationPriority(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_ToastNotificationPriority)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ToastNotificationPriority = type;
        Py_INCREF(state->type_ToastNotificationPriority);


        Py_RETURN_NONE;
    }

    static PyObject* register_ToastTemplateType(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_ToastTemplateType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ToastTemplateType = type;
        Py_INCREF(state->type_ToastTemplateType);


        Py_RETURN_NONE;
    }

    static PyObject* register_UserNotificationChangedKind(PyObject* module, PyObject* type) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        WINRT_ASSERT(state);

        if (state->type_UserNotificationChangedKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_UserNotificationChangedKind = type;
        Py_INCREF(state->type_UserNotificationChangedKind);


        Py_RETURN_NONE;
    }

    // ----- AdaptiveNotificationText class --------------------
    static constexpr const char* const type_name_AdaptiveNotificationText = "AdaptiveNotificationText";

    static PyObject* _new_AdaptiveNotificationText(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Notifications::AdaptiveNotificationText instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AdaptiveNotificationText(py::wrapper::Windows::UI::Notifications::AdaptiveNotificationText* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AdaptiveNotificationText_get_Hints(py::wrapper::Windows::UI::Notifications::AdaptiveNotificationText* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.AdaptiveNotificationText", L"Hints"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Hints());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveNotificationText_get_Kind(py::wrapper::Windows::UI::Notifications::AdaptiveNotificationText* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.AdaptiveNotificationText", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveNotificationText_get_Text(py::wrapper::Windows::UI::Notifications::AdaptiveNotificationText* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.AdaptiveNotificationText", L"Text"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveNotificationText_put_Text(py::wrapper::Windows::UI::Notifications::AdaptiveNotificationText* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.AdaptiveNotificationText", L"Text"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AdaptiveNotificationText_get_Language(py::wrapper::Windows::UI::Notifications::AdaptiveNotificationText* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.AdaptiveNotificationText", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveNotificationText_put_Language(py::wrapper::Windows::UI::Notifications::AdaptiveNotificationText* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.AdaptiveNotificationText", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Language(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AdaptiveNotificationText(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::AdaptiveNotificationText>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AdaptiveNotificationText(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::AdaptiveNotificationText>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdaptiveNotificationText[] = {
        { "_assign_array_", _assign_array_AdaptiveNotificationText, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AdaptiveNotificationText), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AdaptiveNotificationText[] = {
        { "hints", reinterpret_cast<getter>(AdaptiveNotificationText_get_Hints), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(AdaptiveNotificationText_get_Kind), nullptr, nullptr, nullptr },
        { "text", reinterpret_cast<getter>(AdaptiveNotificationText_get_Text), reinterpret_cast<setter>(AdaptiveNotificationText_put_Text), nullptr, nullptr },
        { "language", reinterpret_cast<getter>(AdaptiveNotificationText_get_Language), reinterpret_cast<setter>(AdaptiveNotificationText_put_Language), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AdaptiveNotificationText[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AdaptiveNotificationText) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AdaptiveNotificationText) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AdaptiveNotificationText) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AdaptiveNotificationText) },
        { },
    };

    static PyType_Spec type_spec_AdaptiveNotificationText =
    {
        "_winrt_Windows_UI_Notifications.AdaptiveNotificationText",
        sizeof(py::wrapper::Windows::UI::Notifications::AdaptiveNotificationText),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdaptiveNotificationText
    };

    // ----- BadgeNotification class --------------------
    static constexpr const char* const type_name_BadgeNotification = "BadgeNotification";

    static PyObject* _new_BadgeNotification(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Data::Xml::Dom::XmlDocument>(args, 0);

                winrt::Windows::UI::Notifications::BadgeNotification instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BadgeNotification(py::wrapper::Windows::UI::Notifications::BadgeNotification* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BadgeNotification_get_ExpirationTime(py::wrapper::Windows::UI::Notifications::BadgeNotification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.BadgeNotification", L"ExpirationTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExpirationTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BadgeNotification_put_ExpirationTime(py::wrapper::Windows::UI::Notifications::BadgeNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.BadgeNotification", L"ExpirationTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.ExpirationTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BadgeNotification_get_Content(py::wrapper::Windows::UI::Notifications::BadgeNotification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.BadgeNotification", L"Content"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Content());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BadgeNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::BadgeNotification>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BadgeNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::BadgeNotification>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BadgeNotification[] = {
        { "_assign_array_", _assign_array_BadgeNotification, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BadgeNotification), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BadgeNotification[] = {
        { "expiration_time", reinterpret_cast<getter>(BadgeNotification_get_ExpirationTime), reinterpret_cast<setter>(BadgeNotification_put_ExpirationTime), nullptr, nullptr },
        { "content", reinterpret_cast<getter>(BadgeNotification_get_Content), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BadgeNotification[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BadgeNotification) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BadgeNotification) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BadgeNotification) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BadgeNotification) },
        { },
    };

    static PyType_Spec type_spec_BadgeNotification =
    {
        "_winrt_Windows_UI_Notifications.BadgeNotification",
        sizeof(py::wrapper::Windows::UI::Notifications::BadgeNotification),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BadgeNotification
    };

    // ----- BadgeUpdateManager class --------------------
    static constexpr const char* const type_name_BadgeUpdateManager = "BadgeUpdateManager";

    static PyObject* _new_BadgeUpdateManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BadgeUpdateManager);
        return nullptr;
    }

    static PyObject* BadgeUpdateManager_CreateBadgeUpdaterForApplication(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.BadgeUpdateManager", L"CreateBadgeUpdaterForApplication", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::UI::Notifications::BadgeUpdateManager::CreateBadgeUpdaterForApplication());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.BadgeUpdateManager", L"CreateBadgeUpdaterForApplication", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::UI::Notifications::BadgeUpdateManager::CreateBadgeUpdaterForApplication(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BadgeUpdateManager_CreateBadgeUpdaterForSecondaryTile(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.BadgeUpdateManager", L"CreateBadgeUpdaterForSecondaryTile", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::UI::Notifications::BadgeUpdateManager::CreateBadgeUpdaterForSecondaryTile(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BadgeUpdateManager_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.BadgeUpdateManager", L"GetForUser", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::UI::Notifications::BadgeUpdateManager::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BadgeUpdateManager_GetTemplateContent(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.BadgeUpdateManager", L"GetTemplateContent", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::BadgeTemplateType>(args, 0);

                return py::convert(winrt::Windows::UI::Notifications::BadgeUpdateManager::GetTemplateContent(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_BadgeUpdateManager[] = {
        { "create_badge_updater_for_application", reinterpret_cast<PyCFunction>(BadgeUpdateManager_CreateBadgeUpdaterForApplication), METH_VARARGS | METH_STATIC, nullptr },
        { "create_badge_updater_for_secondary_tile", reinterpret_cast<PyCFunction>(BadgeUpdateManager_CreateBadgeUpdaterForSecondaryTile), METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_user", reinterpret_cast<PyCFunction>(BadgeUpdateManager_GetForUser), METH_VARARGS | METH_STATIC, nullptr },
        { "get_template_content", reinterpret_cast<PyCFunction>(BadgeUpdateManager_GetTemplateContent), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BadgeUpdateManager[] = {
        { }
    };

    static PyType_Slot _type_slots_BadgeUpdateManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BadgeUpdateManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BadgeUpdateManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BadgeUpdateManager) },
        { },
    };

    static PyType_Spec type_spec_BadgeUpdateManager =
    {
        "_winrt_Windows_UI_Notifications.BadgeUpdateManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BadgeUpdateManager
    };

    // ----- BadgeUpdateManagerForUser class --------------------
    static constexpr const char* const type_name_BadgeUpdateManagerForUser = "BadgeUpdateManagerForUser";

    static PyObject* _new_BadgeUpdateManagerForUser(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BadgeUpdateManagerForUser);
        return nullptr;
    }

    static void _dealloc_BadgeUpdateManagerForUser(py::wrapper::Windows::UI::Notifications::BadgeUpdateManagerForUser* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BadgeUpdateManagerForUser_CreateBadgeUpdaterForApplication(py::wrapper::Windows::UI::Notifications::BadgeUpdateManagerForUser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.BadgeUpdateManagerForUser", L"CreateBadgeUpdaterForApplication", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateBadgeUpdaterForApplication());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.BadgeUpdateManagerForUser", L"CreateBadgeUpdaterForApplication", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateBadgeUpdaterForApplication(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BadgeUpdateManagerForUser_CreateBadgeUpdaterForSecondaryTile(py::wrapper::Windows::UI::Notifications::BadgeUpdateManagerForUser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.BadgeUpdateManagerForUser", L"CreateBadgeUpdaterForSecondaryTile", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateBadgeUpdaterForSecondaryTile(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BadgeUpdateManagerForUser_get_User(py::wrapper::Windows::UI::Notifications::BadgeUpdateManagerForUser* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.BadgeUpdateManagerForUser", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BadgeUpdateManagerForUser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::BadgeUpdateManagerForUser>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BadgeUpdateManagerForUser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::BadgeUpdateManagerForUser>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BadgeUpdateManagerForUser[] = {
        { "create_badge_updater_for_application", reinterpret_cast<PyCFunction>(BadgeUpdateManagerForUser_CreateBadgeUpdaterForApplication), METH_VARARGS, nullptr },
        { "create_badge_updater_for_secondary_tile", reinterpret_cast<PyCFunction>(BadgeUpdateManagerForUser_CreateBadgeUpdaterForSecondaryTile), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BadgeUpdateManagerForUser, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BadgeUpdateManagerForUser), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BadgeUpdateManagerForUser[] = {
        { "user", reinterpret_cast<getter>(BadgeUpdateManagerForUser_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BadgeUpdateManagerForUser[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BadgeUpdateManagerForUser) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BadgeUpdateManagerForUser) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BadgeUpdateManagerForUser) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BadgeUpdateManagerForUser) },
        { },
    };

    static PyType_Spec type_spec_BadgeUpdateManagerForUser =
    {
        "_winrt_Windows_UI_Notifications.BadgeUpdateManagerForUser",
        sizeof(py::wrapper::Windows::UI::Notifications::BadgeUpdateManagerForUser),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BadgeUpdateManagerForUser
    };

    // ----- BadgeUpdater class --------------------
    static constexpr const char* const type_name_BadgeUpdater = "BadgeUpdater";

    static PyObject* _new_BadgeUpdater(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BadgeUpdater);
        return nullptr;
    }

    static void _dealloc_BadgeUpdater(py::wrapper::Windows::UI::Notifications::BadgeUpdater* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BadgeUpdater_Clear(py::wrapper::Windows::UI::Notifications::BadgeUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.BadgeUpdater", L"Clear", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BadgeUpdater_StartPeriodicUpdate(py::wrapper::Windows::UI::Notifications::BadgeUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.BadgeUpdater", L"StartPeriodicUpdate", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Notifications::PeriodicUpdateRecurrence>(args, 1);

                self->obj.StartPeriodicUpdate(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.BadgeUpdater", L"StartPeriodicUpdate", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Notifications::PeriodicUpdateRecurrence>(args, 2);

                self->obj.StartPeriodicUpdate(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BadgeUpdater_StopPeriodicUpdate(py::wrapper::Windows::UI::Notifications::BadgeUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.BadgeUpdater", L"StopPeriodicUpdate", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.StopPeriodicUpdate();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BadgeUpdater_Update(py::wrapper::Windows::UI::Notifications::BadgeUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.BadgeUpdater", L"Update", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::BadgeNotification>(args, 0);

                self->obj.Update(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_BadgeUpdater(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::BadgeUpdater>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BadgeUpdater(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::BadgeUpdater>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BadgeUpdater[] = {
        { "clear", reinterpret_cast<PyCFunction>(BadgeUpdater_Clear), METH_VARARGS, nullptr },
        { "start_periodic_update", reinterpret_cast<PyCFunction>(BadgeUpdater_StartPeriodicUpdate), METH_VARARGS, nullptr },
        { "stop_periodic_update", reinterpret_cast<PyCFunction>(BadgeUpdater_StopPeriodicUpdate), METH_VARARGS, nullptr },
        { "update", reinterpret_cast<PyCFunction>(BadgeUpdater_Update), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BadgeUpdater, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BadgeUpdater), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BadgeUpdater[] = {
        { }
    };

    static PyType_Slot _type_slots_BadgeUpdater[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BadgeUpdater) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BadgeUpdater) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BadgeUpdater) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BadgeUpdater) },
        { },
    };

    static PyType_Spec type_spec_BadgeUpdater =
    {
        "_winrt_Windows_UI_Notifications.BadgeUpdater",
        sizeof(py::wrapper::Windows::UI::Notifications::BadgeUpdater),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BadgeUpdater
    };

    // ----- KnownAdaptiveNotificationHints class --------------------
    static constexpr const char* const type_name_KnownAdaptiveNotificationHints = "KnownAdaptiveNotificationHints";

    static PyObject* _new_KnownAdaptiveNotificationHints(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KnownAdaptiveNotificationHints);
        return nullptr;
    }

    static PyObject* KnownAdaptiveNotificationHints_get_Align(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationHints", L"Align"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationHints::Align());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationHints_get_MaxLines(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationHints", L"MaxLines"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationHints::MaxLines());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationHints_get_MinLines(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationHints", L"MinLines"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationHints::MinLines());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationHints_get_Style(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationHints", L"Style"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationHints::Style());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationHints_get_TextStacking(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationHints", L"TextStacking"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationHints::TextStacking());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationHints_get_Wrap(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationHints", L"Wrap"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationHints::Wrap());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownAdaptiveNotificationHints[] = {
        { }
    };

    static PyGetSetDef _getset_KnownAdaptiveNotificationHints[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownAdaptiveNotificationHints[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownAdaptiveNotificationHints) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownAdaptiveNotificationHints) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownAdaptiveNotificationHints) },
        { },
    };

    static PyType_Spec type_spec_KnownAdaptiveNotificationHints =
    {
        "_winrt_Windows_UI_Notifications.KnownAdaptiveNotificationHints",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownAdaptiveNotificationHints
    };

    static PyGetSetDef getset_KnownAdaptiveNotificationHints_Meta[] = {
        { "align", reinterpret_cast<getter>(KnownAdaptiveNotificationHints_get_Align), nullptr, nullptr, nullptr },
        { "max_lines", reinterpret_cast<getter>(KnownAdaptiveNotificationHints_get_MaxLines), nullptr, nullptr, nullptr },
        { "min_lines", reinterpret_cast<getter>(KnownAdaptiveNotificationHints_get_MinLines), nullptr, nullptr, nullptr },
        { "style", reinterpret_cast<getter>(KnownAdaptiveNotificationHints_get_Style), nullptr, nullptr, nullptr },
        { "text_stacking", reinterpret_cast<getter>(KnownAdaptiveNotificationHints_get_TextStacking), nullptr, nullptr, nullptr },
        { "wrap", reinterpret_cast<getter>(KnownAdaptiveNotificationHints_get_Wrap), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_KnownAdaptiveNotificationHints_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownAdaptiveNotificationHints_Meta) },
        { }
    };

    static PyType_Spec type_spec_KnownAdaptiveNotificationHints_Meta =
    {
        "_winrt_Windows_UI_Notifications.KnownAdaptiveNotificationHints_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownAdaptiveNotificationHints_Meta
    };

    // ----- KnownAdaptiveNotificationTextStyles class --------------------
    static constexpr const char* const type_name_KnownAdaptiveNotificationTextStyles = "KnownAdaptiveNotificationTextStyles";

    static PyObject* _new_KnownAdaptiveNotificationTextStyles(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KnownAdaptiveNotificationTextStyles);
        return nullptr;
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_Base(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationTextStyles", L"Base"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::Base());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_BaseSubtle(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationTextStyles", L"BaseSubtle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::BaseSubtle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_Body(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationTextStyles", L"Body"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::Body());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_BodySubtle(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationTextStyles", L"BodySubtle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::BodySubtle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_Caption(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationTextStyles", L"Caption"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::Caption());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_CaptionSubtle(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationTextStyles", L"CaptionSubtle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::CaptionSubtle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_Header(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationTextStyles", L"Header"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::Header());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_HeaderNumeral(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationTextStyles", L"HeaderNumeral"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::HeaderNumeral());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_HeaderNumeralSubtle(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationTextStyles", L"HeaderNumeralSubtle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::HeaderNumeralSubtle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_HeaderSubtle(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationTextStyles", L"HeaderSubtle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::HeaderSubtle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_Subheader(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationTextStyles", L"Subheader"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::Subheader());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_SubheaderNumeral(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationTextStyles", L"SubheaderNumeral"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::SubheaderNumeral());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_SubheaderNumeralSubtle(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationTextStyles", L"SubheaderNumeralSubtle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::SubheaderNumeralSubtle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_SubheaderSubtle(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationTextStyles", L"SubheaderSubtle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::SubheaderSubtle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_Subtitle(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationTextStyles", L"Subtitle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::Subtitle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_SubtitleSubtle(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationTextStyles", L"SubtitleSubtle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::SubtitleSubtle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_Title(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationTextStyles", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_TitleNumeral(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationTextStyles", L"TitleNumeral"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::TitleNumeral());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownAdaptiveNotificationTextStyles_get_TitleSubtle(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownAdaptiveNotificationTextStyles", L"TitleSubtle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles::TitleSubtle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownAdaptiveNotificationTextStyles[] = {
        { }
    };

    static PyGetSetDef _getset_KnownAdaptiveNotificationTextStyles[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownAdaptiveNotificationTextStyles[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownAdaptiveNotificationTextStyles) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownAdaptiveNotificationTextStyles) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownAdaptiveNotificationTextStyles) },
        { },
    };

    static PyType_Spec type_spec_KnownAdaptiveNotificationTextStyles =
    {
        "_winrt_Windows_UI_Notifications.KnownAdaptiveNotificationTextStyles",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownAdaptiveNotificationTextStyles
    };

    static PyGetSetDef getset_KnownAdaptiveNotificationTextStyles_Meta[] = {
        { "base", reinterpret_cast<getter>(KnownAdaptiveNotificationTextStyles_get_Base), nullptr, nullptr, nullptr },
        { "base_subtle", reinterpret_cast<getter>(KnownAdaptiveNotificationTextStyles_get_BaseSubtle), nullptr, nullptr, nullptr },
        { "body", reinterpret_cast<getter>(KnownAdaptiveNotificationTextStyles_get_Body), nullptr, nullptr, nullptr },
        { "body_subtle", reinterpret_cast<getter>(KnownAdaptiveNotificationTextStyles_get_BodySubtle), nullptr, nullptr, nullptr },
        { "caption", reinterpret_cast<getter>(KnownAdaptiveNotificationTextStyles_get_Caption), nullptr, nullptr, nullptr },
        { "caption_subtle", reinterpret_cast<getter>(KnownAdaptiveNotificationTextStyles_get_CaptionSubtle), nullptr, nullptr, nullptr },
        { "header", reinterpret_cast<getter>(KnownAdaptiveNotificationTextStyles_get_Header), nullptr, nullptr, nullptr },
        { "header_numeral", reinterpret_cast<getter>(KnownAdaptiveNotificationTextStyles_get_HeaderNumeral), nullptr, nullptr, nullptr },
        { "header_numeral_subtle", reinterpret_cast<getter>(KnownAdaptiveNotificationTextStyles_get_HeaderNumeralSubtle), nullptr, nullptr, nullptr },
        { "header_subtle", reinterpret_cast<getter>(KnownAdaptiveNotificationTextStyles_get_HeaderSubtle), nullptr, nullptr, nullptr },
        { "subheader", reinterpret_cast<getter>(KnownAdaptiveNotificationTextStyles_get_Subheader), nullptr, nullptr, nullptr },
        { "subheader_numeral", reinterpret_cast<getter>(KnownAdaptiveNotificationTextStyles_get_SubheaderNumeral), nullptr, nullptr, nullptr },
        { "subheader_numeral_subtle", reinterpret_cast<getter>(KnownAdaptiveNotificationTextStyles_get_SubheaderNumeralSubtle), nullptr, nullptr, nullptr },
        { "subheader_subtle", reinterpret_cast<getter>(KnownAdaptiveNotificationTextStyles_get_SubheaderSubtle), nullptr, nullptr, nullptr },
        { "subtitle", reinterpret_cast<getter>(KnownAdaptiveNotificationTextStyles_get_Subtitle), nullptr, nullptr, nullptr },
        { "subtitle_subtle", reinterpret_cast<getter>(KnownAdaptiveNotificationTextStyles_get_SubtitleSubtle), nullptr, nullptr, nullptr },
        { "title", reinterpret_cast<getter>(KnownAdaptiveNotificationTextStyles_get_Title), nullptr, nullptr, nullptr },
        { "title_numeral", reinterpret_cast<getter>(KnownAdaptiveNotificationTextStyles_get_TitleNumeral), nullptr, nullptr, nullptr },
        { "title_subtle", reinterpret_cast<getter>(KnownAdaptiveNotificationTextStyles_get_TitleSubtle), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_KnownAdaptiveNotificationTextStyles_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownAdaptiveNotificationTextStyles_Meta) },
        { }
    };

    static PyType_Spec type_spec_KnownAdaptiveNotificationTextStyles_Meta =
    {
        "_winrt_Windows_UI_Notifications.KnownAdaptiveNotificationTextStyles_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownAdaptiveNotificationTextStyles_Meta
    };

    // ----- KnownNotificationBindings class --------------------
    static constexpr const char* const type_name_KnownNotificationBindings = "KnownNotificationBindings";

    static PyObject* _new_KnownNotificationBindings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KnownNotificationBindings);
        return nullptr;
    }

    static PyObject* KnownNotificationBindings_get_ToastGeneric(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.KnownNotificationBindings", L"ToastGeneric"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Notifications::KnownNotificationBindings::ToastGeneric());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownNotificationBindings[] = {
        { }
    };

    static PyGetSetDef _getset_KnownNotificationBindings[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownNotificationBindings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownNotificationBindings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownNotificationBindings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownNotificationBindings) },
        { },
    };

    static PyType_Spec type_spec_KnownNotificationBindings =
    {
        "_winrt_Windows_UI_Notifications.KnownNotificationBindings",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownNotificationBindings
    };

    static PyGetSetDef getset_KnownNotificationBindings_Meta[] = {
        { "toast_generic", reinterpret_cast<getter>(KnownNotificationBindings_get_ToastGeneric), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_KnownNotificationBindings_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownNotificationBindings_Meta) },
        { }
    };

    static PyType_Spec type_spec_KnownNotificationBindings_Meta =
    {
        "_winrt_Windows_UI_Notifications.KnownNotificationBindings_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownNotificationBindings_Meta
    };

    // ----- Notification class --------------------
    static constexpr const char* const type_name_Notification = "Notification";

    static PyObject* _new_Notification(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Notifications::Notification instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Notification(py::wrapper::Windows::UI::Notifications::Notification* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Notification_get_Visual(py::wrapper::Windows::UI::Notifications::Notification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.Notification", L"Visual"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Visual());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Notification_put_Visual(py::wrapper::Windows::UI::Notifications::Notification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.Notification", L"Visual"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::NotificationVisual>(arg);

            self->obj.Visual(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Notification_get_ExpirationTime(py::wrapper::Windows::UI::Notifications::Notification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.Notification", L"ExpirationTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExpirationTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Notification_put_ExpirationTime(py::wrapper::Windows::UI::Notifications::Notification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.Notification", L"ExpirationTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.ExpirationTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_Notification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::Notification>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Notification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::Notification>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Notification[] = {
        { "_assign_array_", _assign_array_Notification, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Notification), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Notification[] = {
        { "visual", reinterpret_cast<getter>(Notification_get_Visual), reinterpret_cast<setter>(Notification_put_Visual), nullptr, nullptr },
        { "expiration_time", reinterpret_cast<getter>(Notification_get_ExpirationTime), reinterpret_cast<setter>(Notification_put_ExpirationTime), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Notification[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Notification) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Notification) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Notification) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Notification) },
        { },
    };

    static PyType_Spec type_spec_Notification =
    {
        "_winrt_Windows_UI_Notifications.Notification",
        sizeof(py::wrapper::Windows::UI::Notifications::Notification),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Notification
    };

    // ----- NotificationBinding class --------------------
    static constexpr const char* const type_name_NotificationBinding = "NotificationBinding";

    static PyObject* _new_NotificationBinding(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_NotificationBinding);
        return nullptr;
    }

    static void _dealloc_NotificationBinding(py::wrapper::Windows::UI::Notifications::NotificationBinding* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NotificationBinding_GetTextElements(py::wrapper::Windows::UI::Notifications::NotificationBinding* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.NotificationBinding", L"GetTextElements", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetTextElements());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NotificationBinding_get_Template(py::wrapper::Windows::UI::Notifications::NotificationBinding* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.NotificationBinding", L"Template"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Template());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NotificationBinding_put_Template(py::wrapper::Windows::UI::Notifications::NotificationBinding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.NotificationBinding", L"Template"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Template(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NotificationBinding_get_Language(py::wrapper::Windows::UI::Notifications::NotificationBinding* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.NotificationBinding", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NotificationBinding_put_Language(py::wrapper::Windows::UI::Notifications::NotificationBinding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.NotificationBinding", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Language(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NotificationBinding_get_Hints(py::wrapper::Windows::UI::Notifications::NotificationBinding* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.NotificationBinding", L"Hints"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Hints());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NotificationBinding(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::NotificationBinding>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NotificationBinding(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::NotificationBinding>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NotificationBinding[] = {
        { "get_text_elements", reinterpret_cast<PyCFunction>(NotificationBinding_GetTextElements), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_NotificationBinding, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NotificationBinding), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NotificationBinding[] = {
        { "template", reinterpret_cast<getter>(NotificationBinding_get_Template), reinterpret_cast<setter>(NotificationBinding_put_Template), nullptr, nullptr },
        { "language", reinterpret_cast<getter>(NotificationBinding_get_Language), reinterpret_cast<setter>(NotificationBinding_put_Language), nullptr, nullptr },
        { "hints", reinterpret_cast<getter>(NotificationBinding_get_Hints), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NotificationBinding[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NotificationBinding) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NotificationBinding) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NotificationBinding) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NotificationBinding) },
        { },
    };

    static PyType_Spec type_spec_NotificationBinding =
    {
        "_winrt_Windows_UI_Notifications.NotificationBinding",
        sizeof(py::wrapper::Windows::UI::Notifications::NotificationBinding),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NotificationBinding
    };

    // ----- NotificationData class --------------------
    static constexpr const char* const type_name_NotificationData = "NotificationData";

    static PyObject* _new_NotificationData(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::hstring>>>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                winrt::Windows::UI::Notifications::NotificationData instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::hstring>>>(args, 0);

                winrt::Windows::UI::Notifications::NotificationData instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Notifications::NotificationData instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NotificationData(py::wrapper::Windows::UI::Notifications::NotificationData* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NotificationData_get_SequenceNumber(py::wrapper::Windows::UI::Notifications::NotificationData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.NotificationData", L"SequenceNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SequenceNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NotificationData_put_SequenceNumber(py::wrapper::Windows::UI::Notifications::NotificationData* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.NotificationData", L"SequenceNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.SequenceNumber(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NotificationData_get_Values(py::wrapper::Windows::UI::Notifications::NotificationData* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.NotificationData", L"Values"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Values());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NotificationData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::NotificationData>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NotificationData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::NotificationData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NotificationData[] = {
        { "_assign_array_", _assign_array_NotificationData, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NotificationData), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NotificationData[] = {
        { "sequence_number", reinterpret_cast<getter>(NotificationData_get_SequenceNumber), reinterpret_cast<setter>(NotificationData_put_SequenceNumber), nullptr, nullptr },
        { "values", reinterpret_cast<getter>(NotificationData_get_Values), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NotificationData[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NotificationData) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NotificationData) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NotificationData) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NotificationData) },
        { },
    };

    static PyType_Spec type_spec_NotificationData =
    {
        "_winrt_Windows_UI_Notifications.NotificationData",
        sizeof(py::wrapper::Windows::UI::Notifications::NotificationData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NotificationData
    };

    // ----- NotificationVisual class --------------------
    static constexpr const char* const type_name_NotificationVisual = "NotificationVisual";

    static PyObject* _new_NotificationVisual(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_NotificationVisual);
        return nullptr;
    }

    static void _dealloc_NotificationVisual(py::wrapper::Windows::UI::Notifications::NotificationVisual* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NotificationVisual_GetBinding(py::wrapper::Windows::UI::Notifications::NotificationVisual* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.NotificationVisual", L"GetBinding", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetBinding(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NotificationVisual_get_Language(py::wrapper::Windows::UI::Notifications::NotificationVisual* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.NotificationVisual", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NotificationVisual_put_Language(py::wrapper::Windows::UI::Notifications::NotificationVisual* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.NotificationVisual", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Language(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NotificationVisual_get_Bindings(py::wrapper::Windows::UI::Notifications::NotificationVisual* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.NotificationVisual", L"Bindings"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Bindings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NotificationVisual(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::NotificationVisual>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NotificationVisual(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::NotificationVisual>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NotificationVisual[] = {
        { "get_binding", reinterpret_cast<PyCFunction>(NotificationVisual_GetBinding), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_NotificationVisual, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NotificationVisual), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NotificationVisual[] = {
        { "language", reinterpret_cast<getter>(NotificationVisual_get_Language), reinterpret_cast<setter>(NotificationVisual_put_Language), nullptr, nullptr },
        { "bindings", reinterpret_cast<getter>(NotificationVisual_get_Bindings), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NotificationVisual[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NotificationVisual) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NotificationVisual) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NotificationVisual) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NotificationVisual) },
        { },
    };

    static PyType_Spec type_spec_NotificationVisual =
    {
        "_winrt_Windows_UI_Notifications.NotificationVisual",
        sizeof(py::wrapper::Windows::UI::Notifications::NotificationVisual),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NotificationVisual
    };

    // ----- ScheduledTileNotification class --------------------
    static constexpr const char* const type_name_ScheduledTileNotification = "ScheduledTileNotification";

    static PyObject* _new_ScheduledTileNotification(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Data::Xml::Dom::XmlDocument>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);

                winrt::Windows::UI::Notifications::ScheduledTileNotification instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ScheduledTileNotification(py::wrapper::Windows::UI::Notifications::ScheduledTileNotification* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScheduledTileNotification_get_Tag(py::wrapper::Windows::UI::Notifications::ScheduledTileNotification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledTileNotification", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScheduledTileNotification_put_Tag(py::wrapper::Windows::UI::Notifications::ScheduledTileNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledTileNotification", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScheduledTileNotification_get_Id(py::wrapper::Windows::UI::Notifications::ScheduledTileNotification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledTileNotification", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScheduledTileNotification_put_Id(py::wrapper::Windows::UI::Notifications::ScheduledTileNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledTileNotification", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScheduledTileNotification_get_ExpirationTime(py::wrapper::Windows::UI::Notifications::ScheduledTileNotification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledTileNotification", L"ExpirationTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExpirationTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScheduledTileNotification_put_ExpirationTime(py::wrapper::Windows::UI::Notifications::ScheduledTileNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledTileNotification", L"ExpirationTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.ExpirationTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScheduledTileNotification_get_Content(py::wrapper::Windows::UI::Notifications::ScheduledTileNotification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledTileNotification", L"Content"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Content());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScheduledTileNotification_get_DeliveryTime(py::wrapper::Windows::UI::Notifications::ScheduledTileNotification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledTileNotification", L"DeliveryTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeliveryTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ScheduledTileNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::ScheduledTileNotification>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScheduledTileNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ScheduledTileNotification>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScheduledTileNotification[] = {
        { "_assign_array_", _assign_array_ScheduledTileNotification, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScheduledTileNotification), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScheduledTileNotification[] = {
        { "tag", reinterpret_cast<getter>(ScheduledTileNotification_get_Tag), reinterpret_cast<setter>(ScheduledTileNotification_put_Tag), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ScheduledTileNotification_get_Id), reinterpret_cast<setter>(ScheduledTileNotification_put_Id), nullptr, nullptr },
        { "expiration_time", reinterpret_cast<getter>(ScheduledTileNotification_get_ExpirationTime), reinterpret_cast<setter>(ScheduledTileNotification_put_ExpirationTime), nullptr, nullptr },
        { "content", reinterpret_cast<getter>(ScheduledTileNotification_get_Content), nullptr, nullptr, nullptr },
        { "delivery_time", reinterpret_cast<getter>(ScheduledTileNotification_get_DeliveryTime), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ScheduledTileNotification[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScheduledTileNotification) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScheduledTileNotification) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScheduledTileNotification) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScheduledTileNotification) },
        { },
    };

    static PyType_Spec type_spec_ScheduledTileNotification =
    {
        "_winrt_Windows_UI_Notifications.ScheduledTileNotification",
        sizeof(py::wrapper::Windows::UI::Notifications::ScheduledTileNotification),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScheduledTileNotification
    };

    // ----- ScheduledToastNotification class --------------------
    static constexpr const char* const type_name_ScheduledToastNotification = "ScheduledToastNotification";

    static PyObject* _new_ScheduledToastNotification(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Data::Xml::Dom::XmlDocument>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);

                winrt::Windows::UI::Notifications::ScheduledToastNotification instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Data::Xml::Dom::XmlDocument>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);

                winrt::Windows::UI::Notifications::ScheduledToastNotification instance{ param0, param1, param2, param3 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ScheduledToastNotification(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScheduledToastNotification_get_Id(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotification", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScheduledToastNotification_put_Id(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotification", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScheduledToastNotification_get_Content(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotification", L"Content"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Content());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScheduledToastNotification_get_DeliveryTime(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotification", L"DeliveryTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeliveryTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScheduledToastNotification_get_MaximumSnoozeCount(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotification", L"MaximumSnoozeCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaximumSnoozeCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScheduledToastNotification_get_SnoozeInterval(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotification", L"SnoozeInterval"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SnoozeInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScheduledToastNotification_get_Tag(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotification", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScheduledToastNotification_put_Tag(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotification", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScheduledToastNotification_get_SuppressPopup(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotification", L"SuppressPopup"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SuppressPopup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScheduledToastNotification_put_SuppressPopup(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotification", L"SuppressPopup"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.SuppressPopup(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScheduledToastNotification_get_Group(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotification", L"Group"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Group());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScheduledToastNotification_put_Group(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotification", L"Group"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Group(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScheduledToastNotification_get_RemoteId(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotification", L"RemoteId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RemoteId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScheduledToastNotification_put_RemoteId(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotification", L"RemoteId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.RemoteId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScheduledToastNotification_get_NotificationMirroring(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotification", L"NotificationMirroring"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NotificationMirroring());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScheduledToastNotification_put_NotificationMirroring(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotification", L"NotificationMirroring"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::NotificationMirroring>(arg);

            self->obj.NotificationMirroring(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScheduledToastNotification_get_ExpirationTime(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotification", L"ExpirationTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExpirationTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScheduledToastNotification_put_ExpirationTime(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotification", L"ExpirationTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.ExpirationTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ScheduledToastNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::ScheduledToastNotification>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScheduledToastNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ScheduledToastNotification>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScheduledToastNotification[] = {
        { "_assign_array_", _assign_array_ScheduledToastNotification, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScheduledToastNotification), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScheduledToastNotification[] = {
        { "id", reinterpret_cast<getter>(ScheduledToastNotification_get_Id), reinterpret_cast<setter>(ScheduledToastNotification_put_Id), nullptr, nullptr },
        { "content", reinterpret_cast<getter>(ScheduledToastNotification_get_Content), nullptr, nullptr, nullptr },
        { "delivery_time", reinterpret_cast<getter>(ScheduledToastNotification_get_DeliveryTime), nullptr, nullptr, nullptr },
        { "maximum_snooze_count", reinterpret_cast<getter>(ScheduledToastNotification_get_MaximumSnoozeCount), nullptr, nullptr, nullptr },
        { "snooze_interval", reinterpret_cast<getter>(ScheduledToastNotification_get_SnoozeInterval), nullptr, nullptr, nullptr },
        { "tag", reinterpret_cast<getter>(ScheduledToastNotification_get_Tag), reinterpret_cast<setter>(ScheduledToastNotification_put_Tag), nullptr, nullptr },
        { "suppress_popup", reinterpret_cast<getter>(ScheduledToastNotification_get_SuppressPopup), reinterpret_cast<setter>(ScheduledToastNotification_put_SuppressPopup), nullptr, nullptr },
        { "group", reinterpret_cast<getter>(ScheduledToastNotification_get_Group), reinterpret_cast<setter>(ScheduledToastNotification_put_Group), nullptr, nullptr },
        { "remote_id", reinterpret_cast<getter>(ScheduledToastNotification_get_RemoteId), reinterpret_cast<setter>(ScheduledToastNotification_put_RemoteId), nullptr, nullptr },
        { "notification_mirroring", reinterpret_cast<getter>(ScheduledToastNotification_get_NotificationMirroring), reinterpret_cast<setter>(ScheduledToastNotification_put_NotificationMirroring), nullptr, nullptr },
        { "expiration_time", reinterpret_cast<getter>(ScheduledToastNotification_get_ExpirationTime), reinterpret_cast<setter>(ScheduledToastNotification_put_ExpirationTime), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ScheduledToastNotification[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScheduledToastNotification) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScheduledToastNotification) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScheduledToastNotification) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScheduledToastNotification) },
        { },
    };

    static PyType_Spec type_spec_ScheduledToastNotification =
    {
        "_winrt_Windows_UI_Notifications.ScheduledToastNotification",
        sizeof(py::wrapper::Windows::UI::Notifications::ScheduledToastNotification),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScheduledToastNotification
    };

    // ----- ScheduledToastNotificationShowingEventArgs class --------------------
    static constexpr const char* const type_name_ScheduledToastNotificationShowingEventArgs = "ScheduledToastNotificationShowingEventArgs";

    static PyObject* _new_ScheduledToastNotificationShowingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ScheduledToastNotificationShowingEventArgs);
        return nullptr;
    }

    static void _dealloc_ScheduledToastNotificationShowingEventArgs(py::wrapper::Windows::UI::Notifications::ScheduledToastNotificationShowingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScheduledToastNotificationShowingEventArgs_GetDeferral(py::wrapper::Windows::UI::Notifications::ScheduledToastNotificationShowingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ScheduledToastNotificationShowingEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ScheduledToastNotificationShowingEventArgs_get_Cancel(py::wrapper::Windows::UI::Notifications::ScheduledToastNotificationShowingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotificationShowingEventArgs", L"Cancel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Cancel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScheduledToastNotificationShowingEventArgs_put_Cancel(py::wrapper::Windows::UI::Notifications::ScheduledToastNotificationShowingEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotificationShowingEventArgs", L"Cancel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Cancel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScheduledToastNotificationShowingEventArgs_get_ScheduledToastNotification(py::wrapper::Windows::UI::Notifications::ScheduledToastNotificationShowingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ScheduledToastNotificationShowingEventArgs", L"ScheduledToastNotification"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ScheduledToastNotification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ScheduledToastNotificationShowingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::ScheduledToastNotificationShowingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScheduledToastNotificationShowingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ScheduledToastNotificationShowingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScheduledToastNotificationShowingEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(ScheduledToastNotificationShowingEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ScheduledToastNotificationShowingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScheduledToastNotificationShowingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScheduledToastNotificationShowingEventArgs[] = {
        { "cancel", reinterpret_cast<getter>(ScheduledToastNotificationShowingEventArgs_get_Cancel), reinterpret_cast<setter>(ScheduledToastNotificationShowingEventArgs_put_Cancel), nullptr, nullptr },
        { "scheduled_toast_notification", reinterpret_cast<getter>(ScheduledToastNotificationShowingEventArgs_get_ScheduledToastNotification), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ScheduledToastNotificationShowingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScheduledToastNotificationShowingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScheduledToastNotificationShowingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScheduledToastNotificationShowingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScheduledToastNotificationShowingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ScheduledToastNotificationShowingEventArgs =
    {
        "_winrt_Windows_UI_Notifications.ScheduledToastNotificationShowingEventArgs",
        sizeof(py::wrapper::Windows::UI::Notifications::ScheduledToastNotificationShowingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScheduledToastNotificationShowingEventArgs
    };

    // ----- ShownTileNotification class --------------------
    static constexpr const char* const type_name_ShownTileNotification = "ShownTileNotification";

    static PyObject* _new_ShownTileNotification(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ShownTileNotification);
        return nullptr;
    }

    static void _dealloc_ShownTileNotification(py::wrapper::Windows::UI::Notifications::ShownTileNotification* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ShownTileNotification_get_Arguments(py::wrapper::Windows::UI::Notifications::ShownTileNotification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ShownTileNotification", L"Arguments"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Arguments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ShownTileNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::ShownTileNotification>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ShownTileNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ShownTileNotification>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ShownTileNotification[] = {
        { "_assign_array_", _assign_array_ShownTileNotification, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ShownTileNotification), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ShownTileNotification[] = {
        { "arguments", reinterpret_cast<getter>(ShownTileNotification_get_Arguments), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ShownTileNotification[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ShownTileNotification) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ShownTileNotification) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ShownTileNotification) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ShownTileNotification) },
        { },
    };

    static PyType_Spec type_spec_ShownTileNotification =
    {
        "_winrt_Windows_UI_Notifications.ShownTileNotification",
        sizeof(py::wrapper::Windows::UI::Notifications::ShownTileNotification),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ShownTileNotification
    };

    // ----- TileFlyoutNotification class --------------------
    static constexpr const char* const type_name_TileFlyoutNotification = "TileFlyoutNotification";

    static PyObject* _new_TileFlyoutNotification(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Data::Xml::Dom::XmlDocument>(args, 0);

                winrt::Windows::UI::Notifications::TileFlyoutNotification instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TileFlyoutNotification(py::wrapper::Windows::UI::Notifications::TileFlyoutNotification* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TileFlyoutNotification_get_ExpirationTime(py::wrapper::Windows::UI::Notifications::TileFlyoutNotification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.TileFlyoutNotification", L"ExpirationTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExpirationTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TileFlyoutNotification_put_ExpirationTime(py::wrapper::Windows::UI::Notifications::TileFlyoutNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.TileFlyoutNotification", L"ExpirationTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.ExpirationTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TileFlyoutNotification_get_Content(py::wrapper::Windows::UI::Notifications::TileFlyoutNotification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.TileFlyoutNotification", L"Content"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Content());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TileFlyoutNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::TileFlyoutNotification>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TileFlyoutNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::TileFlyoutNotification>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TileFlyoutNotification[] = {
        { "_assign_array_", _assign_array_TileFlyoutNotification, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TileFlyoutNotification), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TileFlyoutNotification[] = {
        { "expiration_time", reinterpret_cast<getter>(TileFlyoutNotification_get_ExpirationTime), reinterpret_cast<setter>(TileFlyoutNotification_put_ExpirationTime), nullptr, nullptr },
        { "content", reinterpret_cast<getter>(TileFlyoutNotification_get_Content), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TileFlyoutNotification[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TileFlyoutNotification) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TileFlyoutNotification) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TileFlyoutNotification) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TileFlyoutNotification) },
        { },
    };

    static PyType_Spec type_spec_TileFlyoutNotification =
    {
        "_winrt_Windows_UI_Notifications.TileFlyoutNotification",
        sizeof(py::wrapper::Windows::UI::Notifications::TileFlyoutNotification),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TileFlyoutNotification
    };

    // ----- TileFlyoutUpdateManager class --------------------
    static constexpr const char* const type_name_TileFlyoutUpdateManager = "TileFlyoutUpdateManager";

    static PyObject* _new_TileFlyoutUpdateManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TileFlyoutUpdateManager);
        return nullptr;
    }

    static PyObject* TileFlyoutUpdateManager_CreateTileFlyoutUpdaterForApplication(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileFlyoutUpdateManager", L"CreateTileFlyoutUpdaterForApplication", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::UI::Notifications::TileFlyoutUpdateManager::CreateTileFlyoutUpdaterForApplication());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileFlyoutUpdateManager", L"CreateTileFlyoutUpdaterForApplication", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::UI::Notifications::TileFlyoutUpdateManager::CreateTileFlyoutUpdaterForApplication(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileFlyoutUpdateManager_CreateTileFlyoutUpdaterForSecondaryTile(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileFlyoutUpdateManager", L"CreateTileFlyoutUpdaterForSecondaryTile", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::UI::Notifications::TileFlyoutUpdateManager::CreateTileFlyoutUpdaterForSecondaryTile(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileFlyoutUpdateManager_GetTemplateContent(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileFlyoutUpdateManager", L"GetTemplateContent", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::TileFlyoutTemplateType>(args, 0);

                return py::convert(winrt::Windows::UI::Notifications::TileFlyoutUpdateManager::GetTemplateContent(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_TileFlyoutUpdateManager[] = {
        { "create_tile_flyout_updater_for_application", reinterpret_cast<PyCFunction>(TileFlyoutUpdateManager_CreateTileFlyoutUpdaterForApplication), METH_VARARGS | METH_STATIC, nullptr },
        { "create_tile_flyout_updater_for_secondary_tile", reinterpret_cast<PyCFunction>(TileFlyoutUpdateManager_CreateTileFlyoutUpdaterForSecondaryTile), METH_VARARGS | METH_STATIC, nullptr },
        { "get_template_content", reinterpret_cast<PyCFunction>(TileFlyoutUpdateManager_GetTemplateContent), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TileFlyoutUpdateManager[] = {
        { }
    };

    static PyType_Slot _type_slots_TileFlyoutUpdateManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TileFlyoutUpdateManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TileFlyoutUpdateManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TileFlyoutUpdateManager) },
        { },
    };

    static PyType_Spec type_spec_TileFlyoutUpdateManager =
    {
        "_winrt_Windows_UI_Notifications.TileFlyoutUpdateManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TileFlyoutUpdateManager
    };

    // ----- TileFlyoutUpdater class --------------------
    static constexpr const char* const type_name_TileFlyoutUpdater = "TileFlyoutUpdater";

    static PyObject* _new_TileFlyoutUpdater(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TileFlyoutUpdater);
        return nullptr;
    }

    static void _dealloc_TileFlyoutUpdater(py::wrapper::Windows::UI::Notifications::TileFlyoutUpdater* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TileFlyoutUpdater_Clear(py::wrapper::Windows::UI::Notifications::TileFlyoutUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileFlyoutUpdater", L"Clear", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileFlyoutUpdater_StartPeriodicUpdate(py::wrapper::Windows::UI::Notifications::TileFlyoutUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileFlyoutUpdater", L"StartPeriodicUpdate", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Notifications::PeriodicUpdateRecurrence>(args, 1);

                self->obj.StartPeriodicUpdate(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileFlyoutUpdater", L"StartPeriodicUpdate", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Notifications::PeriodicUpdateRecurrence>(args, 2);

                self->obj.StartPeriodicUpdate(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileFlyoutUpdater_StopPeriodicUpdate(py::wrapper::Windows::UI::Notifications::TileFlyoutUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileFlyoutUpdater", L"StopPeriodicUpdate", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.StopPeriodicUpdate();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileFlyoutUpdater_Update(py::wrapper::Windows::UI::Notifications::TileFlyoutUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileFlyoutUpdater", L"Update", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::TileFlyoutNotification>(args, 0);

                self->obj.Update(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileFlyoutUpdater_get_Setting(py::wrapper::Windows::UI::Notifications::TileFlyoutUpdater* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.TileFlyoutUpdater", L"Setting"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Setting());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TileFlyoutUpdater(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::TileFlyoutUpdater>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TileFlyoutUpdater(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::TileFlyoutUpdater>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TileFlyoutUpdater[] = {
        { "clear", reinterpret_cast<PyCFunction>(TileFlyoutUpdater_Clear), METH_VARARGS, nullptr },
        { "start_periodic_update", reinterpret_cast<PyCFunction>(TileFlyoutUpdater_StartPeriodicUpdate), METH_VARARGS, nullptr },
        { "stop_periodic_update", reinterpret_cast<PyCFunction>(TileFlyoutUpdater_StopPeriodicUpdate), METH_VARARGS, nullptr },
        { "update", reinterpret_cast<PyCFunction>(TileFlyoutUpdater_Update), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TileFlyoutUpdater, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TileFlyoutUpdater), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TileFlyoutUpdater[] = {
        { "setting", reinterpret_cast<getter>(TileFlyoutUpdater_get_Setting), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TileFlyoutUpdater[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TileFlyoutUpdater) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TileFlyoutUpdater) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TileFlyoutUpdater) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TileFlyoutUpdater) },
        { },
    };

    static PyType_Spec type_spec_TileFlyoutUpdater =
    {
        "_winrt_Windows_UI_Notifications.TileFlyoutUpdater",
        sizeof(py::wrapper::Windows::UI::Notifications::TileFlyoutUpdater),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TileFlyoutUpdater
    };

    // ----- TileNotification class --------------------
    static constexpr const char* const type_name_TileNotification = "TileNotification";

    static PyObject* _new_TileNotification(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Data::Xml::Dom::XmlDocument>(args, 0);

                winrt::Windows::UI::Notifications::TileNotification instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TileNotification(py::wrapper::Windows::UI::Notifications::TileNotification* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TileNotification_get_Tag(py::wrapper::Windows::UI::Notifications::TileNotification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.TileNotification", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TileNotification_put_Tag(py::wrapper::Windows::UI::Notifications::TileNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.TileNotification", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TileNotification_get_ExpirationTime(py::wrapper::Windows::UI::Notifications::TileNotification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.TileNotification", L"ExpirationTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExpirationTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TileNotification_put_ExpirationTime(py::wrapper::Windows::UI::Notifications::TileNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.TileNotification", L"ExpirationTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.ExpirationTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TileNotification_get_Content(py::wrapper::Windows::UI::Notifications::TileNotification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.TileNotification", L"Content"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Content());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TileNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::TileNotification>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TileNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::TileNotification>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TileNotification[] = {
        { "_assign_array_", _assign_array_TileNotification, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TileNotification), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TileNotification[] = {
        { "tag", reinterpret_cast<getter>(TileNotification_get_Tag), reinterpret_cast<setter>(TileNotification_put_Tag), nullptr, nullptr },
        { "expiration_time", reinterpret_cast<getter>(TileNotification_get_ExpirationTime), reinterpret_cast<setter>(TileNotification_put_ExpirationTime), nullptr, nullptr },
        { "content", reinterpret_cast<getter>(TileNotification_get_Content), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TileNotification[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TileNotification) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TileNotification) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TileNotification) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TileNotification) },
        { },
    };

    static PyType_Spec type_spec_TileNotification =
    {
        "_winrt_Windows_UI_Notifications.TileNotification",
        sizeof(py::wrapper::Windows::UI::Notifications::TileNotification),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TileNotification
    };

    // ----- TileUpdateManager class --------------------
    static constexpr const char* const type_name_TileUpdateManager = "TileUpdateManager";

    static PyObject* _new_TileUpdateManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TileUpdateManager);
        return nullptr;
    }

    static PyObject* TileUpdateManager_CreateTileUpdaterForApplication(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdateManager", L"CreateTileUpdaterForApplication", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::UI::Notifications::TileUpdateManager::CreateTileUpdaterForApplication());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdateManager", L"CreateTileUpdaterForApplication", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::UI::Notifications::TileUpdateManager::CreateTileUpdaterForApplication(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdateManager_CreateTileUpdaterForSecondaryTile(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdateManager", L"CreateTileUpdaterForSecondaryTile", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::UI::Notifications::TileUpdateManager::CreateTileUpdaterForSecondaryTile(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdateManager_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdateManager", L"GetForUser", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::UI::Notifications::TileUpdateManager::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdateManager_GetTemplateContent(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdateManager", L"GetTemplateContent", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::TileTemplateType>(args, 0);

                return py::convert(winrt::Windows::UI::Notifications::TileUpdateManager::GetTemplateContent(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_TileUpdateManager[] = {
        { "create_tile_updater_for_application", reinterpret_cast<PyCFunction>(TileUpdateManager_CreateTileUpdaterForApplication), METH_VARARGS | METH_STATIC, nullptr },
        { "create_tile_updater_for_secondary_tile", reinterpret_cast<PyCFunction>(TileUpdateManager_CreateTileUpdaterForSecondaryTile), METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_user", reinterpret_cast<PyCFunction>(TileUpdateManager_GetForUser), METH_VARARGS | METH_STATIC, nullptr },
        { "get_template_content", reinterpret_cast<PyCFunction>(TileUpdateManager_GetTemplateContent), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TileUpdateManager[] = {
        { }
    };

    static PyType_Slot _type_slots_TileUpdateManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TileUpdateManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TileUpdateManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TileUpdateManager) },
        { },
    };

    static PyType_Spec type_spec_TileUpdateManager =
    {
        "_winrt_Windows_UI_Notifications.TileUpdateManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TileUpdateManager
    };

    // ----- TileUpdateManagerForUser class --------------------
    static constexpr const char* const type_name_TileUpdateManagerForUser = "TileUpdateManagerForUser";

    static PyObject* _new_TileUpdateManagerForUser(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TileUpdateManagerForUser);
        return nullptr;
    }

    static void _dealloc_TileUpdateManagerForUser(py::wrapper::Windows::UI::Notifications::TileUpdateManagerForUser* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TileUpdateManagerForUser_CreateTileUpdaterForApplication(py::wrapper::Windows::UI::Notifications::TileUpdateManagerForUser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdateManagerForUser", L"CreateTileUpdaterForApplication", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateTileUpdaterForApplication(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdateManagerForUser_CreateTileUpdaterForApplicationForUser(py::wrapper::Windows::UI::Notifications::TileUpdateManagerForUser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdateManagerForUser", L"CreateTileUpdaterForApplicationForUser", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateTileUpdaterForApplicationForUser());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdateManagerForUser_CreateTileUpdaterForSecondaryTile(py::wrapper::Windows::UI::Notifications::TileUpdateManagerForUser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdateManagerForUser", L"CreateTileUpdaterForSecondaryTile", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateTileUpdaterForSecondaryTile(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdateManagerForUser_get_User(py::wrapper::Windows::UI::Notifications::TileUpdateManagerForUser* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.TileUpdateManagerForUser", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TileUpdateManagerForUser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::TileUpdateManagerForUser>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TileUpdateManagerForUser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::TileUpdateManagerForUser>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TileUpdateManagerForUser[] = {
        { "create_tile_updater_for_application", reinterpret_cast<PyCFunction>(TileUpdateManagerForUser_CreateTileUpdaterForApplication), METH_VARARGS, nullptr },
        { "create_tile_updater_for_application_for_user", reinterpret_cast<PyCFunction>(TileUpdateManagerForUser_CreateTileUpdaterForApplicationForUser), METH_VARARGS, nullptr },
        { "create_tile_updater_for_secondary_tile", reinterpret_cast<PyCFunction>(TileUpdateManagerForUser_CreateTileUpdaterForSecondaryTile), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TileUpdateManagerForUser, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TileUpdateManagerForUser), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TileUpdateManagerForUser[] = {
        { "user", reinterpret_cast<getter>(TileUpdateManagerForUser_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TileUpdateManagerForUser[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TileUpdateManagerForUser) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TileUpdateManagerForUser) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TileUpdateManagerForUser) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TileUpdateManagerForUser) },
        { },
    };

    static PyType_Spec type_spec_TileUpdateManagerForUser =
    {
        "_winrt_Windows_UI_Notifications.TileUpdateManagerForUser",
        sizeof(py::wrapper::Windows::UI::Notifications::TileUpdateManagerForUser),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TileUpdateManagerForUser
    };

    // ----- TileUpdater class --------------------
    static constexpr const char* const type_name_TileUpdater = "TileUpdater";

    static PyObject* _new_TileUpdater(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TileUpdater);
        return nullptr;
    }

    static void _dealloc_TileUpdater(py::wrapper::Windows::UI::Notifications::TileUpdater* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TileUpdater_AddToSchedule(py::wrapper::Windows::UI::Notifications::TileUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdater", L"AddToSchedule", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ScheduledTileNotification>(args, 0);

                self->obj.AddToSchedule(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdater_Clear(py::wrapper::Windows::UI::Notifications::TileUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdater", L"Clear", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdater_EnableNotificationQueue(py::wrapper::Windows::UI::Notifications::TileUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdater", L"EnableNotificationQueue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.EnableNotificationQueue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdater_EnableNotificationQueueForSquare150x150(py::wrapper::Windows::UI::Notifications::TileUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdater", L"EnableNotificationQueueForSquare150x150", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.EnableNotificationQueueForSquare150x150(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdater_EnableNotificationQueueForSquare310x310(py::wrapper::Windows::UI::Notifications::TileUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdater", L"EnableNotificationQueueForSquare310x310", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.EnableNotificationQueueForSquare310x310(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdater_EnableNotificationQueueForWide310x150(py::wrapper::Windows::UI::Notifications::TileUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdater", L"EnableNotificationQueueForWide310x150", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.EnableNotificationQueueForWide310x150(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdater_GetScheduledTileNotifications(py::wrapper::Windows::UI::Notifications::TileUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdater", L"GetScheduledTileNotifications", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetScheduledTileNotifications());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdater_RemoveFromSchedule(py::wrapper::Windows::UI::Notifications::TileUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdater", L"RemoveFromSchedule", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ScheduledTileNotification>(args, 0);

                self->obj.RemoveFromSchedule(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdater_StartPeriodicUpdate(py::wrapper::Windows::UI::Notifications::TileUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdater", L"StartPeriodicUpdate", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Notifications::PeriodicUpdateRecurrence>(args, 1);

                self->obj.StartPeriodicUpdate(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdater", L"StartPeriodicUpdate", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Notifications::PeriodicUpdateRecurrence>(args, 2);

                self->obj.StartPeriodicUpdate(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdater_StartPeriodicUpdateBatch(py::wrapper::Windows::UI::Notifications::TileUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdater", L"StartPeriodicUpdateBatch", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Notifications::PeriodicUpdateRecurrence>(args, 1);

                self->obj.StartPeriodicUpdateBatch(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdater", L"StartPeriodicUpdateBatch", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Notifications::PeriodicUpdateRecurrence>(args, 2);

                self->obj.StartPeriodicUpdateBatch(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdater_StopPeriodicUpdate(py::wrapper::Windows::UI::Notifications::TileUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdater", L"StopPeriodicUpdate", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.StopPeriodicUpdate();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdater_Update(py::wrapper::Windows::UI::Notifications::TileUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.TileUpdater", L"Update", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::TileNotification>(args, 0);

                self->obj.Update(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TileUpdater_get_Setting(py::wrapper::Windows::UI::Notifications::TileUpdater* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.TileUpdater", L"Setting"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Setting());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TileUpdater(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::TileUpdater>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TileUpdater(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::TileUpdater>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TileUpdater[] = {
        { "add_to_schedule", reinterpret_cast<PyCFunction>(TileUpdater_AddToSchedule), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(TileUpdater_Clear), METH_VARARGS, nullptr },
        { "enable_notification_queue", reinterpret_cast<PyCFunction>(TileUpdater_EnableNotificationQueue), METH_VARARGS, nullptr },
        { "enable_notification_queue_for_square150x150", reinterpret_cast<PyCFunction>(TileUpdater_EnableNotificationQueueForSquare150x150), METH_VARARGS, nullptr },
        { "enable_notification_queue_for_square310x310", reinterpret_cast<PyCFunction>(TileUpdater_EnableNotificationQueueForSquare310x310), METH_VARARGS, nullptr },
        { "enable_notification_queue_for_wide310x150", reinterpret_cast<PyCFunction>(TileUpdater_EnableNotificationQueueForWide310x150), METH_VARARGS, nullptr },
        { "get_scheduled_tile_notifications", reinterpret_cast<PyCFunction>(TileUpdater_GetScheduledTileNotifications), METH_VARARGS, nullptr },
        { "remove_from_schedule", reinterpret_cast<PyCFunction>(TileUpdater_RemoveFromSchedule), METH_VARARGS, nullptr },
        { "start_periodic_update", reinterpret_cast<PyCFunction>(TileUpdater_StartPeriodicUpdate), METH_VARARGS, nullptr },
        { "start_periodic_update_batch", reinterpret_cast<PyCFunction>(TileUpdater_StartPeriodicUpdateBatch), METH_VARARGS, nullptr },
        { "stop_periodic_update", reinterpret_cast<PyCFunction>(TileUpdater_StopPeriodicUpdate), METH_VARARGS, nullptr },
        { "update", reinterpret_cast<PyCFunction>(TileUpdater_Update), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TileUpdater, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TileUpdater), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TileUpdater[] = {
        { "setting", reinterpret_cast<getter>(TileUpdater_get_Setting), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TileUpdater[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TileUpdater) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TileUpdater) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TileUpdater) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TileUpdater) },
        { },
    };

    static PyType_Spec type_spec_TileUpdater =
    {
        "_winrt_Windows_UI_Notifications.TileUpdater",
        sizeof(py::wrapper::Windows::UI::Notifications::TileUpdater),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TileUpdater
    };

    // ----- ToastActivatedEventArgs class --------------------
    static constexpr const char* const type_name_ToastActivatedEventArgs = "ToastActivatedEventArgs";

    static PyObject* _new_ToastActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ToastActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_ToastActivatedEventArgs(py::wrapper::Windows::UI::Notifications::ToastActivatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToastActivatedEventArgs_get_Arguments(py::wrapper::Windows::UI::Notifications::ToastActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastActivatedEventArgs", L"Arguments"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Arguments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastActivatedEventArgs_get_UserInput(py::wrapper::Windows::UI::Notifications::ToastActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastActivatedEventArgs", L"UserInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UserInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToastActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::ToastActivatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToastActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ToastActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastActivatedEventArgs[] = {
        { "_assign_array_", _assign_array_ToastActivatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToastActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToastActivatedEventArgs[] = {
        { "arguments", reinterpret_cast<getter>(ToastActivatedEventArgs_get_Arguments), nullptr, nullptr, nullptr },
        { "user_input", reinterpret_cast<getter>(ToastActivatedEventArgs_get_UserInput), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ToastActivatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToastActivatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToastActivatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToastActivatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToastActivatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ToastActivatedEventArgs =
    {
        "_winrt_Windows_UI_Notifications.ToastActivatedEventArgs",
        sizeof(py::wrapper::Windows::UI::Notifications::ToastActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastActivatedEventArgs
    };

    // ----- ToastCollection class --------------------
    static constexpr const char* const type_name_ToastCollection = "ToastCollection";

    static PyObject* _new_ToastCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 3);

                winrt::Windows::UI::Notifications::ToastCollection instance{ param0, param1, param2, param3 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ToastCollection(py::wrapper::Windows::UI::Notifications::ToastCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToastCollection_get_LaunchArgs(py::wrapper::Windows::UI::Notifications::ToastCollection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastCollection", L"LaunchArgs"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LaunchArgs());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToastCollection_put_LaunchArgs(py::wrapper::Windows::UI::Notifications::ToastCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastCollection", L"LaunchArgs"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.LaunchArgs(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToastCollection_get_Icon(py::wrapper::Windows::UI::Notifications::ToastCollection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastCollection", L"Icon"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Icon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToastCollection_put_Icon(py::wrapper::Windows::UI::Notifications::ToastCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastCollection", L"Icon"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Icon(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToastCollection_get_DisplayName(py::wrapper::Windows::UI::Notifications::ToastCollection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastCollection", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToastCollection_put_DisplayName(py::wrapper::Windows::UI::Notifications::ToastCollection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastCollection", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToastCollection_get_Id(py::wrapper::Windows::UI::Notifications::ToastCollection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastCollection", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToastCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::ToastCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToastCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ToastCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastCollection[] = {
        { "_assign_array_", _assign_array_ToastCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToastCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToastCollection[] = {
        { "launch_args", reinterpret_cast<getter>(ToastCollection_get_LaunchArgs), reinterpret_cast<setter>(ToastCollection_put_LaunchArgs), nullptr, nullptr },
        { "icon", reinterpret_cast<getter>(ToastCollection_get_Icon), reinterpret_cast<setter>(ToastCollection_put_Icon), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(ToastCollection_get_DisplayName), reinterpret_cast<setter>(ToastCollection_put_DisplayName), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ToastCollection_get_Id), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ToastCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToastCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToastCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToastCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToastCollection) },
        { },
    };

    static PyType_Spec type_spec_ToastCollection =
    {
        "_winrt_Windows_UI_Notifications.ToastCollection",
        sizeof(py::wrapper::Windows::UI::Notifications::ToastCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastCollection
    };

    // ----- ToastCollectionManager class --------------------
    static constexpr const char* const type_name_ToastCollectionManager = "ToastCollectionManager";

    static PyObject* _new_ToastCollectionManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ToastCollectionManager);
        return nullptr;
    }

    static void _dealloc_ToastCollectionManager(py::wrapper::Windows::UI::Notifications::ToastCollectionManager* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToastCollectionManager_FindAllToastCollectionsAsync(py::wrapper::Windows::UI::Notifications::ToastCollectionManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastCollectionManager", L"FindAllToastCollectionsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.FindAllToastCollectionsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastCollectionManager_GetToastCollectionAsync(py::wrapper::Windows::UI::Notifications::ToastCollectionManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastCollectionManager", L"GetToastCollectionAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetToastCollectionAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastCollectionManager_RemoveAllToastCollectionsAsync(py::wrapper::Windows::UI::Notifications::ToastCollectionManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastCollectionManager", L"RemoveAllToastCollectionsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.RemoveAllToastCollectionsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastCollectionManager_RemoveToastCollectionAsync(py::wrapper::Windows::UI::Notifications::ToastCollectionManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastCollectionManager", L"RemoveToastCollectionAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RemoveToastCollectionAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastCollectionManager_SaveToastCollectionAsync(py::wrapper::Windows::UI::Notifications::ToastCollectionManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastCollectionManager", L"SaveToastCollectionAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ToastCollection>(args, 0);

                return py::convert(self->obj.SaveToastCollectionAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastCollectionManager_get_AppId(py::wrapper::Windows::UI::Notifications::ToastCollectionManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastCollectionManager", L"AppId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastCollectionManager_get_User(py::wrapper::Windows::UI::Notifications::ToastCollectionManager* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastCollectionManager", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToastCollectionManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::ToastCollectionManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToastCollectionManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ToastCollectionManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastCollectionManager[] = {
        { "find_all_toast_collections_async", reinterpret_cast<PyCFunction>(ToastCollectionManager_FindAllToastCollectionsAsync), METH_VARARGS, nullptr },
        { "get_toast_collection_async", reinterpret_cast<PyCFunction>(ToastCollectionManager_GetToastCollectionAsync), METH_VARARGS, nullptr },
        { "remove_all_toast_collections_async", reinterpret_cast<PyCFunction>(ToastCollectionManager_RemoveAllToastCollectionsAsync), METH_VARARGS, nullptr },
        { "remove_toast_collection_async", reinterpret_cast<PyCFunction>(ToastCollectionManager_RemoveToastCollectionAsync), METH_VARARGS, nullptr },
        { "save_toast_collection_async", reinterpret_cast<PyCFunction>(ToastCollectionManager_SaveToastCollectionAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ToastCollectionManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToastCollectionManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToastCollectionManager[] = {
        { "app_id", reinterpret_cast<getter>(ToastCollectionManager_get_AppId), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(ToastCollectionManager_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ToastCollectionManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToastCollectionManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToastCollectionManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToastCollectionManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToastCollectionManager) },
        { },
    };

    static PyType_Spec type_spec_ToastCollectionManager =
    {
        "_winrt_Windows_UI_Notifications.ToastCollectionManager",
        sizeof(py::wrapper::Windows::UI::Notifications::ToastCollectionManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastCollectionManager
    };

    // ----- ToastDismissedEventArgs class --------------------
    static constexpr const char* const type_name_ToastDismissedEventArgs = "ToastDismissedEventArgs";

    static PyObject* _new_ToastDismissedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ToastDismissedEventArgs);
        return nullptr;
    }

    static void _dealloc_ToastDismissedEventArgs(py::wrapper::Windows::UI::Notifications::ToastDismissedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToastDismissedEventArgs_get_Reason(py::wrapper::Windows::UI::Notifications::ToastDismissedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastDismissedEventArgs", L"Reason"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToastDismissedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::ToastDismissedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToastDismissedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ToastDismissedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastDismissedEventArgs[] = {
        { "_assign_array_", _assign_array_ToastDismissedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToastDismissedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToastDismissedEventArgs[] = {
        { "reason", reinterpret_cast<getter>(ToastDismissedEventArgs_get_Reason), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ToastDismissedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToastDismissedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToastDismissedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToastDismissedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToastDismissedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ToastDismissedEventArgs =
    {
        "_winrt_Windows_UI_Notifications.ToastDismissedEventArgs",
        sizeof(py::wrapper::Windows::UI::Notifications::ToastDismissedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastDismissedEventArgs
    };

    // ----- ToastFailedEventArgs class --------------------
    static constexpr const char* const type_name_ToastFailedEventArgs = "ToastFailedEventArgs";

    static PyObject* _new_ToastFailedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ToastFailedEventArgs);
        return nullptr;
    }

    static void _dealloc_ToastFailedEventArgs(py::wrapper::Windows::UI::Notifications::ToastFailedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToastFailedEventArgs_get_ErrorCode(py::wrapper::Windows::UI::Notifications::ToastFailedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastFailedEventArgs", L"ErrorCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToastFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::ToastFailedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToastFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ToastFailedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastFailedEventArgs[] = {
        { "_assign_array_", _assign_array_ToastFailedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToastFailedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToastFailedEventArgs[] = {
        { "error_code", reinterpret_cast<getter>(ToastFailedEventArgs_get_ErrorCode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ToastFailedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToastFailedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToastFailedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToastFailedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToastFailedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ToastFailedEventArgs =
    {
        "_winrt_Windows_UI_Notifications.ToastFailedEventArgs",
        sizeof(py::wrapper::Windows::UI::Notifications::ToastFailedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastFailedEventArgs
    };

    // ----- ToastNotification class --------------------
    static constexpr const char* const type_name_ToastNotification = "ToastNotification";

    static PyObject* _new_ToastNotification(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Data::Xml::Dom::XmlDocument>(args, 0);

                winrt::Windows::UI::Notifications::ToastNotification instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ToastNotification(py::wrapper::Windows::UI::Notifications::ToastNotification* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToastNotification_get_ExpirationTime(py::wrapper::Windows::UI::Notifications::ToastNotification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotification", L"ExpirationTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExpirationTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToastNotification_put_ExpirationTime(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotification", L"ExpirationTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.ExpirationTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToastNotification_get_Content(py::wrapper::Windows::UI::Notifications::ToastNotification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotification", L"Content"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Content());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotification_get_Tag(py::wrapper::Windows::UI::Notifications::ToastNotification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotification", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToastNotification_put_Tag(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotification", L"Tag"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToastNotification_get_SuppressPopup(py::wrapper::Windows::UI::Notifications::ToastNotification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotification", L"SuppressPopup"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SuppressPopup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToastNotification_put_SuppressPopup(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotification", L"SuppressPopup"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.SuppressPopup(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToastNotification_get_Group(py::wrapper::Windows::UI::Notifications::ToastNotification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotification", L"Group"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Group());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToastNotification_put_Group(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotification", L"Group"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Group(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToastNotification_get_RemoteId(py::wrapper::Windows::UI::Notifications::ToastNotification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotification", L"RemoteId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RemoteId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToastNotification_put_RemoteId(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotification", L"RemoteId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.RemoteId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToastNotification_get_NotificationMirroring(py::wrapper::Windows::UI::Notifications::ToastNotification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotification", L"NotificationMirroring"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NotificationMirroring());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToastNotification_put_NotificationMirroring(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotification", L"NotificationMirroring"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::NotificationMirroring>(arg);

            self->obj.NotificationMirroring(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToastNotification_get_Priority(py::wrapper::Windows::UI::Notifications::ToastNotification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotification", L"Priority"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Priority());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToastNotification_put_Priority(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotification", L"Priority"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ToastNotificationPriority>(arg);

            self->obj.Priority(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToastNotification_get_Data(py::wrapper::Windows::UI::Notifications::ToastNotification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotification", L"Data"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToastNotification_put_Data(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotification", L"Data"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::NotificationData>(arg);

            self->obj.Data(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToastNotification_get_ExpiresOnReboot(py::wrapper::Windows::UI::Notifications::ToastNotification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotification", L"ExpiresOnReboot"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExpiresOnReboot());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToastNotification_put_ExpiresOnReboot(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotification", L"ExpiresOnReboot"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ExpiresOnReboot(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToastNotification_add_Activated(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Notifications.ToastNotification", L"Activated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Notifications::ToastNotification, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Activated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotification_remove_Activated(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Notifications.ToastNotification", L"Activated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Activated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotification_add_Dismissed(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Notifications.ToastNotification", L"Dismissed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Notifications::ToastNotification, winrt::Windows::UI::Notifications::ToastDismissedEventArgs>>(arg);

            return py::convert(self->obj.Dismissed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotification_remove_Dismissed(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Notifications.ToastNotification", L"Dismissed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Dismissed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotification_add_Failed(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Notifications.ToastNotification", L"Failed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Notifications::ToastNotification, winrt::Windows::UI::Notifications::ToastFailedEventArgs>>(arg);

            return py::convert(self->obj.Failed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotification_remove_Failed(py::wrapper::Windows::UI::Notifications::ToastNotification* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Notifications.ToastNotification", L"Failed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Failed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToastNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::ToastNotification>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToastNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ToastNotification>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastNotification[] = {
        { "add_activated", reinterpret_cast<PyCFunction>(ToastNotification_add_Activated), METH_O, nullptr },
        { "remove_activated", reinterpret_cast<PyCFunction>(ToastNotification_remove_Activated), METH_O, nullptr },
        { "add_dismissed", reinterpret_cast<PyCFunction>(ToastNotification_add_Dismissed), METH_O, nullptr },
        { "remove_dismissed", reinterpret_cast<PyCFunction>(ToastNotification_remove_Dismissed), METH_O, nullptr },
        { "add_failed", reinterpret_cast<PyCFunction>(ToastNotification_add_Failed), METH_O, nullptr },
        { "remove_failed", reinterpret_cast<PyCFunction>(ToastNotification_remove_Failed), METH_O, nullptr },
        { "_assign_array_", _assign_array_ToastNotification, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToastNotification), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToastNotification[] = {
        { "expiration_time", reinterpret_cast<getter>(ToastNotification_get_ExpirationTime), reinterpret_cast<setter>(ToastNotification_put_ExpirationTime), nullptr, nullptr },
        { "content", reinterpret_cast<getter>(ToastNotification_get_Content), nullptr, nullptr, nullptr },
        { "tag", reinterpret_cast<getter>(ToastNotification_get_Tag), reinterpret_cast<setter>(ToastNotification_put_Tag), nullptr, nullptr },
        { "suppress_popup", reinterpret_cast<getter>(ToastNotification_get_SuppressPopup), reinterpret_cast<setter>(ToastNotification_put_SuppressPopup), nullptr, nullptr },
        { "group", reinterpret_cast<getter>(ToastNotification_get_Group), reinterpret_cast<setter>(ToastNotification_put_Group), nullptr, nullptr },
        { "remote_id", reinterpret_cast<getter>(ToastNotification_get_RemoteId), reinterpret_cast<setter>(ToastNotification_put_RemoteId), nullptr, nullptr },
        { "notification_mirroring", reinterpret_cast<getter>(ToastNotification_get_NotificationMirroring), reinterpret_cast<setter>(ToastNotification_put_NotificationMirroring), nullptr, nullptr },
        { "priority", reinterpret_cast<getter>(ToastNotification_get_Priority), reinterpret_cast<setter>(ToastNotification_put_Priority), nullptr, nullptr },
        { "data", reinterpret_cast<getter>(ToastNotification_get_Data), reinterpret_cast<setter>(ToastNotification_put_Data), nullptr, nullptr },
        { "expires_on_reboot", reinterpret_cast<getter>(ToastNotification_get_ExpiresOnReboot), reinterpret_cast<setter>(ToastNotification_put_ExpiresOnReboot), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ToastNotification[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToastNotification) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToastNotification) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToastNotification) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToastNotification) },
        { },
    };

    static PyType_Spec type_spec_ToastNotification =
    {
        "_winrt_Windows_UI_Notifications.ToastNotification",
        sizeof(py::wrapper::Windows::UI::Notifications::ToastNotification),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastNotification
    };

    // ----- ToastNotificationActionTriggerDetail class --------------------
    static constexpr const char* const type_name_ToastNotificationActionTriggerDetail = "ToastNotificationActionTriggerDetail";

    static PyObject* _new_ToastNotificationActionTriggerDetail(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ToastNotificationActionTriggerDetail);
        return nullptr;
    }

    static void _dealloc_ToastNotificationActionTriggerDetail(py::wrapper::Windows::UI::Notifications::ToastNotificationActionTriggerDetail* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToastNotificationActionTriggerDetail_get_Argument(py::wrapper::Windows::UI::Notifications::ToastNotificationActionTriggerDetail* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotificationActionTriggerDetail", L"Argument"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Argument());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationActionTriggerDetail_get_UserInput(py::wrapper::Windows::UI::Notifications::ToastNotificationActionTriggerDetail* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotificationActionTriggerDetail", L"UserInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UserInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToastNotificationActionTriggerDetail(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::ToastNotificationActionTriggerDetail>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToastNotificationActionTriggerDetail(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ToastNotificationActionTriggerDetail>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastNotificationActionTriggerDetail[] = {
        { "_assign_array_", _assign_array_ToastNotificationActionTriggerDetail, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToastNotificationActionTriggerDetail), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToastNotificationActionTriggerDetail[] = {
        { "argument", reinterpret_cast<getter>(ToastNotificationActionTriggerDetail_get_Argument), nullptr, nullptr, nullptr },
        { "user_input", reinterpret_cast<getter>(ToastNotificationActionTriggerDetail_get_UserInput), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ToastNotificationActionTriggerDetail[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToastNotificationActionTriggerDetail) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToastNotificationActionTriggerDetail) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToastNotificationActionTriggerDetail) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToastNotificationActionTriggerDetail) },
        { },
    };

    static PyType_Spec type_spec_ToastNotificationActionTriggerDetail =
    {
        "_winrt_Windows_UI_Notifications.ToastNotificationActionTriggerDetail",
        sizeof(py::wrapper::Windows::UI::Notifications::ToastNotificationActionTriggerDetail),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastNotificationActionTriggerDetail
    };

    // ----- ToastNotificationHistory class --------------------
    static constexpr const char* const type_name_ToastNotificationHistory = "ToastNotificationHistory";

    static PyObject* _new_ToastNotificationHistory(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ToastNotificationHistory);
        return nullptr;
    }

    static void _dealloc_ToastNotificationHistory(py::wrapper::Windows::UI::Notifications::ToastNotificationHistory* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToastNotificationHistory_Clear(py::wrapper::Windows::UI::Notifications::ToastNotificationHistory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationHistory", L"Clear", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationHistory", L"Clear", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Clear(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationHistory_GetHistory(py::wrapper::Windows::UI::Notifications::ToastNotificationHistory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationHistory", L"GetHistory", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetHistory());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationHistory", L"GetHistory", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetHistory(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationHistory_Remove(py::wrapper::Windows::UI::Notifications::ToastNotificationHistory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationHistory", L"Remove", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationHistory", L"Remove", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.Remove(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationHistory", L"Remove", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                self->obj.Remove(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationHistory_RemoveGroup(py::wrapper::Windows::UI::Notifications::ToastNotificationHistory* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationHistory", L"RemoveGroup", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.RemoveGroup(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationHistory", L"RemoveGroup", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.RemoveGroup(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToastNotificationHistory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::ToastNotificationHistory>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToastNotificationHistory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ToastNotificationHistory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastNotificationHistory[] = {
        { "clear", reinterpret_cast<PyCFunction>(ToastNotificationHistory_Clear), METH_VARARGS, nullptr },
        { "get_history", reinterpret_cast<PyCFunction>(ToastNotificationHistory_GetHistory), METH_VARARGS, nullptr },
        { "remove", reinterpret_cast<PyCFunction>(ToastNotificationHistory_Remove), METH_VARARGS, nullptr },
        { "remove_group", reinterpret_cast<PyCFunction>(ToastNotificationHistory_RemoveGroup), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ToastNotificationHistory, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToastNotificationHistory), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToastNotificationHistory[] = {
        { }
    };

    static PyType_Slot _type_slots_ToastNotificationHistory[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToastNotificationHistory) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToastNotificationHistory) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToastNotificationHistory) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToastNotificationHistory) },
        { },
    };

    static PyType_Spec type_spec_ToastNotificationHistory =
    {
        "_winrt_Windows_UI_Notifications.ToastNotificationHistory",
        sizeof(py::wrapper::Windows::UI::Notifications::ToastNotificationHistory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastNotificationHistory
    };

    // ----- ToastNotificationHistoryChangedTriggerDetail class --------------------
    static constexpr const char* const type_name_ToastNotificationHistoryChangedTriggerDetail = "ToastNotificationHistoryChangedTriggerDetail";

    static PyObject* _new_ToastNotificationHistoryChangedTriggerDetail(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ToastNotificationHistoryChangedTriggerDetail);
        return nullptr;
    }

    static void _dealloc_ToastNotificationHistoryChangedTriggerDetail(py::wrapper::Windows::UI::Notifications::ToastNotificationHistoryChangedTriggerDetail* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToastNotificationHistoryChangedTriggerDetail_get_ChangeType(py::wrapper::Windows::UI::Notifications::ToastNotificationHistoryChangedTriggerDetail* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotificationHistoryChangedTriggerDetail", L"ChangeType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChangeType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationHistoryChangedTriggerDetail_get_CollectionId(py::wrapper::Windows::UI::Notifications::ToastNotificationHistoryChangedTriggerDetail* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotificationHistoryChangedTriggerDetail", L"CollectionId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CollectionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToastNotificationHistoryChangedTriggerDetail(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::ToastNotificationHistoryChangedTriggerDetail>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToastNotificationHistoryChangedTriggerDetail(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ToastNotificationHistoryChangedTriggerDetail>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastNotificationHistoryChangedTriggerDetail[] = {
        { "_assign_array_", _assign_array_ToastNotificationHistoryChangedTriggerDetail, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToastNotificationHistoryChangedTriggerDetail), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToastNotificationHistoryChangedTriggerDetail[] = {
        { "change_type", reinterpret_cast<getter>(ToastNotificationHistoryChangedTriggerDetail_get_ChangeType), nullptr, nullptr, nullptr },
        { "collection_id", reinterpret_cast<getter>(ToastNotificationHistoryChangedTriggerDetail_get_CollectionId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ToastNotificationHistoryChangedTriggerDetail[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToastNotificationHistoryChangedTriggerDetail) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToastNotificationHistoryChangedTriggerDetail) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToastNotificationHistoryChangedTriggerDetail) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToastNotificationHistoryChangedTriggerDetail) },
        { },
    };

    static PyType_Spec type_spec_ToastNotificationHistoryChangedTriggerDetail =
    {
        "_winrt_Windows_UI_Notifications.ToastNotificationHistoryChangedTriggerDetail",
        sizeof(py::wrapper::Windows::UI::Notifications::ToastNotificationHistoryChangedTriggerDetail),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastNotificationHistoryChangedTriggerDetail
    };

    // ----- ToastNotificationManager class --------------------
    static constexpr const char* const type_name_ToastNotificationManager = "ToastNotificationManager";

    static PyObject* _new_ToastNotificationManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ToastNotificationManager);
        return nullptr;
    }

    static PyObject* ToastNotificationManager_ConfigureNotificationMirroring(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationManager", L"ConfigureNotificationMirroring", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::NotificationMirroring>(args, 0);

                winrt::Windows::UI::Notifications::ToastNotificationManager::ConfigureNotificationMirroring(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationManager_CreateToastNotifier(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationManager", L"CreateToastNotifier", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::UI::Notifications::ToastNotificationManager::CreateToastNotifier());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationManager", L"CreateToastNotifier", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::UI::Notifications::ToastNotificationManager::CreateToastNotifier(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationManager_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationManager", L"GetDefault", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::UI::Notifications::ToastNotificationManager::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationManager_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationManager", L"GetForUser", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::UI::Notifications::ToastNotificationManager::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationManager_GetTemplateContent(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationManager", L"GetTemplateContent", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ToastTemplateType>(args, 0);

                return py::convert(winrt::Windows::UI::Notifications::ToastNotificationManager::GetTemplateContent(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationManager_get_History(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotificationManager", L"History"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::UI::Notifications::ToastNotificationManager::History());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastNotificationManager[] = {
        { "configure_notification_mirroring", reinterpret_cast<PyCFunction>(ToastNotificationManager_ConfigureNotificationMirroring), METH_VARARGS | METH_STATIC, nullptr },
        { "create_toast_notifier", reinterpret_cast<PyCFunction>(ToastNotificationManager_CreateToastNotifier), METH_VARARGS | METH_STATIC, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(ToastNotificationManager_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_user", reinterpret_cast<PyCFunction>(ToastNotificationManager_GetForUser), METH_VARARGS | METH_STATIC, nullptr },
        { "get_template_content", reinterpret_cast<PyCFunction>(ToastNotificationManager_GetTemplateContent), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToastNotificationManager[] = {
        { }
    };

    static PyType_Slot _type_slots_ToastNotificationManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToastNotificationManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToastNotificationManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToastNotificationManager) },
        { },
    };

    static PyType_Spec type_spec_ToastNotificationManager =
    {
        "_winrt_Windows_UI_Notifications.ToastNotificationManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastNotificationManager
    };

    static PyGetSetDef getset_ToastNotificationManager_Meta[] = {
        { "history", reinterpret_cast<getter>(ToastNotificationManager_get_History), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_ToastNotificationManager_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ToastNotificationManager_Meta) },
        { }
    };

    static PyType_Spec type_spec_ToastNotificationManager_Meta =
    {
        "_winrt_Windows_UI_Notifications.ToastNotificationManager_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ToastNotificationManager_Meta
    };

    // ----- ToastNotificationManagerForUser class --------------------
    static constexpr const char* const type_name_ToastNotificationManagerForUser = "ToastNotificationManagerForUser";

    static PyObject* _new_ToastNotificationManagerForUser(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ToastNotificationManagerForUser);
        return nullptr;
    }

    static void _dealloc_ToastNotificationManagerForUser(py::wrapper::Windows::UI::Notifications::ToastNotificationManagerForUser* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToastNotificationManagerForUser_CreateToastNotifier(py::wrapper::Windows::UI::Notifications::ToastNotificationManagerForUser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationManagerForUser", L"CreateToastNotifier", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateToastNotifier());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationManagerForUser", L"CreateToastNotifier", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateToastNotifier(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationManagerForUser_GetHistoryForToastCollectionIdAsync(py::wrapper::Windows::UI::Notifications::ToastNotificationManagerForUser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationManagerForUser", L"GetHistoryForToastCollectionIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetHistoryForToastCollectionIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationManagerForUser_GetToastCollectionManager(py::wrapper::Windows::UI::Notifications::ToastNotificationManagerForUser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationManagerForUser", L"GetToastCollectionManager", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetToastCollectionManager());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationManagerForUser", L"GetToastCollectionManager", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetToastCollectionManager(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationManagerForUser_GetToastNotifierForToastCollectionIdAsync(py::wrapper::Windows::UI::Notifications::ToastNotificationManagerForUser* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotificationManagerForUser", L"GetToastNotifierForToastCollectionIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetToastNotifierForToastCollectionIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotificationManagerForUser_get_History(py::wrapper::Windows::UI::Notifications::ToastNotificationManagerForUser* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotificationManagerForUser", L"History"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.History());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationManagerForUser_get_User(py::wrapper::Windows::UI::Notifications::ToastNotificationManagerForUser* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotificationManagerForUser", L"User"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationManagerForUser_get_NotificationMode(py::wrapper::Windows::UI::Notifications::ToastNotificationManagerForUser* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotificationManagerForUser", L"NotificationMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NotificationMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationManagerForUser_add_NotificationModeChanged(py::wrapper::Windows::UI::Notifications::ToastNotificationManagerForUser* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Notifications.ToastNotificationManagerForUser", L"NotificationModeChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Notifications::ToastNotificationManagerForUser, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.NotificationModeChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationManagerForUser_remove_NotificationModeChanged(py::wrapper::Windows::UI::Notifications::ToastNotificationManagerForUser* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Notifications.ToastNotificationManagerForUser", L"NotificationModeChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.NotificationModeChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToastNotificationManagerForUser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::ToastNotificationManagerForUser>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToastNotificationManagerForUser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ToastNotificationManagerForUser>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastNotificationManagerForUser[] = {
        { "create_toast_notifier", reinterpret_cast<PyCFunction>(ToastNotificationManagerForUser_CreateToastNotifier), METH_VARARGS, nullptr },
        { "get_history_for_toast_collection_id_async", reinterpret_cast<PyCFunction>(ToastNotificationManagerForUser_GetHistoryForToastCollectionIdAsync), METH_VARARGS, nullptr },
        { "get_toast_collection_manager", reinterpret_cast<PyCFunction>(ToastNotificationManagerForUser_GetToastCollectionManager), METH_VARARGS, nullptr },
        { "get_toast_notifier_for_toast_collection_id_async", reinterpret_cast<PyCFunction>(ToastNotificationManagerForUser_GetToastNotifierForToastCollectionIdAsync), METH_VARARGS, nullptr },
        { "add_notification_mode_changed", reinterpret_cast<PyCFunction>(ToastNotificationManagerForUser_add_NotificationModeChanged), METH_O, nullptr },
        { "remove_notification_mode_changed", reinterpret_cast<PyCFunction>(ToastNotificationManagerForUser_remove_NotificationModeChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ToastNotificationManagerForUser, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToastNotificationManagerForUser), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToastNotificationManagerForUser[] = {
        { "history", reinterpret_cast<getter>(ToastNotificationManagerForUser_get_History), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(ToastNotificationManagerForUser_get_User), nullptr, nullptr, nullptr },
        { "notification_mode", reinterpret_cast<getter>(ToastNotificationManagerForUser_get_NotificationMode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ToastNotificationManagerForUser[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToastNotificationManagerForUser) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToastNotificationManagerForUser) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToastNotificationManagerForUser) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToastNotificationManagerForUser) },
        { },
    };

    static PyType_Spec type_spec_ToastNotificationManagerForUser =
    {
        "_winrt_Windows_UI_Notifications.ToastNotificationManagerForUser",
        sizeof(py::wrapper::Windows::UI::Notifications::ToastNotificationManagerForUser),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastNotificationManagerForUser
    };

    // ----- ToastNotifier class --------------------
    static constexpr const char* const type_name_ToastNotifier = "ToastNotifier";

    static PyObject* _new_ToastNotifier(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ToastNotifier);
        return nullptr;
    }

    static void _dealloc_ToastNotifier(py::wrapper::Windows::UI::Notifications::ToastNotifier* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToastNotifier_AddToSchedule(py::wrapper::Windows::UI::Notifications::ToastNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotifier", L"AddToSchedule", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ScheduledToastNotification>(args, 0);

                self->obj.AddToSchedule(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotifier_GetScheduledToastNotifications(py::wrapper::Windows::UI::Notifications::ToastNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotifier", L"GetScheduledToastNotifications", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetScheduledToastNotifications());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotifier_Hide(py::wrapper::Windows::UI::Notifications::ToastNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotifier", L"Hide", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ToastNotification>(args, 0);

                self->obj.Hide(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotifier_RemoveFromSchedule(py::wrapper::Windows::UI::Notifications::ToastNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotifier", L"RemoveFromSchedule", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ScheduledToastNotification>(args, 0);

                self->obj.RemoveFromSchedule(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotifier_Show(py::wrapper::Windows::UI::Notifications::ToastNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotifier", L"Show", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ToastNotification>(args, 0);

                self->obj.Show(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotifier_Update(py::wrapper::Windows::UI::Notifications::ToastNotifier* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotifier", L"Update", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::NotificationData>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.Update(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Notifications.ToastNotifier", L"Update", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Notifications::NotificationData>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.Update(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToastNotifier_get_Setting(py::wrapper::Windows::UI::Notifications::ToastNotifier* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.ToastNotifier", L"Setting"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Setting());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotifier_add_ScheduledToastNotificationShowing(py::wrapper::Windows::UI::Notifications::ToastNotifier* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Notifications.ToastNotifier", L"ScheduledToastNotificationShowing"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Notifications::ToastNotifier, winrt::Windows::UI::Notifications::ScheduledToastNotificationShowingEventArgs>>(arg);

            return py::convert(self->obj.ScheduledToastNotificationShowing(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotifier_remove_ScheduledToastNotificationShowing(py::wrapper::Windows::UI::Notifications::ToastNotifier* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Notifications.ToastNotifier", L"ScheduledToastNotificationShowing"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ScheduledToastNotificationShowing(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToastNotifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::ToastNotifier>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToastNotifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::ToastNotifier>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastNotifier[] = {
        { "add_to_schedule", reinterpret_cast<PyCFunction>(ToastNotifier_AddToSchedule), METH_VARARGS, nullptr },
        { "get_scheduled_toast_notifications", reinterpret_cast<PyCFunction>(ToastNotifier_GetScheduledToastNotifications), METH_VARARGS, nullptr },
        { "hide", reinterpret_cast<PyCFunction>(ToastNotifier_Hide), METH_VARARGS, nullptr },
        { "remove_from_schedule", reinterpret_cast<PyCFunction>(ToastNotifier_RemoveFromSchedule), METH_VARARGS, nullptr },
        { "show", reinterpret_cast<PyCFunction>(ToastNotifier_Show), METH_VARARGS, nullptr },
        { "update", reinterpret_cast<PyCFunction>(ToastNotifier_Update), METH_VARARGS, nullptr },
        { "add_scheduled_toast_notification_showing", reinterpret_cast<PyCFunction>(ToastNotifier_add_ScheduledToastNotificationShowing), METH_O, nullptr },
        { "remove_scheduled_toast_notification_showing", reinterpret_cast<PyCFunction>(ToastNotifier_remove_ScheduledToastNotificationShowing), METH_O, nullptr },
        { "_assign_array_", _assign_array_ToastNotifier, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToastNotifier), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToastNotifier[] = {
        { "setting", reinterpret_cast<getter>(ToastNotifier_get_Setting), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ToastNotifier[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToastNotifier) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToastNotifier) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToastNotifier) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToastNotifier) },
        { },
    };

    static PyType_Spec type_spec_ToastNotifier =
    {
        "_winrt_Windows_UI_Notifications.ToastNotifier",
        sizeof(py::wrapper::Windows::UI::Notifications::ToastNotifier),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastNotifier
    };

    // ----- UserNotification class --------------------
    static constexpr const char* const type_name_UserNotification = "UserNotification";

    static PyObject* _new_UserNotification(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UserNotification);
        return nullptr;
    }

    static void _dealloc_UserNotification(py::wrapper::Windows::UI::Notifications::UserNotification* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UserNotification_get_AppInfo(py::wrapper::Windows::UI::Notifications::UserNotification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.UserNotification", L"AppInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserNotification_get_CreationTime(py::wrapper::Windows::UI::Notifications::UserNotification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.UserNotification", L"CreationTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CreationTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserNotification_get_Id(py::wrapper::Windows::UI::Notifications::UserNotification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.UserNotification", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserNotification_get_Notification(py::wrapper::Windows::UI::Notifications::UserNotification* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.UserNotification", L"Notification"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Notification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UserNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::UserNotification>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UserNotification(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::UserNotification>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserNotification[] = {
        { "_assign_array_", _assign_array_UserNotification, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UserNotification), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UserNotification[] = {
        { "app_info", reinterpret_cast<getter>(UserNotification_get_AppInfo), nullptr, nullptr, nullptr },
        { "creation_time", reinterpret_cast<getter>(UserNotification_get_CreationTime), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(UserNotification_get_Id), nullptr, nullptr, nullptr },
        { "notification", reinterpret_cast<getter>(UserNotification_get_Notification), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UserNotification[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UserNotification) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UserNotification) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UserNotification) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UserNotification) },
        { },
    };

    static PyType_Spec type_spec_UserNotification =
    {
        "_winrt_Windows_UI_Notifications.UserNotification",
        sizeof(py::wrapper::Windows::UI::Notifications::UserNotification),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserNotification
    };

    // ----- UserNotificationChangedEventArgs class --------------------
    static constexpr const char* const type_name_UserNotificationChangedEventArgs = "UserNotificationChangedEventArgs";

    static PyObject* _new_UserNotificationChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UserNotificationChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_UserNotificationChangedEventArgs(py::wrapper::Windows::UI::Notifications::UserNotificationChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UserNotificationChangedEventArgs_get_ChangeKind(py::wrapper::Windows::UI::Notifications::UserNotificationChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.UserNotificationChangedEventArgs", L"ChangeKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ChangeKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserNotificationChangedEventArgs_get_UserNotificationId(py::wrapper::Windows::UI::Notifications::UserNotificationChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.UserNotificationChangedEventArgs", L"UserNotificationId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UserNotificationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UserNotificationChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::UserNotificationChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UserNotificationChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::UserNotificationChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserNotificationChangedEventArgs[] = {
        { "_assign_array_", _assign_array_UserNotificationChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UserNotificationChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UserNotificationChangedEventArgs[] = {
        { "change_kind", reinterpret_cast<getter>(UserNotificationChangedEventArgs_get_ChangeKind), nullptr, nullptr, nullptr },
        { "user_notification_id", reinterpret_cast<getter>(UserNotificationChangedEventArgs_get_UserNotificationId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UserNotificationChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UserNotificationChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UserNotificationChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UserNotificationChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UserNotificationChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_UserNotificationChangedEventArgs =
    {
        "_winrt_Windows_UI_Notifications.UserNotificationChangedEventArgs",
        sizeof(py::wrapper::Windows::UI::Notifications::UserNotificationChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserNotificationChangedEventArgs
    };

    // ----- IAdaptiveNotificationContent interface --------------------
    static constexpr const char* const type_name_IAdaptiveNotificationContent = "IAdaptiveNotificationContent";

    static PyObject* _new_IAdaptiveNotificationContent(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        py::set_invalid_activation_error(type_name_IAdaptiveNotificationContent);
        return nullptr;
    }

    static void _dealloc_IAdaptiveNotificationContent(py::wrapper::Windows::UI::Notifications::IAdaptiveNotificationContent* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAdaptiveNotificationContent_get_Hints(py::wrapper::Windows::UI::Notifications::IAdaptiveNotificationContent* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.IAdaptiveNotificationContent", L"Hints"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Hints());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAdaptiveNotificationContent_get_Kind(py::wrapper::Windows::UI::Notifications::IAdaptiveNotificationContent* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Notifications.IAdaptiveNotificationContent", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IAdaptiveNotificationContent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Notifications::IAdaptiveNotificationContent>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAdaptiveNotificationContent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Notifications::IAdaptiveNotificationContent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAdaptiveNotificationContent[] = {
        { "_assign_array_", _assign_array_IAdaptiveNotificationContent, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAdaptiveNotificationContent), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAdaptiveNotificationContent[] = {
        { "hints", reinterpret_cast<getter>(IAdaptiveNotificationContent_get_Hints), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IAdaptiveNotificationContent_get_Kind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAdaptiveNotificationContent[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IAdaptiveNotificationContent) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAdaptiveNotificationContent) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAdaptiveNotificationContent) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAdaptiveNotificationContent) },
        { },
    };

    static PyType_Spec type_spec_IAdaptiveNotificationContent =
    {
        "_winrt_Windows_UI_Notifications.IAdaptiveNotificationContent",
        sizeof(py::wrapper::Windows::UI::Notifications::IAdaptiveNotificationContent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAdaptiveNotificationContent
    };

    // ----- Windows.UI.Notifications Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::UI::Notifications");

    static PyMethodDef module_methods[] = {
        {"_register_AdaptiveNotificationContentKind", register_AdaptiveNotificationContentKind, METH_O, "registers type"},
        {"_register_BadgeTemplateType", register_BadgeTemplateType, METH_O, "registers type"},
        {"_register_NotificationKinds", register_NotificationKinds, METH_O, "registers type"},
        {"_register_NotificationMirroring", register_NotificationMirroring, METH_O, "registers type"},
        {"_register_NotificationSetting", register_NotificationSetting, METH_O, "registers type"},
        {"_register_NotificationUpdateResult", register_NotificationUpdateResult, METH_O, "registers type"},
        {"_register_PeriodicUpdateRecurrence", register_PeriodicUpdateRecurrence, METH_O, "registers type"},
        {"_register_TileFlyoutTemplateType", register_TileFlyoutTemplateType, METH_O, "registers type"},
        {"_register_TileTemplateType", register_TileTemplateType, METH_O, "registers type"},
        {"_register_ToastDismissalReason", register_ToastDismissalReason, METH_O, "registers type"},
        {"_register_ToastHistoryChangedType", register_ToastHistoryChangedType, METH_O, "registers type"},
        {"_register_ToastNotificationMode", register_ToastNotificationMode, METH_O, "registers type"},
        {"_register_ToastNotificationPriority", register_ToastNotificationPriority, METH_O, "registers type"},
        {"_register_ToastTemplateType", register_ToastTemplateType, METH_O, "registers type"},
        {"_register_UserNotificationChangedKind", register_UserNotificationChangedKind, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_AdaptiveNotificationContentKind);
        Py_VISIT(state->type_BadgeTemplateType);
        Py_VISIT(state->type_NotificationKinds);
        Py_VISIT(state->type_NotificationMirroring);
        Py_VISIT(state->type_NotificationSetting);
        Py_VISIT(state->type_NotificationUpdateResult);
        Py_VISIT(state->type_PeriodicUpdateRecurrence);
        Py_VISIT(state->type_TileFlyoutTemplateType);
        Py_VISIT(state->type_TileTemplateType);
        Py_VISIT(state->type_ToastDismissalReason);
        Py_VISIT(state->type_ToastHistoryChangedType);
        Py_VISIT(state->type_ToastNotificationMode);
        Py_VISIT(state->type_ToastNotificationPriority);
        Py_VISIT(state->type_ToastTemplateType);
        Py_VISIT(state->type_UserNotificationChangedKind);
        Py_VISIT(state->type_AdaptiveNotificationText);
        Py_VISIT(state->type_BadgeNotification);
        Py_VISIT(state->type_BadgeUpdateManager);
        Py_VISIT(state->type_BadgeUpdateManagerForUser);
        Py_VISIT(state->type_BadgeUpdater);
        Py_VISIT(state->type_KnownAdaptiveNotificationHints);
        Py_VISIT(state->type_KnownAdaptiveNotificationTextStyles);
        Py_VISIT(state->type_KnownNotificationBindings);
        Py_VISIT(state->type_Notification);
        Py_VISIT(state->type_NotificationBinding);
        Py_VISIT(state->type_NotificationData);
        Py_VISIT(state->type_NotificationVisual);
        Py_VISIT(state->type_ScheduledTileNotification);
        Py_VISIT(state->type_ScheduledToastNotification);
        Py_VISIT(state->type_ScheduledToastNotificationShowingEventArgs);
        Py_VISIT(state->type_ShownTileNotification);
        Py_VISIT(state->type_TileFlyoutNotification);
        Py_VISIT(state->type_TileFlyoutUpdateManager);
        Py_VISIT(state->type_TileFlyoutUpdater);
        Py_VISIT(state->type_TileNotification);
        Py_VISIT(state->type_TileUpdateManager);
        Py_VISIT(state->type_TileUpdateManagerForUser);
        Py_VISIT(state->type_TileUpdater);
        Py_VISIT(state->type_ToastActivatedEventArgs);
        Py_VISIT(state->type_ToastCollection);
        Py_VISIT(state->type_ToastCollectionManager);
        Py_VISIT(state->type_ToastDismissedEventArgs);
        Py_VISIT(state->type_ToastFailedEventArgs);
        Py_VISIT(state->type_ToastNotification);
        Py_VISIT(state->type_ToastNotificationActionTriggerDetail);
        Py_VISIT(state->type_ToastNotificationHistory);
        Py_VISIT(state->type_ToastNotificationHistoryChangedTriggerDetail);
        Py_VISIT(state->type_ToastNotificationManager);
        Py_VISIT(state->type_ToastNotificationManagerForUser);
        Py_VISIT(state->type_ToastNotifier);
        Py_VISIT(state->type_UserNotification);
        Py_VISIT(state->type_UserNotificationChangedEventArgs);
        Py_VISIT(state->type_IAdaptiveNotificationContent);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_AdaptiveNotificationContentKind);
        Py_CLEAR(state->type_BadgeTemplateType);
        Py_CLEAR(state->type_NotificationKinds);
        Py_CLEAR(state->type_NotificationMirroring);
        Py_CLEAR(state->type_NotificationSetting);
        Py_CLEAR(state->type_NotificationUpdateResult);
        Py_CLEAR(state->type_PeriodicUpdateRecurrence);
        Py_CLEAR(state->type_TileFlyoutTemplateType);
        Py_CLEAR(state->type_TileTemplateType);
        Py_CLEAR(state->type_ToastDismissalReason);
        Py_CLEAR(state->type_ToastHistoryChangedType);
        Py_CLEAR(state->type_ToastNotificationMode);
        Py_CLEAR(state->type_ToastNotificationPriority);
        Py_CLEAR(state->type_ToastTemplateType);
        Py_CLEAR(state->type_UserNotificationChangedKind);
        Py_CLEAR(state->type_AdaptiveNotificationText);
        Py_CLEAR(state->type_BadgeNotification);
        Py_CLEAR(state->type_BadgeUpdateManager);
        Py_CLEAR(state->type_BadgeUpdateManagerForUser);
        Py_CLEAR(state->type_BadgeUpdater);
        Py_CLEAR(state->type_KnownAdaptiveNotificationHints);
        Py_CLEAR(state->type_KnownAdaptiveNotificationTextStyles);
        Py_CLEAR(state->type_KnownNotificationBindings);
        Py_CLEAR(state->type_Notification);
        Py_CLEAR(state->type_NotificationBinding);
        Py_CLEAR(state->type_NotificationData);
        Py_CLEAR(state->type_NotificationVisual);
        Py_CLEAR(state->type_ScheduledTileNotification);
        Py_CLEAR(state->type_ScheduledToastNotification);
        Py_CLEAR(state->type_ScheduledToastNotificationShowingEventArgs);
        Py_CLEAR(state->type_ShownTileNotification);
        Py_CLEAR(state->type_TileFlyoutNotification);
        Py_CLEAR(state->type_TileFlyoutUpdateManager);
        Py_CLEAR(state->type_TileFlyoutUpdater);
        Py_CLEAR(state->type_TileNotification);
        Py_CLEAR(state->type_TileUpdateManager);
        Py_CLEAR(state->type_TileUpdateManagerForUser);
        Py_CLEAR(state->type_TileUpdater);
        Py_CLEAR(state->type_ToastActivatedEventArgs);
        Py_CLEAR(state->type_ToastCollection);
        Py_CLEAR(state->type_ToastCollectionManager);
        Py_CLEAR(state->type_ToastDismissedEventArgs);
        Py_CLEAR(state->type_ToastFailedEventArgs);
        Py_CLEAR(state->type_ToastNotification);
        Py_CLEAR(state->type_ToastNotificationActionTriggerDetail);
        Py_CLEAR(state->type_ToastNotificationHistory);
        Py_CLEAR(state->type_ToastNotificationHistoryChangedTriggerDetail);
        Py_CLEAR(state->type_ToastNotificationManager);
        Py_CLEAR(state->type_ToastNotificationManagerForUser);
        Py_CLEAR(state->type_ToastNotifier);
        Py_CLEAR(state->type_UserNotification);
        Py_CLEAR(state->type_UserNotificationChangedEventArgs);
        Py_CLEAR(state->type_IAdaptiveNotificationContent);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_Windows_UI_Notifications",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::UI::Notifications

PyMODINIT_FUNC PyInit__winrt_Windows_UI_Notifications(void) noexcept
{
    using namespace py::cpp::Windows::UI::Notifications;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    WINRT_ASSERT(state);

    state->type_AdaptiveNotificationText = py::register_python_type(module.get(), type_name_AdaptiveNotificationText, &type_spec_AdaptiveNotificationText, object_bases.get(), nullptr);
    if (!state->type_AdaptiveNotificationText)
    {
        return nullptr;
    }

    state->type_BadgeNotification = py::register_python_type(module.get(), type_name_BadgeNotification, &type_spec_BadgeNotification, object_bases.get(), nullptr);
    if (!state->type_BadgeNotification)
    {
        return nullptr;
    }

    state->type_BadgeUpdateManager = py::register_python_type(module.get(), type_name_BadgeUpdateManager, &type_spec_BadgeUpdateManager, object_bases.get(), nullptr);
    if (!state->type_BadgeUpdateManager)
    {
        return nullptr;
    }

    state->type_BadgeUpdateManagerForUser = py::register_python_type(module.get(), type_name_BadgeUpdateManagerForUser, &type_spec_BadgeUpdateManagerForUser, object_bases.get(), nullptr);
    if (!state->type_BadgeUpdateManagerForUser)
    {
        return nullptr;
    }

    state->type_BadgeUpdater = py::register_python_type(module.get(), type_name_BadgeUpdater, &type_spec_BadgeUpdater, object_bases.get(), nullptr);
    if (!state->type_BadgeUpdater)
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownAdaptiveNotificationHints_Meta{PyType_FromSpec(&type_spec_KnownAdaptiveNotificationHints_Meta)};
    if (!type_KnownAdaptiveNotificationHints_Meta)
    {
        return nullptr;
    }

    state->type_KnownAdaptiveNotificationHints = py::register_python_type(module.get(), type_name_KnownAdaptiveNotificationHints, &type_spec_KnownAdaptiveNotificationHints, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KnownAdaptiveNotificationHints_Meta.get()));
    if (!state->type_KnownAdaptiveNotificationHints)
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownAdaptiveNotificationTextStyles_Meta{PyType_FromSpec(&type_spec_KnownAdaptiveNotificationTextStyles_Meta)};
    if (!type_KnownAdaptiveNotificationTextStyles_Meta)
    {
        return nullptr;
    }

    state->type_KnownAdaptiveNotificationTextStyles = py::register_python_type(module.get(), type_name_KnownAdaptiveNotificationTextStyles, &type_spec_KnownAdaptiveNotificationTextStyles, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KnownAdaptiveNotificationTextStyles_Meta.get()));
    if (!state->type_KnownAdaptiveNotificationTextStyles)
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownNotificationBindings_Meta{PyType_FromSpec(&type_spec_KnownNotificationBindings_Meta)};
    if (!type_KnownNotificationBindings_Meta)
    {
        return nullptr;
    }

    state->type_KnownNotificationBindings = py::register_python_type(module.get(), type_name_KnownNotificationBindings, &type_spec_KnownNotificationBindings, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KnownNotificationBindings_Meta.get()));
    if (!state->type_KnownNotificationBindings)
    {
        return nullptr;
    }

    state->type_Notification = py::register_python_type(module.get(), type_name_Notification, &type_spec_Notification, object_bases.get(), nullptr);
    if (!state->type_Notification)
    {
        return nullptr;
    }

    state->type_NotificationBinding = py::register_python_type(module.get(), type_name_NotificationBinding, &type_spec_NotificationBinding, object_bases.get(), nullptr);
    if (!state->type_NotificationBinding)
    {
        return nullptr;
    }

    state->type_NotificationData = py::register_python_type(module.get(), type_name_NotificationData, &type_spec_NotificationData, object_bases.get(), nullptr);
    if (!state->type_NotificationData)
    {
        return nullptr;
    }

    state->type_NotificationVisual = py::register_python_type(module.get(), type_name_NotificationVisual, &type_spec_NotificationVisual, object_bases.get(), nullptr);
    if (!state->type_NotificationVisual)
    {
        return nullptr;
    }

    state->type_ScheduledTileNotification = py::register_python_type(module.get(), type_name_ScheduledTileNotification, &type_spec_ScheduledTileNotification, object_bases.get(), nullptr);
    if (!state->type_ScheduledTileNotification)
    {
        return nullptr;
    }

    state->type_ScheduledToastNotification = py::register_python_type(module.get(), type_name_ScheduledToastNotification, &type_spec_ScheduledToastNotification, object_bases.get(), nullptr);
    if (!state->type_ScheduledToastNotification)
    {
        return nullptr;
    }

    state->type_ScheduledToastNotificationShowingEventArgs = py::register_python_type(module.get(), type_name_ScheduledToastNotificationShowingEventArgs, &type_spec_ScheduledToastNotificationShowingEventArgs, object_bases.get(), nullptr);
    if (!state->type_ScheduledToastNotificationShowingEventArgs)
    {
        return nullptr;
    }

    state->type_ShownTileNotification = py::register_python_type(module.get(), type_name_ShownTileNotification, &type_spec_ShownTileNotification, object_bases.get(), nullptr);
    if (!state->type_ShownTileNotification)
    {
        return nullptr;
    }

    state->type_TileFlyoutNotification = py::register_python_type(module.get(), type_name_TileFlyoutNotification, &type_spec_TileFlyoutNotification, object_bases.get(), nullptr);
    if (!state->type_TileFlyoutNotification)
    {
        return nullptr;
    }

    state->type_TileFlyoutUpdateManager = py::register_python_type(module.get(), type_name_TileFlyoutUpdateManager, &type_spec_TileFlyoutUpdateManager, object_bases.get(), nullptr);
    if (!state->type_TileFlyoutUpdateManager)
    {
        return nullptr;
    }

    state->type_TileFlyoutUpdater = py::register_python_type(module.get(), type_name_TileFlyoutUpdater, &type_spec_TileFlyoutUpdater, object_bases.get(), nullptr);
    if (!state->type_TileFlyoutUpdater)
    {
        return nullptr;
    }

    state->type_TileNotification = py::register_python_type(module.get(), type_name_TileNotification, &type_spec_TileNotification, object_bases.get(), nullptr);
    if (!state->type_TileNotification)
    {
        return nullptr;
    }

    state->type_TileUpdateManager = py::register_python_type(module.get(), type_name_TileUpdateManager, &type_spec_TileUpdateManager, object_bases.get(), nullptr);
    if (!state->type_TileUpdateManager)
    {
        return nullptr;
    }

    state->type_TileUpdateManagerForUser = py::register_python_type(module.get(), type_name_TileUpdateManagerForUser, &type_spec_TileUpdateManagerForUser, object_bases.get(), nullptr);
    if (!state->type_TileUpdateManagerForUser)
    {
        return nullptr;
    }

    state->type_TileUpdater = py::register_python_type(module.get(), type_name_TileUpdater, &type_spec_TileUpdater, object_bases.get(), nullptr);
    if (!state->type_TileUpdater)
    {
        return nullptr;
    }

    state->type_ToastActivatedEventArgs = py::register_python_type(module.get(), type_name_ToastActivatedEventArgs, &type_spec_ToastActivatedEventArgs, object_bases.get(), nullptr);
    if (!state->type_ToastActivatedEventArgs)
    {
        return nullptr;
    }

    state->type_ToastCollection = py::register_python_type(module.get(), type_name_ToastCollection, &type_spec_ToastCollection, object_bases.get(), nullptr);
    if (!state->type_ToastCollection)
    {
        return nullptr;
    }

    state->type_ToastCollectionManager = py::register_python_type(module.get(), type_name_ToastCollectionManager, &type_spec_ToastCollectionManager, object_bases.get(), nullptr);
    if (!state->type_ToastCollectionManager)
    {
        return nullptr;
    }

    state->type_ToastDismissedEventArgs = py::register_python_type(module.get(), type_name_ToastDismissedEventArgs, &type_spec_ToastDismissedEventArgs, object_bases.get(), nullptr);
    if (!state->type_ToastDismissedEventArgs)
    {
        return nullptr;
    }

    state->type_ToastFailedEventArgs = py::register_python_type(module.get(), type_name_ToastFailedEventArgs, &type_spec_ToastFailedEventArgs, object_bases.get(), nullptr);
    if (!state->type_ToastFailedEventArgs)
    {
        return nullptr;
    }

    state->type_ToastNotification = py::register_python_type(module.get(), type_name_ToastNotification, &type_spec_ToastNotification, object_bases.get(), nullptr);
    if (!state->type_ToastNotification)
    {
        return nullptr;
    }

    state->type_ToastNotificationActionTriggerDetail = py::register_python_type(module.get(), type_name_ToastNotificationActionTriggerDetail, &type_spec_ToastNotificationActionTriggerDetail, object_bases.get(), nullptr);
    if (!state->type_ToastNotificationActionTriggerDetail)
    {
        return nullptr;
    }

    state->type_ToastNotificationHistory = py::register_python_type(module.get(), type_name_ToastNotificationHistory, &type_spec_ToastNotificationHistory, object_bases.get(), nullptr);
    if (!state->type_ToastNotificationHistory)
    {
        return nullptr;
    }

    state->type_ToastNotificationHistoryChangedTriggerDetail = py::register_python_type(module.get(), type_name_ToastNotificationHistoryChangedTriggerDetail, &type_spec_ToastNotificationHistoryChangedTriggerDetail, object_bases.get(), nullptr);
    if (!state->type_ToastNotificationHistoryChangedTriggerDetail)
    {
        return nullptr;
    }

    py::pyobj_handle type_ToastNotificationManager_Meta{PyType_FromSpec(&type_spec_ToastNotificationManager_Meta)};
    if (!type_ToastNotificationManager_Meta)
    {
        return nullptr;
    }

    state->type_ToastNotificationManager = py::register_python_type(module.get(), type_name_ToastNotificationManager, &type_spec_ToastNotificationManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ToastNotificationManager_Meta.get()));
    if (!state->type_ToastNotificationManager)
    {
        return nullptr;
    }

    state->type_ToastNotificationManagerForUser = py::register_python_type(module.get(), type_name_ToastNotificationManagerForUser, &type_spec_ToastNotificationManagerForUser, object_bases.get(), nullptr);
    if (!state->type_ToastNotificationManagerForUser)
    {
        return nullptr;
    }

    state->type_ToastNotifier = py::register_python_type(module.get(), type_name_ToastNotifier, &type_spec_ToastNotifier, object_bases.get(), nullptr);
    if (!state->type_ToastNotifier)
    {
        return nullptr;
    }

    state->type_UserNotification = py::register_python_type(module.get(), type_name_UserNotification, &type_spec_UserNotification, object_bases.get(), nullptr);
    if (!state->type_UserNotification)
    {
        return nullptr;
    }

    state->type_UserNotificationChangedEventArgs = py::register_python_type(module.get(), type_name_UserNotificationChangedEventArgs, &type_spec_UserNotificationChangedEventArgs, object_bases.get(), nullptr);
    if (!state->type_UserNotificationChangedEventArgs)
    {
        return nullptr;
    }

    state->type_IAdaptiveNotificationContent = py::register_python_type(module.get(), type_name_IAdaptiveNotificationContent, &type_spec_IAdaptiveNotificationContent, object_bases.get(), nullptr);
    if (!state->type_IAdaptiveNotificationContent)
    {
        return nullptr;
    }


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::UI::Notifications::AdaptiveNotificationContentKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AdaptiveNotificationContentKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::AdaptiveNotificationContentKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Notifications::BadgeTemplateType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BadgeTemplateType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::BadgeTemplateType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Notifications::NotificationKinds>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NotificationKinds;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::NotificationKinds is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Notifications::NotificationMirroring>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NotificationMirroring;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::NotificationMirroring is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Notifications::NotificationSetting>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NotificationSetting;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::NotificationSetting is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Notifications::NotificationUpdateResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NotificationUpdateResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::NotificationUpdateResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Notifications::PeriodicUpdateRecurrence>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PeriodicUpdateRecurrence;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::PeriodicUpdateRecurrence is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Notifications::TileFlyoutTemplateType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TileFlyoutTemplateType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::TileFlyoutTemplateType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Notifications::TileTemplateType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TileTemplateType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::TileTemplateType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Notifications::ToastDismissalReason>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ToastDismissalReason;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::ToastDismissalReason is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Notifications::ToastHistoryChangedType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ToastHistoryChangedType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::ToastHistoryChangedType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Notifications::ToastNotificationMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ToastNotificationMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::ToastNotificationMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Notifications::ToastNotificationPriority>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ToastNotificationPriority;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::ToastNotificationPriority is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Notifications::ToastTemplateType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ToastTemplateType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::ToastTemplateType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Notifications::UserNotificationChangedKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UserNotificationChangedKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::UserNotificationChangedKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::AdaptiveNotificationText>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AdaptiveNotificationText;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::AdaptiveNotificationText is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::BadgeNotification>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BadgeNotification;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::BadgeNotification is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::BadgeUpdateManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BadgeUpdateManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::BadgeUpdateManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::BadgeUpdateManagerForUser>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BadgeUpdateManagerForUser;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::BadgeUpdateManagerForUser is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::BadgeUpdater>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BadgeUpdater;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::BadgeUpdater is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::KnownAdaptiveNotificationHints>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KnownAdaptiveNotificationHints;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::KnownAdaptiveNotificationHints is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KnownAdaptiveNotificationTextStyles;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::KnownAdaptiveNotificationTextStyles is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::KnownNotificationBindings>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KnownNotificationBindings;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::KnownNotificationBindings is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::Notification>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_Notification;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::Notification is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::NotificationBinding>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NotificationBinding;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::NotificationBinding is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::NotificationData>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NotificationData;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::NotificationData is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::NotificationVisual>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NotificationVisual;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::NotificationVisual is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::ScheduledTileNotification>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ScheduledTileNotification;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::ScheduledTileNotification is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::ScheduledToastNotification>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ScheduledToastNotification;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::ScheduledToastNotification is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::ScheduledToastNotificationShowingEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ScheduledToastNotificationShowingEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::ScheduledToastNotificationShowingEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::ShownTileNotification>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ShownTileNotification;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::ShownTileNotification is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::TileFlyoutNotification>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TileFlyoutNotification;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::TileFlyoutNotification is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::TileFlyoutUpdateManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TileFlyoutUpdateManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::TileFlyoutUpdateManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::TileFlyoutUpdater>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TileFlyoutUpdater;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::TileFlyoutUpdater is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::TileNotification>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TileNotification;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::TileNotification is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::TileUpdateManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TileUpdateManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::TileUpdateManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::TileUpdateManagerForUser>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TileUpdateManagerForUser;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::TileUpdateManagerForUser is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::TileUpdater>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TileUpdater;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::TileUpdater is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::ToastActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ToastActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::ToastActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::ToastCollection>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ToastCollection;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::ToastCollection is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::ToastCollectionManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ToastCollectionManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::ToastCollectionManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::ToastDismissedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ToastDismissedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::ToastDismissedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::ToastFailedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ToastFailedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::ToastFailedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::ToastNotification>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ToastNotification;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::ToastNotification is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::ToastNotificationActionTriggerDetail>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ToastNotificationActionTriggerDetail;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::ToastNotificationActionTriggerDetail is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::ToastNotificationHistory>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ToastNotificationHistory;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::ToastNotificationHistory is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::ToastNotificationHistoryChangedTriggerDetail>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ToastNotificationHistoryChangedTriggerDetail;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::ToastNotificationHistoryChangedTriggerDetail is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::ToastNotificationManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ToastNotificationManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::ToastNotificationManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::ToastNotificationManagerForUser>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ToastNotificationManagerForUser;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::ToastNotificationManagerForUser is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::ToastNotifier>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ToastNotifier;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::ToastNotifier is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::UserNotification>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UserNotification;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::UserNotification is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::UserNotificationChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UserNotificationChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::UserNotificationChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Notifications::IAdaptiveNotificationContent>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Notifications;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Notifications");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IAdaptiveNotificationContent;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Notifications::IAdaptiveNotificationContent is not registered");
        return nullptr;
    }

    return python_type;
}
