# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.storage
import winrt.windows.system

from winrt.windows.storage.streams import ByteOrder, FileOpenDisposition, InputStreamOptions, UnicodeEncoding

Self = typing.TypeVar('Self')

@typing.final
class Buffer_Static(type):
    def create_copy_from_memory_buffer(cls, input: typing.Optional[winrt.windows.foundation.IMemoryBuffer], /) -> typing.Optional[Buffer]: ...
    def create_memory_buffer_over_i_buffer(cls, input: typing.Optional[IBuffer], /) -> typing.Optional[winrt.windows.foundation.MemoryBuffer]: ...

@typing.final
class Buffer(winrt.system.Object, metaclass=Buffer_Static):
    def __buffer__(self, flags: int) -> memoryview: ...
    def __release_buffer__(self, view: memoryview) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Buffer: ...
    def __new__(cls: typing.Type[Buffer], capacity: winrt.system.UInt32) -> Buffer:...
    @_property
    def length(self) -> winrt.system.UInt32: ...
    @length.setter
    def length(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def capacity(self) -> winrt.system.UInt32: ...

@typing.final
class DataReader_Static(type):
    def from_buffer(cls, buffer: typing.Optional[IBuffer], /) -> typing.Optional[DataReader]: ...

@typing.final
class DataReader(winrt.system.Object, metaclass=DataReader_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DataReader: ...
    def __new__(cls: typing.Type[DataReader], input_stream: typing.Optional[IInputStream]) -> DataReader:...
    def close(self) -> None: ...
    def detach_buffer(self) -> typing.Optional[IBuffer]: ...
    def detach_stream(self) -> typing.Optional[IInputStream]: ...
    def load_async(self, count: winrt.system.UInt32, /) -> DataReaderLoadOperation: ...
    def read_boolean(self) -> bool: ...
    def read_buffer(self, length: winrt.system.UInt32, /) -> typing.Optional[IBuffer]: ...
    def read_byte(self) -> winrt.system.UInt8: ...
    def read_bytes(self, value: winrt.system.Array[winrt.system.UInt8], /) -> None: ...
    def read_date_time(self) -> datetime.datetime: ...
    def read_double(self) -> winrt.system.Double: ...
    def read_guid(self) -> _uuid.UUID: ...
    def read_int16(self) -> winrt.system.Int16: ...
    def read_int32(self) -> winrt.system.Int32: ...
    def read_int64(self) -> winrt.system.Int64: ...
    def read_single(self) -> winrt.system.Single: ...
    def read_string(self, code_unit_count: winrt.system.UInt32, /) -> str: ...
    def read_time_span(self) -> datetime.timedelta: ...
    def read_uint16(self) -> winrt.system.UInt16: ...
    def read_uint32(self) -> winrt.system.UInt32: ...
    def read_uint64(self) -> winrt.system.UInt64: ...
    @_property
    def unicode_encoding(self) -> UnicodeEncoding: ...
    @unicode_encoding.setter
    def unicode_encoding(self, value: UnicodeEncoding) -> None: ...
    @_property
    def input_stream_options(self) -> InputStreamOptions: ...
    @input_stream_options.setter
    def input_stream_options(self, value: InputStreamOptions) -> None: ...
    @_property
    def byte_order(self) -> ByteOrder: ...
    @byte_order.setter
    def byte_order(self, value: ByteOrder) -> None: ...
    @_property
    def unconsumed_buffer_length(self) -> winrt.system.UInt32: ...

@typing.final
class DataReaderLoadOperation(winrt.system.Object):
    def __await__(self) -> typing.Generator[typing.Any, None, winrt.system.UInt32]: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DataReaderLoadOperation: ...
    def cancel(self) -> None: ...
    def close(self) -> None: ...
    def get_results(self) -> winrt.system.UInt32: ...
    @_property
    def error_code(self) -> winrt.windows.foundation.HResult: ...
    @_property
    def id(self) -> winrt.system.UInt32: ...
    @_property
    def status(self) -> winrt.windows.foundation.AsyncStatus: ...
    @_property
    def completed(self) -> typing.Optional[winrt.windows.foundation.AsyncOperationCompletedHandler[winrt.system.UInt32]]: ...
    @completed.setter
    def completed(self, value: typing.Optional[winrt.windows.foundation.AsyncOperationCompletedHandler[winrt.system.UInt32]]) -> None: ...

@typing.final
class DataWriter(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DataWriter: ...
    @typing.overload
    def __new__(cls: typing.Type[DataWriter], output_stream: typing.Optional[IOutputStream]) -> DataWriter:...
    @typing.overload
    def __new__(cls: typing.Type[DataWriter]) -> DataWriter:...
    def close(self) -> None: ...
    def detach_buffer(self) -> typing.Optional[IBuffer]: ...
    def detach_stream(self) -> typing.Optional[IOutputStream]: ...
    def flush_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def measure_string(self, value: str, /) -> winrt.system.UInt32: ...
    def store_async(self) -> DataWriterStoreOperation: ...
    def write_boolean(self, value: bool, /) -> None: ...
    @typing.overload
    def write_buffer(self, buffer: typing.Optional[IBuffer], /) -> None: ...
    @typing.overload
    def write_buffer(self, buffer: typing.Optional[IBuffer], start: winrt.system.UInt32, count: winrt.system.UInt32, /) -> None: ...
    def write_byte(self, value: winrt.system.UInt8, /) -> None: ...
    def write_bytes(self, value: winrt.system.Array[winrt.system.UInt8], /) -> None: ...
    def write_date_time(self, value: datetime.datetime, /) -> None: ...
    def write_double(self, value: winrt.system.Double, /) -> None: ...
    def write_guid(self, value: _uuid.UUID, /) -> None: ...
    def write_int16(self, value: winrt.system.Int16, /) -> None: ...
    def write_int32(self, value: winrt.system.Int32, /) -> None: ...
    def write_int64(self, value: winrt.system.Int64, /) -> None: ...
    def write_single(self, value: winrt.system.Single, /) -> None: ...
    def write_string(self, value: str, /) -> winrt.system.UInt32: ...
    def write_time_span(self, value: datetime.timedelta, /) -> None: ...
    def write_uint16(self, value: winrt.system.UInt16, /) -> None: ...
    def write_uint32(self, value: winrt.system.UInt32, /) -> None: ...
    def write_uint64(self, value: winrt.system.UInt64, /) -> None: ...
    @_property
    def unicode_encoding(self) -> UnicodeEncoding: ...
    @unicode_encoding.setter
    def unicode_encoding(self, value: UnicodeEncoding) -> None: ...
    @_property
    def byte_order(self) -> ByteOrder: ...
    @byte_order.setter
    def byte_order(self, value: ByteOrder) -> None: ...
    @_property
    def unstored_buffer_length(self) -> winrt.system.UInt32: ...

@typing.final
class DataWriterStoreOperation(winrt.system.Object):
    def __await__(self) -> typing.Generator[typing.Any, None, winrt.system.UInt32]: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DataWriterStoreOperation: ...
    def cancel(self) -> None: ...
    def close(self) -> None: ...
    def get_results(self) -> winrt.system.UInt32: ...
    @_property
    def error_code(self) -> winrt.windows.foundation.HResult: ...
    @_property
    def id(self) -> winrt.system.UInt32: ...
    @_property
    def status(self) -> winrt.windows.foundation.AsyncStatus: ...
    @_property
    def completed(self) -> typing.Optional[winrt.windows.foundation.AsyncOperationCompletedHandler[winrt.system.UInt32]]: ...
    @completed.setter
    def completed(self, value: typing.Optional[winrt.windows.foundation.AsyncOperationCompletedHandler[winrt.system.UInt32]]) -> None: ...

@typing.final
class FileInputStream(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FileInputStream: ...
    def close(self) -> None: ...
    def read_async(self, buffer: typing.Optional[IBuffer], count: winrt.system.UInt32, options: InputStreamOptions, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[IBuffer, winrt.system.UInt32]: ...

@typing.final
class FileOutputStream(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FileOutputStream: ...
    def close(self) -> None: ...
    def flush_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def write_async(self, buffer: typing.Optional[IBuffer], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[winrt.system.UInt32, winrt.system.UInt32]: ...

@typing.final
class FileRandomAccessStream_Static(type):
    @typing.overload
    def open_async(cls, file_path: str, access_mode: winrt.windows.storage.FileAccessMode, /) -> winrt.windows.foundation.IAsyncOperation[IRandomAccessStream]: ...
    @typing.overload
    def open_async(cls, file_path: str, access_mode: winrt.windows.storage.FileAccessMode, sharing_options: winrt.windows.storage.StorageOpenOptions, open_disposition: FileOpenDisposition, /) -> winrt.windows.foundation.IAsyncOperation[IRandomAccessStream]: ...
    @typing.overload
    def open_for_user_async(cls, user: typing.Optional[winrt.windows.system.User], file_path: str, access_mode: winrt.windows.storage.FileAccessMode, /) -> winrt.windows.foundation.IAsyncOperation[IRandomAccessStream]: ...
    @typing.overload
    def open_for_user_async(cls, user: typing.Optional[winrt.windows.system.User], file_path: str, access_mode: winrt.windows.storage.FileAccessMode, sharing_options: winrt.windows.storage.StorageOpenOptions, open_disposition: FileOpenDisposition, /) -> winrt.windows.foundation.IAsyncOperation[IRandomAccessStream]: ...
    @typing.overload
    def open_transacted_write_async(cls, file_path: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.StorageStreamTransaction]: ...
    @typing.overload
    def open_transacted_write_async(cls, file_path: str, open_options: winrt.windows.storage.StorageOpenOptions, open_disposition: FileOpenDisposition, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.StorageStreamTransaction]: ...
    @typing.overload
    def open_transacted_write_for_user_async(cls, user: typing.Optional[winrt.windows.system.User], file_path: str, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.StorageStreamTransaction]: ...
    @typing.overload
    def open_transacted_write_for_user_async(cls, user: typing.Optional[winrt.windows.system.User], file_path: str, open_options: winrt.windows.storage.StorageOpenOptions, open_disposition: FileOpenDisposition, /) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.storage.StorageStreamTransaction]: ...

@typing.final
class FileRandomAccessStream(winrt.system.Object, metaclass=FileRandomAccessStream_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FileRandomAccessStream: ...
    def clone_stream(self) -> typing.Optional[IRandomAccessStream]: ...
    def close(self) -> None: ...
    def flush_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def get_input_stream_at(self, position: winrt.system.UInt64, /) -> typing.Optional[IInputStream]: ...
    def get_output_stream_at(self, position: winrt.system.UInt64, /) -> typing.Optional[IOutputStream]: ...
    def read_async(self, buffer: typing.Optional[IBuffer], count: winrt.system.UInt32, options: InputStreamOptions, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[IBuffer, winrt.system.UInt32]: ...
    def seek(self, position: winrt.system.UInt64, /) -> None: ...
    def write_async(self, buffer: typing.Optional[IBuffer], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[winrt.system.UInt32, winrt.system.UInt32]: ...
    @_property
    def size(self) -> winrt.system.UInt64: ...
    @size.setter
    def size(self, value: winrt.system.UInt64) -> None: ...
    @_property
    def can_read(self) -> bool: ...
    @_property
    def can_write(self) -> bool: ...
    @_property
    def position(self) -> winrt.system.UInt64: ...

@typing.final
class InMemoryRandomAccessStream(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InMemoryRandomAccessStream: ...
    def __new__(cls: typing.Type[InMemoryRandomAccessStream]) -> InMemoryRandomAccessStream:...
    def clone_stream(self) -> typing.Optional[IRandomAccessStream]: ...
    def close(self) -> None: ...
    def flush_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def get_input_stream_at(self, position: winrt.system.UInt64, /) -> typing.Optional[IInputStream]: ...
    def get_output_stream_at(self, position: winrt.system.UInt64, /) -> typing.Optional[IOutputStream]: ...
    def read_async(self, buffer: typing.Optional[IBuffer], count: winrt.system.UInt32, options: InputStreamOptions, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[IBuffer, winrt.system.UInt32]: ...
    def seek(self, position: winrt.system.UInt64, /) -> None: ...
    def write_async(self, buffer: typing.Optional[IBuffer], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[winrt.system.UInt32, winrt.system.UInt32]: ...
    @_property
    def size(self) -> winrt.system.UInt64: ...
    @size.setter
    def size(self, value: winrt.system.UInt64) -> None: ...
    @_property
    def can_read(self) -> bool: ...
    @_property
    def can_write(self) -> bool: ...
    @_property
    def position(self) -> winrt.system.UInt64: ...

@typing.final
class InputStreamOverStream(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> InputStreamOverStream: ...
    def close(self) -> None: ...
    def read_async(self, buffer: typing.Optional[IBuffer], count: winrt.system.UInt32, options: InputStreamOptions, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[IBuffer, winrt.system.UInt32]: ...

@typing.final
class OutputStreamOverStream(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> OutputStreamOverStream: ...
    def close(self) -> None: ...
    def flush_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def write_async(self, buffer: typing.Optional[IBuffer], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[winrt.system.UInt32, winrt.system.UInt32]: ...

@typing.final
class RandomAccessStream_Static(type):
    def copy_and_close_async(cls, source: typing.Optional[IInputStream], destination: typing.Optional[IOutputStream], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[winrt.system.UInt64, winrt.system.UInt64]: ...
    @typing.overload
    def copy_async(cls, source: typing.Optional[IInputStream], destination: typing.Optional[IOutputStream], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[winrt.system.UInt64, winrt.system.UInt64]: ...
    @typing.overload
    def copy_async(cls, source: typing.Optional[IInputStream], destination: typing.Optional[IOutputStream], bytes_to_copy: winrt.system.UInt64, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[winrt.system.UInt64, winrt.system.UInt64]: ...

@typing.final
class RandomAccessStream(winrt.system.Object, metaclass=RandomAccessStream_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RandomAccessStream: ...

@typing.final
class RandomAccessStreamOverStream(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RandomAccessStreamOverStream: ...
    def clone_stream(self) -> typing.Optional[IRandomAccessStream]: ...
    def close(self) -> None: ...
    def flush_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def get_input_stream_at(self, position: winrt.system.UInt64, /) -> typing.Optional[IInputStream]: ...
    def get_output_stream_at(self, position: winrt.system.UInt64, /) -> typing.Optional[IOutputStream]: ...
    def read_async(self, buffer: typing.Optional[IBuffer], count: winrt.system.UInt32, options: InputStreamOptions, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[IBuffer, winrt.system.UInt32]: ...
    def seek(self, position: winrt.system.UInt64, /) -> None: ...
    def write_async(self, buffer: typing.Optional[IBuffer], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[winrt.system.UInt32, winrt.system.UInt32]: ...
    @_property
    def size(self) -> winrt.system.UInt64: ...
    @size.setter
    def size(self, value: winrt.system.UInt64) -> None: ...
    @_property
    def can_read(self) -> bool: ...
    @_property
    def can_write(self) -> bool: ...
    @_property
    def position(self) -> winrt.system.UInt64: ...

@typing.final
class RandomAccessStreamReference_Static(type):
    def create_from_file(cls, file: typing.Optional[winrt.windows.storage.IStorageFile], /) -> typing.Optional[RandomAccessStreamReference]: ...
    def create_from_stream(cls, stream: typing.Optional[IRandomAccessStream], /) -> typing.Optional[RandomAccessStreamReference]: ...
    def create_from_uri(cls, uri: typing.Optional[winrt.windows.foundation.Uri], /) -> typing.Optional[RandomAccessStreamReference]: ...

@typing.final
class RandomAccessStreamReference(winrt.system.Object, metaclass=RandomAccessStreamReference_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RandomAccessStreamReference: ...
    def open_read_async(self) -> winrt.windows.foundation.IAsyncOperation[IRandomAccessStreamWithContentType]: ...

@typing.final
class IBuffer(winrt.system.Object):
    def __buffer__(self, flags: int) -> memoryview: ...
    def __release_buffer__(self, view: memoryview) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IBuffer: ...
    @_property
    def capacity(self) -> winrt.system.UInt32: ...
    @_property
    def length(self) -> winrt.system.UInt32: ...
    @length.setter
    def length(self, value: winrt.system.UInt32) -> None: ...

@typing.final
class IContentTypeProvider(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IContentTypeProvider: ...
    @_property
    def content_type(self) -> str: ...

@typing.final
class IDataReader(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IDataReader: ...
    def detach_buffer(self) -> typing.Optional[IBuffer]: ...
    def detach_stream(self) -> typing.Optional[IInputStream]: ...
    def load_async(self, count: winrt.system.UInt32, /) -> DataReaderLoadOperation: ...
    def read_boolean(self) -> bool: ...
    def read_buffer(self, length: winrt.system.UInt32, /) -> typing.Optional[IBuffer]: ...
    def read_byte(self) -> winrt.system.UInt8: ...
    def read_bytes(self, value: winrt.system.Array[winrt.system.UInt8], /) -> None: ...
    def read_date_time(self) -> datetime.datetime: ...
    def read_double(self) -> winrt.system.Double: ...
    def read_guid(self) -> _uuid.UUID: ...
    def read_int16(self) -> winrt.system.Int16: ...
    def read_int32(self) -> winrt.system.Int32: ...
    def read_int64(self) -> winrt.system.Int64: ...
    def read_single(self) -> winrt.system.Single: ...
    def read_string(self, code_unit_count: winrt.system.UInt32, /) -> str: ...
    def read_time_span(self) -> datetime.timedelta: ...
    def read_uint16(self) -> winrt.system.UInt16: ...
    def read_uint32(self) -> winrt.system.UInt32: ...
    def read_uint64(self) -> winrt.system.UInt64: ...
    @_property
    def byte_order(self) -> ByteOrder: ...
    @byte_order.setter
    def byte_order(self, value: ByteOrder) -> None: ...
    @_property
    def input_stream_options(self) -> InputStreamOptions: ...
    @input_stream_options.setter
    def input_stream_options(self, value: InputStreamOptions) -> None: ...
    @_property
    def unconsumed_buffer_length(self) -> winrt.system.UInt32: ...
    @_property
    def unicode_encoding(self) -> UnicodeEncoding: ...
    @unicode_encoding.setter
    def unicode_encoding(self, value: UnicodeEncoding) -> None: ...

@typing.final
class IDataWriter(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IDataWriter: ...
    def detach_buffer(self) -> typing.Optional[IBuffer]: ...
    def detach_stream(self) -> typing.Optional[IOutputStream]: ...
    def flush_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def measure_string(self, value: str, /) -> winrt.system.UInt32: ...
    def store_async(self) -> DataWriterStoreOperation: ...
    def write_boolean(self, value: bool, /) -> None: ...
    @typing.overload
    def write_buffer(self, buffer: typing.Optional[IBuffer], /) -> None: ...
    @typing.overload
    def write_buffer(self, buffer: typing.Optional[IBuffer], start: winrt.system.UInt32, count: winrt.system.UInt32, /) -> None: ...
    def write_byte(self, value: winrt.system.UInt8, /) -> None: ...
    def write_bytes(self, value: winrt.system.Array[winrt.system.UInt8], /) -> None: ...
    def write_date_time(self, value: datetime.datetime, /) -> None: ...
    def write_double(self, value: winrt.system.Double, /) -> None: ...
    def write_guid(self, value: _uuid.UUID, /) -> None: ...
    def write_int16(self, value: winrt.system.Int16, /) -> None: ...
    def write_int32(self, value: winrt.system.Int32, /) -> None: ...
    def write_int64(self, value: winrt.system.Int64, /) -> None: ...
    def write_single(self, value: winrt.system.Single, /) -> None: ...
    def write_string(self, value: str, /) -> winrt.system.UInt32: ...
    def write_time_span(self, value: datetime.timedelta, /) -> None: ...
    def write_uint16(self, value: winrt.system.UInt16, /) -> None: ...
    def write_uint32(self, value: winrt.system.UInt32, /) -> None: ...
    def write_uint64(self, value: winrt.system.UInt64, /) -> None: ...
    @_property
    def byte_order(self) -> ByteOrder: ...
    @byte_order.setter
    def byte_order(self, value: ByteOrder) -> None: ...
    @_property
    def unicode_encoding(self) -> UnicodeEncoding: ...
    @unicode_encoding.setter
    def unicode_encoding(self, value: UnicodeEncoding) -> None: ...
    @_property
    def unstored_buffer_length(self) -> winrt.system.UInt32: ...

@typing.final
class IInputStream(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IInputStream: ...
    def close(self) -> None: ...
    def read_async(self, buffer: typing.Optional[IBuffer], count: winrt.system.UInt32, options: InputStreamOptions, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[IBuffer, winrt.system.UInt32]: ...

@typing.final
class IInputStreamReference(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IInputStreamReference: ...
    def open_sequential_read_async(self) -> winrt.windows.foundation.IAsyncOperation[IInputStream]: ...

@typing.final
class IOutputStream(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IOutputStream: ...
    def close(self) -> None: ...
    def flush_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def write_async(self, buffer: typing.Optional[IBuffer], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[winrt.system.UInt32, winrt.system.UInt32]: ...

@typing.final
class IPropertySetSerializer(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IPropertySetSerializer: ...
    def deserialize(self, property_set: typing.Optional[winrt.windows.foundation.collections.IPropertySet], buffer: typing.Optional[IBuffer], /) -> None: ...
    def serialize(self, property_set: typing.Optional[winrt.windows.foundation.collections.IPropertySet], /) -> typing.Optional[IBuffer]: ...

@typing.final
class IRandomAccessStream(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IRandomAccessStream: ...
    def clone_stream(self) -> typing.Optional[IRandomAccessStream]: ...
    def close(self) -> None: ...
    def flush_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def get_input_stream_at(self, position: winrt.system.UInt64, /) -> typing.Optional[IInputStream]: ...
    def get_output_stream_at(self, position: winrt.system.UInt64, /) -> typing.Optional[IOutputStream]: ...
    def read_async(self, buffer: typing.Optional[IBuffer], count: winrt.system.UInt32, options: InputStreamOptions, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[IBuffer, winrt.system.UInt32]: ...
    def seek(self, position: winrt.system.UInt64, /) -> None: ...
    def write_async(self, buffer: typing.Optional[IBuffer], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[winrt.system.UInt32, winrt.system.UInt32]: ...
    @_property
    def can_read(self) -> bool: ...
    @_property
    def can_write(self) -> bool: ...
    @_property
    def position(self) -> winrt.system.UInt64: ...
    @_property
    def size(self) -> winrt.system.UInt64: ...
    @size.setter
    def size(self, value: winrt.system.UInt64) -> None: ...

@typing.final
class IRandomAccessStreamReference(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IRandomAccessStreamReference: ...
    def open_read_async(self) -> winrt.windows.foundation.IAsyncOperation[IRandomAccessStreamWithContentType]: ...

@typing.final
class IRandomAccessStreamWithContentType(winrt.system.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> IRandomAccessStreamWithContentType: ...
    def clone_stream(self) -> typing.Optional[IRandomAccessStream]: ...
    def close(self) -> None: ...
    def flush_async(self) -> winrt.windows.foundation.IAsyncOperation[bool]: ...
    def get_input_stream_at(self, position: winrt.system.UInt64, /) -> typing.Optional[IInputStream]: ...
    def get_output_stream_at(self, position: winrt.system.UInt64, /) -> typing.Optional[IOutputStream]: ...
    def read_async(self, buffer: typing.Optional[IBuffer], count: winrt.system.UInt32, options: InputStreamOptions, /) -> winrt.windows.foundation.IAsyncOperationWithProgress[IBuffer, winrt.system.UInt32]: ...
    def seek(self, position: winrt.system.UInt64, /) -> None: ...
    def write_async(self, buffer: typing.Optional[IBuffer], /) -> winrt.windows.foundation.IAsyncOperationWithProgress[winrt.system.UInt32, winrt.system.UInt32]: ...
    @_property
    def can_read(self) -> bool: ...
    @_property
    def can_write(self) -> bool: ...
    @_property
    def position(self) -> winrt.system.UInt64: ...
    @_property
    def size(self) -> winrt.system.UInt64: ...
    @size.setter
    def size(self, value: winrt.system.UInt64) -> None: ...
    @_property
    def content_type(self) -> str: ...

