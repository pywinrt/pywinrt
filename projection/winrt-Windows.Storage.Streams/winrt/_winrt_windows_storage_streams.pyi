# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.foundation as windows_foundation
import winrt.windows.foundation.collections as windows_foundation_collections
import winrt.windows.storage as windows_storage
import winrt.windows.system as windows_system

from winrt.windows.storage.streams import ByteOrder, FileOpenDisposition, InputStreamOptions, UnicodeEncoding

Self = typing.TypeVar('Self')

@typing.final
class Buffer_Static(type):
    def create_copy_from_memory_buffer(cls, input: windows_foundation.ImplementsIMemoryBuffer, /) -> Buffer: ...
    def create_memory_buffer_over_ibuffer(cls, input: ImplementsIBuffer, /) -> windows_foundation.MemoryBuffer: ...

@typing.final
class Buffer(winrt.system.Object, ImplementsIBuffer, metaclass=Buffer_Static):
    def __buffer__(self, flags: int, /) -> memoryview: ...
    def __release_buffer__(self, view: memoryview, /) -> None: ...
    def __new__(cls: typing.Type[Self], capacity: winrt.system.UInt32) -> Self: ...
    @_property
    def length(self) -> winrt.system.UInt32: ...
    @length.setter
    def length(self, value: winrt.system.UInt32) -> None: ...
    @_property
    def capacity(self) -> winrt.system.UInt32: ...

@typing.final
class DataReader_Static(type):
    def from_buffer(cls, buffer: ImplementsIBuffer, /) -> DataReader: ...

@typing.final
class DataReader(winrt.system.Object, windows_foundation.ImplementsIClosable, ImplementsIDataReader, metaclass=DataReader_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    def __new__(cls: typing.Type[Self], input_stream: ImplementsIInputStream) -> Self: ...
    def close(self) -> None: ...
    def detach_buffer(self) -> IBuffer: ...
    def detach_stream(self) -> IInputStream: ...
    def load_async(self, count: winrt.system.UInt32, /) -> DataReaderLoadOperation: ...
    def read_boolean(self) -> bool: ...
    def read_buffer(self, length: winrt.system.UInt32, /) -> IBuffer: ...
    def read_byte(self) -> winrt.system.UInt8: ...
    def read_bytes(self, value: typing.Union[winrt.system.Array[winrt.system.UInt8], winrt.system.WriteableBuffer], /) -> None: ...
    def read_date_time(self) -> datetime.datetime: ...
    def read_double(self) -> winrt.system.Double: ...
    def read_guid(self) -> _uuid.UUID: ...
    def read_int16(self) -> winrt.system.Int16: ...
    def read_int32(self) -> winrt.system.Int32: ...
    def read_int64(self) -> winrt.system.Int64: ...
    def read_single(self) -> winrt.system.Single: ...
    def read_string(self, code_unit_count: winrt.system.UInt32, /) -> str: ...
    def read_time_span(self) -> datetime.timedelta: ...
    def read_uint16(self) -> winrt.system.UInt16: ...
    def read_uint32(self) -> winrt.system.UInt32: ...
    def read_uint64(self) -> winrt.system.UInt64: ...
    @_property
    def unicode_encoding(self) -> UnicodeEncoding: ...
    @unicode_encoding.setter
    def unicode_encoding(self, value: UnicodeEncoding) -> None: ...
    @_property
    def input_stream_options(self) -> InputStreamOptions: ...
    @input_stream_options.setter
    def input_stream_options(self, value: InputStreamOptions) -> None: ...
    @_property
    def byte_order(self) -> ByteOrder: ...
    @byte_order.setter
    def byte_order(self, value: ByteOrder) -> None: ...
    @_property
    def unconsumed_buffer_length(self) -> winrt.system.UInt32: ...

@typing.final
class DataReaderLoadOperation(winrt.system.Object, windows_foundation.ImplementsIAsyncOperation[winrt.system.UInt32], windows_foundation.ImplementsIAsyncInfo):
    def __await__(self) -> typing.Generator[typing.Any, None, winrt.system.UInt32]: ...
    def cancel(self) -> None: ...
    def close(self) -> None: ...
    def get_results(self) -> winrt.system.UInt32: ...
    @_property
    def error_code(self) -> windows_foundation.HResult: ...
    @_property
    def id(self) -> winrt.system.UInt32: ...
    @_property
    def status(self) -> windows_foundation.AsyncStatus: ...
    @_property
    def completed(self) -> windows_foundation.AsyncOperationCompletedHandler[winrt.system.UInt32]: ...
    @completed.setter
    def completed(self, value: windows_foundation.AsyncOperationCompletedHandler[winrt.system.UInt32]) -> None: ...

@typing.final
class DataWriter(winrt.system.Object, windows_foundation.ImplementsIClosable, ImplementsIDataWriter):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @typing.overload
    def __new__(cls: typing.Type[Self], output_stream: ImplementsIOutputStream) -> Self: ...
    @typing.overload
    def __new__(cls: typing.Type[Self]) -> Self: ...
    def close(self) -> None: ...
    def detach_buffer(self) -> IBuffer: ...
    def detach_stream(self) -> IOutputStream: ...
    def flush_async(self) -> windows_foundation.IAsyncOperation[bool]: ...
    def measure_string(self, value: str, /) -> winrt.system.UInt32: ...
    def store_async(self) -> DataWriterStoreOperation: ...
    def write_boolean(self, value: bool, /) -> None: ...
    def write_buffer(self, buffer: ImplementsIBuffer, /) -> None: ...
    def write_buffer_range(self, buffer: ImplementsIBuffer, start: winrt.system.UInt32, count: winrt.system.UInt32, /) -> None: ...
    def write_byte(self, value: winrt.system.UInt8, /) -> None: ...
    def write_bytes(self, value: typing.Union[winrt.system.Array[winrt.system.UInt8], winrt.system.ReadableBuffer], /) -> None: ...
    def write_date_time(self, value: datetime.datetime, /) -> None: ...
    def write_double(self, value: winrt.system.Double, /) -> None: ...
    def write_guid(self, value: _uuid.UUID, /) -> None: ...
    def write_int16(self, value: winrt.system.Int16, /) -> None: ...
    def write_int32(self, value: winrt.system.Int32, /) -> None: ...
    def write_int64(self, value: winrt.system.Int64, /) -> None: ...
    def write_single(self, value: winrt.system.Single, /) -> None: ...
    def write_string(self, value: str, /) -> winrt.system.UInt32: ...
    def write_time_span(self, value: datetime.timedelta, /) -> None: ...
    def write_uint16(self, value: winrt.system.UInt16, /) -> None: ...
    def write_uint32(self, value: winrt.system.UInt32, /) -> None: ...
    def write_uint64(self, value: winrt.system.UInt64, /) -> None: ...
    @_property
    def unicode_encoding(self) -> UnicodeEncoding: ...
    @unicode_encoding.setter
    def unicode_encoding(self, value: UnicodeEncoding) -> None: ...
    @_property
    def byte_order(self) -> ByteOrder: ...
    @byte_order.setter
    def byte_order(self, value: ByteOrder) -> None: ...
    @_property
    def unstored_buffer_length(self) -> winrt.system.UInt32: ...

@typing.final
class DataWriterStoreOperation(winrt.system.Object, windows_foundation.ImplementsIAsyncOperation[winrt.system.UInt32], windows_foundation.ImplementsIAsyncInfo):
    def __await__(self) -> typing.Generator[typing.Any, None, winrt.system.UInt32]: ...
    def cancel(self) -> None: ...
    def close(self) -> None: ...
    def get_results(self) -> winrt.system.UInt32: ...
    @_property
    def error_code(self) -> windows_foundation.HResult: ...
    @_property
    def id(self) -> winrt.system.UInt32: ...
    @_property
    def status(self) -> windows_foundation.AsyncStatus: ...
    @_property
    def completed(self) -> windows_foundation.AsyncOperationCompletedHandler[winrt.system.UInt32]: ...
    @completed.setter
    def completed(self, value: windows_foundation.AsyncOperationCompletedHandler[winrt.system.UInt32]) -> None: ...

@typing.final
class FileInputStream(winrt.system.Object, ImplementsIInputStream, windows_foundation.ImplementsIClosable):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    def close(self) -> None: ...
    def read_async(self, buffer: ImplementsIBuffer, count: winrt.system.UInt32, options: InputStreamOptions, /) -> windows_foundation.IAsyncOperationWithProgress[IBuffer, winrt.system.UInt32]: ...

@typing.final
class FileOutputStream(winrt.system.Object, ImplementsIOutputStream, windows_foundation.ImplementsIClosable):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    def close(self) -> None: ...
    def flush_async(self) -> windows_foundation.IAsyncOperation[bool]: ...
    def write_async(self, buffer: ImplementsIBuffer, /) -> windows_foundation.IAsyncOperationWithProgress[winrt.system.UInt32, winrt.system.UInt32]: ...

@typing.final
class FileRandomAccessStream_Static(type):
    def open_async(cls, file_path: str, access_mode: windows_storage.FileAccessMode, /) -> windows_foundation.IAsyncOperation[IRandomAccessStream]: ...
    def open_for_user_async(cls, user: windows_system.User, file_path: str, access_mode: windows_storage.FileAccessMode, /) -> windows_foundation.IAsyncOperation[IRandomAccessStream]: ...
    def open_for_user_with_options_async(cls, user: windows_system.User, file_path: str, access_mode: windows_storage.FileAccessMode, sharing_options: windows_storage.StorageOpenOptions, open_disposition: FileOpenDisposition, /) -> windows_foundation.IAsyncOperation[IRandomAccessStream]: ...
    def open_transacted_write_async(cls, file_path: str, /) -> windows_foundation.IAsyncOperation[windows_storage.StorageStreamTransaction]: ...
    def open_transacted_write_for_user_async(cls, user: windows_system.User, file_path: str, /) -> windows_foundation.IAsyncOperation[windows_storage.StorageStreamTransaction]: ...
    def open_transacted_write_for_user_with_options_async(cls, user: windows_system.User, file_path: str, open_options: windows_storage.StorageOpenOptions, open_disposition: FileOpenDisposition, /) -> windows_foundation.IAsyncOperation[windows_storage.StorageStreamTransaction]: ...
    def open_transacted_write_with_options_async(cls, file_path: str, open_options: windows_storage.StorageOpenOptions, open_disposition: FileOpenDisposition, /) -> windows_foundation.IAsyncOperation[windows_storage.StorageStreamTransaction]: ...
    def open_with_options_async(cls, file_path: str, access_mode: windows_storage.FileAccessMode, sharing_options: windows_storage.StorageOpenOptions, open_disposition: FileOpenDisposition, /) -> windows_foundation.IAsyncOperation[IRandomAccessStream]: ...

@typing.final
class FileRandomAccessStream(winrt.system.Object, ImplementsIRandomAccessStream, ImplementsIOutputStream, ImplementsIInputStream, windows_foundation.ImplementsIClosable, metaclass=FileRandomAccessStream_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    def clone_stream(self) -> IRandomAccessStream: ...
    def close(self) -> None: ...
    def flush_async(self) -> windows_foundation.IAsyncOperation[bool]: ...
    def get_input_stream_at(self, position: winrt.system.UInt64, /) -> IInputStream: ...
    def get_output_stream_at(self, position: winrt.system.UInt64, /) -> IOutputStream: ...
    def read_async(self, buffer: ImplementsIBuffer, count: winrt.system.UInt32, options: InputStreamOptions, /) -> windows_foundation.IAsyncOperationWithProgress[IBuffer, winrt.system.UInt32]: ...
    def seek(self, position: winrt.system.UInt64, /) -> None: ...
    def write_async(self, buffer: ImplementsIBuffer, /) -> windows_foundation.IAsyncOperationWithProgress[winrt.system.UInt32, winrt.system.UInt32]: ...
    @_property
    def size(self) -> winrt.system.UInt64: ...
    @size.setter
    def size(self, value: winrt.system.UInt64) -> None: ...
    @_property
    def can_read(self) -> bool: ...
    @_property
    def can_write(self) -> bool: ...
    @_property
    def position(self) -> winrt.system.UInt64: ...

@typing.final
class InMemoryRandomAccessStream(winrt.system.Object, ImplementsIRandomAccessStream, ImplementsIOutputStream, ImplementsIInputStream, windows_foundation.ImplementsIClosable):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...
    def clone_stream(self) -> IRandomAccessStream: ...
    def close(self) -> None: ...
    def flush_async(self) -> windows_foundation.IAsyncOperation[bool]: ...
    def get_input_stream_at(self, position: winrt.system.UInt64, /) -> IInputStream: ...
    def get_output_stream_at(self, position: winrt.system.UInt64, /) -> IOutputStream: ...
    def read_async(self, buffer: ImplementsIBuffer, count: winrt.system.UInt32, options: InputStreamOptions, /) -> windows_foundation.IAsyncOperationWithProgress[IBuffer, winrt.system.UInt32]: ...
    def seek(self, position: winrt.system.UInt64, /) -> None: ...
    def write_async(self, buffer: ImplementsIBuffer, /) -> windows_foundation.IAsyncOperationWithProgress[winrt.system.UInt32, winrt.system.UInt32]: ...
    @_property
    def size(self) -> winrt.system.UInt64: ...
    @size.setter
    def size(self, value: winrt.system.UInt64) -> None: ...
    @_property
    def can_read(self) -> bool: ...
    @_property
    def can_write(self) -> bool: ...
    @_property
    def position(self) -> winrt.system.UInt64: ...

@typing.final
class InputStreamOverStream(winrt.system.Object, ImplementsIInputStream, windows_foundation.ImplementsIClosable):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    def close(self) -> None: ...
    def read_async(self, buffer: ImplementsIBuffer, count: winrt.system.UInt32, options: InputStreamOptions, /) -> windows_foundation.IAsyncOperationWithProgress[IBuffer, winrt.system.UInt32]: ...

@typing.final
class OutputStreamOverStream(winrt.system.Object, ImplementsIOutputStream, windows_foundation.ImplementsIClosable):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    def close(self) -> None: ...
    def flush_async(self) -> windows_foundation.IAsyncOperation[bool]: ...
    def write_async(self, buffer: ImplementsIBuffer, /) -> windows_foundation.IAsyncOperationWithProgress[winrt.system.UInt32, winrt.system.UInt32]: ...

@typing.final
class RandomAccessStream_Static(type):
    def copy_and_close_async(cls, source: ImplementsIInputStream, destination: ImplementsIOutputStream, /) -> windows_foundation.IAsyncOperationWithProgress[winrt.system.UInt64, winrt.system.UInt64]: ...
    def copy_async(cls, source: ImplementsIInputStream, destination: ImplementsIOutputStream, /) -> windows_foundation.IAsyncOperationWithProgress[winrt.system.UInt64, winrt.system.UInt64]: ...
    def copy_size_async(cls, source: ImplementsIInputStream, destination: ImplementsIOutputStream, bytes_to_copy: winrt.system.UInt64, /) -> windows_foundation.IAsyncOperationWithProgress[winrt.system.UInt64, winrt.system.UInt64]: ...

@typing.final
class RandomAccessStream(winrt.system.Object, metaclass=RandomAccessStream_Static):
    pass

@typing.final
class RandomAccessStreamOverStream(winrt.system.Object, ImplementsIRandomAccessStream, ImplementsIOutputStream, ImplementsIInputStream, windows_foundation.ImplementsIClosable):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    def clone_stream(self) -> IRandomAccessStream: ...
    def close(self) -> None: ...
    def flush_async(self) -> windows_foundation.IAsyncOperation[bool]: ...
    def get_input_stream_at(self, position: winrt.system.UInt64, /) -> IInputStream: ...
    def get_output_stream_at(self, position: winrt.system.UInt64, /) -> IOutputStream: ...
    def read_async(self, buffer: ImplementsIBuffer, count: winrt.system.UInt32, options: InputStreamOptions, /) -> windows_foundation.IAsyncOperationWithProgress[IBuffer, winrt.system.UInt32]: ...
    def seek(self, position: winrt.system.UInt64, /) -> None: ...
    def write_async(self, buffer: ImplementsIBuffer, /) -> windows_foundation.IAsyncOperationWithProgress[winrt.system.UInt32, winrt.system.UInt32]: ...
    @_property
    def size(self) -> winrt.system.UInt64: ...
    @size.setter
    def size(self, value: winrt.system.UInt64) -> None: ...
    @_property
    def can_read(self) -> bool: ...
    @_property
    def can_write(self) -> bool: ...
    @_property
    def position(self) -> winrt.system.UInt64: ...

@typing.final
class RandomAccessStreamReference_Static(type):
    def create_from_file(cls, file: windows_storage.ImplementsIStorageFile, /) -> RandomAccessStreamReference: ...
    def create_from_stream(cls, stream: ImplementsIRandomAccessStream, /) -> RandomAccessStreamReference: ...
    def create_from_uri(cls, uri: windows_foundation.Uri, /) -> RandomAccessStreamReference: ...

@typing.final
class RandomAccessStreamReference(winrt.system.Object, ImplementsIRandomAccessStreamReference, metaclass=RandomAccessStreamReference_Static):
    def open_read_async(self) -> windows_foundation.IAsyncOperation[IRandomAccessStreamWithContentType]: ...

class ImplementsIBuffer():
    pass

@typing.final
class IBuffer(winrt.system.Object, ImplementsIBuffer):
    def __buffer__(self, flags: int, /) -> memoryview: ...
    def __release_buffer__(self, view: memoryview, /) -> None: ...
    @_property
    def capacity(self) -> winrt.system.UInt32: ...
    @_property
    def length(self) -> winrt.system.UInt32: ...
    @length.setter
    def length(self, value: winrt.system.UInt32) -> None: ...

class ImplementsIContentTypeProvider():
    pass

@typing.final
class IContentTypeProvider(winrt.system.Object, ImplementsIContentTypeProvider):
    @_property
    def content_type(self) -> str: ...

class ImplementsIDataReader():
    pass

@typing.final
class IDataReader(winrt.system.Object, ImplementsIDataReader):
    def detach_buffer(self) -> IBuffer: ...
    def detach_stream(self) -> IInputStream: ...
    def load_async(self, count: winrt.system.UInt32, /) -> DataReaderLoadOperation: ...
    def read_boolean(self) -> bool: ...
    def read_buffer(self, length: winrt.system.UInt32, /) -> IBuffer: ...
    def read_byte(self) -> winrt.system.UInt8: ...
    def read_bytes(self, value: typing.Union[winrt.system.Array[winrt.system.UInt8], winrt.system.WriteableBuffer], /) -> None: ...
    def read_date_time(self) -> datetime.datetime: ...
    def read_double(self) -> winrt.system.Double: ...
    def read_guid(self) -> _uuid.UUID: ...
    def read_int16(self) -> winrt.system.Int16: ...
    def read_int32(self) -> winrt.system.Int32: ...
    def read_int64(self) -> winrt.system.Int64: ...
    def read_single(self) -> winrt.system.Single: ...
    def read_string(self, code_unit_count: winrt.system.UInt32, /) -> str: ...
    def read_time_span(self) -> datetime.timedelta: ...
    def read_uint16(self) -> winrt.system.UInt16: ...
    def read_uint32(self) -> winrt.system.UInt32: ...
    def read_uint64(self) -> winrt.system.UInt64: ...
    @_property
    def byte_order(self) -> ByteOrder: ...
    @byte_order.setter
    def byte_order(self, value: ByteOrder) -> None: ...
    @_property
    def input_stream_options(self) -> InputStreamOptions: ...
    @input_stream_options.setter
    def input_stream_options(self, value: InputStreamOptions) -> None: ...
    @_property
    def unconsumed_buffer_length(self) -> winrt.system.UInt32: ...
    @_property
    def unicode_encoding(self) -> UnicodeEncoding: ...
    @unicode_encoding.setter
    def unicode_encoding(self, value: UnicodeEncoding) -> None: ...

class ImplementsIDataWriter():
    pass

@typing.final
class IDataWriter(winrt.system.Object, ImplementsIDataWriter):
    def detach_buffer(self) -> IBuffer: ...
    def detach_stream(self) -> IOutputStream: ...
    def flush_async(self) -> windows_foundation.IAsyncOperation[bool]: ...
    def measure_string(self, value: str, /) -> winrt.system.UInt32: ...
    def store_async(self) -> DataWriterStoreOperation: ...
    def write_boolean(self, value: bool, /) -> None: ...
    def write_buffer(self, buffer: ImplementsIBuffer, /) -> None: ...
    def write_buffer_range(self, buffer: ImplementsIBuffer, start: winrt.system.UInt32, count: winrt.system.UInt32, /) -> None: ...
    def write_byte(self, value: winrt.system.UInt8, /) -> None: ...
    def write_bytes(self, value: typing.Union[winrt.system.Array[winrt.system.UInt8], winrt.system.ReadableBuffer], /) -> None: ...
    def write_date_time(self, value: datetime.datetime, /) -> None: ...
    def write_double(self, value: winrt.system.Double, /) -> None: ...
    def write_guid(self, value: _uuid.UUID, /) -> None: ...
    def write_int16(self, value: winrt.system.Int16, /) -> None: ...
    def write_int32(self, value: winrt.system.Int32, /) -> None: ...
    def write_int64(self, value: winrt.system.Int64, /) -> None: ...
    def write_single(self, value: winrt.system.Single, /) -> None: ...
    def write_string(self, value: str, /) -> winrt.system.UInt32: ...
    def write_time_span(self, value: datetime.timedelta, /) -> None: ...
    def write_uint16(self, value: winrt.system.UInt16, /) -> None: ...
    def write_uint32(self, value: winrt.system.UInt32, /) -> None: ...
    def write_uint64(self, value: winrt.system.UInt64, /) -> None: ...
    @_property
    def byte_order(self) -> ByteOrder: ...
    @byte_order.setter
    def byte_order(self, value: ByteOrder) -> None: ...
    @_property
    def unicode_encoding(self) -> UnicodeEncoding: ...
    @unicode_encoding.setter
    def unicode_encoding(self, value: UnicodeEncoding) -> None: ...
    @_property
    def unstored_buffer_length(self) -> winrt.system.UInt32: ...

class ImplementsIInputStream():
    pass

@typing.final
class IInputStream(winrt.system.Object, ImplementsIInputStream, windows_foundation.ImplementsIClosable):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    def close(self) -> None: ...
    def read_async(self, buffer: ImplementsIBuffer, count: winrt.system.UInt32, options: InputStreamOptions, /) -> windows_foundation.IAsyncOperationWithProgress[IBuffer, winrt.system.UInt32]: ...

class ImplementsIInputStreamReference():
    pass

@typing.final
class IInputStreamReference(winrt.system.Object, ImplementsIInputStreamReference):
    def open_sequential_read_async(self) -> windows_foundation.IAsyncOperation[IInputStream]: ...

class ImplementsIOutputStream():
    pass

@typing.final
class IOutputStream(winrt.system.Object, ImplementsIOutputStream, windows_foundation.ImplementsIClosable):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    def close(self) -> None: ...
    def flush_async(self) -> windows_foundation.IAsyncOperation[bool]: ...
    def write_async(self, buffer: ImplementsIBuffer, /) -> windows_foundation.IAsyncOperationWithProgress[winrt.system.UInt32, winrt.system.UInt32]: ...

class ImplementsIPropertySetSerializer():
    pass

@typing.final
class IPropertySetSerializer(winrt.system.Object, ImplementsIPropertySetSerializer):
    def deserialize(self, property_set: windows_foundation_collections.ImplementsIPropertySet, buffer: ImplementsIBuffer, /) -> None: ...
    def serialize(self, property_set: windows_foundation_collections.ImplementsIPropertySet, /) -> IBuffer: ...

class ImplementsIRandomAccessStream():
    pass

@typing.final
class IRandomAccessStream(winrt.system.Object, ImplementsIRandomAccessStream, ImplementsIOutputStream, ImplementsIInputStream, windows_foundation.ImplementsIClosable):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    def clone_stream(self) -> IRandomAccessStream: ...
    def close(self) -> None: ...
    def flush_async(self) -> windows_foundation.IAsyncOperation[bool]: ...
    def get_input_stream_at(self, position: winrt.system.UInt64, /) -> IInputStream: ...
    def get_output_stream_at(self, position: winrt.system.UInt64, /) -> IOutputStream: ...
    def read_async(self, buffer: ImplementsIBuffer, count: winrt.system.UInt32, options: InputStreamOptions, /) -> windows_foundation.IAsyncOperationWithProgress[IBuffer, winrt.system.UInt32]: ...
    def seek(self, position: winrt.system.UInt64, /) -> None: ...
    def write_async(self, buffer: ImplementsIBuffer, /) -> windows_foundation.IAsyncOperationWithProgress[winrt.system.UInt32, winrt.system.UInt32]: ...
    @_property
    def can_read(self) -> bool: ...
    @_property
    def can_write(self) -> bool: ...
    @_property
    def position(self) -> winrt.system.UInt64: ...
    @_property
    def size(self) -> winrt.system.UInt64: ...
    @size.setter
    def size(self, value: winrt.system.UInt64) -> None: ...

class ImplementsIRandomAccessStreamReference():
    pass

@typing.final
class IRandomAccessStreamReference(winrt.system.Object, ImplementsIRandomAccessStreamReference):
    def open_read_async(self) -> windows_foundation.IAsyncOperation[IRandomAccessStreamWithContentType]: ...

class ImplementsIRandomAccessStreamWithContentType():
    pass

@typing.final
class IRandomAccessStreamWithContentType(winrt.system.Object, ImplementsIRandomAccessStreamWithContentType, ImplementsIContentTypeProvider, ImplementsIRandomAccessStream, ImplementsIOutputStream, ImplementsIInputStream, windows_foundation.ImplementsIClosable):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    def clone_stream(self) -> IRandomAccessStream: ...
    def close(self) -> None: ...
    def flush_async(self) -> windows_foundation.IAsyncOperation[bool]: ...
    def get_input_stream_at(self, position: winrt.system.UInt64, /) -> IInputStream: ...
    def get_output_stream_at(self, position: winrt.system.UInt64, /) -> IOutputStream: ...
    def read_async(self, buffer: ImplementsIBuffer, count: winrt.system.UInt32, options: InputStreamOptions, /) -> windows_foundation.IAsyncOperationWithProgress[IBuffer, winrt.system.UInt32]: ...
    def seek(self, position: winrt.system.UInt64, /) -> None: ...
    def write_async(self, buffer: ImplementsIBuffer, /) -> windows_foundation.IAsyncOperationWithProgress[winrt.system.UInt32, winrt.system.UInt32]: ...
    @_property
    def can_read(self) -> bool: ...
    @_property
    def can_write(self) -> bool: ...
    @_property
    def position(self) -> winrt.system.UInt64: ...
    @_property
    def size(self) -> winrt.system.UInt64: ...
    @size.setter
    def size(self, value: winrt.system.UInt64) -> None: ...
    @_property
    def content_type(self) -> str: ...

