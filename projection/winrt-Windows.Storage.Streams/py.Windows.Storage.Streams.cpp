// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.Storage.Streams.h"


namespace py::cpp::Windows::Storage::Streams
{
    // ----- Buffer class --------------------

    static PyObject* _new_Buffer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                winrt::Windows::Storage::Streams::Buffer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Buffer(py::wrapper::Windows::Storage::Streams::Buffer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Buffer_CreateCopyFromMemoryBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.Buffer", L"CreateCopyFromMemoryBuffer", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IMemoryBuffer>(args, 0);

                return py::convert(winrt::Windows::Storage::Streams::Buffer::CreateCopyFromMemoryBuffer(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Buffer_CreateMemoryBufferOverIBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.Buffer", L"CreateMemoryBufferOverIBuffer", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(winrt::Windows::Storage::Streams::Buffer::CreateMemoryBufferOverIBuffer(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Buffer_get_Length(py::wrapper::Windows::Storage::Streams::Buffer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.Buffer", L"Length"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Length());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Buffer_put_Length(py::wrapper::Windows::Storage::Streams::Buffer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.Buffer", L"Length"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Length(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Buffer_get_Capacity(py::wrapper::Windows::Storage::Streams::Buffer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.Buffer", L"Capacity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Capacity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Buffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Streams::Buffer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Buffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::Buffer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _get_buffer_Buffer(py::wrapper::Windows::Storage::Streams::Buffer* self, Py_buffer* view, int flags) noexcept
    {
        try
        {
            return PyBuffer_FillInfo(view, reinterpret_cast<PyObject*>(self), reinterpret_cast<void*>(self->obj.data()), static_cast<Py_ssize_t>(self->obj.Length()), 0, flags);
        }
        catch (...)
        {
            view->obj = nullptr;
            PyErr_SetNone(PyExc_BufferError);
            return -1;
        }
    }

    static PyMethodDef _methods_Buffer[] = {
        { "_assign_array_", _assign_array_Buffer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Buffer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Buffer[] = {
        { "length", reinterpret_cast<getter>(Buffer_get_Length), reinterpret_cast<setter>(Buffer_put_Length), nullptr, nullptr },
        { "capacity", reinterpret_cast<getter>(Buffer_get_Capacity), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Buffer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Buffer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Buffer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Buffer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Buffer) },
        { Py_bf_getbuffer, reinterpret_cast<void*>(_get_buffer_Buffer) },
        { },
    };

    static PyType_Spec type_spec_Buffer =
    {
        "winrt._winrt_windows_storage_streams.Buffer",
        sizeof(py::wrapper::Windows::Storage::Streams::Buffer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Buffer
    };

    static PyGetSetDef getset_Buffer_Static[] = {
        { }
    };

    static PyMethodDef methods_Buffer_Static[] = {
        { "create_copy_from_memory_buffer", reinterpret_cast<PyCFunction>(Buffer_CreateCopyFromMemoryBuffer), METH_VARARGS, nullptr },
        { "create_memory_buffer_over_i_buffer", reinterpret_cast<PyCFunction>(Buffer_CreateMemoryBufferOverIBuffer), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_Buffer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Buffer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Buffer_Static) },
        { }
    };

    static PyType_Spec type_spec_Buffer_Static =
    {
        "winrt._winrt_windows_storage_streams.Buffer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Buffer_Static
    };

    // ----- DataReader class --------------------

    static PyObject* _new_DataReader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);

                winrt::Windows::Storage::Streams::DataReader instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DataReader(py::wrapper::Windows::Storage::Streams::DataReader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DataReader_Close(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataReader", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_DetachBuffer(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataReader", L"DetachBuffer", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.DetachBuffer());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_DetachStream(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataReader", L"DetachStream", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.DetachStream());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_FromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataReader", L"FromBuffer", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(winrt::Windows::Storage::Streams::DataReader::FromBuffer(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_LoadAsync(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataReader", L"LoadAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.LoadAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_ReadBoolean(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataReader", L"ReadBoolean", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReadBoolean());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_ReadBuffer(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataReader", L"ReadBuffer", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.ReadBuffer(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_ReadByte(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataReader", L"ReadByte", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReadByte());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_ReadBytes(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataReader", L"ReadBytes", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, true>>(args, 0);

                self->obj.ReadBytes(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_ReadDateTime(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataReader", L"ReadDateTime", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReadDateTime());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_ReadDouble(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataReader", L"ReadDouble", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReadDouble());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_ReadGuid(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataReader", L"ReadGuid", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReadGuid());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_ReadInt16(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataReader", L"ReadInt16", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReadInt16());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_ReadInt32(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataReader", L"ReadInt32", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReadInt32());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_ReadInt64(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataReader", L"ReadInt64", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReadInt64());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_ReadSingle(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataReader", L"ReadSingle", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReadSingle());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_ReadString(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataReader", L"ReadString", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.ReadString(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_ReadTimeSpan(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataReader", L"ReadTimeSpan", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReadTimeSpan());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_ReadUInt16(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataReader", L"ReadUInt16", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReadUInt16());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_ReadUInt32(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataReader", L"ReadUInt32", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReadUInt32());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_ReadUInt64(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataReader", L"ReadUInt64", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReadUInt64());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReader_get_UnicodeEncoding(py::wrapper::Windows::Storage::Streams::DataReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.DataReader", L"UnicodeEncoding"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UnicodeEncoding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataReader_put_UnicodeEncoding(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.DataReader", L"UnicodeEncoding"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(arg);

            self->obj.UnicodeEncoding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataReader_get_InputStreamOptions(py::wrapper::Windows::Storage::Streams::DataReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.DataReader", L"InputStreamOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InputStreamOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataReader_put_InputStreamOptions(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.DataReader", L"InputStreamOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(arg);

            self->obj.InputStreamOptions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataReader_get_ByteOrder(py::wrapper::Windows::Storage::Streams::DataReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.DataReader", L"ByteOrder"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ByteOrder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataReader_put_ByteOrder(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.DataReader", L"ByteOrder"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::ByteOrder>(arg);

            self->obj.ByteOrder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataReader_get_UnconsumedBufferLength(py::wrapper::Windows::Storage::Streams::DataReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.DataReader", L"UnconsumedBufferLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UnconsumedBufferLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DataReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Streams::DataReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DataReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::DataReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_DataReader(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_DataReader(py::wrapper::Windows::Storage::Streams::DataReader* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataReader[] = {
        { "close", reinterpret_cast<PyCFunction>(DataReader_Close), METH_VARARGS, nullptr },
        { "detach_buffer", reinterpret_cast<PyCFunction>(DataReader_DetachBuffer), METH_VARARGS, nullptr },
        { "detach_stream", reinterpret_cast<PyCFunction>(DataReader_DetachStream), METH_VARARGS, nullptr },
        { "load_async", reinterpret_cast<PyCFunction>(DataReader_LoadAsync), METH_VARARGS, nullptr },
        { "read_boolean", reinterpret_cast<PyCFunction>(DataReader_ReadBoolean), METH_VARARGS, nullptr },
        { "read_buffer", reinterpret_cast<PyCFunction>(DataReader_ReadBuffer), METH_VARARGS, nullptr },
        { "read_byte", reinterpret_cast<PyCFunction>(DataReader_ReadByte), METH_VARARGS, nullptr },
        { "read_bytes", reinterpret_cast<PyCFunction>(DataReader_ReadBytes), METH_VARARGS, nullptr },
        { "read_date_time", reinterpret_cast<PyCFunction>(DataReader_ReadDateTime), METH_VARARGS, nullptr },
        { "read_double", reinterpret_cast<PyCFunction>(DataReader_ReadDouble), METH_VARARGS, nullptr },
        { "read_guid", reinterpret_cast<PyCFunction>(DataReader_ReadGuid), METH_VARARGS, nullptr },
        { "read_int16", reinterpret_cast<PyCFunction>(DataReader_ReadInt16), METH_VARARGS, nullptr },
        { "read_int32", reinterpret_cast<PyCFunction>(DataReader_ReadInt32), METH_VARARGS, nullptr },
        { "read_int64", reinterpret_cast<PyCFunction>(DataReader_ReadInt64), METH_VARARGS, nullptr },
        { "read_single", reinterpret_cast<PyCFunction>(DataReader_ReadSingle), METH_VARARGS, nullptr },
        { "read_string", reinterpret_cast<PyCFunction>(DataReader_ReadString), METH_VARARGS, nullptr },
        { "read_time_span", reinterpret_cast<PyCFunction>(DataReader_ReadTimeSpan), METH_VARARGS, nullptr },
        { "read_uint16", reinterpret_cast<PyCFunction>(DataReader_ReadUInt16), METH_VARARGS, nullptr },
        { "read_uint32", reinterpret_cast<PyCFunction>(DataReader_ReadUInt32), METH_VARARGS, nullptr },
        { "read_uint64", reinterpret_cast<PyCFunction>(DataReader_ReadUInt64), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DataReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DataReader), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_DataReader), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_DataReader), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataReader[] = {
        { "unicode_encoding", reinterpret_cast<getter>(DataReader_get_UnicodeEncoding), reinterpret_cast<setter>(DataReader_put_UnicodeEncoding), nullptr, nullptr },
        { "input_stream_options", reinterpret_cast<getter>(DataReader_get_InputStreamOptions), reinterpret_cast<setter>(DataReader_put_InputStreamOptions), nullptr, nullptr },
        { "byte_order", reinterpret_cast<getter>(DataReader_get_ByteOrder), reinterpret_cast<setter>(DataReader_put_ByteOrder), nullptr, nullptr },
        { "unconsumed_buffer_length", reinterpret_cast<getter>(DataReader_get_UnconsumedBufferLength), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DataReader[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DataReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DataReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DataReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DataReader) },
        { },
    };

    static PyType_Spec type_spec_DataReader =
    {
        "winrt._winrt_windows_storage_streams.DataReader",
        sizeof(py::wrapper::Windows::Storage::Streams::DataReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataReader
    };

    static PyGetSetDef getset_DataReader_Static[] = {
        { }
    };

    static PyMethodDef methods_DataReader_Static[] = {
        { "from_buffer", reinterpret_cast<PyCFunction>(DataReader_FromBuffer), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_DataReader_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DataReader_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_DataReader_Static) },
        { }
    };

    static PyType_Spec type_spec_DataReader_Static =
    {
        "winrt._winrt_windows_storage_streams.DataReader_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DataReader_Static
    };

    // ----- DataReaderLoadOperation class --------------------

    static PyObject* _new_DataReaderLoadOperation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Streams::DataReaderLoadOperation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Streams::DataReaderLoadOperation>::type_name);
        return nullptr;
    }

    static void _dealloc_DataReaderLoadOperation(py::wrapper::Windows::Storage::Streams::DataReaderLoadOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DataReaderLoadOperation_Cancel(py::wrapper::Windows::Storage::Streams::DataReaderLoadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataReaderLoadOperation", L"Cancel", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Cancel();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReaderLoadOperation_Close(py::wrapper::Windows::Storage::Streams::DataReaderLoadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataReaderLoadOperation", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReaderLoadOperation_GetResults(py::wrapper::Windows::Storage::Streams::DataReaderLoadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataReaderLoadOperation", L"GetResults", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetResults());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataReaderLoadOperation_get_ErrorCode(py::wrapper::Windows::Storage::Streams::DataReaderLoadOperation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.DataReaderLoadOperation", L"ErrorCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataReaderLoadOperation_get_Id(py::wrapper::Windows::Storage::Streams::DataReaderLoadOperation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.DataReaderLoadOperation", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataReaderLoadOperation_get_Status(py::wrapper::Windows::Storage::Streams::DataReaderLoadOperation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.DataReaderLoadOperation", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataReaderLoadOperation_get_Completed(py::wrapper::Windows::Storage::Streams::DataReaderLoadOperation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.DataReaderLoadOperation", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Completed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataReaderLoadOperation_put_Completed(py::wrapper::Windows::Storage::Streams::DataReaderLoadOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.DataReaderLoadOperation", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncOperationCompletedHandler<uint32_t>>(arg);

            self->obj.Completed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_DataReaderLoadOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Streams::DataReaderLoadOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DataReaderLoadOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::DataReaderLoadOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _await_DataReaderLoadOperation(py::wrapper::Windows::Storage::Streams::DataReaderLoadOperation* self) noexcept
    {
        return py::dunder_await(self->obj);
    }

    static PyMethodDef _methods_DataReaderLoadOperation[] = {
        { "cancel", reinterpret_cast<PyCFunction>(DataReaderLoadOperation_Cancel), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(DataReaderLoadOperation_Close), METH_VARARGS, nullptr },
        { "get_results", reinterpret_cast<PyCFunction>(DataReaderLoadOperation_GetResults), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DataReaderLoadOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DataReaderLoadOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataReaderLoadOperation[] = {
        { "error_code", reinterpret_cast<getter>(DataReaderLoadOperation_get_ErrorCode), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(DataReaderLoadOperation_get_Id), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(DataReaderLoadOperation_get_Status), nullptr, nullptr, nullptr },
        { "completed", reinterpret_cast<getter>(DataReaderLoadOperation_get_Completed), reinterpret_cast<setter>(DataReaderLoadOperation_put_Completed), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DataReaderLoadOperation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DataReaderLoadOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DataReaderLoadOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DataReaderLoadOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DataReaderLoadOperation) },
        { Py_am_await, reinterpret_cast<void*>(_await_DataReaderLoadOperation) },
        { },
    };

    static PyType_Spec type_spec_DataReaderLoadOperation =
    {
        "winrt._winrt_windows_storage_streams.DataReaderLoadOperation",
        sizeof(py::wrapper::Windows::Storage::Streams::DataReaderLoadOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataReaderLoadOperation
    };

    // ----- DataWriter class --------------------

    static PyObject* _new_DataWriter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 0);

                winrt::Windows::Storage::Streams::DataWriter instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Streams::DataWriter instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DataWriter(py::wrapper::Windows::Storage::Streams::DataWriter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DataWriter_Close(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataWriter", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_DetachBuffer(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataWriter", L"DetachBuffer", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.DetachBuffer());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_DetachStream(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataWriter", L"DetachStream", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.DetachStream());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_FlushAsync(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataWriter", L"FlushAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.FlushAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_MeasureString(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataWriter", L"MeasureString", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.MeasureString(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_StoreAsync(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataWriter", L"StoreAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.StoreAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_WriteBoolean(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataWriter", L"WriteBoolean", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.WriteBoolean(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_WriteBuffer(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataWriter", L"WriteBuffer", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                self->obj.WriteBuffer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataWriter", L"WriteBuffer", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.WriteBuffer(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_WriteByte(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataWriter", L"WriteByte", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);

                self->obj.WriteByte(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_WriteBytes(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataWriter", L"WriteBytes", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                self->obj.WriteBytes(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_WriteDateTime(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataWriter", L"WriteDateTime", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);

                self->obj.WriteDateTime(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_WriteDouble(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataWriter", L"WriteDouble", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                self->obj.WriteDouble(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_WriteGuid(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataWriter", L"WriteGuid", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                self->obj.WriteGuid(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_WriteInt16(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataWriter", L"WriteInt16", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int16_t>(args, 0);

                self->obj.WriteInt16(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_WriteInt32(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataWriter", L"WriteInt32", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.WriteInt32(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_WriteInt64(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataWriter", L"WriteInt64", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int64_t>(args, 0);

                self->obj.WriteInt64(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_WriteSingle(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataWriter", L"WriteSingle", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<float>(args, 0);

                self->obj.WriteSingle(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_WriteString(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataWriter", L"WriteString", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.WriteString(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_WriteTimeSpan(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataWriter", L"WriteTimeSpan", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                self->obj.WriteTimeSpan(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_WriteUInt16(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataWriter", L"WriteUInt16", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);

                self->obj.WriteUInt16(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_WriteUInt32(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataWriter", L"WriteUInt32", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.WriteUInt32(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_WriteUInt64(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataWriter", L"WriteUInt64", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.WriteUInt64(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriter_get_UnicodeEncoding(py::wrapper::Windows::Storage::Streams::DataWriter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.DataWriter", L"UnicodeEncoding"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UnicodeEncoding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataWriter_put_UnicodeEncoding(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.DataWriter", L"UnicodeEncoding"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(arg);

            self->obj.UnicodeEncoding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataWriter_get_ByteOrder(py::wrapper::Windows::Storage::Streams::DataWriter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.DataWriter", L"ByteOrder"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ByteOrder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataWriter_put_ByteOrder(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.DataWriter", L"ByteOrder"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::ByteOrder>(arg);

            self->obj.ByteOrder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataWriter_get_UnstoredBufferLength(py::wrapper::Windows::Storage::Streams::DataWriter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.DataWriter", L"UnstoredBufferLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UnstoredBufferLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DataWriter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Streams::DataWriter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DataWriter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::DataWriter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_DataWriter(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_DataWriter(py::wrapper::Windows::Storage::Streams::DataWriter* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataWriter[] = {
        { "close", reinterpret_cast<PyCFunction>(DataWriter_Close), METH_VARARGS, nullptr },
        { "detach_buffer", reinterpret_cast<PyCFunction>(DataWriter_DetachBuffer), METH_VARARGS, nullptr },
        { "detach_stream", reinterpret_cast<PyCFunction>(DataWriter_DetachStream), METH_VARARGS, nullptr },
        { "flush_async", reinterpret_cast<PyCFunction>(DataWriter_FlushAsync), METH_VARARGS, nullptr },
        { "measure_string", reinterpret_cast<PyCFunction>(DataWriter_MeasureString), METH_VARARGS, nullptr },
        { "store_async", reinterpret_cast<PyCFunction>(DataWriter_StoreAsync), METH_VARARGS, nullptr },
        { "write_boolean", reinterpret_cast<PyCFunction>(DataWriter_WriteBoolean), METH_VARARGS, nullptr },
        { "write_buffer", reinterpret_cast<PyCFunction>(DataWriter_WriteBuffer), METH_VARARGS, nullptr },
        { "write_byte", reinterpret_cast<PyCFunction>(DataWriter_WriteByte), METH_VARARGS, nullptr },
        { "write_bytes", reinterpret_cast<PyCFunction>(DataWriter_WriteBytes), METH_VARARGS, nullptr },
        { "write_date_time", reinterpret_cast<PyCFunction>(DataWriter_WriteDateTime), METH_VARARGS, nullptr },
        { "write_double", reinterpret_cast<PyCFunction>(DataWriter_WriteDouble), METH_VARARGS, nullptr },
        { "write_guid", reinterpret_cast<PyCFunction>(DataWriter_WriteGuid), METH_VARARGS, nullptr },
        { "write_int16", reinterpret_cast<PyCFunction>(DataWriter_WriteInt16), METH_VARARGS, nullptr },
        { "write_int32", reinterpret_cast<PyCFunction>(DataWriter_WriteInt32), METH_VARARGS, nullptr },
        { "write_int64", reinterpret_cast<PyCFunction>(DataWriter_WriteInt64), METH_VARARGS, nullptr },
        { "write_single", reinterpret_cast<PyCFunction>(DataWriter_WriteSingle), METH_VARARGS, nullptr },
        { "write_string", reinterpret_cast<PyCFunction>(DataWriter_WriteString), METH_VARARGS, nullptr },
        { "write_time_span", reinterpret_cast<PyCFunction>(DataWriter_WriteTimeSpan), METH_VARARGS, nullptr },
        { "write_uint16", reinterpret_cast<PyCFunction>(DataWriter_WriteUInt16), METH_VARARGS, nullptr },
        { "write_uint32", reinterpret_cast<PyCFunction>(DataWriter_WriteUInt32), METH_VARARGS, nullptr },
        { "write_uint64", reinterpret_cast<PyCFunction>(DataWriter_WriteUInt64), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DataWriter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DataWriter), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_DataWriter), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_DataWriter), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataWriter[] = {
        { "unicode_encoding", reinterpret_cast<getter>(DataWriter_get_UnicodeEncoding), reinterpret_cast<setter>(DataWriter_put_UnicodeEncoding), nullptr, nullptr },
        { "byte_order", reinterpret_cast<getter>(DataWriter_get_ByteOrder), reinterpret_cast<setter>(DataWriter_put_ByteOrder), nullptr, nullptr },
        { "unstored_buffer_length", reinterpret_cast<getter>(DataWriter_get_UnstoredBufferLength), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DataWriter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DataWriter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DataWriter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DataWriter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DataWriter) },
        { },
    };

    static PyType_Spec type_spec_DataWriter =
    {
        "winrt._winrt_windows_storage_streams.DataWriter",
        sizeof(py::wrapper::Windows::Storage::Streams::DataWriter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataWriter
    };

    // ----- DataWriterStoreOperation class --------------------

    static PyObject* _new_DataWriterStoreOperation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Streams::DataWriterStoreOperation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Streams::DataWriterStoreOperation>::type_name);
        return nullptr;
    }

    static void _dealloc_DataWriterStoreOperation(py::wrapper::Windows::Storage::Streams::DataWriterStoreOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DataWriterStoreOperation_Cancel(py::wrapper::Windows::Storage::Streams::DataWriterStoreOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataWriterStoreOperation", L"Cancel", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Cancel();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriterStoreOperation_Close(py::wrapper::Windows::Storage::Streams::DataWriterStoreOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataWriterStoreOperation", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriterStoreOperation_GetResults(py::wrapper::Windows::Storage::Streams::DataWriterStoreOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.DataWriterStoreOperation", L"GetResults", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetResults());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataWriterStoreOperation_get_ErrorCode(py::wrapper::Windows::Storage::Streams::DataWriterStoreOperation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.DataWriterStoreOperation", L"ErrorCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataWriterStoreOperation_get_Id(py::wrapper::Windows::Storage::Streams::DataWriterStoreOperation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.DataWriterStoreOperation", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataWriterStoreOperation_get_Status(py::wrapper::Windows::Storage::Streams::DataWriterStoreOperation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.DataWriterStoreOperation", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataWriterStoreOperation_get_Completed(py::wrapper::Windows::Storage::Streams::DataWriterStoreOperation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.DataWriterStoreOperation", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Completed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataWriterStoreOperation_put_Completed(py::wrapper::Windows::Storage::Streams::DataWriterStoreOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.DataWriterStoreOperation", L"Completed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::AsyncOperationCompletedHandler<uint32_t>>(arg);

            self->obj.Completed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_DataWriterStoreOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Streams::DataWriterStoreOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DataWriterStoreOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::DataWriterStoreOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _await_DataWriterStoreOperation(py::wrapper::Windows::Storage::Streams::DataWriterStoreOperation* self) noexcept
    {
        return py::dunder_await(self->obj);
    }

    static PyMethodDef _methods_DataWriterStoreOperation[] = {
        { "cancel", reinterpret_cast<PyCFunction>(DataWriterStoreOperation_Cancel), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(DataWriterStoreOperation_Close), METH_VARARGS, nullptr },
        { "get_results", reinterpret_cast<PyCFunction>(DataWriterStoreOperation_GetResults), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DataWriterStoreOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DataWriterStoreOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataWriterStoreOperation[] = {
        { "error_code", reinterpret_cast<getter>(DataWriterStoreOperation_get_ErrorCode), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(DataWriterStoreOperation_get_Id), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(DataWriterStoreOperation_get_Status), nullptr, nullptr, nullptr },
        { "completed", reinterpret_cast<getter>(DataWriterStoreOperation_get_Completed), reinterpret_cast<setter>(DataWriterStoreOperation_put_Completed), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DataWriterStoreOperation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DataWriterStoreOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DataWriterStoreOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DataWriterStoreOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DataWriterStoreOperation) },
        { Py_am_await, reinterpret_cast<void*>(_await_DataWriterStoreOperation) },
        { },
    };

    static PyType_Spec type_spec_DataWriterStoreOperation =
    {
        "winrt._winrt_windows_storage_streams.DataWriterStoreOperation",
        sizeof(py::wrapper::Windows::Storage::Streams::DataWriterStoreOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataWriterStoreOperation
    };

    // ----- FileInputStream class --------------------

    static PyObject* _new_FileInputStream(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Streams::FileInputStream>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Streams::FileInputStream>::type_name);
        return nullptr;
    }

    static void _dealloc_FileInputStream(py::wrapper::Windows::Storage::Streams::FileInputStream* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FileInputStream_Close(py::wrapper::Windows::Storage::Streams::FileInputStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.FileInputStream", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileInputStream_ReadAsync(py::wrapper::Windows::Storage::Streams::FileInputStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.FileInputStream", L"ReadAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);

                return py::convert(self->obj.ReadAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_FileInputStream(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Streams::FileInputStream>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FileInputStream(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::FileInputStream>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_FileInputStream(py::wrapper::Windows::Storage::Streams::FileInputStream* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_FileInputStream(py::wrapper::Windows::Storage::Streams::FileInputStream* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileInputStream[] = {
        { "close", reinterpret_cast<PyCFunction>(FileInputStream_Close), METH_VARARGS, nullptr },
        { "read_async", reinterpret_cast<PyCFunction>(FileInputStream_ReadAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_FileInputStream, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FileInputStream), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_FileInputStream), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_FileInputStream), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_FileInputStream[] = {
        { }
    };

    static PyType_Slot _type_slots_FileInputStream[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FileInputStream) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FileInputStream) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FileInputStream) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FileInputStream) },
        { },
    };

    static PyType_Spec type_spec_FileInputStream =
    {
        "winrt._winrt_windows_storage_streams.FileInputStream",
        sizeof(py::wrapper::Windows::Storage::Streams::FileInputStream),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileInputStream
    };

    // ----- FileOutputStream class --------------------

    static PyObject* _new_FileOutputStream(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Streams::FileOutputStream>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Streams::FileOutputStream>::type_name);
        return nullptr;
    }

    static void _dealloc_FileOutputStream(py::wrapper::Windows::Storage::Streams::FileOutputStream* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FileOutputStream_Close(py::wrapper::Windows::Storage::Streams::FileOutputStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.FileOutputStream", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileOutputStream_FlushAsync(py::wrapper::Windows::Storage::Streams::FileOutputStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.FileOutputStream", L"FlushAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.FlushAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileOutputStream_WriteAsync(py::wrapper::Windows::Storage::Streams::FileOutputStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.FileOutputStream", L"WriteAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.WriteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_FileOutputStream(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Streams::FileOutputStream>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FileOutputStream(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::FileOutputStream>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_FileOutputStream(py::wrapper::Windows::Storage::Streams::FileOutputStream* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_FileOutputStream(py::wrapper::Windows::Storage::Streams::FileOutputStream* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileOutputStream[] = {
        { "close", reinterpret_cast<PyCFunction>(FileOutputStream_Close), METH_VARARGS, nullptr },
        { "flush_async", reinterpret_cast<PyCFunction>(FileOutputStream_FlushAsync), METH_VARARGS, nullptr },
        { "write_async", reinterpret_cast<PyCFunction>(FileOutputStream_WriteAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_FileOutputStream, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FileOutputStream), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_FileOutputStream), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_FileOutputStream), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_FileOutputStream[] = {
        { }
    };

    static PyType_Slot _type_slots_FileOutputStream[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FileOutputStream) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FileOutputStream) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FileOutputStream) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FileOutputStream) },
        { },
    };

    static PyType_Spec type_spec_FileOutputStream =
    {
        "winrt._winrt_windows_storage_streams.FileOutputStream",
        sizeof(py::wrapper::Windows::Storage::Streams::FileOutputStream),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileOutputStream
    };

    // ----- FileRandomAccessStream class --------------------

    static PyObject* _new_FileRandomAccessStream(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Streams::FileRandomAccessStream>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Streams::FileRandomAccessStream>::type_name);
        return nullptr;
    }

    static void _dealloc_FileRandomAccessStream(py::wrapper::Windows::Storage::Streams::FileRandomAccessStream* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FileRandomAccessStream_CloneStream(py::wrapper::Windows::Storage::Streams::FileRandomAccessStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.FileRandomAccessStream", L"CloneStream", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CloneStream());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileRandomAccessStream_Close(py::wrapper::Windows::Storage::Streams::FileRandomAccessStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.FileRandomAccessStream", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileRandomAccessStream_FlushAsync(py::wrapper::Windows::Storage::Streams::FileRandomAccessStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.FileRandomAccessStream", L"FlushAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.FlushAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileRandomAccessStream_GetInputStreamAt(py::wrapper::Windows::Storage::Streams::FileRandomAccessStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.FileRandomAccessStream", L"GetInputStreamAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetInputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileRandomAccessStream_GetOutputStreamAt(py::wrapper::Windows::Storage::Streams::FileRandomAccessStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.FileRandomAccessStream", L"GetOutputStreamAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetOutputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileRandomAccessStream_OpenAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.FileRandomAccessStream", L"OpenAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 1);

                return py::convert(winrt::Windows::Storage::Streams::FileRandomAccessStream::OpenAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.FileRandomAccessStream", L"OpenAsync", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Storage::Streams::FileOpenDisposition>(args, 3);

                return py::convert(winrt::Windows::Storage::Streams::FileRandomAccessStream::OpenAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileRandomAccessStream_OpenForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.FileRandomAccessStream", L"OpenForUserAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 2);

                return py::convert(winrt::Windows::Storage::Streams::FileRandomAccessStream::OpenForUserAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.FileRandomAccessStream", L"OpenForUserAsync", 5))
            {
                py::set_arg_count_version_error(5);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::FileAccessMode>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Storage::Streams::FileOpenDisposition>(args, 4);

                return py::convert(winrt::Windows::Storage::Streams::FileRandomAccessStream::OpenForUserAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileRandomAccessStream_OpenTransactedWriteAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.FileRandomAccessStream", L"OpenTransactedWriteAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Storage::Streams::FileRandomAccessStream::OpenTransactedWriteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.FileRandomAccessStream", L"OpenTransactedWriteAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::FileOpenDisposition>(args, 2);

                return py::convert(winrt::Windows::Storage::Streams::FileRandomAccessStream::OpenTransactedWriteAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileRandomAccessStream_OpenTransactedWriteForUserAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.FileRandomAccessStream", L"OpenTransactedWriteForUserAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Storage::Streams::FileRandomAccessStream::OpenTransactedWriteForUserAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.FileRandomAccessStream", L"OpenTransactedWriteForUserAsync", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::StorageOpenOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Storage::Streams::FileOpenDisposition>(args, 3);

                return py::convert(winrt::Windows::Storage::Streams::FileRandomAccessStream::OpenTransactedWriteForUserAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileRandomAccessStream_ReadAsync(py::wrapper::Windows::Storage::Streams::FileRandomAccessStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.FileRandomAccessStream", L"ReadAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);

                return py::convert(self->obj.ReadAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileRandomAccessStream_Seek(py::wrapper::Windows::Storage::Streams::FileRandomAccessStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.FileRandomAccessStream", L"Seek", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.Seek(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileRandomAccessStream_WriteAsync(py::wrapper::Windows::Storage::Streams::FileRandomAccessStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.FileRandomAccessStream", L"WriteAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.WriteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileRandomAccessStream_get_Size(py::wrapper::Windows::Storage::Streams::FileRandomAccessStream* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.FileRandomAccessStream", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FileRandomAccessStream_put_Size(py::wrapper::Windows::Storage::Streams::FileRandomAccessStream* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.FileRandomAccessStream", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint64_t>(arg);

            self->obj.Size(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FileRandomAccessStream_get_CanRead(py::wrapper::Windows::Storage::Streams::FileRandomAccessStream* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.FileRandomAccessStream", L"CanRead"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanRead());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileRandomAccessStream_get_CanWrite(py::wrapper::Windows::Storage::Streams::FileRandomAccessStream* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.FileRandomAccessStream", L"CanWrite"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanWrite());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileRandomAccessStream_get_Position(py::wrapper::Windows::Storage::Streams::FileRandomAccessStream* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.FileRandomAccessStream", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FileRandomAccessStream(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Streams::FileRandomAccessStream>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FileRandomAccessStream(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::FileRandomAccessStream>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_FileRandomAccessStream(py::wrapper::Windows::Storage::Streams::FileRandomAccessStream* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_FileRandomAccessStream(py::wrapper::Windows::Storage::Streams::FileRandomAccessStream* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileRandomAccessStream[] = {
        { "clone_stream", reinterpret_cast<PyCFunction>(FileRandomAccessStream_CloneStream), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(FileRandomAccessStream_Close), METH_VARARGS, nullptr },
        { "flush_async", reinterpret_cast<PyCFunction>(FileRandomAccessStream_FlushAsync), METH_VARARGS, nullptr },
        { "get_input_stream_at", reinterpret_cast<PyCFunction>(FileRandomAccessStream_GetInputStreamAt), METH_VARARGS, nullptr },
        { "get_output_stream_at", reinterpret_cast<PyCFunction>(FileRandomAccessStream_GetOutputStreamAt), METH_VARARGS, nullptr },
        { "read_async", reinterpret_cast<PyCFunction>(FileRandomAccessStream_ReadAsync), METH_VARARGS, nullptr },
        { "seek", reinterpret_cast<PyCFunction>(FileRandomAccessStream_Seek), METH_VARARGS, nullptr },
        { "write_async", reinterpret_cast<PyCFunction>(FileRandomAccessStream_WriteAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_FileRandomAccessStream, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FileRandomAccessStream), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_FileRandomAccessStream), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_FileRandomAccessStream), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_FileRandomAccessStream[] = {
        { "size", reinterpret_cast<getter>(FileRandomAccessStream_get_Size), reinterpret_cast<setter>(FileRandomAccessStream_put_Size), nullptr, nullptr },
        { "can_read", reinterpret_cast<getter>(FileRandomAccessStream_get_CanRead), nullptr, nullptr, nullptr },
        { "can_write", reinterpret_cast<getter>(FileRandomAccessStream_get_CanWrite), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(FileRandomAccessStream_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FileRandomAccessStream[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FileRandomAccessStream) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FileRandomAccessStream) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FileRandomAccessStream) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FileRandomAccessStream) },
        { },
    };

    static PyType_Spec type_spec_FileRandomAccessStream =
    {
        "winrt._winrt_windows_storage_streams.FileRandomAccessStream",
        sizeof(py::wrapper::Windows::Storage::Streams::FileRandomAccessStream),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileRandomAccessStream
    };

    static PyGetSetDef getset_FileRandomAccessStream_Static[] = {
        { }
    };

    static PyMethodDef methods_FileRandomAccessStream_Static[] = {
        { "open_async", reinterpret_cast<PyCFunction>(FileRandomAccessStream_OpenAsync), METH_VARARGS, nullptr },
        { "open_for_user_async", reinterpret_cast<PyCFunction>(FileRandomAccessStream_OpenForUserAsync), METH_VARARGS, nullptr },
        { "open_transacted_write_async", reinterpret_cast<PyCFunction>(FileRandomAccessStream_OpenTransactedWriteAsync), METH_VARARGS, nullptr },
        { "open_transacted_write_for_user_async", reinterpret_cast<PyCFunction>(FileRandomAccessStream_OpenTransactedWriteForUserAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_FileRandomAccessStream_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FileRandomAccessStream_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_FileRandomAccessStream_Static) },
        { }
    };

    static PyType_Spec type_spec_FileRandomAccessStream_Static =
    {
        "winrt._winrt_windows_storage_streams.FileRandomAccessStream_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_FileRandomAccessStream_Static
    };

    // ----- InMemoryRandomAccessStream class --------------------

    static PyObject* _new_InMemoryRandomAccessStream(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Streams::InMemoryRandomAccessStream instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InMemoryRandomAccessStream(py::wrapper::Windows::Storage::Streams::InMemoryRandomAccessStream* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InMemoryRandomAccessStream_CloneStream(py::wrapper::Windows::Storage::Streams::InMemoryRandomAccessStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.InMemoryRandomAccessStream", L"CloneStream", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CloneStream());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InMemoryRandomAccessStream_Close(py::wrapper::Windows::Storage::Streams::InMemoryRandomAccessStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.InMemoryRandomAccessStream", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InMemoryRandomAccessStream_FlushAsync(py::wrapper::Windows::Storage::Streams::InMemoryRandomAccessStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.InMemoryRandomAccessStream", L"FlushAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.FlushAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InMemoryRandomAccessStream_GetInputStreamAt(py::wrapper::Windows::Storage::Streams::InMemoryRandomAccessStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.InMemoryRandomAccessStream", L"GetInputStreamAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetInputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InMemoryRandomAccessStream_GetOutputStreamAt(py::wrapper::Windows::Storage::Streams::InMemoryRandomAccessStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.InMemoryRandomAccessStream", L"GetOutputStreamAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetOutputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InMemoryRandomAccessStream_ReadAsync(py::wrapper::Windows::Storage::Streams::InMemoryRandomAccessStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.InMemoryRandomAccessStream", L"ReadAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);

                return py::convert(self->obj.ReadAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InMemoryRandomAccessStream_Seek(py::wrapper::Windows::Storage::Streams::InMemoryRandomAccessStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.InMemoryRandomAccessStream", L"Seek", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.Seek(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InMemoryRandomAccessStream_WriteAsync(py::wrapper::Windows::Storage::Streams::InMemoryRandomAccessStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.InMemoryRandomAccessStream", L"WriteAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.WriteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InMemoryRandomAccessStream_get_Size(py::wrapper::Windows::Storage::Streams::InMemoryRandomAccessStream* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.InMemoryRandomAccessStream", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InMemoryRandomAccessStream_put_Size(py::wrapper::Windows::Storage::Streams::InMemoryRandomAccessStream* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.InMemoryRandomAccessStream", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint64_t>(arg);

            self->obj.Size(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InMemoryRandomAccessStream_get_CanRead(py::wrapper::Windows::Storage::Streams::InMemoryRandomAccessStream* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.InMemoryRandomAccessStream", L"CanRead"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanRead());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InMemoryRandomAccessStream_get_CanWrite(py::wrapper::Windows::Storage::Streams::InMemoryRandomAccessStream* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.InMemoryRandomAccessStream", L"CanWrite"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanWrite());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InMemoryRandomAccessStream_get_Position(py::wrapper::Windows::Storage::Streams::InMemoryRandomAccessStream* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.InMemoryRandomAccessStream", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InMemoryRandomAccessStream(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InMemoryRandomAccessStream(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::InMemoryRandomAccessStream>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_InMemoryRandomAccessStream(py::wrapper::Windows::Storage::Streams::InMemoryRandomAccessStream* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_InMemoryRandomAccessStream(py::wrapper::Windows::Storage::Streams::InMemoryRandomAccessStream* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InMemoryRandomAccessStream[] = {
        { "clone_stream", reinterpret_cast<PyCFunction>(InMemoryRandomAccessStream_CloneStream), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(InMemoryRandomAccessStream_Close), METH_VARARGS, nullptr },
        { "flush_async", reinterpret_cast<PyCFunction>(InMemoryRandomAccessStream_FlushAsync), METH_VARARGS, nullptr },
        { "get_input_stream_at", reinterpret_cast<PyCFunction>(InMemoryRandomAccessStream_GetInputStreamAt), METH_VARARGS, nullptr },
        { "get_output_stream_at", reinterpret_cast<PyCFunction>(InMemoryRandomAccessStream_GetOutputStreamAt), METH_VARARGS, nullptr },
        { "read_async", reinterpret_cast<PyCFunction>(InMemoryRandomAccessStream_ReadAsync), METH_VARARGS, nullptr },
        { "seek", reinterpret_cast<PyCFunction>(InMemoryRandomAccessStream_Seek), METH_VARARGS, nullptr },
        { "write_async", reinterpret_cast<PyCFunction>(InMemoryRandomAccessStream_WriteAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_InMemoryRandomAccessStream, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InMemoryRandomAccessStream), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_InMemoryRandomAccessStream), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_InMemoryRandomAccessStream), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_InMemoryRandomAccessStream[] = {
        { "size", reinterpret_cast<getter>(InMemoryRandomAccessStream_get_Size), reinterpret_cast<setter>(InMemoryRandomAccessStream_put_Size), nullptr, nullptr },
        { "can_read", reinterpret_cast<getter>(InMemoryRandomAccessStream_get_CanRead), nullptr, nullptr, nullptr },
        { "can_write", reinterpret_cast<getter>(InMemoryRandomAccessStream_get_CanWrite), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(InMemoryRandomAccessStream_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InMemoryRandomAccessStream[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InMemoryRandomAccessStream) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InMemoryRandomAccessStream) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InMemoryRandomAccessStream) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InMemoryRandomAccessStream) },
        { },
    };

    static PyType_Spec type_spec_InMemoryRandomAccessStream =
    {
        "winrt._winrt_windows_storage_streams.InMemoryRandomAccessStream",
        sizeof(py::wrapper::Windows::Storage::Streams::InMemoryRandomAccessStream),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InMemoryRandomAccessStream
    };

    // ----- InputStreamOverStream class --------------------

    static PyObject* _new_InputStreamOverStream(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Streams::InputStreamOverStream>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Streams::InputStreamOverStream>::type_name);
        return nullptr;
    }

    static void _dealloc_InputStreamOverStream(py::wrapper::Windows::Storage::Streams::InputStreamOverStream* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InputStreamOverStream_Close(py::wrapper::Windows::Storage::Streams::InputStreamOverStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.InputStreamOverStream", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputStreamOverStream_ReadAsync(py::wrapper::Windows::Storage::Streams::InputStreamOverStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.InputStreamOverStream", L"ReadAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);

                return py::convert(self->obj.ReadAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_InputStreamOverStream(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Streams::InputStreamOverStream>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InputStreamOverStream(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::InputStreamOverStream>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_InputStreamOverStream(py::wrapper::Windows::Storage::Streams::InputStreamOverStream* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_InputStreamOverStream(py::wrapper::Windows::Storage::Streams::InputStreamOverStream* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InputStreamOverStream[] = {
        { "close", reinterpret_cast<PyCFunction>(InputStreamOverStream_Close), METH_VARARGS, nullptr },
        { "read_async", reinterpret_cast<PyCFunction>(InputStreamOverStream_ReadAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_InputStreamOverStream, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InputStreamOverStream), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_InputStreamOverStream), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_InputStreamOverStream), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_InputStreamOverStream[] = {
        { }
    };

    static PyType_Slot _type_slots_InputStreamOverStream[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InputStreamOverStream) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InputStreamOverStream) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InputStreamOverStream) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InputStreamOverStream) },
        { },
    };

    static PyType_Spec type_spec_InputStreamOverStream =
    {
        "winrt._winrt_windows_storage_streams.InputStreamOverStream",
        sizeof(py::wrapper::Windows::Storage::Streams::InputStreamOverStream),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InputStreamOverStream
    };

    // ----- OutputStreamOverStream class --------------------

    static PyObject* _new_OutputStreamOverStream(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Streams::OutputStreamOverStream>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Streams::OutputStreamOverStream>::type_name);
        return nullptr;
    }

    static void _dealloc_OutputStreamOverStream(py::wrapper::Windows::Storage::Streams::OutputStreamOverStream* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* OutputStreamOverStream_Close(py::wrapper::Windows::Storage::Streams::OutputStreamOverStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.OutputStreamOverStream", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OutputStreamOverStream_FlushAsync(py::wrapper::Windows::Storage::Streams::OutputStreamOverStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.OutputStreamOverStream", L"FlushAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.FlushAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* OutputStreamOverStream_WriteAsync(py::wrapper::Windows::Storage::Streams::OutputStreamOverStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.OutputStreamOverStream", L"WriteAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.WriteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_OutputStreamOverStream(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Streams::OutputStreamOverStream>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_OutputStreamOverStream(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::OutputStreamOverStream>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_OutputStreamOverStream(py::wrapper::Windows::Storage::Streams::OutputStreamOverStream* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_OutputStreamOverStream(py::wrapper::Windows::Storage::Streams::OutputStreamOverStream* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_OutputStreamOverStream[] = {
        { "close", reinterpret_cast<PyCFunction>(OutputStreamOverStream_Close), METH_VARARGS, nullptr },
        { "flush_async", reinterpret_cast<PyCFunction>(OutputStreamOverStream_FlushAsync), METH_VARARGS, nullptr },
        { "write_async", reinterpret_cast<PyCFunction>(OutputStreamOverStream_WriteAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_OutputStreamOverStream, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_OutputStreamOverStream), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_OutputStreamOverStream), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_OutputStreamOverStream), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_OutputStreamOverStream[] = {
        { }
    };

    static PyType_Slot _type_slots_OutputStreamOverStream[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_OutputStreamOverStream) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_OutputStreamOverStream) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_OutputStreamOverStream) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_OutputStreamOverStream) },
        { },
    };

    static PyType_Spec type_spec_OutputStreamOverStream =
    {
        "winrt._winrt_windows_storage_streams.OutputStreamOverStream",
        sizeof(py::wrapper::Windows::Storage::Streams::OutputStreamOverStream),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_OutputStreamOverStream
    };

    // ----- RandomAccessStream class --------------------

    static PyObject* _new_RandomAccessStream(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Streams::RandomAccessStream>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Streams::RandomAccessStream>::type_name);
        return nullptr;
    }

    static PyObject* RandomAccessStream_CopyAndCloseAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.RandomAccessStream", L"CopyAndCloseAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 1);

                return py::convert(winrt::Windows::Storage::Streams::RandomAccessStream::CopyAndCloseAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RandomAccessStream_CopyAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.RandomAccessStream", L"CopyAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 1);

                return py::convert(winrt::Windows::Storage::Streams::RandomAccessStream::CopyAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.RandomAccessStream", L"CopyAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IOutputStream>(args, 1);
                auto param2 = py::convert_to<uint64_t>(args, 2);

                return py::convert(winrt::Windows::Storage::Streams::RandomAccessStream::CopyAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_RandomAccessStream[] = {
        { }
    };

    static PyGetSetDef _getset_RandomAccessStream[] = {
        { }
    };

    static PyType_Slot _type_slots_RandomAccessStream[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RandomAccessStream) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RandomAccessStream) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RandomAccessStream) },
        { },
    };

    static PyType_Spec type_spec_RandomAccessStream =
    {
        "winrt._winrt_windows_storage_streams.RandomAccessStream",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RandomAccessStream
    };

    static PyGetSetDef getset_RandomAccessStream_Static[] = {
        { }
    };

    static PyMethodDef methods_RandomAccessStream_Static[] = {
        { "copy_and_close_async", reinterpret_cast<PyCFunction>(RandomAccessStream_CopyAndCloseAsync), METH_VARARGS, nullptr },
        { "copy_async", reinterpret_cast<PyCFunction>(RandomAccessStream_CopyAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_RandomAccessStream_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RandomAccessStream_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RandomAccessStream_Static) },
        { }
    };

    static PyType_Spec type_spec_RandomAccessStream_Static =
    {
        "winrt._winrt_windows_storage_streams.RandomAccessStream_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RandomAccessStream_Static
    };

    // ----- RandomAccessStreamOverStream class --------------------

    static PyObject* _new_RandomAccessStreamOverStream(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>::type_name);
        return nullptr;
    }

    static void _dealloc_RandomAccessStreamOverStream(py::wrapper::Windows::Storage::Streams::RandomAccessStreamOverStream* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RandomAccessStreamOverStream_CloneStream(py::wrapper::Windows::Storage::Streams::RandomAccessStreamOverStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.RandomAccessStreamOverStream", L"CloneStream", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CloneStream());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RandomAccessStreamOverStream_Close(py::wrapper::Windows::Storage::Streams::RandomAccessStreamOverStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.RandomAccessStreamOverStream", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RandomAccessStreamOverStream_FlushAsync(py::wrapper::Windows::Storage::Streams::RandomAccessStreamOverStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.RandomAccessStreamOverStream", L"FlushAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.FlushAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RandomAccessStreamOverStream_GetInputStreamAt(py::wrapper::Windows::Storage::Streams::RandomAccessStreamOverStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.RandomAccessStreamOverStream", L"GetInputStreamAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetInputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RandomAccessStreamOverStream_GetOutputStreamAt(py::wrapper::Windows::Storage::Streams::RandomAccessStreamOverStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.RandomAccessStreamOverStream", L"GetOutputStreamAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetOutputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RandomAccessStreamOverStream_ReadAsync(py::wrapper::Windows::Storage::Streams::RandomAccessStreamOverStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.RandomAccessStreamOverStream", L"ReadAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);

                return py::convert(self->obj.ReadAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RandomAccessStreamOverStream_Seek(py::wrapper::Windows::Storage::Streams::RandomAccessStreamOverStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.RandomAccessStreamOverStream", L"Seek", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.Seek(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RandomAccessStreamOverStream_WriteAsync(py::wrapper::Windows::Storage::Streams::RandomAccessStreamOverStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.RandomAccessStreamOverStream", L"WriteAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.WriteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RandomAccessStreamOverStream_get_Size(py::wrapper::Windows::Storage::Streams::RandomAccessStreamOverStream* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.RandomAccessStreamOverStream", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RandomAccessStreamOverStream_put_Size(py::wrapper::Windows::Storage::Streams::RandomAccessStreamOverStream* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.RandomAccessStreamOverStream", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint64_t>(arg);

            self->obj.Size(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RandomAccessStreamOverStream_get_CanRead(py::wrapper::Windows::Storage::Streams::RandomAccessStreamOverStream* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.RandomAccessStreamOverStream", L"CanRead"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanRead());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RandomAccessStreamOverStream_get_CanWrite(py::wrapper::Windows::Storage::Streams::RandomAccessStreamOverStream* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.RandomAccessStreamOverStream", L"CanWrite"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanWrite());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RandomAccessStreamOverStream_get_Position(py::wrapper::Windows::Storage::Streams::RandomAccessStreamOverStream* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.RandomAccessStreamOverStream", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RandomAccessStreamOverStream(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RandomAccessStreamOverStream(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::RandomAccessStreamOverStream>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_RandomAccessStreamOverStream(py::wrapper::Windows::Storage::Streams::RandomAccessStreamOverStream* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_RandomAccessStreamOverStream(py::wrapper::Windows::Storage::Streams::RandomAccessStreamOverStream* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RandomAccessStreamOverStream[] = {
        { "clone_stream", reinterpret_cast<PyCFunction>(RandomAccessStreamOverStream_CloneStream), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(RandomAccessStreamOverStream_Close), METH_VARARGS, nullptr },
        { "flush_async", reinterpret_cast<PyCFunction>(RandomAccessStreamOverStream_FlushAsync), METH_VARARGS, nullptr },
        { "get_input_stream_at", reinterpret_cast<PyCFunction>(RandomAccessStreamOverStream_GetInputStreamAt), METH_VARARGS, nullptr },
        { "get_output_stream_at", reinterpret_cast<PyCFunction>(RandomAccessStreamOverStream_GetOutputStreamAt), METH_VARARGS, nullptr },
        { "read_async", reinterpret_cast<PyCFunction>(RandomAccessStreamOverStream_ReadAsync), METH_VARARGS, nullptr },
        { "seek", reinterpret_cast<PyCFunction>(RandomAccessStreamOverStream_Seek), METH_VARARGS, nullptr },
        { "write_async", reinterpret_cast<PyCFunction>(RandomAccessStreamOverStream_WriteAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RandomAccessStreamOverStream, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RandomAccessStreamOverStream), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_RandomAccessStreamOverStream), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_RandomAccessStreamOverStream), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_RandomAccessStreamOverStream[] = {
        { "size", reinterpret_cast<getter>(RandomAccessStreamOverStream_get_Size), reinterpret_cast<setter>(RandomAccessStreamOverStream_put_Size), nullptr, nullptr },
        { "can_read", reinterpret_cast<getter>(RandomAccessStreamOverStream_get_CanRead), nullptr, nullptr, nullptr },
        { "can_write", reinterpret_cast<getter>(RandomAccessStreamOverStream_get_CanWrite), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(RandomAccessStreamOverStream_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RandomAccessStreamOverStream[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RandomAccessStreamOverStream) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RandomAccessStreamOverStream) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RandomAccessStreamOverStream) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RandomAccessStreamOverStream) },
        { },
    };

    static PyType_Spec type_spec_RandomAccessStreamOverStream =
    {
        "winrt._winrt_windows_storage_streams.RandomAccessStreamOverStream",
        sizeof(py::wrapper::Windows::Storage::Streams::RandomAccessStreamOverStream),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RandomAccessStreamOverStream
    };

    // ----- RandomAccessStreamReference class --------------------

    static PyObject* _new_RandomAccessStreamReference(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Streams::RandomAccessStreamReference>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Streams::RandomAccessStreamReference>::type_name);
        return nullptr;
    }

    static void _dealloc_RandomAccessStreamReference(py::wrapper::Windows::Storage::Streams::RandomAccessStreamReference* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RandomAccessStreamReference_CreateFromFile(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.RandomAccessStreamReference", L"CreateFromFile", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(winrt::Windows::Storage::Streams::RandomAccessStreamReference::CreateFromFile(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RandomAccessStreamReference_CreateFromStream(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.RandomAccessStreamReference", L"CreateFromStream", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);

                return py::convert(winrt::Windows::Storage::Streams::RandomAccessStreamReference::CreateFromStream(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RandomAccessStreamReference_CreateFromUri(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.RandomAccessStreamReference", L"CreateFromUri", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(winrt::Windows::Storage::Streams::RandomAccessStreamReference::CreateFromUri(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RandomAccessStreamReference_OpenReadAsync(py::wrapper::Windows::Storage::Streams::RandomAccessStreamReference* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.RandomAccessStreamReference", L"OpenReadAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.OpenReadAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_RandomAccessStreamReference(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Streams::RandomAccessStreamReference>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RandomAccessStreamReference(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::RandomAccessStreamReference>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RandomAccessStreamReference[] = {
        { "open_read_async", reinterpret_cast<PyCFunction>(RandomAccessStreamReference_OpenReadAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RandomAccessStreamReference, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RandomAccessStreamReference), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RandomAccessStreamReference[] = {
        { }
    };

    static PyType_Slot _type_slots_RandomAccessStreamReference[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RandomAccessStreamReference) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RandomAccessStreamReference) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RandomAccessStreamReference) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RandomAccessStreamReference) },
        { },
    };

    static PyType_Spec type_spec_RandomAccessStreamReference =
    {
        "winrt._winrt_windows_storage_streams.RandomAccessStreamReference",
        sizeof(py::wrapper::Windows::Storage::Streams::RandomAccessStreamReference),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RandomAccessStreamReference
    };

    static PyGetSetDef getset_RandomAccessStreamReference_Static[] = {
        { }
    };

    static PyMethodDef methods_RandomAccessStreamReference_Static[] = {
        { "create_from_file", reinterpret_cast<PyCFunction>(RandomAccessStreamReference_CreateFromFile), METH_VARARGS, nullptr },
        { "create_from_stream", reinterpret_cast<PyCFunction>(RandomAccessStreamReference_CreateFromStream), METH_VARARGS, nullptr },
        { "create_from_uri", reinterpret_cast<PyCFunction>(RandomAccessStreamReference_CreateFromUri), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_RandomAccessStreamReference_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RandomAccessStreamReference_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RandomAccessStreamReference_Static) },
        { }
    };

    static PyType_Spec type_spec_RandomAccessStreamReference_Static =
    {
        "winrt._winrt_windows_storage_streams.RandomAccessStreamReference_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RandomAccessStreamReference_Static
    };

    // ----- IBuffer interface --------------------

    static PyObject* _new_IBuffer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Streams::IBuffer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Streams::IBuffer>::type_name);
        return nullptr;
    }

    static void _dealloc_IBuffer(py::wrapper::Windows::Storage::Streams::IBuffer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBuffer_get_Capacity(py::wrapper::Windows::Storage::Streams::IBuffer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.IBuffer", L"Capacity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Capacity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBuffer_get_Length(py::wrapper::Windows::Storage::Streams::IBuffer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.IBuffer", L"Length"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Length());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IBuffer_put_Length(py::wrapper::Windows::Storage::Streams::IBuffer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.IBuffer", L"Length"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Length(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IBuffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Streams::IBuffer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBuffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::IBuffer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _get_buffer_IBuffer(py::wrapper::Windows::Storage::Streams::IBuffer* self, Py_buffer* view, int flags) noexcept
    {
        try
        {
            return PyBuffer_FillInfo(view, reinterpret_cast<PyObject*>(self), reinterpret_cast<void*>(self->obj.data()), static_cast<Py_ssize_t>(self->obj.Length()), 0, flags);
        }
        catch (...)
        {
            view->obj = nullptr;
            PyErr_SetNone(PyExc_BufferError);
            return -1;
        }
    }

    static PyMethodDef _methods_IBuffer[] = {
        { "_assign_array_", _assign_array_IBuffer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBuffer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBuffer[] = {
        { "capacity", reinterpret_cast<getter>(IBuffer_get_Capacity), nullptr, nullptr, nullptr },
        { "length", reinterpret_cast<getter>(IBuffer_get_Length), reinterpret_cast<setter>(IBuffer_put_Length), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBuffer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBuffer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBuffer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBuffer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBuffer) },
        { Py_bf_getbuffer, reinterpret_cast<void*>(_get_buffer_IBuffer) },
        { },
    };

    static PyType_Spec type_spec_IBuffer =
    {
        "winrt._winrt_windows_storage_streams.IBuffer",
        sizeof(py::wrapper::Windows::Storage::Streams::IBuffer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBuffer
    };

    // ----- IContentTypeProvider interface --------------------

    static PyObject* _new_IContentTypeProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Streams::IContentTypeProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Streams::IContentTypeProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IContentTypeProvider(py::wrapper::Windows::Storage::Streams::IContentTypeProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContentTypeProvider_get_ContentType(py::wrapper::Windows::Storage::Streams::IContentTypeProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.IContentTypeProvider", L"ContentType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IContentTypeProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Streams::IContentTypeProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IContentTypeProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::IContentTypeProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContentTypeProvider[] = {
        { "_assign_array_", _assign_array_IContentTypeProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IContentTypeProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IContentTypeProvider[] = {
        { "content_type", reinterpret_cast<getter>(IContentTypeProvider_get_ContentType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IContentTypeProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IContentTypeProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IContentTypeProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IContentTypeProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IContentTypeProvider) },
        { },
    };

    static PyType_Spec type_spec_IContentTypeProvider =
    {
        "winrt._winrt_windows_storage_streams.IContentTypeProvider",
        sizeof(py::wrapper::Windows::Storage::Streams::IContentTypeProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContentTypeProvider
    };

    // ----- IDataReader interface --------------------

    static PyObject* _new_IDataReader(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Streams::IDataReader>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Streams::IDataReader>::type_name);
        return nullptr;
    }

    static void _dealloc_IDataReader(py::wrapper::Windows::Storage::Streams::IDataReader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IDataReader_DetachBuffer(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataReader", L"DetachBuffer", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.DetachBuffer());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataReader_DetachStream(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataReader", L"DetachStream", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.DetachStream());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataReader_LoadAsync(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataReader", L"LoadAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.LoadAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataReader_ReadBoolean(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataReader", L"ReadBoolean", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReadBoolean());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataReader_ReadBuffer(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataReader", L"ReadBuffer", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.ReadBuffer(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataReader_ReadByte(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataReader", L"ReadByte", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReadByte());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataReader_ReadBytes(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataReader", L"ReadBytes", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, true>>(args, 0);

                self->obj.ReadBytes(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataReader_ReadDateTime(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataReader", L"ReadDateTime", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReadDateTime());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataReader_ReadDouble(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataReader", L"ReadDouble", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReadDouble());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataReader_ReadGuid(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataReader", L"ReadGuid", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReadGuid());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataReader_ReadInt16(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataReader", L"ReadInt16", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReadInt16());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataReader_ReadInt32(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataReader", L"ReadInt32", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReadInt32());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataReader_ReadInt64(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataReader", L"ReadInt64", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReadInt64());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataReader_ReadSingle(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataReader", L"ReadSingle", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReadSingle());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataReader_ReadString(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataReader", L"ReadString", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.ReadString(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataReader_ReadTimeSpan(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataReader", L"ReadTimeSpan", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReadTimeSpan());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataReader_ReadUInt16(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataReader", L"ReadUInt16", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReadUInt16());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataReader_ReadUInt32(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataReader", L"ReadUInt32", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReadUInt32());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataReader_ReadUInt64(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataReader", L"ReadUInt64", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ReadUInt64());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataReader_get_ByteOrder(py::wrapper::Windows::Storage::Streams::IDataReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.IDataReader", L"ByteOrder"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ByteOrder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IDataReader_put_ByteOrder(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.IDataReader", L"ByteOrder"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::ByteOrder>(arg);

            self->obj.ByteOrder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IDataReader_get_InputStreamOptions(py::wrapper::Windows::Storage::Streams::IDataReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.IDataReader", L"InputStreamOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InputStreamOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IDataReader_put_InputStreamOptions(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.IDataReader", L"InputStreamOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(arg);

            self->obj.InputStreamOptions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IDataReader_get_UnconsumedBufferLength(py::wrapper::Windows::Storage::Streams::IDataReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.IDataReader", L"UnconsumedBufferLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UnconsumedBufferLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDataReader_get_UnicodeEncoding(py::wrapper::Windows::Storage::Streams::IDataReader* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.IDataReader", L"UnicodeEncoding"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UnicodeEncoding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IDataReader_put_UnicodeEncoding(py::wrapper::Windows::Storage::Streams::IDataReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.IDataReader", L"UnicodeEncoding"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(arg);

            self->obj.UnicodeEncoding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IDataReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Streams::IDataReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IDataReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::IDataReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IDataReader[] = {
        { "detach_buffer", reinterpret_cast<PyCFunction>(IDataReader_DetachBuffer), METH_VARARGS, nullptr },
        { "detach_stream", reinterpret_cast<PyCFunction>(IDataReader_DetachStream), METH_VARARGS, nullptr },
        { "load_async", reinterpret_cast<PyCFunction>(IDataReader_LoadAsync), METH_VARARGS, nullptr },
        { "read_boolean", reinterpret_cast<PyCFunction>(IDataReader_ReadBoolean), METH_VARARGS, nullptr },
        { "read_buffer", reinterpret_cast<PyCFunction>(IDataReader_ReadBuffer), METH_VARARGS, nullptr },
        { "read_byte", reinterpret_cast<PyCFunction>(IDataReader_ReadByte), METH_VARARGS, nullptr },
        { "read_bytes", reinterpret_cast<PyCFunction>(IDataReader_ReadBytes), METH_VARARGS, nullptr },
        { "read_date_time", reinterpret_cast<PyCFunction>(IDataReader_ReadDateTime), METH_VARARGS, nullptr },
        { "read_double", reinterpret_cast<PyCFunction>(IDataReader_ReadDouble), METH_VARARGS, nullptr },
        { "read_guid", reinterpret_cast<PyCFunction>(IDataReader_ReadGuid), METH_VARARGS, nullptr },
        { "read_int16", reinterpret_cast<PyCFunction>(IDataReader_ReadInt16), METH_VARARGS, nullptr },
        { "read_int32", reinterpret_cast<PyCFunction>(IDataReader_ReadInt32), METH_VARARGS, nullptr },
        { "read_int64", reinterpret_cast<PyCFunction>(IDataReader_ReadInt64), METH_VARARGS, nullptr },
        { "read_single", reinterpret_cast<PyCFunction>(IDataReader_ReadSingle), METH_VARARGS, nullptr },
        { "read_string", reinterpret_cast<PyCFunction>(IDataReader_ReadString), METH_VARARGS, nullptr },
        { "read_time_span", reinterpret_cast<PyCFunction>(IDataReader_ReadTimeSpan), METH_VARARGS, nullptr },
        { "read_uint16", reinterpret_cast<PyCFunction>(IDataReader_ReadUInt16), METH_VARARGS, nullptr },
        { "read_uint32", reinterpret_cast<PyCFunction>(IDataReader_ReadUInt32), METH_VARARGS, nullptr },
        { "read_uint64", reinterpret_cast<PyCFunction>(IDataReader_ReadUInt64), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IDataReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IDataReader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IDataReader[] = {
        { "byte_order", reinterpret_cast<getter>(IDataReader_get_ByteOrder), reinterpret_cast<setter>(IDataReader_put_ByteOrder), nullptr, nullptr },
        { "input_stream_options", reinterpret_cast<getter>(IDataReader_get_InputStreamOptions), reinterpret_cast<setter>(IDataReader_put_InputStreamOptions), nullptr, nullptr },
        { "unconsumed_buffer_length", reinterpret_cast<getter>(IDataReader_get_UnconsumedBufferLength), nullptr, nullptr, nullptr },
        { "unicode_encoding", reinterpret_cast<getter>(IDataReader_get_UnicodeEncoding), reinterpret_cast<setter>(IDataReader_put_UnicodeEncoding), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IDataReader[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IDataReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IDataReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IDataReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IDataReader) },
        { },
    };

    static PyType_Spec type_spec_IDataReader =
    {
        "winrt._winrt_windows_storage_streams.IDataReader",
        sizeof(py::wrapper::Windows::Storage::Streams::IDataReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IDataReader
    };

    // ----- IDataWriter interface --------------------

    static PyObject* _new_IDataWriter(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Streams::IDataWriter>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Streams::IDataWriter>::type_name);
        return nullptr;
    }

    static void _dealloc_IDataWriter(py::wrapper::Windows::Storage::Streams::IDataWriter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IDataWriter_DetachBuffer(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataWriter", L"DetachBuffer", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.DetachBuffer());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_DetachStream(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataWriter", L"DetachStream", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.DetachStream());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_FlushAsync(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataWriter", L"FlushAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.FlushAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_MeasureString(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataWriter", L"MeasureString", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.MeasureString(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_StoreAsync(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataWriter", L"StoreAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.StoreAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_WriteBoolean(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataWriter", L"WriteBoolean", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.WriteBoolean(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_WriteBuffer(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataWriter", L"WriteBuffer", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                self->obj.WriteBuffer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataWriter", L"WriteBuffer", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.WriteBuffer(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_WriteByte(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataWriter", L"WriteByte", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);

                self->obj.WriteByte(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_WriteBytes(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataWriter", L"WriteBytes", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                self->obj.WriteBytes(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_WriteDateTime(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataWriter", L"WriteDateTime", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);

                self->obj.WriteDateTime(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_WriteDouble(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataWriter", L"WriteDouble", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                self->obj.WriteDouble(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_WriteGuid(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataWriter", L"WriteGuid", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                self->obj.WriteGuid(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_WriteInt16(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataWriter", L"WriteInt16", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int16_t>(args, 0);

                self->obj.WriteInt16(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_WriteInt32(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataWriter", L"WriteInt32", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.WriteInt32(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_WriteInt64(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataWriter", L"WriteInt64", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int64_t>(args, 0);

                self->obj.WriteInt64(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_WriteSingle(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataWriter", L"WriteSingle", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<float>(args, 0);

                self->obj.WriteSingle(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_WriteString(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataWriter", L"WriteString", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.WriteString(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_WriteTimeSpan(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataWriter", L"WriteTimeSpan", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                self->obj.WriteTimeSpan(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_WriteUInt16(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataWriter", L"WriteUInt16", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);

                self->obj.WriteUInt16(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_WriteUInt32(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataWriter", L"WriteUInt32", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.WriteUInt32(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_WriteUInt64(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IDataWriter", L"WriteUInt64", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.WriteUInt64(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDataWriter_get_ByteOrder(py::wrapper::Windows::Storage::Streams::IDataWriter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.IDataWriter", L"ByteOrder"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ByteOrder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IDataWriter_put_ByteOrder(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.IDataWriter", L"ByteOrder"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::ByteOrder>(arg);

            self->obj.ByteOrder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IDataWriter_get_UnicodeEncoding(py::wrapper::Windows::Storage::Streams::IDataWriter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.IDataWriter", L"UnicodeEncoding"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UnicodeEncoding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IDataWriter_put_UnicodeEncoding(py::wrapper::Windows::Storage::Streams::IDataWriter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.IDataWriter", L"UnicodeEncoding"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::UnicodeEncoding>(arg);

            self->obj.UnicodeEncoding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IDataWriter_get_UnstoredBufferLength(py::wrapper::Windows::Storage::Streams::IDataWriter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.IDataWriter", L"UnstoredBufferLength"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UnstoredBufferLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IDataWriter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Streams::IDataWriter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IDataWriter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::IDataWriter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IDataWriter[] = {
        { "detach_buffer", reinterpret_cast<PyCFunction>(IDataWriter_DetachBuffer), METH_VARARGS, nullptr },
        { "detach_stream", reinterpret_cast<PyCFunction>(IDataWriter_DetachStream), METH_VARARGS, nullptr },
        { "flush_async", reinterpret_cast<PyCFunction>(IDataWriter_FlushAsync), METH_VARARGS, nullptr },
        { "measure_string", reinterpret_cast<PyCFunction>(IDataWriter_MeasureString), METH_VARARGS, nullptr },
        { "store_async", reinterpret_cast<PyCFunction>(IDataWriter_StoreAsync), METH_VARARGS, nullptr },
        { "write_boolean", reinterpret_cast<PyCFunction>(IDataWriter_WriteBoolean), METH_VARARGS, nullptr },
        { "write_buffer", reinterpret_cast<PyCFunction>(IDataWriter_WriteBuffer), METH_VARARGS, nullptr },
        { "write_byte", reinterpret_cast<PyCFunction>(IDataWriter_WriteByte), METH_VARARGS, nullptr },
        { "write_bytes", reinterpret_cast<PyCFunction>(IDataWriter_WriteBytes), METH_VARARGS, nullptr },
        { "write_date_time", reinterpret_cast<PyCFunction>(IDataWriter_WriteDateTime), METH_VARARGS, nullptr },
        { "write_double", reinterpret_cast<PyCFunction>(IDataWriter_WriteDouble), METH_VARARGS, nullptr },
        { "write_guid", reinterpret_cast<PyCFunction>(IDataWriter_WriteGuid), METH_VARARGS, nullptr },
        { "write_int16", reinterpret_cast<PyCFunction>(IDataWriter_WriteInt16), METH_VARARGS, nullptr },
        { "write_int32", reinterpret_cast<PyCFunction>(IDataWriter_WriteInt32), METH_VARARGS, nullptr },
        { "write_int64", reinterpret_cast<PyCFunction>(IDataWriter_WriteInt64), METH_VARARGS, nullptr },
        { "write_single", reinterpret_cast<PyCFunction>(IDataWriter_WriteSingle), METH_VARARGS, nullptr },
        { "write_string", reinterpret_cast<PyCFunction>(IDataWriter_WriteString), METH_VARARGS, nullptr },
        { "write_time_span", reinterpret_cast<PyCFunction>(IDataWriter_WriteTimeSpan), METH_VARARGS, nullptr },
        { "write_uint16", reinterpret_cast<PyCFunction>(IDataWriter_WriteUInt16), METH_VARARGS, nullptr },
        { "write_uint32", reinterpret_cast<PyCFunction>(IDataWriter_WriteUInt32), METH_VARARGS, nullptr },
        { "write_uint64", reinterpret_cast<PyCFunction>(IDataWriter_WriteUInt64), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IDataWriter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IDataWriter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IDataWriter[] = {
        { "byte_order", reinterpret_cast<getter>(IDataWriter_get_ByteOrder), reinterpret_cast<setter>(IDataWriter_put_ByteOrder), nullptr, nullptr },
        { "unicode_encoding", reinterpret_cast<getter>(IDataWriter_get_UnicodeEncoding), reinterpret_cast<setter>(IDataWriter_put_UnicodeEncoding), nullptr, nullptr },
        { "unstored_buffer_length", reinterpret_cast<getter>(IDataWriter_get_UnstoredBufferLength), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IDataWriter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IDataWriter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IDataWriter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IDataWriter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IDataWriter) },
        { },
    };

    static PyType_Spec type_spec_IDataWriter =
    {
        "winrt._winrt_windows_storage_streams.IDataWriter",
        sizeof(py::wrapper::Windows::Storage::Streams::IDataWriter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IDataWriter
    };

    // ----- IInputStream interface --------------------

    static PyObject* _new_IInputStream(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Streams::IInputStream>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Streams::IInputStream>::type_name);
        return nullptr;
    }

    static void _dealloc_IInputStream(py::wrapper::Windows::Storage::Streams::IInputStream* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IInputStream_Close(py::wrapper::Windows::Storage::Streams::IInputStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IInputStream_ReadAsync(py::wrapper::Windows::Storage::Streams::IInputStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IInputStream", L"ReadAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);

                return py::convert(self->obj.ReadAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IInputStream(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Streams::IInputStream>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IInputStream(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::IInputStream>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IInputStream(py::wrapper::Windows::Storage::Streams::IInputStream* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_IInputStream(py::wrapper::Windows::Storage::Streams::IInputStream* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IInputStream[] = {
        { "close", reinterpret_cast<PyCFunction>(IInputStream_Close), METH_VARARGS, nullptr },
        { "read_async", reinterpret_cast<PyCFunction>(IInputStream_ReadAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IInputStream, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IInputStream), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IInputStream), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_IInputStream), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_IInputStream[] = {
        { }
    };

    static PyType_Slot _type_slots_IInputStream[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IInputStream) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IInputStream) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IInputStream) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IInputStream) },
        { },
    };

    static PyType_Spec type_spec_IInputStream =
    {
        "winrt._winrt_windows_storage_streams.IInputStream",
        sizeof(py::wrapper::Windows::Storage::Streams::IInputStream),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IInputStream
    };

    // ----- IInputStreamReference interface --------------------

    static PyObject* _new_IInputStreamReference(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Streams::IInputStreamReference>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Streams::IInputStreamReference>::type_name);
        return nullptr;
    }

    static void _dealloc_IInputStreamReference(py::wrapper::Windows::Storage::Streams::IInputStreamReference* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IInputStreamReference_OpenSequentialReadAsync(py::wrapper::Windows::Storage::Streams::IInputStreamReference* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IInputStreamReference", L"OpenSequentialReadAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.OpenSequentialReadAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IInputStreamReference(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Streams::IInputStreamReference>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IInputStreamReference(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::IInputStreamReference>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IInputStreamReference[] = {
        { "open_sequential_read_async", reinterpret_cast<PyCFunction>(IInputStreamReference_OpenSequentialReadAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IInputStreamReference, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IInputStreamReference), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IInputStreamReference[] = {
        { }
    };

    static PyType_Slot _type_slots_IInputStreamReference[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IInputStreamReference) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IInputStreamReference) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IInputStreamReference) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IInputStreamReference) },
        { },
    };

    static PyType_Spec type_spec_IInputStreamReference =
    {
        "winrt._winrt_windows_storage_streams.IInputStreamReference",
        sizeof(py::wrapper::Windows::Storage::Streams::IInputStreamReference),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IInputStreamReference
    };

    // ----- IOutputStream interface --------------------

    static PyObject* _new_IOutputStream(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Streams::IOutputStream>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Streams::IOutputStream>::type_name);
        return nullptr;
    }

    static void _dealloc_IOutputStream(py::wrapper::Windows::Storage::Streams::IOutputStream* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IOutputStream_Close(py::wrapper::Windows::Storage::Streams::IOutputStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IOutputStream_FlushAsync(py::wrapper::Windows::Storage::Streams::IOutputStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IOutputStream", L"FlushAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.FlushAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IOutputStream_WriteAsync(py::wrapper::Windows::Storage::Streams::IOutputStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IOutputStream", L"WriteAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.WriteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IOutputStream(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Streams::IOutputStream>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IOutputStream(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::IOutputStream>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IOutputStream(py::wrapper::Windows::Storage::Streams::IOutputStream* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_IOutputStream(py::wrapper::Windows::Storage::Streams::IOutputStream* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IOutputStream[] = {
        { "close", reinterpret_cast<PyCFunction>(IOutputStream_Close), METH_VARARGS, nullptr },
        { "flush_async", reinterpret_cast<PyCFunction>(IOutputStream_FlushAsync), METH_VARARGS, nullptr },
        { "write_async", reinterpret_cast<PyCFunction>(IOutputStream_WriteAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IOutputStream, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IOutputStream), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IOutputStream), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_IOutputStream), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_IOutputStream[] = {
        { }
    };

    static PyType_Slot _type_slots_IOutputStream[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IOutputStream) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IOutputStream) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IOutputStream) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IOutputStream) },
        { },
    };

    static PyType_Spec type_spec_IOutputStream =
    {
        "winrt._winrt_windows_storage_streams.IOutputStream",
        sizeof(py::wrapper::Windows::Storage::Streams::IOutputStream),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IOutputStream
    };

    // ----- IPropertySetSerializer interface --------------------

    static PyObject* _new_IPropertySetSerializer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Streams::IPropertySetSerializer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Streams::IPropertySetSerializer>::type_name);
        return nullptr;
    }

    static void _dealloc_IPropertySetSerializer(py::wrapper::Windows::Storage::Streams::IPropertySetSerializer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPropertySetSerializer_Deserialize(py::wrapper::Windows::Storage::Streams::IPropertySetSerializer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IPropertySetSerializer", L"Deserialize", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                self->obj.Deserialize(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPropertySetSerializer_Serialize(py::wrapper::Windows::Storage::Streams::IPropertySetSerializer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IPropertySetSerializer", L"Serialize", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 0);

                return py::convert(self->obj.Serialize(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IPropertySetSerializer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Streams::IPropertySetSerializer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPropertySetSerializer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::IPropertySetSerializer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPropertySetSerializer[] = {
        { "deserialize", reinterpret_cast<PyCFunction>(IPropertySetSerializer_Deserialize), METH_VARARGS, nullptr },
        { "serialize", reinterpret_cast<PyCFunction>(IPropertySetSerializer_Serialize), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IPropertySetSerializer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPropertySetSerializer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IPropertySetSerializer[] = {
        { }
    };

    static PyType_Slot _type_slots_IPropertySetSerializer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IPropertySetSerializer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPropertySetSerializer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPropertySetSerializer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPropertySetSerializer) },
        { },
    };

    static PyType_Spec type_spec_IPropertySetSerializer =
    {
        "winrt._winrt_windows_storage_streams.IPropertySetSerializer",
        sizeof(py::wrapper::Windows::Storage::Streams::IPropertySetSerializer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPropertySetSerializer
    };

    // ----- IRandomAccessStream interface --------------------

    static PyObject* _new_IRandomAccessStream(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Streams::IRandomAccessStream>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Streams::IRandomAccessStream>::type_name);
        return nullptr;
    }

    static void _dealloc_IRandomAccessStream(py::wrapper::Windows::Storage::Streams::IRandomAccessStream* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IRandomAccessStream_CloneStream(py::wrapper::Windows::Storage::Streams::IRandomAccessStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IRandomAccessStream", L"CloneStream", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CloneStream());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStream_Close(py::wrapper::Windows::Storage::Streams::IRandomAccessStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStream_FlushAsync(py::wrapper::Windows::Storage::Streams::IRandomAccessStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IOutputStream", L"FlushAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.FlushAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStream_GetInputStreamAt(py::wrapper::Windows::Storage::Streams::IRandomAccessStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IRandomAccessStream", L"GetInputStreamAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetInputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStream_GetOutputStreamAt(py::wrapper::Windows::Storage::Streams::IRandomAccessStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IRandomAccessStream", L"GetOutputStreamAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetOutputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStream_ReadAsync(py::wrapper::Windows::Storage::Streams::IRandomAccessStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IInputStream", L"ReadAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);

                return py::convert(self->obj.ReadAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStream_Seek(py::wrapper::Windows::Storage::Streams::IRandomAccessStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IRandomAccessStream", L"Seek", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.Seek(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStream_WriteAsync(py::wrapper::Windows::Storage::Streams::IRandomAccessStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IOutputStream", L"WriteAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.WriteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStream_get_CanRead(py::wrapper::Windows::Storage::Streams::IRandomAccessStream* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.IRandomAccessStream", L"CanRead"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanRead());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStream_get_CanWrite(py::wrapper::Windows::Storage::Streams::IRandomAccessStream* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.IRandomAccessStream", L"CanWrite"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanWrite());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStream_get_Position(py::wrapper::Windows::Storage::Streams::IRandomAccessStream* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.IRandomAccessStream", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStream_get_Size(py::wrapper::Windows::Storage::Streams::IRandomAccessStream* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.IRandomAccessStream", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IRandomAccessStream_put_Size(py::wrapper::Windows::Storage::Streams::IRandomAccessStream* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.IRandomAccessStream", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint64_t>(arg);

            self->obj.Size(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IRandomAccessStream(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Streams::IRandomAccessStream>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IRandomAccessStream(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::IRandomAccessStream>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IRandomAccessStream(py::wrapper::Windows::Storage::Streams::IRandomAccessStream* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_IRandomAccessStream(py::wrapper::Windows::Storage::Streams::IRandomAccessStream* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IRandomAccessStream[] = {
        { "clone_stream", reinterpret_cast<PyCFunction>(IRandomAccessStream_CloneStream), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(IRandomAccessStream_Close), METH_VARARGS, nullptr },
        { "flush_async", reinterpret_cast<PyCFunction>(IRandomAccessStream_FlushAsync), METH_VARARGS, nullptr },
        { "get_input_stream_at", reinterpret_cast<PyCFunction>(IRandomAccessStream_GetInputStreamAt), METH_VARARGS, nullptr },
        { "get_output_stream_at", reinterpret_cast<PyCFunction>(IRandomAccessStream_GetOutputStreamAt), METH_VARARGS, nullptr },
        { "read_async", reinterpret_cast<PyCFunction>(IRandomAccessStream_ReadAsync), METH_VARARGS, nullptr },
        { "seek", reinterpret_cast<PyCFunction>(IRandomAccessStream_Seek), METH_VARARGS, nullptr },
        { "write_async", reinterpret_cast<PyCFunction>(IRandomAccessStream_WriteAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IRandomAccessStream, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IRandomAccessStream), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IRandomAccessStream), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_IRandomAccessStream), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_IRandomAccessStream[] = {
        { "can_read", reinterpret_cast<getter>(IRandomAccessStream_get_CanRead), nullptr, nullptr, nullptr },
        { "can_write", reinterpret_cast<getter>(IRandomAccessStream_get_CanWrite), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(IRandomAccessStream_get_Position), nullptr, nullptr, nullptr },
        { "size", reinterpret_cast<getter>(IRandomAccessStream_get_Size), reinterpret_cast<setter>(IRandomAccessStream_put_Size), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IRandomAccessStream[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IRandomAccessStream) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IRandomAccessStream) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IRandomAccessStream) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IRandomAccessStream) },
        { },
    };

    static PyType_Spec type_spec_IRandomAccessStream =
    {
        "winrt._winrt_windows_storage_streams.IRandomAccessStream",
        sizeof(py::wrapper::Windows::Storage::Streams::IRandomAccessStream),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IRandomAccessStream
    };

    // ----- IRandomAccessStreamReference interface --------------------

    static PyObject* _new_IRandomAccessStreamReference(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>::type_name);
        return nullptr;
    }

    static void _dealloc_IRandomAccessStreamReference(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamReference* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IRandomAccessStreamReference_OpenReadAsync(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamReference* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IRandomAccessStreamReference", L"OpenReadAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.OpenReadAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IRandomAccessStreamReference(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IRandomAccessStreamReference(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IRandomAccessStreamReference[] = {
        { "open_read_async", reinterpret_cast<PyCFunction>(IRandomAccessStreamReference_OpenReadAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IRandomAccessStreamReference, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IRandomAccessStreamReference), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IRandomAccessStreamReference[] = {
        { }
    };

    static PyType_Slot _type_slots_IRandomAccessStreamReference[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IRandomAccessStreamReference) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IRandomAccessStreamReference) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IRandomAccessStreamReference) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IRandomAccessStreamReference) },
        { },
    };

    static PyType_Spec type_spec_IRandomAccessStreamReference =
    {
        "winrt._winrt_windows_storage_streams.IRandomAccessStreamReference",
        sizeof(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamReference),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IRandomAccessStreamReference
    };

    // ----- IRandomAccessStreamWithContentType interface --------------------

    static PyObject* _new_IRandomAccessStreamWithContentType(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>::type_name);
        return nullptr;
    }

    static void _dealloc_IRandomAccessStreamWithContentType(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamWithContentType* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IRandomAccessStreamWithContentType_CloneStream(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamWithContentType* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IRandomAccessStream", L"CloneStream", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CloneStream());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStreamWithContentType_Close(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamWithContentType* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStreamWithContentType_FlushAsync(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamWithContentType* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IOutputStream", L"FlushAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.FlushAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStreamWithContentType_GetInputStreamAt(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamWithContentType* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IRandomAccessStream", L"GetInputStreamAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetInputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStreamWithContentType_GetOutputStreamAt(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamWithContentType* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IRandomAccessStream", L"GetOutputStreamAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetOutputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStreamWithContentType_ReadAsync(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamWithContentType* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IInputStream", L"ReadAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);

                return py::convert(self->obj.ReadAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStreamWithContentType_Seek(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamWithContentType* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IRandomAccessStream", L"Seek", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.Seek(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStreamWithContentType_WriteAsync(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamWithContentType* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Storage.Streams.IOutputStream", L"WriteAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.WriteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStreamWithContentType_get_CanRead(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamWithContentType* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.IRandomAccessStream", L"CanRead"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanRead());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStreamWithContentType_get_CanWrite(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamWithContentType* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.IRandomAccessStream", L"CanWrite"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanWrite());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStreamWithContentType_get_Position(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamWithContentType* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.IRandomAccessStream", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IRandomAccessStreamWithContentType_get_Size(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamWithContentType* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.IRandomAccessStream", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IRandomAccessStreamWithContentType_put_Size(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamWithContentType* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.IRandomAccessStream", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint64_t>(arg);

            self->obj.Size(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IRandomAccessStreamWithContentType_get_ContentType(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamWithContentType* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Storage.Streams.IContentTypeProvider", L"ContentType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IRandomAccessStreamWithContentType(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IRandomAccessStreamWithContentType(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Streams::IRandomAccessStreamWithContentType>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IRandomAccessStreamWithContentType(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamWithContentType* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_IRandomAccessStreamWithContentType(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamWithContentType* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IRandomAccessStreamWithContentType[] = {
        { "clone_stream", reinterpret_cast<PyCFunction>(IRandomAccessStreamWithContentType_CloneStream), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(IRandomAccessStreamWithContentType_Close), METH_VARARGS, nullptr },
        { "flush_async", reinterpret_cast<PyCFunction>(IRandomAccessStreamWithContentType_FlushAsync), METH_VARARGS, nullptr },
        { "get_input_stream_at", reinterpret_cast<PyCFunction>(IRandomAccessStreamWithContentType_GetInputStreamAt), METH_VARARGS, nullptr },
        { "get_output_stream_at", reinterpret_cast<PyCFunction>(IRandomAccessStreamWithContentType_GetOutputStreamAt), METH_VARARGS, nullptr },
        { "read_async", reinterpret_cast<PyCFunction>(IRandomAccessStreamWithContentType_ReadAsync), METH_VARARGS, nullptr },
        { "seek", reinterpret_cast<PyCFunction>(IRandomAccessStreamWithContentType_Seek), METH_VARARGS, nullptr },
        { "write_async", reinterpret_cast<PyCFunction>(IRandomAccessStreamWithContentType_WriteAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IRandomAccessStreamWithContentType, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IRandomAccessStreamWithContentType), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IRandomAccessStreamWithContentType), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_IRandomAccessStreamWithContentType), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_IRandomAccessStreamWithContentType[] = {
        { "can_read", reinterpret_cast<getter>(IRandomAccessStreamWithContentType_get_CanRead), nullptr, nullptr, nullptr },
        { "can_write", reinterpret_cast<getter>(IRandomAccessStreamWithContentType_get_CanWrite), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(IRandomAccessStreamWithContentType_get_Position), nullptr, nullptr, nullptr },
        { "size", reinterpret_cast<getter>(IRandomAccessStreamWithContentType_get_Size), reinterpret_cast<setter>(IRandomAccessStreamWithContentType_put_Size), nullptr, nullptr },
        { "content_type", reinterpret_cast<getter>(IRandomAccessStreamWithContentType_get_ContentType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IRandomAccessStreamWithContentType[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IRandomAccessStreamWithContentType) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IRandomAccessStreamWithContentType) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IRandomAccessStreamWithContentType) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IRandomAccessStreamWithContentType) },
        { },
    };

    static PyType_Spec type_spec_IRandomAccessStreamWithContentType =
    {
        "winrt._winrt_windows_storage_streams.IRandomAccessStreamWithContentType",
        sizeof(py::wrapper::Windows::Storage::Streams::IRandomAccessStreamWithContentType),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IRandomAccessStreamWithContentType
    };

    // ----- Windows.Storage.Streams Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Storage::Streams");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_storage_streams",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::Storage::Streams

PyMODINIT_FUNC PyInit__winrt_windows_storage_streams(void) noexcept
{
    using namespace py::cpp::Windows::Storage::Streams;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Buffer_Static{PyType_FromSpec(&type_spec_Buffer_Static)};
    if (!type_Buffer_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Buffer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Buffer_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_DataReader_Static{PyType_FromSpec(&type_spec_DataReader_Static)};
    if (!type_DataReader_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DataReader, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DataReader_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DataReaderLoadOperation, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DataWriter, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DataWriterStoreOperation, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_FileInputStream, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_FileOutputStream, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_FileRandomAccessStream_Static{PyType_FromSpec(&type_spec_FileRandomAccessStream_Static)};
    if (!type_FileRandomAccessStream_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_FileRandomAccessStream, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_FileRandomAccessStream_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InMemoryRandomAccessStream, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InputStreamOverStream, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_OutputStreamOverStream, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_RandomAccessStream_Static{PyType_FromSpec(&type_spec_RandomAccessStream_Static)};
    if (!type_RandomAccessStream_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RandomAccessStream, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RandomAccessStream_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RandomAccessStreamOverStream, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_RandomAccessStreamReference_Static{PyType_FromSpec(&type_spec_RandomAccessStreamReference_Static)};
    if (!type_RandomAccessStreamReference_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RandomAccessStreamReference, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RandomAccessStreamReference_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IBuffer, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IContentTypeProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IDataReader, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IDataWriter, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IInputStream, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IInputStreamReference, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IOutputStream, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IPropertySetSerializer, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IRandomAccessStream, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IRandomAccessStreamReference, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IRandomAccessStreamWithContentType, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
