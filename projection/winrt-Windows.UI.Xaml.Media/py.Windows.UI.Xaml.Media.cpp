// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.UI.Xaml.Media.h"

namespace py::cpp::Windows::UI::Xaml::Media
{
    // ----- AcrylicBrush class --------------------

    struct PyWinrtAcrylicBrush;
    using BasePyWinrtAcrylicBrush = winrt::Windows::UI::Xaml::Media::AcrylicBrushT<PyWinrtAcrylicBrush, py::IPywinrtObject>;

    struct PyWinrtAcrylicBrush : py::py_obj_ref, BasePyWinrtAcrylicBrush
    {
        PyWinrtAcrylicBrush(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtAcrylicBrush() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtAcrylicBrush* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_AcrylicBrush(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Media::AcrylicBrush>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Media::AcrylicBrush*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Media::AcrylicBrush*>(self.get())->obj = winrt::make<PyWinrtAcrylicBrush>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Media::AcrylicBrush instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AcrylicBrush(py::wrapper::Windows::UI::Xaml::Media::AcrylicBrush* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AcrylicBrush_get_TintTransitionDuration(py::wrapper::Windows::UI::Xaml::Media::AcrylicBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.AcrylicBrush", L"TintTransitionDuration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Media::AcrylicBrush>().TintTransitionDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AcrylicBrush_put_TintTransitionDuration(py::wrapper::Windows::UI::Xaml::Media::AcrylicBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.AcrylicBrush", L"TintTransitionDuration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Media::AcrylicBrush>().TintTransitionDuration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AcrylicBrush_get_TintOpacity(py::wrapper::Windows::UI::Xaml::Media::AcrylicBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.AcrylicBrush", L"TintOpacity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Media::AcrylicBrush>().TintOpacity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AcrylicBrush_put_TintOpacity(py::wrapper::Windows::UI::Xaml::Media::AcrylicBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.AcrylicBrush", L"TintOpacity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Media::AcrylicBrush>().TintOpacity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AcrylicBrush_get_TintColor(py::wrapper::Windows::UI::Xaml::Media::AcrylicBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.AcrylicBrush", L"TintColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Media::AcrylicBrush>().TintColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AcrylicBrush_put_TintColor(py::wrapper::Windows::UI::Xaml::Media::AcrylicBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.AcrylicBrush", L"TintColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Media::AcrylicBrush>().TintColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AcrylicBrush_get_BackgroundSource(py::wrapper::Windows::UI::Xaml::Media::AcrylicBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.AcrylicBrush", L"BackgroundSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Media::AcrylicBrush>().BackgroundSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AcrylicBrush_put_BackgroundSource(py::wrapper::Windows::UI::Xaml::Media::AcrylicBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.AcrylicBrush", L"BackgroundSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::AcrylicBackgroundSource>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Media::AcrylicBrush>().BackgroundSource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AcrylicBrush_get_AlwaysUseFallback(py::wrapper::Windows::UI::Xaml::Media::AcrylicBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.AcrylicBrush", L"AlwaysUseFallback");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Media::AcrylicBrush>().AlwaysUseFallback());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AcrylicBrush_put_AlwaysUseFallback(py::wrapper::Windows::UI::Xaml::Media::AcrylicBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.AcrylicBrush", L"AlwaysUseFallback");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Media::AcrylicBrush>().AlwaysUseFallback(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AcrylicBrush_get_TintLuminosityOpacity(py::wrapper::Windows::UI::Xaml::Media::AcrylicBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.AcrylicBrush", L"TintLuminosityOpacity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Media::AcrylicBrush>().TintLuminosityOpacity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AcrylicBrush_put_TintLuminosityOpacity(py::wrapper::Windows::UI::Xaml::Media::AcrylicBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.AcrylicBrush", L"TintLuminosityOpacity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<double>>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Media::AcrylicBrush>().TintLuminosityOpacity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AcrylicBrush_get_AlwaysUseFallbackProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.AcrylicBrush", L"AlwaysUseFallbackProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::AcrylicBrush::AlwaysUseFallbackProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AcrylicBrush_get_BackgroundSourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.AcrylicBrush", L"BackgroundSourceProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::AcrylicBrush::BackgroundSourceProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AcrylicBrush_get_TintColorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.AcrylicBrush", L"TintColorProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::AcrylicBrush::TintColorProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AcrylicBrush_get_TintOpacityProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.AcrylicBrush", L"TintOpacityProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::AcrylicBrush::TintOpacityProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AcrylicBrush_get_TintTransitionDurationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.AcrylicBrush", L"TintTransitionDurationProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::AcrylicBrush::TintTransitionDurationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AcrylicBrush_get_TintLuminosityOpacityProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.AcrylicBrush", L"TintLuminosityOpacityProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::AcrylicBrush::TintLuminosityOpacityProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AcrylicBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::AcrylicBrush>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AcrylicBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::AcrylicBrush>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AcrylicBrush[] = {
        { "_assign_array_", _assign_array_AcrylicBrush, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AcrylicBrush), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AcrylicBrush[] = {
        { "tint_transition_duration", reinterpret_cast<getter>(AcrylicBrush_get_TintTransitionDuration), reinterpret_cast<setter>(AcrylicBrush_put_TintTransitionDuration), nullptr, nullptr },
        { "tint_opacity", reinterpret_cast<getter>(AcrylicBrush_get_TintOpacity), reinterpret_cast<setter>(AcrylicBrush_put_TintOpacity), nullptr, nullptr },
        { "tint_color", reinterpret_cast<getter>(AcrylicBrush_get_TintColor), reinterpret_cast<setter>(AcrylicBrush_put_TintColor), nullptr, nullptr },
        { "background_source", reinterpret_cast<getter>(AcrylicBrush_get_BackgroundSource), reinterpret_cast<setter>(AcrylicBrush_put_BackgroundSource), nullptr, nullptr },
        { "always_use_fallback", reinterpret_cast<getter>(AcrylicBrush_get_AlwaysUseFallback), reinterpret_cast<setter>(AcrylicBrush_put_AlwaysUseFallback), nullptr, nullptr },
        { "tint_luminosity_opacity", reinterpret_cast<getter>(AcrylicBrush_get_TintLuminosityOpacity), reinterpret_cast<setter>(AcrylicBrush_put_TintLuminosityOpacity), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AcrylicBrush[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AcrylicBrush) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AcrylicBrush) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AcrylicBrush) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AcrylicBrush) },
        { }
    };

    static PyType_Spec type_spec_AcrylicBrush = {
        "winrt._winrt_windows_ui_xaml_media.AcrylicBrush",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::AcrylicBrush),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_AcrylicBrush};

    static PyGetSetDef getset_AcrylicBrush_Static[] = {
        { "always_use_fallback_property", reinterpret_cast<getter>(AcrylicBrush_get_AlwaysUseFallbackProperty), nullptr, nullptr, nullptr },
        { "background_source_property", reinterpret_cast<getter>(AcrylicBrush_get_BackgroundSourceProperty), nullptr, nullptr, nullptr },
        { "tint_color_property", reinterpret_cast<getter>(AcrylicBrush_get_TintColorProperty), nullptr, nullptr, nullptr },
        { "tint_opacity_property", reinterpret_cast<getter>(AcrylicBrush_get_TintOpacityProperty), nullptr, nullptr, nullptr },
        { "tint_transition_duration_property", reinterpret_cast<getter>(AcrylicBrush_get_TintTransitionDurationProperty), nullptr, nullptr, nullptr },
        { "tint_luminosity_opacity_property", reinterpret_cast<getter>(AcrylicBrush_get_TintLuminosityOpacityProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_AcrylicBrush_Static[] = {
        { }
    };

    static PyType_Slot type_slots_AcrylicBrush_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AcrylicBrush_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AcrylicBrush_Static) },
        { }
    };

    static PyType_Spec type_spec_AcrylicBrush_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.AcrylicBrush_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_AcrylicBrush_Static
    };

    // ----- ArcSegment class --------------------

    static PyObject* _new_ArcSegment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::ArcSegment instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ArcSegment(py::wrapper::Windows::UI::Xaml::Media::ArcSegment* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ArcSegment_get_SweepDirection(py::wrapper::Windows::UI::Xaml::Media::ArcSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.ArcSegment", L"SweepDirection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SweepDirection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ArcSegment_put_SweepDirection(py::wrapper::Windows::UI::Xaml::Media::ArcSegment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.ArcSegment", L"SweepDirection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::SweepDirection>(arg);

            self->obj.SweepDirection(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ArcSegment_get_Size(py::wrapper::Windows::UI::Xaml::Media::ArcSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.ArcSegment", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ArcSegment_put_Size(py::wrapper::Windows::UI::Xaml::Media::ArcSegment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.ArcSegment", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(arg);

            self->obj.Size(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ArcSegment_get_RotationAngle(py::wrapper::Windows::UI::Xaml::Media::ArcSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.ArcSegment", L"RotationAngle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RotationAngle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ArcSegment_put_RotationAngle(py::wrapper::Windows::UI::Xaml::Media::ArcSegment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.ArcSegment", L"RotationAngle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.RotationAngle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ArcSegment_get_Point(py::wrapper::Windows::UI::Xaml::Media::ArcSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.ArcSegment", L"Point");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Point());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ArcSegment_put_Point(py::wrapper::Windows::UI::Xaml::Media::ArcSegment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.ArcSegment", L"Point");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.Point(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ArcSegment_get_IsLargeArc(py::wrapper::Windows::UI::Xaml::Media::ArcSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.ArcSegment", L"IsLargeArc");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsLargeArc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ArcSegment_put_IsLargeArc(py::wrapper::Windows::UI::Xaml::Media::ArcSegment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.ArcSegment", L"IsLargeArc");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsLargeArc(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ArcSegment_get_IsLargeArcProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.ArcSegment", L"IsLargeArcProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::ArcSegment::IsLargeArcProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcSegment_get_PointProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.ArcSegment", L"PointProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::ArcSegment::PointProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcSegment_get_RotationAngleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.ArcSegment", L"RotationAngleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::ArcSegment::RotationAngleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcSegment_get_SizeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.ArcSegment", L"SizeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::ArcSegment::SizeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcSegment_get_SweepDirectionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.ArcSegment", L"SweepDirectionProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::ArcSegment::SweepDirectionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ArcSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::ArcSegment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ArcSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::ArcSegment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ArcSegment[] = {
        { "_assign_array_", _assign_array_ArcSegment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ArcSegment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ArcSegment[] = {
        { "sweep_direction", reinterpret_cast<getter>(ArcSegment_get_SweepDirection), reinterpret_cast<setter>(ArcSegment_put_SweepDirection), nullptr, nullptr },
        { "size", reinterpret_cast<getter>(ArcSegment_get_Size), reinterpret_cast<setter>(ArcSegment_put_Size), nullptr, nullptr },
        { "rotation_angle", reinterpret_cast<getter>(ArcSegment_get_RotationAngle), reinterpret_cast<setter>(ArcSegment_put_RotationAngle), nullptr, nullptr },
        { "point", reinterpret_cast<getter>(ArcSegment_get_Point), reinterpret_cast<setter>(ArcSegment_put_Point), nullptr, nullptr },
        { "is_large_arc", reinterpret_cast<getter>(ArcSegment_get_IsLargeArc), reinterpret_cast<setter>(ArcSegment_put_IsLargeArc), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ArcSegment[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ArcSegment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ArcSegment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ArcSegment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ArcSegment) },
        { }
    };

    static PyType_Spec type_spec_ArcSegment = {
        "winrt._winrt_windows_ui_xaml_media.ArcSegment",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::ArcSegment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ArcSegment};

    static PyGetSetDef getset_ArcSegment_Static[] = {
        { "is_large_arc_property", reinterpret_cast<getter>(ArcSegment_get_IsLargeArcProperty), nullptr, nullptr, nullptr },
        { "point_property", reinterpret_cast<getter>(ArcSegment_get_PointProperty), nullptr, nullptr, nullptr },
        { "rotation_angle_property", reinterpret_cast<getter>(ArcSegment_get_RotationAngleProperty), nullptr, nullptr, nullptr },
        { "size_property", reinterpret_cast<getter>(ArcSegment_get_SizeProperty), nullptr, nullptr, nullptr },
        { "sweep_direction_property", reinterpret_cast<getter>(ArcSegment_get_SweepDirectionProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ArcSegment_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ArcSegment_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ArcSegment_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ArcSegment_Static) },
        { }
    };

    static PyType_Spec type_spec_ArcSegment_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.ArcSegment_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ArcSegment_Static
    };

    // ----- BezierSegment class --------------------

    static PyObject* _new_BezierSegment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::BezierSegment instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BezierSegment(py::wrapper::Windows::UI::Xaml::Media::BezierSegment* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BezierSegment_get_Point3(py::wrapper::Windows::UI::Xaml::Media::BezierSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.BezierSegment", L"Point3");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Point3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BezierSegment_put_Point3(py::wrapper::Windows::UI::Xaml::Media::BezierSegment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.BezierSegment", L"Point3");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.Point3(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BezierSegment_get_Point2(py::wrapper::Windows::UI::Xaml::Media::BezierSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.BezierSegment", L"Point2");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Point2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BezierSegment_put_Point2(py::wrapper::Windows::UI::Xaml::Media::BezierSegment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.BezierSegment", L"Point2");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.Point2(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BezierSegment_get_Point1(py::wrapper::Windows::UI::Xaml::Media::BezierSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.BezierSegment", L"Point1");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Point1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BezierSegment_put_Point1(py::wrapper::Windows::UI::Xaml::Media::BezierSegment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.BezierSegment", L"Point1");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.Point1(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BezierSegment_get_Point1Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.BezierSegment", L"Point1Property");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::BezierSegment::Point1Property());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BezierSegment_get_Point2Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.BezierSegment", L"Point2Property");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::BezierSegment::Point2Property());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BezierSegment_get_Point3Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.BezierSegment", L"Point3Property");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::BezierSegment::Point3Property());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BezierSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::BezierSegment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BezierSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::BezierSegment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BezierSegment[] = {
        { "_assign_array_", _assign_array_BezierSegment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BezierSegment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BezierSegment[] = {
        { "point3", reinterpret_cast<getter>(BezierSegment_get_Point3), reinterpret_cast<setter>(BezierSegment_put_Point3), nullptr, nullptr },
        { "point2", reinterpret_cast<getter>(BezierSegment_get_Point2), reinterpret_cast<setter>(BezierSegment_put_Point2), nullptr, nullptr },
        { "point1", reinterpret_cast<getter>(BezierSegment_get_Point1), reinterpret_cast<setter>(BezierSegment_put_Point1), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BezierSegment[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BezierSegment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BezierSegment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BezierSegment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BezierSegment) },
        { }
    };

    static PyType_Spec type_spec_BezierSegment = {
        "winrt._winrt_windows_ui_xaml_media.BezierSegment",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::BezierSegment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BezierSegment};

    static PyGetSetDef getset_BezierSegment_Static[] = {
        { "point1_property", reinterpret_cast<getter>(BezierSegment_get_Point1Property), nullptr, nullptr, nullptr },
        { "point2_property", reinterpret_cast<getter>(BezierSegment_get_Point2Property), nullptr, nullptr, nullptr },
        { "point3_property", reinterpret_cast<getter>(BezierSegment_get_Point3Property), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_BezierSegment_Static[] = {
        { }
    };

    static PyType_Slot type_slots_BezierSegment_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BezierSegment_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BezierSegment_Static) },
        { }
    };

    static PyType_Spec type_spec_BezierSegment_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.BezierSegment_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BezierSegment_Static
    };

    // ----- BitmapCache class --------------------

    static PyObject* _new_BitmapCache(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::BitmapCache instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BitmapCache(py::wrapper::Windows::UI::Xaml::Media::BitmapCache* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_BitmapCache(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::BitmapCache>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BitmapCache(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::BitmapCache>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BitmapCache[] = {
        { "_assign_array_", _assign_array_BitmapCache, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BitmapCache), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BitmapCache[] = {
        { }
    };

    static PyType_Slot _type_slots_BitmapCache[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BitmapCache) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BitmapCache) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BitmapCache) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BitmapCache) },
        { }
    };

    static PyType_Spec type_spec_BitmapCache = {
        "winrt._winrt_windows_ui_xaml_media.BitmapCache",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::BitmapCache),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapCache};

    // ----- Brush class --------------------

    struct PyWinrtBrush;
    using BasePyWinrtBrush = winrt::Windows::UI::Xaml::Media::BrushT<PyWinrtBrush, py::IPywinrtObject>;

    struct PyWinrtBrush : py::py_obj_ref, BasePyWinrtBrush
    {

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtBrush* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_Brush(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Media::Brush>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Media::Brush>::type_name);
        return nullptr;
    }

    static void _dealloc_Brush(py::wrapper::Windows::UI::Xaml::Media::Brush* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Brush_PopulatePropertyInfo(py::wrapper::Windows::UI::Xaml::Media::Brush* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.Brush", L"PopulatePropertyInfo", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Composition::AnimationPropertyInfo>(args, 1);

                self->obj.try_as<winrt::Windows::UI::Xaml::Media::Brush>().PopulatePropertyInfo(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Brush_PopulatePropertyInfoOverride(PyObject* /*unused*/, PyObject* /* unused */) noexcept
    {
        PyErr_SetString(PyExc_RuntimeError, "cannot call protected method");
        return nullptr;
    }

    static PyObject* Brush_get_Transform(py::wrapper::Windows::UI::Xaml::Media::Brush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Brush", L"Transform");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Media::Brush>().Transform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Brush_put_Transform(py::wrapper::Windows::UI::Xaml::Media::Brush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Brush", L"Transform");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Transform>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Media::Brush>().Transform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Brush_get_RelativeTransform(py::wrapper::Windows::UI::Xaml::Media::Brush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Brush", L"RelativeTransform");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Media::Brush>().RelativeTransform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Brush_put_RelativeTransform(py::wrapper::Windows::UI::Xaml::Media::Brush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Brush", L"RelativeTransform");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Transform>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Media::Brush>().RelativeTransform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Brush_get_Opacity(py::wrapper::Windows::UI::Xaml::Media::Brush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Brush", L"Opacity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Media::Brush>().Opacity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Brush_put_Opacity(py::wrapper::Windows::UI::Xaml::Media::Brush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Brush", L"Opacity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Media::Brush>().Opacity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Brush_get_OpacityProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Brush", L"OpacityProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::Brush::OpacityProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Brush_get_RelativeTransformProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Brush", L"RelativeTransformProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::Brush::RelativeTransformProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Brush_get_TransformProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Brush", L"TransformProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::Brush::TransformProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Brush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Brush>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Brush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Brush>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Brush[] = {
        { "populate_property_info", reinterpret_cast<PyCFunction>(Brush_PopulatePropertyInfo), METH_VARARGS, nullptr },
        { "_populate_property_info_override", reinterpret_cast<PyCFunction>(Brush_PopulatePropertyInfoOverride), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_Brush, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Brush), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Brush[] = {
        { "transform", reinterpret_cast<getter>(Brush_get_Transform), reinterpret_cast<setter>(Brush_put_Transform), nullptr, nullptr },
        { "relative_transform", reinterpret_cast<getter>(Brush_get_RelativeTransform), reinterpret_cast<setter>(Brush_put_RelativeTransform), nullptr, nullptr },
        { "opacity", reinterpret_cast<getter>(Brush_get_Opacity), reinterpret_cast<setter>(Brush_put_Opacity), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Brush[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Brush) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Brush) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Brush) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Brush) },
        { }
    };

    static PyType_Spec type_spec_Brush = {
        "winrt._winrt_windows_ui_xaml_media.Brush",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Brush),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_Brush};

    static PyGetSetDef getset_Brush_Static[] = {
        { "opacity_property", reinterpret_cast<getter>(Brush_get_OpacityProperty), nullptr, nullptr, nullptr },
        { "relative_transform_property", reinterpret_cast<getter>(Brush_get_RelativeTransformProperty), nullptr, nullptr, nullptr },
        { "transform_property", reinterpret_cast<getter>(Brush_get_TransformProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Brush_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Brush_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Brush_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Brush_Static) },
        { }
    };

    static PyType_Spec type_spec_Brush_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.Brush_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_Brush_Static
    };

    // ----- BrushCollection class --------------------

    static PyObject* _new_BrushCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::BrushCollection instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BrushCollection(py::wrapper::Windows::UI::Xaml::Media::BrushCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BrushCollection_Append(py::wrapper::Windows::UI::Xaml::Media::BrushCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.BrushCollection", L"Append", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BrushCollection_Clear(py::wrapper::Windows::UI::Xaml::Media::BrushCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.BrushCollection", L"Clear", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BrushCollection_First(py::wrapper::Windows::UI::Xaml::Media::BrushCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.BrushCollection", L"First", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BrushCollection_GetAt(py::wrapper::Windows::UI::Xaml::Media::BrushCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.BrushCollection", L"GetAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BrushCollection_GetMany(py::wrapper::Windows::UI::Xaml::Media::BrushCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.BrushCollection", L"GetMany", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Media::Brush, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BrushCollection_GetView(py::wrapper::Windows::UI::Xaml::Media::BrushCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.BrushCollection", L"GetView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BrushCollection_IndexOf(py::wrapper::Windows::UI::Xaml::Media::BrushCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.BrushCollection", L"IndexOf", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(args, 0);
                uint32_t param1{};

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BrushCollection_InsertAt(py::wrapper::Windows::UI::Xaml::Media::BrushCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.BrushCollection", L"InsertAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BrushCollection_RemoveAt(py::wrapper::Windows::UI::Xaml::Media::BrushCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.BrushCollection", L"RemoveAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BrushCollection_RemoveAtEnd(py::wrapper::Windows::UI::Xaml::Media::BrushCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.BrushCollection", L"RemoveAtEnd", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BrushCollection_ReplaceAll(py::wrapper::Windows::UI::Xaml::Media::BrushCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.BrushCollection", L"ReplaceAll", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Media::Brush, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BrushCollection_SetAt(py::wrapper::Windows::UI::Xaml::Media::BrushCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.BrushCollection", L"SetAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BrushCollection_get_Size(py::wrapper::Windows::UI::Xaml::Media::BrushCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.BrushCollection", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BrushCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::BrushCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BrushCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::BrushCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_BrushCollection(py::wrapper::Windows::UI::Xaml::Media::BrushCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_BrushCollection(py::wrapper::Windows::UI::Xaml::Media::BrushCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_BrushCollection(py::wrapper::Windows::UI::Xaml::Media::BrushCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_BrushCollection(py::wrapper::Windows::UI::Xaml::Media::BrushCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_BrushCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(PyExc_TypeError, "indices must be integers, not '%s'", Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(slice, self->obj.Size(), &start, &stop, &step, &length) < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(PyExc_NotImplementedError, "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::UI::Xaml::Media::Brush> items(static_cast<uint32_t>(length), empty_instance<winrt::Windows::UI::Xaml::Media::Brush>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(PyExc_RuntimeError, "returned count %d did not match requested length %zd", count, length);
                return nullptr;
            }

            return convert(items);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_BrushCollection(py::wrapper::Windows::UI::Xaml::Media::BrushCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (!value)
            {
                self->obj.RemoveAt(static_cast<uint32_t>(i));
            }
            else
            {
                self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(value));
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_BrushCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(BrushCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(BrushCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(BrushCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(BrushCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(BrushCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(BrushCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(BrushCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(BrushCollection_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(BrushCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(BrushCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(BrushCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(BrushCollection_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BrushCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BrushCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BrushCollection[] = {
        { "size", reinterpret_cast<getter>(BrushCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BrushCollection[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BrushCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BrushCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BrushCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BrushCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_BrushCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_BrushCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_BrushCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_BrushCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_BrushCollection) },
        { }
    };

    static PyType_Spec type_spec_BrushCollection = {
        "winrt._winrt_windows_ui_xaml_media.BrushCollection",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::BrushCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BrushCollection};

    // ----- CacheMode class --------------------

    struct PyWinrtCacheMode;
    using BasePyWinrtCacheMode = winrt::Windows::UI::Xaml::Media::CacheModeT<PyWinrtCacheMode, py::IPywinrtObject>;

    struct PyWinrtCacheMode : py::py_obj_ref, BasePyWinrtCacheMode
    {

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtCacheMode* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_CacheMode(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Media::CacheMode>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Media::CacheMode>::type_name);
        return nullptr;
    }

    static void _dealloc_CacheMode(py::wrapper::Windows::UI::Xaml::Media::CacheMode* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_CacheMode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::CacheMode>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CacheMode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::CacheMode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CacheMode[] = {
        { "_assign_array_", _assign_array_CacheMode, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CacheMode), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CacheMode[] = {
        { }
    };

    static PyType_Slot _type_slots_CacheMode[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CacheMode) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CacheMode) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CacheMode) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CacheMode) },
        { }
    };

    static PyType_Spec type_spec_CacheMode = {
        "winrt._winrt_windows_ui_xaml_media.CacheMode",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::CacheMode),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_CacheMode};

    static PyGetSetDef getset_CacheMode_Static[] = {
        { }
    };

    static PyMethodDef methods_CacheMode_Static[] = {
        { }
    };

    static PyType_Slot type_slots_CacheMode_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CacheMode_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CacheMode_Static) },
        { }
    };

    static PyType_Spec type_spec_CacheMode_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.CacheMode_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_CacheMode_Static
    };

    // ----- CompositeTransform class --------------------

    static PyObject* _new_CompositeTransform(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::CompositeTransform instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CompositeTransform(py::wrapper::Windows::UI::Xaml::Media::CompositeTransform* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositeTransform_get_TranslateY(py::wrapper::Windows::UI::Xaml::Media::CompositeTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.CompositeTransform", L"TranslateY");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TranslateY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositeTransform_put_TranslateY(py::wrapper::Windows::UI::Xaml::Media::CompositeTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.CompositeTransform", L"TranslateY");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.TranslateY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositeTransform_get_TranslateX(py::wrapper::Windows::UI::Xaml::Media::CompositeTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.CompositeTransform", L"TranslateX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TranslateX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositeTransform_put_TranslateX(py::wrapper::Windows::UI::Xaml::Media::CompositeTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.CompositeTransform", L"TranslateX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.TranslateX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositeTransform_get_SkewY(py::wrapper::Windows::UI::Xaml::Media::CompositeTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.CompositeTransform", L"SkewY");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SkewY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositeTransform_put_SkewY(py::wrapper::Windows::UI::Xaml::Media::CompositeTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.CompositeTransform", L"SkewY");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.SkewY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositeTransform_get_SkewX(py::wrapper::Windows::UI::Xaml::Media::CompositeTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.CompositeTransform", L"SkewX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SkewX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositeTransform_put_SkewX(py::wrapper::Windows::UI::Xaml::Media::CompositeTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.CompositeTransform", L"SkewX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.SkewX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositeTransform_get_ScaleY(py::wrapper::Windows::UI::Xaml::Media::CompositeTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.CompositeTransform", L"ScaleY");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ScaleY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositeTransform_put_ScaleY(py::wrapper::Windows::UI::Xaml::Media::CompositeTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.CompositeTransform", L"ScaleY");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.ScaleY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositeTransform_get_ScaleX(py::wrapper::Windows::UI::Xaml::Media::CompositeTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.CompositeTransform", L"ScaleX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ScaleX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositeTransform_put_ScaleX(py::wrapper::Windows::UI::Xaml::Media::CompositeTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.CompositeTransform", L"ScaleX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.ScaleX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositeTransform_get_Rotation(py::wrapper::Windows::UI::Xaml::Media::CompositeTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.CompositeTransform", L"Rotation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Rotation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositeTransform_put_Rotation(py::wrapper::Windows::UI::Xaml::Media::CompositeTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.CompositeTransform", L"Rotation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.Rotation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositeTransform_get_CenterY(py::wrapper::Windows::UI::Xaml::Media::CompositeTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.CompositeTransform", L"CenterY");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CenterY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositeTransform_put_CenterY(py::wrapper::Windows::UI::Xaml::Media::CompositeTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.CompositeTransform", L"CenterY");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.CenterY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositeTransform_get_CenterX(py::wrapper::Windows::UI::Xaml::Media::CompositeTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.CompositeTransform", L"CenterX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CenterX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositeTransform_put_CenterX(py::wrapper::Windows::UI::Xaml::Media::CompositeTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.CompositeTransform", L"CenterX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.CenterX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositeTransform_get_CenterXProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.CompositeTransform", L"CenterXProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::CompositeTransform::CenterXProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositeTransform_get_CenterYProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.CompositeTransform", L"CenterYProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::CompositeTransform::CenterYProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositeTransform_get_RotationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.CompositeTransform", L"RotationProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::CompositeTransform::RotationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositeTransform_get_ScaleXProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.CompositeTransform", L"ScaleXProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::CompositeTransform::ScaleXProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositeTransform_get_ScaleYProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.CompositeTransform", L"ScaleYProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::CompositeTransform::ScaleYProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositeTransform_get_SkewXProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.CompositeTransform", L"SkewXProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::CompositeTransform::SkewXProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositeTransform_get_SkewYProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.CompositeTransform", L"SkewYProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::CompositeTransform::SkewYProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositeTransform_get_TranslateXProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.CompositeTransform", L"TranslateXProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::CompositeTransform::TranslateXProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositeTransform_get_TranslateYProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.CompositeTransform", L"TranslateYProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::CompositeTransform::TranslateYProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CompositeTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::CompositeTransform>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositeTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::CompositeTransform>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositeTransform[] = {
        { "_assign_array_", _assign_array_CompositeTransform, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositeTransform), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositeTransform[] = {
        { "translate_y", reinterpret_cast<getter>(CompositeTransform_get_TranslateY), reinterpret_cast<setter>(CompositeTransform_put_TranslateY), nullptr, nullptr },
        { "translate_x", reinterpret_cast<getter>(CompositeTransform_get_TranslateX), reinterpret_cast<setter>(CompositeTransform_put_TranslateX), nullptr, nullptr },
        { "skew_y", reinterpret_cast<getter>(CompositeTransform_get_SkewY), reinterpret_cast<setter>(CompositeTransform_put_SkewY), nullptr, nullptr },
        { "skew_x", reinterpret_cast<getter>(CompositeTransform_get_SkewX), reinterpret_cast<setter>(CompositeTransform_put_SkewX), nullptr, nullptr },
        { "scale_y", reinterpret_cast<getter>(CompositeTransform_get_ScaleY), reinterpret_cast<setter>(CompositeTransform_put_ScaleY), nullptr, nullptr },
        { "scale_x", reinterpret_cast<getter>(CompositeTransform_get_ScaleX), reinterpret_cast<setter>(CompositeTransform_put_ScaleX), nullptr, nullptr },
        { "rotation", reinterpret_cast<getter>(CompositeTransform_get_Rotation), reinterpret_cast<setter>(CompositeTransform_put_Rotation), nullptr, nullptr },
        { "center_y", reinterpret_cast<getter>(CompositeTransform_get_CenterY), reinterpret_cast<setter>(CompositeTransform_put_CenterY), nullptr, nullptr },
        { "center_x", reinterpret_cast<getter>(CompositeTransform_get_CenterX), reinterpret_cast<setter>(CompositeTransform_put_CenterX), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositeTransform[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositeTransform) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositeTransform) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositeTransform) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositeTransform) },
        { }
    };

    static PyType_Spec type_spec_CompositeTransform = {
        "winrt._winrt_windows_ui_xaml_media.CompositeTransform",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::CompositeTransform),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositeTransform};

    static PyGetSetDef getset_CompositeTransform_Static[] = {
        { "center_x_property", reinterpret_cast<getter>(CompositeTransform_get_CenterXProperty), nullptr, nullptr, nullptr },
        { "center_y_property", reinterpret_cast<getter>(CompositeTransform_get_CenterYProperty), nullptr, nullptr, nullptr },
        { "rotation_property", reinterpret_cast<getter>(CompositeTransform_get_RotationProperty), nullptr, nullptr, nullptr },
        { "scale_x_property", reinterpret_cast<getter>(CompositeTransform_get_ScaleXProperty), nullptr, nullptr, nullptr },
        { "scale_y_property", reinterpret_cast<getter>(CompositeTransform_get_ScaleYProperty), nullptr, nullptr, nullptr },
        { "skew_x_property", reinterpret_cast<getter>(CompositeTransform_get_SkewXProperty), nullptr, nullptr, nullptr },
        { "skew_y_property", reinterpret_cast<getter>(CompositeTransform_get_SkewYProperty), nullptr, nullptr, nullptr },
        { "translate_x_property", reinterpret_cast<getter>(CompositeTransform_get_TranslateXProperty), nullptr, nullptr, nullptr },
        { "translate_y_property", reinterpret_cast<getter>(CompositeTransform_get_TranslateYProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_CompositeTransform_Static[] = {
        { }
    };

    static PyType_Slot type_slots_CompositeTransform_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CompositeTransform_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CompositeTransform_Static) },
        { }
    };

    static PyType_Spec type_spec_CompositeTransform_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.CompositeTransform_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CompositeTransform_Static
    };

    // ----- CompositionTarget class --------------------

    static PyObject* _new_CompositionTarget(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Media::CompositionTarget>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Media::CompositionTarget>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionTarget(py::wrapper::Windows::UI::Xaml::Media::CompositionTarget* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionTarget_add_Rendered(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Media.CompositionTarget", L"Rendered");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::UI::Xaml::Media::RenderedEventArgs>>(arg);

            return py::convert(winrt::Windows::UI::Xaml::Media::CompositionTarget::Rendered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositionTarget_remove_Rendered(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Media.CompositionTarget", L"Rendered");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::UI::Xaml::Media::CompositionTarget::Rendered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositionTarget_add_Rendering(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Media.CompositionTarget", L"Rendering");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::UI::Xaml::Media::CompositionTarget::Rendering(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositionTarget_remove_Rendering(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Media.CompositionTarget", L"Rendering");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::UI::Xaml::Media::CompositionTarget::Rendering(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositionTarget_add_SurfaceContentsLost(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Media.CompositionTarget", L"SurfaceContentsLost");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::UI::Xaml::Media::CompositionTarget::SurfaceContentsLost(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositionTarget_remove_SurfaceContentsLost(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Media.CompositionTarget", L"SurfaceContentsLost");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::UI::Xaml::Media::CompositionTarget::SurfaceContentsLost(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CompositionTarget(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::CompositionTarget>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionTarget(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::CompositionTarget>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionTarget[] = {
        { "_assign_array_", _assign_array_CompositionTarget, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionTarget), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionTarget[] = {
        { }
    };

    static PyType_Slot _type_slots_CompositionTarget[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionTarget) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionTarget) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionTarget) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionTarget) },
        { }
    };

    static PyType_Spec type_spec_CompositionTarget = {
        "winrt._winrt_windows_ui_xaml_media.CompositionTarget",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::CompositionTarget),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionTarget};

    static PyGetSetDef getset_CompositionTarget_Static[] = {
        { }
    };

    static PyMethodDef methods_CompositionTarget_Static[] = {
        { "add_rendered", reinterpret_cast<PyCFunction>(CompositionTarget_add_Rendered), METH_O, nullptr },
        { "remove_rendered", reinterpret_cast<PyCFunction>(CompositionTarget_remove_Rendered), METH_O, nullptr },
        { "add_rendering", reinterpret_cast<PyCFunction>(CompositionTarget_add_Rendering), METH_O, nullptr },
        { "remove_rendering", reinterpret_cast<PyCFunction>(CompositionTarget_remove_Rendering), METH_O, nullptr },
        { "add_surface_contents_lost", reinterpret_cast<PyCFunction>(CompositionTarget_add_SurfaceContentsLost), METH_O, nullptr },
        { "remove_surface_contents_lost", reinterpret_cast<PyCFunction>(CompositionTarget_remove_SurfaceContentsLost), METH_O, nullptr },
        { }
    };

    static PyType_Slot type_slots_CompositionTarget_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CompositionTarget_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CompositionTarget_Static) },
        { }
    };

    static PyType_Spec type_spec_CompositionTarget_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.CompositionTarget_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CompositionTarget_Static
    };

    // ----- DoubleCollection class --------------------

    static PyObject* _new_DoubleCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::DoubleCollection instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DoubleCollection(py::wrapper::Windows::UI::Xaml::Media::DoubleCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DoubleCollection_Append(py::wrapper::Windows::UI::Xaml::Media::DoubleCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.DoubleCollection", L"Append", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DoubleCollection_Clear(py::wrapper::Windows::UI::Xaml::Media::DoubleCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.DoubleCollection", L"Clear", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DoubleCollection_First(py::wrapper::Windows::UI::Xaml::Media::DoubleCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.DoubleCollection", L"First", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DoubleCollection_GetAt(py::wrapper::Windows::UI::Xaml::Media::DoubleCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.DoubleCollection", L"GetAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DoubleCollection_GetMany(py::wrapper::Windows::UI::Xaml::Media::DoubleCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.DoubleCollection", L"GetMany", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<double, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DoubleCollection_GetView(py::wrapper::Windows::UI::Xaml::Media::DoubleCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.DoubleCollection", L"GetView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DoubleCollection_IndexOf(py::wrapper::Windows::UI::Xaml::Media::DoubleCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.DoubleCollection", L"IndexOf", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                uint32_t param1{};

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DoubleCollection_InsertAt(py::wrapper::Windows::UI::Xaml::Media::DoubleCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.DoubleCollection", L"InsertAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DoubleCollection_RemoveAt(py::wrapper::Windows::UI::Xaml::Media::DoubleCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.DoubleCollection", L"RemoveAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DoubleCollection_RemoveAtEnd(py::wrapper::Windows::UI::Xaml::Media::DoubleCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.DoubleCollection", L"RemoveAtEnd", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DoubleCollection_ReplaceAll(py::wrapper::Windows::UI::Xaml::Media::DoubleCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.DoubleCollection", L"ReplaceAll", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<double, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DoubleCollection_SetAt(py::wrapper::Windows::UI::Xaml::Media::DoubleCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.DoubleCollection", L"SetAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DoubleCollection_get_Size(py::wrapper::Windows::UI::Xaml::Media::DoubleCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.DoubleCollection", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DoubleCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::DoubleCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DoubleCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::DoubleCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_DoubleCollection(py::wrapper::Windows::UI::Xaml::Media::DoubleCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_DoubleCollection(py::wrapper::Windows::UI::Xaml::Media::DoubleCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_DoubleCollection(py::wrapper::Windows::UI::Xaml::Media::DoubleCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_DoubleCollection(py::wrapper::Windows::UI::Xaml::Media::DoubleCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_DoubleCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(PyExc_TypeError, "indices must be integers, not '%s'", Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(slice, self->obj.Size(), &start, &stop, &step, &length) < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(PyExc_NotImplementedError, "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<double> items(static_cast<uint32_t>(length), empty_instance<double>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(PyExc_RuntimeError, "returned count %d did not match requested length %zd", count, length);
                return nullptr;
            }

            return convert(items);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_DoubleCollection(py::wrapper::Windows::UI::Xaml::Media::DoubleCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (!value)
            {
                self->obj.RemoveAt(static_cast<uint32_t>(i));
            }
            else
            {
                self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<double>(value));
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_DoubleCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(DoubleCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(DoubleCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(DoubleCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(DoubleCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(DoubleCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(DoubleCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(DoubleCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(DoubleCollection_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(DoubleCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(DoubleCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(DoubleCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(DoubleCollection_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DoubleCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DoubleCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DoubleCollection[] = {
        { "size", reinterpret_cast<getter>(DoubleCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DoubleCollection[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DoubleCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DoubleCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DoubleCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DoubleCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_DoubleCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_DoubleCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_DoubleCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_DoubleCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_DoubleCollection) },
        { }
    };

    static PyType_Spec type_spec_DoubleCollection = {
        "winrt._winrt_windows_ui_xaml_media.DoubleCollection",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::DoubleCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DoubleCollection};

    // ----- EllipseGeometry class --------------------

    static PyObject* _new_EllipseGeometry(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::EllipseGeometry instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EllipseGeometry(py::wrapper::Windows::UI::Xaml::Media::EllipseGeometry* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EllipseGeometry_get_RadiusY(py::wrapper::Windows::UI::Xaml::Media::EllipseGeometry* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.EllipseGeometry", L"RadiusY");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RadiusY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EllipseGeometry_put_RadiusY(py::wrapper::Windows::UI::Xaml::Media::EllipseGeometry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.EllipseGeometry", L"RadiusY");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.RadiusY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EllipseGeometry_get_RadiusX(py::wrapper::Windows::UI::Xaml::Media::EllipseGeometry* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.EllipseGeometry", L"RadiusX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RadiusX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EllipseGeometry_put_RadiusX(py::wrapper::Windows::UI::Xaml::Media::EllipseGeometry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.EllipseGeometry", L"RadiusX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.RadiusX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EllipseGeometry_get_Center(py::wrapper::Windows::UI::Xaml::Media::EllipseGeometry* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.EllipseGeometry", L"Center");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Center());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EllipseGeometry_put_Center(py::wrapper::Windows::UI::Xaml::Media::EllipseGeometry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.EllipseGeometry", L"Center");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.Center(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EllipseGeometry_get_CenterProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.EllipseGeometry", L"CenterProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::EllipseGeometry::CenterProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EllipseGeometry_get_RadiusXProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.EllipseGeometry", L"RadiusXProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::EllipseGeometry::RadiusXProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EllipseGeometry_get_RadiusYProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.EllipseGeometry", L"RadiusYProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::EllipseGeometry::RadiusYProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EllipseGeometry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::EllipseGeometry>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EllipseGeometry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::EllipseGeometry>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EllipseGeometry[] = {
        { "_assign_array_", _assign_array_EllipseGeometry, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EllipseGeometry), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EllipseGeometry[] = {
        { "radius_y", reinterpret_cast<getter>(EllipseGeometry_get_RadiusY), reinterpret_cast<setter>(EllipseGeometry_put_RadiusY), nullptr, nullptr },
        { "radius_x", reinterpret_cast<getter>(EllipseGeometry_get_RadiusX), reinterpret_cast<setter>(EllipseGeometry_put_RadiusX), nullptr, nullptr },
        { "center", reinterpret_cast<getter>(EllipseGeometry_get_Center), reinterpret_cast<setter>(EllipseGeometry_put_Center), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EllipseGeometry[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_EllipseGeometry) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EllipseGeometry) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EllipseGeometry) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EllipseGeometry) },
        { }
    };

    static PyType_Spec type_spec_EllipseGeometry = {
        "winrt._winrt_windows_ui_xaml_media.EllipseGeometry",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::EllipseGeometry),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EllipseGeometry};

    static PyGetSetDef getset_EllipseGeometry_Static[] = {
        { "center_property", reinterpret_cast<getter>(EllipseGeometry_get_CenterProperty), nullptr, nullptr, nullptr },
        { "radius_x_property", reinterpret_cast<getter>(EllipseGeometry_get_RadiusXProperty), nullptr, nullptr, nullptr },
        { "radius_y_property", reinterpret_cast<getter>(EllipseGeometry_get_RadiusYProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_EllipseGeometry_Static[] = {
        { }
    };

    static PyType_Slot type_slots_EllipseGeometry_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_EllipseGeometry_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_EllipseGeometry_Static) },
        { }
    };

    static PyType_Spec type_spec_EllipseGeometry_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.EllipseGeometry_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_EllipseGeometry_Static
    };

    // ----- FontFamily class --------------------

    struct PyWinrtFontFamily;
    using BasePyWinrtFontFamily = winrt::Windows::UI::Xaml::Media::FontFamilyT<PyWinrtFontFamily, py::IPywinrtObject>;

    struct PyWinrtFontFamily : py::py_obj_ref, BasePyWinrtFontFamily
    {
        PyWinrtFontFamily(PyObject* py_obj, winrt::hstring familyName) : py::py_obj_ref(py_obj), BasePyWinrtFontFamily(familyName) {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtFontFamily* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_FontFamily(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Media::FontFamily>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Media::FontFamily*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Media::FontFamily*>(self.get())->obj = winrt::make<PyWinrtFontFamily>(self.get(), param0);

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Media::FontFamily instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FontFamily(py::wrapper::Windows::UI::Xaml::Media::FontFamily* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FontFamily_get_Source(py::wrapper::Windows::UI::Xaml::Media::FontFamily* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.FontFamily", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Media::FontFamily>().Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FontFamily_get_XamlAutoFontFamily(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.FontFamily", L"XamlAutoFontFamily");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::FontFamily::XamlAutoFontFamily());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FontFamily(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::FontFamily>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FontFamily(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::FontFamily>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FontFamily[] = {
        { "_assign_array_", _assign_array_FontFamily, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FontFamily), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FontFamily[] = {
        { "source", reinterpret_cast<getter>(FontFamily_get_Source), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FontFamily[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FontFamily) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FontFamily) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FontFamily) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FontFamily) },
        { }
    };

    static PyType_Spec type_spec_FontFamily = {
        "winrt._winrt_windows_ui_xaml_media.FontFamily",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::FontFamily),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_FontFamily};

    static PyGetSetDef getset_FontFamily_Static[] = {
        { "xaml_auto_font_family", reinterpret_cast<getter>(FontFamily_get_XamlAutoFontFamily), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_FontFamily_Static[] = {
        { }
    };

    static PyType_Slot type_slots_FontFamily_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FontFamily_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_FontFamily_Static) },
        { }
    };

    static PyType_Spec type_spec_FontFamily_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.FontFamily_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_FontFamily_Static
    };

    // ----- GeneralTransform class --------------------

    struct PyWinrtGeneralTransform;
    using BasePyWinrtGeneralTransform = winrt::Windows::UI::Xaml::Media::GeneralTransformT<PyWinrtGeneralTransform, py::IPywinrtObject>;

    struct PyWinrtGeneralTransform : py::py_obj_ref, BasePyWinrtGeneralTransform
    {

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtGeneralTransform* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_GeneralTransform(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Media::GeneralTransform>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Media::GeneralTransform>::type_name);
        return nullptr;
    }

    static void _dealloc_GeneralTransform(py::wrapper::Windows::UI::Xaml::Media::GeneralTransform* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GeneralTransform_TransformBounds(py::wrapper::Windows::UI::Xaml::Media::GeneralTransform* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.GeneralTransform", L"TransformBounds", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Media::GeneralTransform>().TransformBounds(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeneralTransform_TransformBoundsCore(PyObject* /*unused*/, PyObject* /* unused */) noexcept
    {
        PyErr_SetString(PyExc_RuntimeError, "cannot call protected method");
        return nullptr;
    }

    static PyObject* GeneralTransform_TransformPoint(py::wrapper::Windows::UI::Xaml::Media::GeneralTransform* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.GeneralTransform", L"TransformPoint", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Media::GeneralTransform>().TransformPoint(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeneralTransform_TryTransform(py::wrapper::Windows::UI::Xaml::Media::GeneralTransform* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.GeneralTransform", L"TryTransform", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                winrt::Windows::Foundation::Point param1{};

                auto return_value = self->obj.try_as<winrt::Windows::UI::Xaml::Media::GeneralTransform>().TryTransform(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeneralTransform_TryTransformCore(PyObject* /*unused*/, PyObject* /* unused */) noexcept
    {
        PyErr_SetString(PyExc_RuntimeError, "cannot call protected method");
        return nullptr;
    }

    static PyObject* GeneralTransform_get_Inverse(py::wrapper::Windows::UI::Xaml::Media::GeneralTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.GeneralTransform", L"Inverse");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Media::GeneralTransform>().Inverse());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GeneralTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::GeneralTransform>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GeneralTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::GeneralTransform>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GeneralTransform[] = {
        { "transform_bounds", reinterpret_cast<PyCFunction>(GeneralTransform_TransformBounds), METH_VARARGS, nullptr },
        { "_transform_bounds_core", reinterpret_cast<PyCFunction>(GeneralTransform_TransformBoundsCore), METH_VARARGS, nullptr },
        { "transform_point", reinterpret_cast<PyCFunction>(GeneralTransform_TransformPoint), METH_VARARGS, nullptr },
        { "try_transform", reinterpret_cast<PyCFunction>(GeneralTransform_TryTransform), METH_VARARGS, nullptr },
        { "_try_transform_core", reinterpret_cast<PyCFunction>(GeneralTransform_TryTransformCore), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_GeneralTransform, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GeneralTransform), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GeneralTransform[] = {
        { "inverse", reinterpret_cast<getter>(GeneralTransform_get_Inverse), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GeneralTransform[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GeneralTransform) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GeneralTransform) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GeneralTransform) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GeneralTransform) },
        { }
    };

    static PyType_Spec type_spec_GeneralTransform = {
        "winrt._winrt_windows_ui_xaml_media.GeneralTransform",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::GeneralTransform),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_GeneralTransform};

    static PyGetSetDef getset_GeneralTransform_Static[] = {
        { }
    };

    static PyMethodDef methods_GeneralTransform_Static[] = {
        { }
    };

    static PyType_Slot type_slots_GeneralTransform_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GeneralTransform_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GeneralTransform_Static) },
        { }
    };

    static PyType_Spec type_spec_GeneralTransform_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.GeneralTransform_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_GeneralTransform_Static
    };

    // ----- Geometry class --------------------

    static PyObject* _new_Geometry(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Media::Geometry>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Media::Geometry>::type_name);
        return nullptr;
    }

    static void _dealloc_Geometry(py::wrapper::Windows::UI::Xaml::Media::Geometry* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Geometry_get_Transform(py::wrapper::Windows::UI::Xaml::Media::Geometry* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Geometry", L"Transform");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Media::Geometry>().Transform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Geometry_put_Transform(py::wrapper::Windows::UI::Xaml::Media::Geometry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Geometry", L"Transform");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Transform>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Media::Geometry>().Transform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Geometry_get_Bounds(py::wrapper::Windows::UI::Xaml::Media::Geometry* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Geometry", L"Bounds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Media::Geometry>().Bounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geometry_get_Empty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Geometry", L"Empty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::Geometry::Empty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geometry_get_StandardFlatteningTolerance(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Geometry", L"StandardFlatteningTolerance");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::Geometry::StandardFlatteningTolerance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geometry_get_TransformProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Geometry", L"TransformProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::Geometry::TransformProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Geometry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Geometry>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Geometry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Geometry>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Geometry[] = {
        { "_assign_array_", _assign_array_Geometry, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Geometry), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Geometry[] = {
        { "transform", reinterpret_cast<getter>(Geometry_get_Transform), reinterpret_cast<setter>(Geometry_put_Transform), nullptr, nullptr },
        { "bounds", reinterpret_cast<getter>(Geometry_get_Bounds), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Geometry[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Geometry) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Geometry) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Geometry) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Geometry) },
        { }
    };

    static PyType_Spec type_spec_Geometry = {
        "winrt._winrt_windows_ui_xaml_media.Geometry",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Geometry),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_Geometry};

    static PyGetSetDef getset_Geometry_Static[] = {
        { "empty", reinterpret_cast<getter>(Geometry_get_Empty), nullptr, nullptr, nullptr },
        { "standard_flattening_tolerance", reinterpret_cast<getter>(Geometry_get_StandardFlatteningTolerance), nullptr, nullptr, nullptr },
        { "transform_property", reinterpret_cast<getter>(Geometry_get_TransformProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Geometry_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Geometry_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Geometry_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Geometry_Static) },
        { }
    };

    static PyType_Spec type_spec_Geometry_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.Geometry_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_Geometry_Static
    };

    // ----- GeometryCollection class --------------------

    static PyObject* _new_GeometryCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::GeometryCollection instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GeometryCollection(py::wrapper::Windows::UI::Xaml::Media::GeometryCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GeometryCollection_Append(py::wrapper::Windows::UI::Xaml::Media::GeometryCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.GeometryCollection", L"Append", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Geometry>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeometryCollection_Clear(py::wrapper::Windows::UI::Xaml::Media::GeometryCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.GeometryCollection", L"Clear", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeometryCollection_First(py::wrapper::Windows::UI::Xaml::Media::GeometryCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.GeometryCollection", L"First", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeometryCollection_GetAt(py::wrapper::Windows::UI::Xaml::Media::GeometryCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.GeometryCollection", L"GetAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeometryCollection_GetMany(py::wrapper::Windows::UI::Xaml::Media::GeometryCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.GeometryCollection", L"GetMany", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Media::Geometry, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeometryCollection_GetView(py::wrapper::Windows::UI::Xaml::Media::GeometryCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.GeometryCollection", L"GetView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeometryCollection_IndexOf(py::wrapper::Windows::UI::Xaml::Media::GeometryCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.GeometryCollection", L"IndexOf", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Geometry>(args, 0);
                uint32_t param1{};

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeometryCollection_InsertAt(py::wrapper::Windows::UI::Xaml::Media::GeometryCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.GeometryCollection", L"InsertAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Media::Geometry>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeometryCollection_RemoveAt(py::wrapper::Windows::UI::Xaml::Media::GeometryCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.GeometryCollection", L"RemoveAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeometryCollection_RemoveAtEnd(py::wrapper::Windows::UI::Xaml::Media::GeometryCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.GeometryCollection", L"RemoveAtEnd", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeometryCollection_ReplaceAll(py::wrapper::Windows::UI::Xaml::Media::GeometryCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.GeometryCollection", L"ReplaceAll", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Media::Geometry, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeometryCollection_SetAt(py::wrapper::Windows::UI::Xaml::Media::GeometryCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.GeometryCollection", L"SetAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Media::Geometry>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeometryCollection_get_Size(py::wrapper::Windows::UI::Xaml::Media::GeometryCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.GeometryCollection", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GeometryCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::GeometryCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GeometryCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::GeometryCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_GeometryCollection(py::wrapper::Windows::UI::Xaml::Media::GeometryCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_GeometryCollection(py::wrapper::Windows::UI::Xaml::Media::GeometryCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_GeometryCollection(py::wrapper::Windows::UI::Xaml::Media::GeometryCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_GeometryCollection(py::wrapper::Windows::UI::Xaml::Media::GeometryCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_GeometryCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(PyExc_TypeError, "indices must be integers, not '%s'", Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(slice, self->obj.Size(), &start, &stop, &step, &length) < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(PyExc_NotImplementedError, "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::UI::Xaml::Media::Geometry> items(static_cast<uint32_t>(length), empty_instance<winrt::Windows::UI::Xaml::Media::Geometry>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(PyExc_RuntimeError, "returned count %d did not match requested length %zd", count, length);
                return nullptr;
            }

            return convert(items);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_GeometryCollection(py::wrapper::Windows::UI::Xaml::Media::GeometryCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (!value)
            {
                self->obj.RemoveAt(static_cast<uint32_t>(i));
            }
            else
            {
                self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::UI::Xaml::Media::Geometry>(value));
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_GeometryCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(GeometryCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(GeometryCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(GeometryCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(GeometryCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(GeometryCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(GeometryCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(GeometryCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(GeometryCollection_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(GeometryCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(GeometryCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(GeometryCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(GeometryCollection_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_GeometryCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GeometryCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GeometryCollection[] = {
        { "size", reinterpret_cast<getter>(GeometryCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GeometryCollection[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GeometryCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GeometryCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GeometryCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GeometryCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_GeometryCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_GeometryCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_GeometryCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_GeometryCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_GeometryCollection) },
        { }
    };

    static PyType_Spec type_spec_GeometryCollection = {
        "winrt._winrt_windows_ui_xaml_media.GeometryCollection",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::GeometryCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GeometryCollection};

    // ----- GeometryGroup class --------------------

    static PyObject* _new_GeometryGroup(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::GeometryGroup instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GeometryGroup(py::wrapper::Windows::UI::Xaml::Media::GeometryGroup* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GeometryGroup_get_FillRule(py::wrapper::Windows::UI::Xaml::Media::GeometryGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.GeometryGroup", L"FillRule");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FillRule());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GeometryGroup_put_FillRule(py::wrapper::Windows::UI::Xaml::Media::GeometryGroup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.GeometryGroup", L"FillRule");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::FillRule>(arg);

            self->obj.FillRule(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GeometryGroup_get_Children(py::wrapper::Windows::UI::Xaml::Media::GeometryGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.GeometryGroup", L"Children");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Children());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GeometryGroup_put_Children(py::wrapper::Windows::UI::Xaml::Media::GeometryGroup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.GeometryGroup", L"Children");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::GeometryCollection>(arg);

            self->obj.Children(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GeometryGroup_get_ChildrenProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.GeometryGroup", L"ChildrenProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::GeometryGroup::ChildrenProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GeometryGroup_get_FillRuleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.GeometryGroup", L"FillRuleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::GeometryGroup::FillRuleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GeometryGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::GeometryGroup>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GeometryGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::GeometryGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GeometryGroup[] = {
        { "_assign_array_", _assign_array_GeometryGroup, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GeometryGroup), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GeometryGroup[] = {
        { "fill_rule", reinterpret_cast<getter>(GeometryGroup_get_FillRule), reinterpret_cast<setter>(GeometryGroup_put_FillRule), nullptr, nullptr },
        { "children", reinterpret_cast<getter>(GeometryGroup_get_Children), reinterpret_cast<setter>(GeometryGroup_put_Children), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GeometryGroup[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GeometryGroup) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GeometryGroup) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GeometryGroup) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GeometryGroup) },
        { }
    };

    static PyType_Spec type_spec_GeometryGroup = {
        "winrt._winrt_windows_ui_xaml_media.GeometryGroup",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::GeometryGroup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GeometryGroup};

    static PyGetSetDef getset_GeometryGroup_Static[] = {
        { "children_property", reinterpret_cast<getter>(GeometryGroup_get_ChildrenProperty), nullptr, nullptr, nullptr },
        { "fill_rule_property", reinterpret_cast<getter>(GeometryGroup_get_FillRuleProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_GeometryGroup_Static[] = {
        { }
    };

    static PyType_Slot type_slots_GeometryGroup_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GeometryGroup_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GeometryGroup_Static) },
        { }
    };

    static PyType_Spec type_spec_GeometryGroup_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.GeometryGroup_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GeometryGroup_Static
    };

    // ----- GradientBrush class --------------------

    struct PyWinrtGradientBrush;
    using BasePyWinrtGradientBrush = winrt::Windows::UI::Xaml::Media::GradientBrushT<PyWinrtGradientBrush, py::IPywinrtObject>;

    struct PyWinrtGradientBrush : py::py_obj_ref, BasePyWinrtGradientBrush
    {

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtGradientBrush* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_GradientBrush(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Media::GradientBrush>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Media::GradientBrush>::type_name);
        return nullptr;
    }

    static void _dealloc_GradientBrush(py::wrapper::Windows::UI::Xaml::Media::GradientBrush* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GradientBrush_get_SpreadMethod(py::wrapper::Windows::UI::Xaml::Media::GradientBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.GradientBrush", L"SpreadMethod");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Media::GradientBrush>().SpreadMethod());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GradientBrush_put_SpreadMethod(py::wrapper::Windows::UI::Xaml::Media::GradientBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.GradientBrush", L"SpreadMethod");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::GradientSpreadMethod>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Media::GradientBrush>().SpreadMethod(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GradientBrush_get_MappingMode(py::wrapper::Windows::UI::Xaml::Media::GradientBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.GradientBrush", L"MappingMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Media::GradientBrush>().MappingMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GradientBrush_put_MappingMode(py::wrapper::Windows::UI::Xaml::Media::GradientBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.GradientBrush", L"MappingMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::BrushMappingMode>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Media::GradientBrush>().MappingMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GradientBrush_get_GradientStops(py::wrapper::Windows::UI::Xaml::Media::GradientBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.GradientBrush", L"GradientStops");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Media::GradientBrush>().GradientStops());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GradientBrush_put_GradientStops(py::wrapper::Windows::UI::Xaml::Media::GradientBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.GradientBrush", L"GradientStops");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::GradientStopCollection>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Media::GradientBrush>().GradientStops(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GradientBrush_get_ColorInterpolationMode(py::wrapper::Windows::UI::Xaml::Media::GradientBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.GradientBrush", L"ColorInterpolationMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Media::GradientBrush>().ColorInterpolationMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GradientBrush_put_ColorInterpolationMode(py::wrapper::Windows::UI::Xaml::Media::GradientBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.GradientBrush", L"ColorInterpolationMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::ColorInterpolationMode>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Media::GradientBrush>().ColorInterpolationMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GradientBrush_get_ColorInterpolationModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.GradientBrush", L"ColorInterpolationModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::GradientBrush::ColorInterpolationModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GradientBrush_get_GradientStopsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.GradientBrush", L"GradientStopsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::GradientBrush::GradientStopsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GradientBrush_get_MappingModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.GradientBrush", L"MappingModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::GradientBrush::MappingModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GradientBrush_get_SpreadMethodProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.GradientBrush", L"SpreadMethodProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::GradientBrush::SpreadMethodProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GradientBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::GradientBrush>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GradientBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::GradientBrush>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GradientBrush[] = {
        { "_assign_array_", _assign_array_GradientBrush, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GradientBrush), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GradientBrush[] = {
        { "spread_method", reinterpret_cast<getter>(GradientBrush_get_SpreadMethod), reinterpret_cast<setter>(GradientBrush_put_SpreadMethod), nullptr, nullptr },
        { "mapping_mode", reinterpret_cast<getter>(GradientBrush_get_MappingMode), reinterpret_cast<setter>(GradientBrush_put_MappingMode), nullptr, nullptr },
        { "gradient_stops", reinterpret_cast<getter>(GradientBrush_get_GradientStops), reinterpret_cast<setter>(GradientBrush_put_GradientStops), nullptr, nullptr },
        { "color_interpolation_mode", reinterpret_cast<getter>(GradientBrush_get_ColorInterpolationMode), reinterpret_cast<setter>(GradientBrush_put_ColorInterpolationMode), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GradientBrush[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GradientBrush) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GradientBrush) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GradientBrush) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GradientBrush) },
        { }
    };

    static PyType_Spec type_spec_GradientBrush = {
        "winrt._winrt_windows_ui_xaml_media.GradientBrush",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::GradientBrush),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_GradientBrush};

    static PyGetSetDef getset_GradientBrush_Static[] = {
        { "color_interpolation_mode_property", reinterpret_cast<getter>(GradientBrush_get_ColorInterpolationModeProperty), nullptr, nullptr, nullptr },
        { "gradient_stops_property", reinterpret_cast<getter>(GradientBrush_get_GradientStopsProperty), nullptr, nullptr, nullptr },
        { "mapping_mode_property", reinterpret_cast<getter>(GradientBrush_get_MappingModeProperty), nullptr, nullptr, nullptr },
        { "spread_method_property", reinterpret_cast<getter>(GradientBrush_get_SpreadMethodProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_GradientBrush_Static[] = {
        { }
    };

    static PyType_Slot type_slots_GradientBrush_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GradientBrush_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GradientBrush_Static) },
        { }
    };

    static PyType_Spec type_spec_GradientBrush_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.GradientBrush_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_GradientBrush_Static
    };

    // ----- GradientStop class --------------------

    static PyObject* _new_GradientStop(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::GradientStop instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GradientStop(py::wrapper::Windows::UI::Xaml::Media::GradientStop* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GradientStop_get_Offset(py::wrapper::Windows::UI::Xaml::Media::GradientStop* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.GradientStop", L"Offset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Offset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GradientStop_put_Offset(py::wrapper::Windows::UI::Xaml::Media::GradientStop* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.GradientStop", L"Offset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.Offset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GradientStop_get_Color(py::wrapper::Windows::UI::Xaml::Media::GradientStop* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.GradientStop", L"Color");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Color());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GradientStop_put_Color(py::wrapper::Windows::UI::Xaml::Media::GradientStop* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.GradientStop", L"Color");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Color(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GradientStop_get_ColorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.GradientStop", L"ColorProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::GradientStop::ColorProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GradientStop_get_OffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.GradientStop", L"OffsetProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::GradientStop::OffsetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GradientStop(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::GradientStop>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GradientStop(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::GradientStop>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GradientStop[] = {
        { "_assign_array_", _assign_array_GradientStop, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GradientStop), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GradientStop[] = {
        { "offset", reinterpret_cast<getter>(GradientStop_get_Offset), reinterpret_cast<setter>(GradientStop_put_Offset), nullptr, nullptr },
        { "color", reinterpret_cast<getter>(GradientStop_get_Color), reinterpret_cast<setter>(GradientStop_put_Color), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GradientStop[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GradientStop) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GradientStop) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GradientStop) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GradientStop) },
        { }
    };

    static PyType_Spec type_spec_GradientStop = {
        "winrt._winrt_windows_ui_xaml_media.GradientStop",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::GradientStop),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GradientStop};

    static PyGetSetDef getset_GradientStop_Static[] = {
        { "color_property", reinterpret_cast<getter>(GradientStop_get_ColorProperty), nullptr, nullptr, nullptr },
        { "offset_property", reinterpret_cast<getter>(GradientStop_get_OffsetProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_GradientStop_Static[] = {
        { }
    };

    static PyType_Slot type_slots_GradientStop_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GradientStop_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GradientStop_Static) },
        { }
    };

    static PyType_Spec type_spec_GradientStop_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.GradientStop_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GradientStop_Static
    };

    // ----- GradientStopCollection class --------------------

    static PyObject* _new_GradientStopCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::GradientStopCollection instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GradientStopCollection(py::wrapper::Windows::UI::Xaml::Media::GradientStopCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GradientStopCollection_Append(py::wrapper::Windows::UI::Xaml::Media::GradientStopCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.GradientStopCollection", L"Append", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::GradientStop>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GradientStopCollection_Clear(py::wrapper::Windows::UI::Xaml::Media::GradientStopCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.GradientStopCollection", L"Clear", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GradientStopCollection_First(py::wrapper::Windows::UI::Xaml::Media::GradientStopCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.GradientStopCollection", L"First", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GradientStopCollection_GetAt(py::wrapper::Windows::UI::Xaml::Media::GradientStopCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.GradientStopCollection", L"GetAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GradientStopCollection_GetMany(py::wrapper::Windows::UI::Xaml::Media::GradientStopCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.GradientStopCollection", L"GetMany", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Media::GradientStop, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GradientStopCollection_GetView(py::wrapper::Windows::UI::Xaml::Media::GradientStopCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.GradientStopCollection", L"GetView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GradientStopCollection_IndexOf(py::wrapper::Windows::UI::Xaml::Media::GradientStopCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.GradientStopCollection", L"IndexOf", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::GradientStop>(args, 0);
                uint32_t param1{};

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GradientStopCollection_InsertAt(py::wrapper::Windows::UI::Xaml::Media::GradientStopCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.GradientStopCollection", L"InsertAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Media::GradientStop>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GradientStopCollection_RemoveAt(py::wrapper::Windows::UI::Xaml::Media::GradientStopCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.GradientStopCollection", L"RemoveAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GradientStopCollection_RemoveAtEnd(py::wrapper::Windows::UI::Xaml::Media::GradientStopCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.GradientStopCollection", L"RemoveAtEnd", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GradientStopCollection_ReplaceAll(py::wrapper::Windows::UI::Xaml::Media::GradientStopCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.GradientStopCollection", L"ReplaceAll", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Media::GradientStop, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GradientStopCollection_SetAt(py::wrapper::Windows::UI::Xaml::Media::GradientStopCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.GradientStopCollection", L"SetAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Media::GradientStop>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GradientStopCollection_get_Size(py::wrapper::Windows::UI::Xaml::Media::GradientStopCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.GradientStopCollection", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GradientStopCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::GradientStopCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GradientStopCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::GradientStopCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_GradientStopCollection(py::wrapper::Windows::UI::Xaml::Media::GradientStopCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_GradientStopCollection(py::wrapper::Windows::UI::Xaml::Media::GradientStopCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_GradientStopCollection(py::wrapper::Windows::UI::Xaml::Media::GradientStopCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_GradientStopCollection(py::wrapper::Windows::UI::Xaml::Media::GradientStopCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_GradientStopCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(PyExc_TypeError, "indices must be integers, not '%s'", Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(slice, self->obj.Size(), &start, &stop, &step, &length) < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(PyExc_NotImplementedError, "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::UI::Xaml::Media::GradientStop> items(static_cast<uint32_t>(length), empty_instance<winrt::Windows::UI::Xaml::Media::GradientStop>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(PyExc_RuntimeError, "returned count %d did not match requested length %zd", count, length);
                return nullptr;
            }

            return convert(items);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_GradientStopCollection(py::wrapper::Windows::UI::Xaml::Media::GradientStopCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (!value)
            {
                self->obj.RemoveAt(static_cast<uint32_t>(i));
            }
            else
            {
                self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::UI::Xaml::Media::GradientStop>(value));
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_GradientStopCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(GradientStopCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(GradientStopCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(GradientStopCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(GradientStopCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(GradientStopCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(GradientStopCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(GradientStopCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(GradientStopCollection_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(GradientStopCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(GradientStopCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(GradientStopCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(GradientStopCollection_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_GradientStopCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GradientStopCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GradientStopCollection[] = {
        { "size", reinterpret_cast<getter>(GradientStopCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GradientStopCollection[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GradientStopCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GradientStopCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GradientStopCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GradientStopCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_GradientStopCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_GradientStopCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_GradientStopCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_GradientStopCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_GradientStopCollection) },
        { }
    };

    static PyType_Spec type_spec_GradientStopCollection = {
        "winrt._winrt_windows_ui_xaml_media.GradientStopCollection",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::GradientStopCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GradientStopCollection};

    // ----- ImageBrush class --------------------

    static PyObject* _new_ImageBrush(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::ImageBrush instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ImageBrush(py::wrapper::Windows::UI::Xaml::Media::ImageBrush* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ImageBrush_get_ImageSource(py::wrapper::Windows::UI::Xaml::Media::ImageBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.ImageBrush", L"ImageSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ImageSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageBrush_put_ImageSource(py::wrapper::Windows::UI::Xaml::Media::ImageBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.ImageBrush", L"ImageSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::ImageSource>(arg);

            self->obj.ImageSource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageBrush_get_ImageSourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.ImageBrush", L"ImageSourceProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::ImageBrush::ImageSourceProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageBrush_add_ImageFailed(py::wrapper::Windows::UI::Xaml::Media::ImageBrush* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Media.ImageBrush", L"ImageFailed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::ExceptionRoutedEventHandler>(arg);

            return py::convert(self->obj.ImageFailed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageBrush_remove_ImageFailed(py::wrapper::Windows::UI::Xaml::Media::ImageBrush* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Media.ImageBrush", L"ImageFailed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ImageFailed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageBrush_add_ImageOpened(py::wrapper::Windows::UI::Xaml::Media::ImageBrush* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Media.ImageBrush", L"ImageOpened");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::RoutedEventHandler>(arg);

            return py::convert(self->obj.ImageOpened(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageBrush_remove_ImageOpened(py::wrapper::Windows::UI::Xaml::Media::ImageBrush* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Media.ImageBrush", L"ImageOpened");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ImageOpened(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ImageBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::ImageBrush>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ImageBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::ImageBrush>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageBrush[] = {
        { "add_image_failed", reinterpret_cast<PyCFunction>(ImageBrush_add_ImageFailed), METH_O, nullptr },
        { "remove_image_failed", reinterpret_cast<PyCFunction>(ImageBrush_remove_ImageFailed), METH_O, nullptr },
        { "add_image_opened", reinterpret_cast<PyCFunction>(ImageBrush_add_ImageOpened), METH_O, nullptr },
        { "remove_image_opened", reinterpret_cast<PyCFunction>(ImageBrush_remove_ImageOpened), METH_O, nullptr },
        { "_assign_array_", _assign_array_ImageBrush, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ImageBrush), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ImageBrush[] = {
        { "image_source", reinterpret_cast<getter>(ImageBrush_get_ImageSource), reinterpret_cast<setter>(ImageBrush_put_ImageSource), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ImageBrush[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ImageBrush) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ImageBrush) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ImageBrush) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ImageBrush) },
        { }
    };

    static PyType_Spec type_spec_ImageBrush = {
        "winrt._winrt_windows_ui_xaml_media.ImageBrush",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::ImageBrush),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageBrush};

    static PyGetSetDef getset_ImageBrush_Static[] = {
        { "image_source_property", reinterpret_cast<getter>(ImageBrush_get_ImageSourceProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ImageBrush_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ImageBrush_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ImageBrush_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImageBrush_Static) },
        { }
    };

    static PyType_Spec type_spec_ImageBrush_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.ImageBrush_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ImageBrush_Static
    };

    // ----- ImageSource class --------------------

    static PyObject* _new_ImageSource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Media::ImageSource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Media::ImageSource>::type_name);
        return nullptr;
    }

    static void _dealloc_ImageSource(py::wrapper::Windows::UI::Xaml::Media::ImageSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ImageSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::ImageSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ImageSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::ImageSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageSource[] = {
        { "_assign_array_", _assign_array_ImageSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ImageSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ImageSource[] = {
        { }
    };

    static PyType_Slot _type_slots_ImageSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ImageSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ImageSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ImageSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ImageSource) },
        { }
    };

    static PyType_Spec type_spec_ImageSource = {
        "winrt._winrt_windows_ui_xaml_media.ImageSource",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::ImageSource),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ImageSource};

    static PyGetSetDef getset_ImageSource_Static[] = {
        { }
    };

    static PyMethodDef methods_ImageSource_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ImageSource_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ImageSource_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImageSource_Static) },
        { }
    };

    static PyType_Spec type_spec_ImageSource_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.ImageSource_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImageSource_Static
    };

    // ----- LineGeometry class --------------------

    static PyObject* _new_LineGeometry(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::LineGeometry instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LineGeometry(py::wrapper::Windows::UI::Xaml::Media::LineGeometry* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LineGeometry_get_StartPoint(py::wrapper::Windows::UI::Xaml::Media::LineGeometry* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.LineGeometry", L"StartPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StartPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineGeometry_put_StartPoint(py::wrapper::Windows::UI::Xaml::Media::LineGeometry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.LineGeometry", L"StartPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.StartPoint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineGeometry_get_EndPoint(py::wrapper::Windows::UI::Xaml::Media::LineGeometry* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.LineGeometry", L"EndPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EndPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineGeometry_put_EndPoint(py::wrapper::Windows::UI::Xaml::Media::LineGeometry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.LineGeometry", L"EndPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.EndPoint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineGeometry_get_EndPointProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.LineGeometry", L"EndPointProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::LineGeometry::EndPointProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineGeometry_get_StartPointProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.LineGeometry", L"StartPointProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::LineGeometry::StartPointProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LineGeometry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::LineGeometry>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LineGeometry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::LineGeometry>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineGeometry[] = {
        { "_assign_array_", _assign_array_LineGeometry, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LineGeometry), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LineGeometry[] = {
        { "start_point", reinterpret_cast<getter>(LineGeometry_get_StartPoint), reinterpret_cast<setter>(LineGeometry_put_StartPoint), nullptr, nullptr },
        { "end_point", reinterpret_cast<getter>(LineGeometry_get_EndPoint), reinterpret_cast<setter>(LineGeometry_put_EndPoint), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LineGeometry[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LineGeometry) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LineGeometry) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LineGeometry) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LineGeometry) },
        { }
    };

    static PyType_Spec type_spec_LineGeometry = {
        "winrt._winrt_windows_ui_xaml_media.LineGeometry",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::LineGeometry),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineGeometry};

    static PyGetSetDef getset_LineGeometry_Static[] = {
        { "end_point_property", reinterpret_cast<getter>(LineGeometry_get_EndPointProperty), nullptr, nullptr, nullptr },
        { "start_point_property", reinterpret_cast<getter>(LineGeometry_get_StartPointProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_LineGeometry_Static[] = {
        { }
    };

    static PyType_Slot type_slots_LineGeometry_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_LineGeometry_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_LineGeometry_Static) },
        { }
    };

    static PyType_Spec type_spec_LineGeometry_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.LineGeometry_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_LineGeometry_Static
    };

    // ----- LineSegment class --------------------

    static PyObject* _new_LineSegment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::LineSegment instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LineSegment(py::wrapper::Windows::UI::Xaml::Media::LineSegment* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LineSegment_get_Point(py::wrapper::Windows::UI::Xaml::Media::LineSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.LineSegment", L"Point");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Point());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineSegment_put_Point(py::wrapper::Windows::UI::Xaml::Media::LineSegment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.LineSegment", L"Point");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.Point(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineSegment_get_PointProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.LineSegment", L"PointProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::LineSegment::PointProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LineSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::LineSegment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LineSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::LineSegment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineSegment[] = {
        { "_assign_array_", _assign_array_LineSegment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LineSegment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LineSegment[] = {
        { "point", reinterpret_cast<getter>(LineSegment_get_Point), reinterpret_cast<setter>(LineSegment_put_Point), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LineSegment[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LineSegment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LineSegment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LineSegment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LineSegment) },
        { }
    };

    static PyType_Spec type_spec_LineSegment = {
        "winrt._winrt_windows_ui_xaml_media.LineSegment",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::LineSegment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineSegment};

    static PyGetSetDef getset_LineSegment_Static[] = {
        { "point_property", reinterpret_cast<getter>(LineSegment_get_PointProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_LineSegment_Static[] = {
        { }
    };

    static PyType_Slot type_slots_LineSegment_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_LineSegment_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_LineSegment_Static) },
        { }
    };

    static PyType_Spec type_spec_LineSegment_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.LineSegment_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_LineSegment_Static
    };

    // ----- LinearGradientBrush class --------------------

    static PyObject* _new_LinearGradientBrush(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::GradientStopCollection>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                winrt::Windows::UI::Xaml::Media::LinearGradientBrush instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::LinearGradientBrush instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LinearGradientBrush(py::wrapper::Windows::UI::Xaml::Media::LinearGradientBrush* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LinearGradientBrush_get_StartPoint(py::wrapper::Windows::UI::Xaml::Media::LinearGradientBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.LinearGradientBrush", L"StartPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StartPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LinearGradientBrush_put_StartPoint(py::wrapper::Windows::UI::Xaml::Media::LinearGradientBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.LinearGradientBrush", L"StartPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.StartPoint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LinearGradientBrush_get_EndPoint(py::wrapper::Windows::UI::Xaml::Media::LinearGradientBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.LinearGradientBrush", L"EndPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EndPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LinearGradientBrush_put_EndPoint(py::wrapper::Windows::UI::Xaml::Media::LinearGradientBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.LinearGradientBrush", L"EndPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.EndPoint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LinearGradientBrush_get_EndPointProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.LinearGradientBrush", L"EndPointProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::LinearGradientBrush::EndPointProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LinearGradientBrush_get_StartPointProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.LinearGradientBrush", L"StartPointProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::LinearGradientBrush::StartPointProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LinearGradientBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::LinearGradientBrush>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LinearGradientBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::LinearGradientBrush>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LinearGradientBrush[] = {
        { "_assign_array_", _assign_array_LinearGradientBrush, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LinearGradientBrush), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LinearGradientBrush[] = {
        { "start_point", reinterpret_cast<getter>(LinearGradientBrush_get_StartPoint), reinterpret_cast<setter>(LinearGradientBrush_put_StartPoint), nullptr, nullptr },
        { "end_point", reinterpret_cast<getter>(LinearGradientBrush_get_EndPoint), reinterpret_cast<setter>(LinearGradientBrush_put_EndPoint), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LinearGradientBrush[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LinearGradientBrush) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LinearGradientBrush) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LinearGradientBrush) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LinearGradientBrush) },
        { }
    };

    static PyType_Spec type_spec_LinearGradientBrush = {
        "winrt._winrt_windows_ui_xaml_media.LinearGradientBrush",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::LinearGradientBrush),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LinearGradientBrush};

    static PyGetSetDef getset_LinearGradientBrush_Static[] = {
        { "end_point_property", reinterpret_cast<getter>(LinearGradientBrush_get_EndPointProperty), nullptr, nullptr, nullptr },
        { "start_point_property", reinterpret_cast<getter>(LinearGradientBrush_get_StartPointProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_LinearGradientBrush_Static[] = {
        { }
    };

    static PyType_Slot type_slots_LinearGradientBrush_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_LinearGradientBrush_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_LinearGradientBrush_Static) },
        { }
    };

    static PyType_Spec type_spec_LinearGradientBrush_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.LinearGradientBrush_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_LinearGradientBrush_Static
    };

    // ----- LoadedImageSourceLoadCompletedEventArgs class --------------------

    static PyObject* _new_LoadedImageSourceLoadCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Media::LoadedImageSourceLoadCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Media::LoadedImageSourceLoadCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_LoadedImageSourceLoadCompletedEventArgs(py::wrapper::Windows::UI::Xaml::Media::LoadedImageSourceLoadCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LoadedImageSourceLoadCompletedEventArgs_get_Status(py::wrapper::Windows::UI::Xaml::Media::LoadedImageSourceLoadCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.LoadedImageSourceLoadCompletedEventArgs", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LoadedImageSourceLoadCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::LoadedImageSourceLoadCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LoadedImageSourceLoadCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::LoadedImageSourceLoadCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoadedImageSourceLoadCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_LoadedImageSourceLoadCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LoadedImageSourceLoadCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LoadedImageSourceLoadCompletedEventArgs[] = {
        { "status", reinterpret_cast<getter>(LoadedImageSourceLoadCompletedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LoadedImageSourceLoadCompletedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LoadedImageSourceLoadCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LoadedImageSourceLoadCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LoadedImageSourceLoadCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LoadedImageSourceLoadCompletedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_LoadedImageSourceLoadCompletedEventArgs = {
        "winrt._winrt_windows_ui_xaml_media.LoadedImageSourceLoadCompletedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::LoadedImageSourceLoadCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoadedImageSourceLoadCompletedEventArgs};

    // ----- LoadedImageSurface class --------------------

    static PyObject* _new_LoadedImageSurface(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Media::LoadedImageSurface>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Media::LoadedImageSurface>::type_name);
        return nullptr;
    }

    static void _dealloc_LoadedImageSurface(py::wrapper::Windows::UI::Xaml::Media::LoadedImageSurface* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LoadedImageSurface_Close(py::wrapper::Windows::UI::Xaml::Media::LoadedImageSurface* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.LoadedImageSurface", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoadedImageSurface_StartLoadFromStream(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.LoadedImageSurface", L"StartLoadFromStream", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Media::LoadedImageSurface::StartLoadFromStream(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoadedImageSurface_StartLoadFromStreamWithSize(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.LoadedImageSurface", L"StartLoadFromStream", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Size>(args, 1);

                return py::convert(winrt::Windows::UI::Xaml::Media::LoadedImageSurface::StartLoadFromStream(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoadedImageSurface_StartLoadFromUri(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.LoadedImageSurface", L"StartLoadFromUri", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Media::LoadedImageSurface::StartLoadFromUri(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoadedImageSurface_StartLoadFromUriWithSize(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.LoadedImageSurface", L"StartLoadFromUri", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Size>(args, 1);

                return py::convert(winrt::Windows::UI::Xaml::Media::LoadedImageSurface::StartLoadFromUri(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoadedImageSurface_get_DecodedPhysicalSize(py::wrapper::Windows::UI::Xaml::Media::LoadedImageSurface* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.LoadedImageSurface", L"DecodedPhysicalSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DecodedPhysicalSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoadedImageSurface_get_DecodedSize(py::wrapper::Windows::UI::Xaml::Media::LoadedImageSurface* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.LoadedImageSurface", L"DecodedSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DecodedSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoadedImageSurface_get_NaturalSize(py::wrapper::Windows::UI::Xaml::Media::LoadedImageSurface* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.LoadedImageSurface", L"NaturalSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NaturalSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoadedImageSurface_add_LoadCompleted(py::wrapper::Windows::UI::Xaml::Media::LoadedImageSurface* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Media.LoadedImageSurface", L"LoadCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Xaml::Media::LoadedImageSurface, winrt::Windows::UI::Xaml::Media::LoadedImageSourceLoadCompletedEventArgs>>(arg);

            return py::convert(self->obj.LoadCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoadedImageSurface_remove_LoadCompleted(py::wrapper::Windows::UI::Xaml::Media::LoadedImageSurface* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Media.LoadedImageSurface", L"LoadCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LoadCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LoadedImageSurface(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::LoadedImageSurface>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LoadedImageSurface(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::LoadedImageSurface>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_LoadedImageSurface(py::wrapper::Windows::UI::Xaml::Media::LoadedImageSurface* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_LoadedImageSurface(py::wrapper::Windows::UI::Xaml::Media::LoadedImageSurface* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoadedImageSurface[] = {
        { "close", reinterpret_cast<PyCFunction>(LoadedImageSurface_Close), METH_VARARGS, nullptr },
        { "add_load_completed", reinterpret_cast<PyCFunction>(LoadedImageSurface_add_LoadCompleted), METH_O, nullptr },
        { "remove_load_completed", reinterpret_cast<PyCFunction>(LoadedImageSurface_remove_LoadCompleted), METH_O, nullptr },
        { "_assign_array_", _assign_array_LoadedImageSurface, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LoadedImageSurface), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_LoadedImageSurface), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_LoadedImageSurface), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_LoadedImageSurface[] = {
        { "decoded_physical_size", reinterpret_cast<getter>(LoadedImageSurface_get_DecodedPhysicalSize), nullptr, nullptr, nullptr },
        { "decoded_size", reinterpret_cast<getter>(LoadedImageSurface_get_DecodedSize), nullptr, nullptr, nullptr },
        { "natural_size", reinterpret_cast<getter>(LoadedImageSurface_get_NaturalSize), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LoadedImageSurface[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LoadedImageSurface) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LoadedImageSurface) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LoadedImageSurface) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LoadedImageSurface) },
        { }
    };

    static PyType_Spec type_spec_LoadedImageSurface = {
        "winrt._winrt_windows_ui_xaml_media.LoadedImageSurface",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::LoadedImageSurface),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoadedImageSurface};

    static PyGetSetDef getset_LoadedImageSurface_Static[] = {
        { }
    };

    static PyMethodDef methods_LoadedImageSurface_Static[] = {
        { "start_load_from_stream", reinterpret_cast<PyCFunction>(LoadedImageSurface_StartLoadFromStream), METH_VARARGS, nullptr },
        { "start_load_from_stream_with_size", reinterpret_cast<PyCFunction>(LoadedImageSurface_StartLoadFromStreamWithSize), METH_VARARGS, nullptr },
        { "start_load_from_uri", reinterpret_cast<PyCFunction>(LoadedImageSurface_StartLoadFromUri), METH_VARARGS, nullptr },
        { "start_load_from_uri_with_size", reinterpret_cast<PyCFunction>(LoadedImageSurface_StartLoadFromUriWithSize), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_LoadedImageSurface_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_LoadedImageSurface_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_LoadedImageSurface_Static) },
        { }
    };

    static PyType_Spec type_spec_LoadedImageSurface_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.LoadedImageSurface_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_LoadedImageSurface_Static
    };

    // ----- Matrix3DProjection class --------------------

    static PyObject* _new_Matrix3DProjection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::Matrix3DProjection instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Matrix3DProjection(py::wrapper::Windows::UI::Xaml::Media::Matrix3DProjection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Matrix3DProjection_get_ProjectionMatrix(py::wrapper::Windows::UI::Xaml::Media::Matrix3DProjection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Matrix3DProjection", L"ProjectionMatrix");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProjectionMatrix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix3DProjection_put_ProjectionMatrix(py::wrapper::Windows::UI::Xaml::Media::Matrix3DProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Matrix3DProjection", L"ProjectionMatrix");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Media3D::Matrix3D>(arg);

            self->obj.ProjectionMatrix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix3DProjection_get_ProjectionMatrixProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.Matrix3DProjection", L"ProjectionMatrixProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::Matrix3DProjection::ProjectionMatrixProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Matrix3DProjection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Matrix3DProjection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Matrix3DProjection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Matrix3DProjection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Matrix3DProjection[] = {
        { "_assign_array_", _assign_array_Matrix3DProjection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Matrix3DProjection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Matrix3DProjection[] = {
        { "projection_matrix", reinterpret_cast<getter>(Matrix3DProjection_get_ProjectionMatrix), reinterpret_cast<setter>(Matrix3DProjection_put_ProjectionMatrix), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Matrix3DProjection[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Matrix3DProjection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Matrix3DProjection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Matrix3DProjection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Matrix3DProjection) },
        { }
    };

    static PyType_Spec type_spec_Matrix3DProjection = {
        "winrt._winrt_windows_ui_xaml_media.Matrix3DProjection",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Matrix3DProjection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Matrix3DProjection};

    static PyGetSetDef getset_Matrix3DProjection_Static[] = {
        { "projection_matrix_property", reinterpret_cast<getter>(Matrix3DProjection_get_ProjectionMatrixProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Matrix3DProjection_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Matrix3DProjection_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Matrix3DProjection_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Matrix3DProjection_Static) },
        { }
    };

    static PyType_Spec type_spec_Matrix3DProjection_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.Matrix3DProjection_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Matrix3DProjection_Static
    };

    // ----- MatrixHelper class --------------------

    static PyObject* _new_MatrixHelper(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Media::MatrixHelper>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Media::MatrixHelper>::type_name);
        return nullptr;
    }

    static void _dealloc_MatrixHelper(py::wrapper::Windows::UI::Xaml::Media::MatrixHelper* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MatrixHelper_FromElements(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.MatrixHelper", L"FromElements", 6);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(6);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<double>(args, 2);
                auto param3 = py::convert_to<double>(args, 3);
                auto param4 = py::convert_to<double>(args, 4);
                auto param5 = py::convert_to<double>(args, 5);

                return py::convert(winrt::Windows::UI::Xaml::Media::MatrixHelper::FromElements(param0, param1, param2, param3, param4, param5));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MatrixHelper_GetIsIdentity(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.MatrixHelper", L"GetIsIdentity", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Matrix>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Media::MatrixHelper::GetIsIdentity(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MatrixHelper_Transform(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.MatrixHelper", L"Transform", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Matrix>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);

                return py::convert(winrt::Windows::UI::Xaml::Media::MatrixHelper::Transform(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MatrixHelper_get_Identity(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.MatrixHelper", L"Identity");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::MatrixHelper::Identity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MatrixHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::MatrixHelper>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MatrixHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::MatrixHelper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MatrixHelper[] = {
        { "_assign_array_", _assign_array_MatrixHelper, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MatrixHelper), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MatrixHelper[] = {
        { }
    };

    static PyType_Slot _type_slots_MatrixHelper[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MatrixHelper) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MatrixHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MatrixHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MatrixHelper) },
        { }
    };

    static PyType_Spec type_spec_MatrixHelper = {
        "winrt._winrt_windows_ui_xaml_media.MatrixHelper",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::MatrixHelper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MatrixHelper};

    static PyGetSetDef getset_MatrixHelper_Static[] = {
        { "identity", reinterpret_cast<getter>(MatrixHelper_get_Identity), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_MatrixHelper_Static[] = {
        { "from_elements", reinterpret_cast<PyCFunction>(MatrixHelper_FromElements), METH_VARARGS, nullptr },
        { "get_is_identity", reinterpret_cast<PyCFunction>(MatrixHelper_GetIsIdentity), METH_VARARGS, nullptr },
        { "transform", reinterpret_cast<PyCFunction>(MatrixHelper_Transform), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_MatrixHelper_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MatrixHelper_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MatrixHelper_Static) },
        { }
    };

    static PyType_Spec type_spec_MatrixHelper_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.MatrixHelper_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MatrixHelper_Static
    };

    // ----- MatrixTransform class --------------------

    static PyObject* _new_MatrixTransform(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::MatrixTransform instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MatrixTransform(py::wrapper::Windows::UI::Xaml::Media::MatrixTransform* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MatrixTransform_get_Matrix(py::wrapper::Windows::UI::Xaml::Media::MatrixTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.MatrixTransform", L"Matrix");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Matrix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MatrixTransform_put_Matrix(py::wrapper::Windows::UI::Xaml::Media::MatrixTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.MatrixTransform", L"Matrix");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Matrix>(arg);

            self->obj.Matrix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MatrixTransform_get_MatrixProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.MatrixTransform", L"MatrixProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::MatrixTransform::MatrixProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MatrixTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::MatrixTransform>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MatrixTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::MatrixTransform>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MatrixTransform[] = {
        { "_assign_array_", _assign_array_MatrixTransform, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MatrixTransform), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MatrixTransform[] = {
        { "matrix", reinterpret_cast<getter>(MatrixTransform_get_Matrix), reinterpret_cast<setter>(MatrixTransform_put_Matrix), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MatrixTransform[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MatrixTransform) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MatrixTransform) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MatrixTransform) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MatrixTransform) },
        { }
    };

    static PyType_Spec type_spec_MatrixTransform = {
        "winrt._winrt_windows_ui_xaml_media.MatrixTransform",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::MatrixTransform),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MatrixTransform};

    static PyGetSetDef getset_MatrixTransform_Static[] = {
        { "matrix_property", reinterpret_cast<getter>(MatrixTransform_get_MatrixProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_MatrixTransform_Static[] = {
        { }
    };

    static PyType_Slot type_slots_MatrixTransform_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MatrixTransform_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MatrixTransform_Static) },
        { }
    };

    static PyType_Spec type_spec_MatrixTransform_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.MatrixTransform_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MatrixTransform_Static
    };

    // ----- MediaTransportControlsThumbnailRequestedEventArgs class --------------------

    static PyObject* _new_MediaTransportControlsThumbnailRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Media::MediaTransportControlsThumbnailRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Media::MediaTransportControlsThumbnailRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaTransportControlsThumbnailRequestedEventArgs(py::wrapper::Windows::UI::Xaml::Media::MediaTransportControlsThumbnailRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaTransportControlsThumbnailRequestedEventArgs_GetDeferral(py::wrapper::Windows::UI::Xaml::Media::MediaTransportControlsThumbnailRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.MediaTransportControlsThumbnailRequestedEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaTransportControlsThumbnailRequestedEventArgs_SetThumbnailImage(py::wrapper::Windows::UI::Xaml::Media::MediaTransportControlsThumbnailRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.MediaTransportControlsThumbnailRequestedEventArgs", L"SetThumbnailImage", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);

                self->obj.SetThumbnailImage(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaTransportControlsThumbnailRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::MediaTransportControlsThumbnailRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaTransportControlsThumbnailRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::MediaTransportControlsThumbnailRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaTransportControlsThumbnailRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(MediaTransportControlsThumbnailRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "set_thumbnail_image", reinterpret_cast<PyCFunction>(MediaTransportControlsThumbnailRequestedEventArgs_SetThumbnailImage), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaTransportControlsThumbnailRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaTransportControlsThumbnailRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaTransportControlsThumbnailRequestedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaTransportControlsThumbnailRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaTransportControlsThumbnailRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaTransportControlsThumbnailRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaTransportControlsThumbnailRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaTransportControlsThumbnailRequestedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MediaTransportControlsThumbnailRequestedEventArgs = {
        "winrt._winrt_windows_ui_xaml_media.MediaTransportControlsThumbnailRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::MediaTransportControlsThumbnailRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaTransportControlsThumbnailRequestedEventArgs};

    // ----- PartialMediaFailureDetectedEventArgs class --------------------

    static PyObject* _new_PartialMediaFailureDetectedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::PartialMediaFailureDetectedEventArgs instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PartialMediaFailureDetectedEventArgs(py::wrapper::Windows::UI::Xaml::Media::PartialMediaFailureDetectedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PartialMediaFailureDetectedEventArgs_get_StreamKind(py::wrapper::Windows::UI::Xaml::Media::PartialMediaFailureDetectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PartialMediaFailureDetectedEventArgs", L"StreamKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StreamKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PartialMediaFailureDetectedEventArgs_get_ExtendedError(py::wrapper::Windows::UI::Xaml::Media::PartialMediaFailureDetectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PartialMediaFailureDetectedEventArgs", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PartialMediaFailureDetectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::PartialMediaFailureDetectedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PartialMediaFailureDetectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::PartialMediaFailureDetectedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PartialMediaFailureDetectedEventArgs[] = {
        { "_assign_array_", _assign_array_PartialMediaFailureDetectedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PartialMediaFailureDetectedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PartialMediaFailureDetectedEventArgs[] = {
        { "stream_kind", reinterpret_cast<getter>(PartialMediaFailureDetectedEventArgs_get_StreamKind), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(PartialMediaFailureDetectedEventArgs_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PartialMediaFailureDetectedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PartialMediaFailureDetectedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PartialMediaFailureDetectedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PartialMediaFailureDetectedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PartialMediaFailureDetectedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_PartialMediaFailureDetectedEventArgs = {
        "winrt._winrt_windows_ui_xaml_media.PartialMediaFailureDetectedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::PartialMediaFailureDetectedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PartialMediaFailureDetectedEventArgs};

    // ----- PathFigure class --------------------

    static PyObject* _new_PathFigure(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::PathFigure instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PathFigure(py::wrapper::Windows::UI::Xaml::Media::PathFigure* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PathFigure_get_StartPoint(py::wrapper::Windows::UI::Xaml::Media::PathFigure* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PathFigure", L"StartPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StartPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PathFigure_put_StartPoint(py::wrapper::Windows::UI::Xaml::Media::PathFigure* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PathFigure", L"StartPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.StartPoint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PathFigure_get_Segments(py::wrapper::Windows::UI::Xaml::Media::PathFigure* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PathFigure", L"Segments");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Segments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PathFigure_put_Segments(py::wrapper::Windows::UI::Xaml::Media::PathFigure* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PathFigure", L"Segments");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::PathSegmentCollection>(arg);

            self->obj.Segments(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PathFigure_get_IsFilled(py::wrapper::Windows::UI::Xaml::Media::PathFigure* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PathFigure", L"IsFilled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsFilled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PathFigure_put_IsFilled(py::wrapper::Windows::UI::Xaml::Media::PathFigure* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PathFigure", L"IsFilled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsFilled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PathFigure_get_IsClosed(py::wrapper::Windows::UI::Xaml::Media::PathFigure* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PathFigure", L"IsClosed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsClosed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PathFigure_put_IsClosed(py::wrapper::Windows::UI::Xaml::Media::PathFigure* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PathFigure", L"IsClosed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsClosed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PathFigure_get_IsClosedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PathFigure", L"IsClosedProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::PathFigure::IsClosedProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PathFigure_get_IsFilledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PathFigure", L"IsFilledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::PathFigure::IsFilledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PathFigure_get_SegmentsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PathFigure", L"SegmentsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::PathFigure::SegmentsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PathFigure_get_StartPointProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PathFigure", L"StartPointProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::PathFigure::StartPointProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PathFigure(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::PathFigure>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PathFigure(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::PathFigure>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PathFigure[] = {
        { "_assign_array_", _assign_array_PathFigure, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PathFigure), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PathFigure[] = {
        { "start_point", reinterpret_cast<getter>(PathFigure_get_StartPoint), reinterpret_cast<setter>(PathFigure_put_StartPoint), nullptr, nullptr },
        { "segments", reinterpret_cast<getter>(PathFigure_get_Segments), reinterpret_cast<setter>(PathFigure_put_Segments), nullptr, nullptr },
        { "is_filled", reinterpret_cast<getter>(PathFigure_get_IsFilled), reinterpret_cast<setter>(PathFigure_put_IsFilled), nullptr, nullptr },
        { "is_closed", reinterpret_cast<getter>(PathFigure_get_IsClosed), reinterpret_cast<setter>(PathFigure_put_IsClosed), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PathFigure[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PathFigure) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PathFigure) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PathFigure) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PathFigure) },
        { }
    };

    static PyType_Spec type_spec_PathFigure = {
        "winrt._winrt_windows_ui_xaml_media.PathFigure",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::PathFigure),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PathFigure};

    static PyGetSetDef getset_PathFigure_Static[] = {
        { "is_closed_property", reinterpret_cast<getter>(PathFigure_get_IsClosedProperty), nullptr, nullptr, nullptr },
        { "is_filled_property", reinterpret_cast<getter>(PathFigure_get_IsFilledProperty), nullptr, nullptr, nullptr },
        { "segments_property", reinterpret_cast<getter>(PathFigure_get_SegmentsProperty), nullptr, nullptr, nullptr },
        { "start_point_property", reinterpret_cast<getter>(PathFigure_get_StartPointProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_PathFigure_Static[] = {
        { }
    };

    static PyType_Slot type_slots_PathFigure_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PathFigure_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PathFigure_Static) },
        { }
    };

    static PyType_Spec type_spec_PathFigure_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.PathFigure_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PathFigure_Static
    };

    // ----- PathFigureCollection class --------------------

    static PyObject* _new_PathFigureCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::PathFigureCollection instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PathFigureCollection(py::wrapper::Windows::UI::Xaml::Media::PathFigureCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PathFigureCollection_Append(py::wrapper::Windows::UI::Xaml::Media::PathFigureCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.PathFigureCollection", L"Append", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::PathFigure>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathFigureCollection_Clear(py::wrapper::Windows::UI::Xaml::Media::PathFigureCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.PathFigureCollection", L"Clear", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathFigureCollection_First(py::wrapper::Windows::UI::Xaml::Media::PathFigureCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.PathFigureCollection", L"First", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathFigureCollection_GetAt(py::wrapper::Windows::UI::Xaml::Media::PathFigureCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.PathFigureCollection", L"GetAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathFigureCollection_GetMany(py::wrapper::Windows::UI::Xaml::Media::PathFigureCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.PathFigureCollection", L"GetMany", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Media::PathFigure, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathFigureCollection_GetView(py::wrapper::Windows::UI::Xaml::Media::PathFigureCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.PathFigureCollection", L"GetView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathFigureCollection_IndexOf(py::wrapper::Windows::UI::Xaml::Media::PathFigureCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.PathFigureCollection", L"IndexOf", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::PathFigure>(args, 0);
                uint32_t param1{};

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathFigureCollection_InsertAt(py::wrapper::Windows::UI::Xaml::Media::PathFigureCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.PathFigureCollection", L"InsertAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Media::PathFigure>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathFigureCollection_RemoveAt(py::wrapper::Windows::UI::Xaml::Media::PathFigureCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.PathFigureCollection", L"RemoveAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathFigureCollection_RemoveAtEnd(py::wrapper::Windows::UI::Xaml::Media::PathFigureCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.PathFigureCollection", L"RemoveAtEnd", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathFigureCollection_ReplaceAll(py::wrapper::Windows::UI::Xaml::Media::PathFigureCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.PathFigureCollection", L"ReplaceAll", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Media::PathFigure, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathFigureCollection_SetAt(py::wrapper::Windows::UI::Xaml::Media::PathFigureCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.PathFigureCollection", L"SetAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Media::PathFigure>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathFigureCollection_get_Size(py::wrapper::Windows::UI::Xaml::Media::PathFigureCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PathFigureCollection", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PathFigureCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::PathFigureCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PathFigureCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::PathFigureCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_PathFigureCollection(py::wrapper::Windows::UI::Xaml::Media::PathFigureCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_PathFigureCollection(py::wrapper::Windows::UI::Xaml::Media::PathFigureCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_PathFigureCollection(py::wrapper::Windows::UI::Xaml::Media::PathFigureCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_PathFigureCollection(py::wrapper::Windows::UI::Xaml::Media::PathFigureCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_PathFigureCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(PyExc_TypeError, "indices must be integers, not '%s'", Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(slice, self->obj.Size(), &start, &stop, &step, &length) < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(PyExc_NotImplementedError, "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::UI::Xaml::Media::PathFigure> items(static_cast<uint32_t>(length), empty_instance<winrt::Windows::UI::Xaml::Media::PathFigure>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(PyExc_RuntimeError, "returned count %d did not match requested length %zd", count, length);
                return nullptr;
            }

            return convert(items);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_PathFigureCollection(py::wrapper::Windows::UI::Xaml::Media::PathFigureCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (!value)
            {
                self->obj.RemoveAt(static_cast<uint32_t>(i));
            }
            else
            {
                self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::UI::Xaml::Media::PathFigure>(value));
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_PathFigureCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(PathFigureCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(PathFigureCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(PathFigureCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(PathFigureCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(PathFigureCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(PathFigureCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(PathFigureCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(PathFigureCollection_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(PathFigureCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(PathFigureCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(PathFigureCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(PathFigureCollection_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PathFigureCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PathFigureCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PathFigureCollection[] = {
        { "size", reinterpret_cast<getter>(PathFigureCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PathFigureCollection[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PathFigureCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PathFigureCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PathFigureCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PathFigureCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_PathFigureCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_PathFigureCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_PathFigureCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_PathFigureCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_PathFigureCollection) },
        { }
    };

    static PyType_Spec type_spec_PathFigureCollection = {
        "winrt._winrt_windows_ui_xaml_media.PathFigureCollection",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::PathFigureCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PathFigureCollection};

    // ----- PathGeometry class --------------------

    static PyObject* _new_PathGeometry(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::PathGeometry instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PathGeometry(py::wrapper::Windows::UI::Xaml::Media::PathGeometry* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PathGeometry_get_FillRule(py::wrapper::Windows::UI::Xaml::Media::PathGeometry* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PathGeometry", L"FillRule");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FillRule());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PathGeometry_put_FillRule(py::wrapper::Windows::UI::Xaml::Media::PathGeometry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PathGeometry", L"FillRule");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::FillRule>(arg);

            self->obj.FillRule(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PathGeometry_get_Figures(py::wrapper::Windows::UI::Xaml::Media::PathGeometry* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PathGeometry", L"Figures");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Figures());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PathGeometry_put_Figures(py::wrapper::Windows::UI::Xaml::Media::PathGeometry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PathGeometry", L"Figures");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::PathFigureCollection>(arg);

            self->obj.Figures(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PathGeometry_get_FiguresProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PathGeometry", L"FiguresProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::PathGeometry::FiguresProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PathGeometry_get_FillRuleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PathGeometry", L"FillRuleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::PathGeometry::FillRuleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PathGeometry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::PathGeometry>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PathGeometry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::PathGeometry>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PathGeometry[] = {
        { "_assign_array_", _assign_array_PathGeometry, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PathGeometry), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PathGeometry[] = {
        { "fill_rule", reinterpret_cast<getter>(PathGeometry_get_FillRule), reinterpret_cast<setter>(PathGeometry_put_FillRule), nullptr, nullptr },
        { "figures", reinterpret_cast<getter>(PathGeometry_get_Figures), reinterpret_cast<setter>(PathGeometry_put_Figures), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PathGeometry[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PathGeometry) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PathGeometry) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PathGeometry) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PathGeometry) },
        { }
    };

    static PyType_Spec type_spec_PathGeometry = {
        "winrt._winrt_windows_ui_xaml_media.PathGeometry",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::PathGeometry),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PathGeometry};

    static PyGetSetDef getset_PathGeometry_Static[] = {
        { "figures_property", reinterpret_cast<getter>(PathGeometry_get_FiguresProperty), nullptr, nullptr, nullptr },
        { "fill_rule_property", reinterpret_cast<getter>(PathGeometry_get_FillRuleProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_PathGeometry_Static[] = {
        { }
    };

    static PyType_Slot type_slots_PathGeometry_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PathGeometry_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PathGeometry_Static) },
        { }
    };

    static PyType_Spec type_spec_PathGeometry_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.PathGeometry_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PathGeometry_Static
    };

    // ----- PathSegment class --------------------

    static PyObject* _new_PathSegment(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Media::PathSegment>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Media::PathSegment>::type_name);
        return nullptr;
    }

    static void _dealloc_PathSegment(py::wrapper::Windows::UI::Xaml::Media::PathSegment* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PathSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::PathSegment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PathSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::PathSegment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PathSegment[] = {
        { "_assign_array_", _assign_array_PathSegment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PathSegment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PathSegment[] = {
        { }
    };

    static PyType_Slot _type_slots_PathSegment[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PathSegment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PathSegment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PathSegment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PathSegment) },
        { }
    };

    static PyType_Spec type_spec_PathSegment = {
        "winrt._winrt_windows_ui_xaml_media.PathSegment",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::PathSegment),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_PathSegment};

    static PyGetSetDef getset_PathSegment_Static[] = {
        { }
    };

    static PyMethodDef methods_PathSegment_Static[] = {
        { }
    };

    static PyType_Slot type_slots_PathSegment_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PathSegment_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PathSegment_Static) },
        { }
    };

    static PyType_Spec type_spec_PathSegment_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.PathSegment_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_PathSegment_Static
    };

    // ----- PathSegmentCollection class --------------------

    static PyObject* _new_PathSegmentCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::PathSegmentCollection instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PathSegmentCollection(py::wrapper::Windows::UI::Xaml::Media::PathSegmentCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PathSegmentCollection_Append(py::wrapper::Windows::UI::Xaml::Media::PathSegmentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.PathSegmentCollection", L"Append", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::PathSegment>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathSegmentCollection_Clear(py::wrapper::Windows::UI::Xaml::Media::PathSegmentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.PathSegmentCollection", L"Clear", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathSegmentCollection_First(py::wrapper::Windows::UI::Xaml::Media::PathSegmentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.PathSegmentCollection", L"First", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathSegmentCollection_GetAt(py::wrapper::Windows::UI::Xaml::Media::PathSegmentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.PathSegmentCollection", L"GetAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathSegmentCollection_GetMany(py::wrapper::Windows::UI::Xaml::Media::PathSegmentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.PathSegmentCollection", L"GetMany", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Media::PathSegment, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathSegmentCollection_GetView(py::wrapper::Windows::UI::Xaml::Media::PathSegmentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.PathSegmentCollection", L"GetView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathSegmentCollection_IndexOf(py::wrapper::Windows::UI::Xaml::Media::PathSegmentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.PathSegmentCollection", L"IndexOf", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::PathSegment>(args, 0);
                uint32_t param1{};

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathSegmentCollection_InsertAt(py::wrapper::Windows::UI::Xaml::Media::PathSegmentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.PathSegmentCollection", L"InsertAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Media::PathSegment>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathSegmentCollection_RemoveAt(py::wrapper::Windows::UI::Xaml::Media::PathSegmentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.PathSegmentCollection", L"RemoveAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathSegmentCollection_RemoveAtEnd(py::wrapper::Windows::UI::Xaml::Media::PathSegmentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.PathSegmentCollection", L"RemoveAtEnd", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathSegmentCollection_ReplaceAll(py::wrapper::Windows::UI::Xaml::Media::PathSegmentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.PathSegmentCollection", L"ReplaceAll", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Media::PathSegment, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathSegmentCollection_SetAt(py::wrapper::Windows::UI::Xaml::Media::PathSegmentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.PathSegmentCollection", L"SetAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Media::PathSegment>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathSegmentCollection_get_Size(py::wrapper::Windows::UI::Xaml::Media::PathSegmentCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PathSegmentCollection", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PathSegmentCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::PathSegmentCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PathSegmentCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::PathSegmentCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_PathSegmentCollection(py::wrapper::Windows::UI::Xaml::Media::PathSegmentCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_PathSegmentCollection(py::wrapper::Windows::UI::Xaml::Media::PathSegmentCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_PathSegmentCollection(py::wrapper::Windows::UI::Xaml::Media::PathSegmentCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_PathSegmentCollection(py::wrapper::Windows::UI::Xaml::Media::PathSegmentCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_PathSegmentCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(PyExc_TypeError, "indices must be integers, not '%s'", Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(slice, self->obj.Size(), &start, &stop, &step, &length) < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(PyExc_NotImplementedError, "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::UI::Xaml::Media::PathSegment> items(static_cast<uint32_t>(length), empty_instance<winrt::Windows::UI::Xaml::Media::PathSegment>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(PyExc_RuntimeError, "returned count %d did not match requested length %zd", count, length);
                return nullptr;
            }

            return convert(items);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_PathSegmentCollection(py::wrapper::Windows::UI::Xaml::Media::PathSegmentCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (!value)
            {
                self->obj.RemoveAt(static_cast<uint32_t>(i));
            }
            else
            {
                self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::UI::Xaml::Media::PathSegment>(value));
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_PathSegmentCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(PathSegmentCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(PathSegmentCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(PathSegmentCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(PathSegmentCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(PathSegmentCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(PathSegmentCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(PathSegmentCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(PathSegmentCollection_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(PathSegmentCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(PathSegmentCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(PathSegmentCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(PathSegmentCollection_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PathSegmentCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PathSegmentCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PathSegmentCollection[] = {
        { "size", reinterpret_cast<getter>(PathSegmentCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PathSegmentCollection[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PathSegmentCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PathSegmentCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PathSegmentCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PathSegmentCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_PathSegmentCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_PathSegmentCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_PathSegmentCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_PathSegmentCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_PathSegmentCollection) },
        { }
    };

    static PyType_Spec type_spec_PathSegmentCollection = {
        "winrt._winrt_windows_ui_xaml_media.PathSegmentCollection",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::PathSegmentCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PathSegmentCollection};

    // ----- PlaneProjection class --------------------

    static PyObject* _new_PlaneProjection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::PlaneProjection instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlaneProjection(py::wrapper::Windows::UI::Xaml::Media::PlaneProjection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlaneProjection_get_RotationZ(py::wrapper::Windows::UI::Xaml::Media::PlaneProjection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PlaneProjection", L"RotationZ");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RotationZ());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlaneProjection_put_RotationZ(py::wrapper::Windows::UI::Xaml::Media::PlaneProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PlaneProjection", L"RotationZ");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.RotationZ(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlaneProjection_get_RotationY(py::wrapper::Windows::UI::Xaml::Media::PlaneProjection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PlaneProjection", L"RotationY");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RotationY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlaneProjection_put_RotationY(py::wrapper::Windows::UI::Xaml::Media::PlaneProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PlaneProjection", L"RotationY");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.RotationY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlaneProjection_get_RotationX(py::wrapper::Windows::UI::Xaml::Media::PlaneProjection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PlaneProjection", L"RotationX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RotationX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlaneProjection_put_RotationX(py::wrapper::Windows::UI::Xaml::Media::PlaneProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PlaneProjection", L"RotationX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.RotationX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlaneProjection_get_LocalOffsetZ(py::wrapper::Windows::UI::Xaml::Media::PlaneProjection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PlaneProjection", L"LocalOffsetZ");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LocalOffsetZ());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlaneProjection_put_LocalOffsetZ(py::wrapper::Windows::UI::Xaml::Media::PlaneProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PlaneProjection", L"LocalOffsetZ");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.LocalOffsetZ(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlaneProjection_get_LocalOffsetY(py::wrapper::Windows::UI::Xaml::Media::PlaneProjection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PlaneProjection", L"LocalOffsetY");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LocalOffsetY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlaneProjection_put_LocalOffsetY(py::wrapper::Windows::UI::Xaml::Media::PlaneProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PlaneProjection", L"LocalOffsetY");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.LocalOffsetY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlaneProjection_get_LocalOffsetX(py::wrapper::Windows::UI::Xaml::Media::PlaneProjection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PlaneProjection", L"LocalOffsetX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LocalOffsetX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlaneProjection_put_LocalOffsetX(py::wrapper::Windows::UI::Xaml::Media::PlaneProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PlaneProjection", L"LocalOffsetX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.LocalOffsetX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlaneProjection_get_GlobalOffsetZ(py::wrapper::Windows::UI::Xaml::Media::PlaneProjection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PlaneProjection", L"GlobalOffsetZ");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.GlobalOffsetZ());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlaneProjection_put_GlobalOffsetZ(py::wrapper::Windows::UI::Xaml::Media::PlaneProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PlaneProjection", L"GlobalOffsetZ");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.GlobalOffsetZ(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlaneProjection_get_GlobalOffsetY(py::wrapper::Windows::UI::Xaml::Media::PlaneProjection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PlaneProjection", L"GlobalOffsetY");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.GlobalOffsetY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlaneProjection_put_GlobalOffsetY(py::wrapper::Windows::UI::Xaml::Media::PlaneProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PlaneProjection", L"GlobalOffsetY");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.GlobalOffsetY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlaneProjection_get_GlobalOffsetX(py::wrapper::Windows::UI::Xaml::Media::PlaneProjection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PlaneProjection", L"GlobalOffsetX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.GlobalOffsetX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlaneProjection_put_GlobalOffsetX(py::wrapper::Windows::UI::Xaml::Media::PlaneProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PlaneProjection", L"GlobalOffsetX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.GlobalOffsetX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlaneProjection_get_CenterOfRotationZ(py::wrapper::Windows::UI::Xaml::Media::PlaneProjection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PlaneProjection", L"CenterOfRotationZ");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CenterOfRotationZ());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlaneProjection_put_CenterOfRotationZ(py::wrapper::Windows::UI::Xaml::Media::PlaneProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PlaneProjection", L"CenterOfRotationZ");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.CenterOfRotationZ(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlaneProjection_get_CenterOfRotationY(py::wrapper::Windows::UI::Xaml::Media::PlaneProjection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PlaneProjection", L"CenterOfRotationY");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CenterOfRotationY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlaneProjection_put_CenterOfRotationY(py::wrapper::Windows::UI::Xaml::Media::PlaneProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PlaneProjection", L"CenterOfRotationY");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.CenterOfRotationY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlaneProjection_get_CenterOfRotationX(py::wrapper::Windows::UI::Xaml::Media::PlaneProjection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PlaneProjection", L"CenterOfRotationX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CenterOfRotationX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlaneProjection_put_CenterOfRotationX(py::wrapper::Windows::UI::Xaml::Media::PlaneProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PlaneProjection", L"CenterOfRotationX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.CenterOfRotationX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlaneProjection_get_ProjectionMatrix(py::wrapper::Windows::UI::Xaml::Media::PlaneProjection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PlaneProjection", L"ProjectionMatrix");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProjectionMatrix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlaneProjection_get_CenterOfRotationXProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PlaneProjection", L"CenterOfRotationXProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::PlaneProjection::CenterOfRotationXProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlaneProjection_get_CenterOfRotationYProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PlaneProjection", L"CenterOfRotationYProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::PlaneProjection::CenterOfRotationYProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlaneProjection_get_CenterOfRotationZProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PlaneProjection", L"CenterOfRotationZProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::PlaneProjection::CenterOfRotationZProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlaneProjection_get_GlobalOffsetXProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PlaneProjection", L"GlobalOffsetXProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::PlaneProjection::GlobalOffsetXProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlaneProjection_get_GlobalOffsetYProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PlaneProjection", L"GlobalOffsetYProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::PlaneProjection::GlobalOffsetYProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlaneProjection_get_GlobalOffsetZProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PlaneProjection", L"GlobalOffsetZProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::PlaneProjection::GlobalOffsetZProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlaneProjection_get_LocalOffsetXProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PlaneProjection", L"LocalOffsetXProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::PlaneProjection::LocalOffsetXProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlaneProjection_get_LocalOffsetYProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PlaneProjection", L"LocalOffsetYProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::PlaneProjection::LocalOffsetYProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlaneProjection_get_LocalOffsetZProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PlaneProjection", L"LocalOffsetZProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::PlaneProjection::LocalOffsetZProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlaneProjection_get_ProjectionMatrixProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PlaneProjection", L"ProjectionMatrixProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::PlaneProjection::ProjectionMatrixProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlaneProjection_get_RotationXProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PlaneProjection", L"RotationXProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::PlaneProjection::RotationXProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlaneProjection_get_RotationYProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PlaneProjection", L"RotationYProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::PlaneProjection::RotationYProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlaneProjection_get_RotationZProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PlaneProjection", L"RotationZProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::PlaneProjection::RotationZProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlaneProjection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::PlaneProjection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlaneProjection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::PlaneProjection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlaneProjection[] = {
        { "_assign_array_", _assign_array_PlaneProjection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlaneProjection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlaneProjection[] = {
        { "rotation_z", reinterpret_cast<getter>(PlaneProjection_get_RotationZ), reinterpret_cast<setter>(PlaneProjection_put_RotationZ), nullptr, nullptr },
        { "rotation_y", reinterpret_cast<getter>(PlaneProjection_get_RotationY), reinterpret_cast<setter>(PlaneProjection_put_RotationY), nullptr, nullptr },
        { "rotation_x", reinterpret_cast<getter>(PlaneProjection_get_RotationX), reinterpret_cast<setter>(PlaneProjection_put_RotationX), nullptr, nullptr },
        { "local_offset_z", reinterpret_cast<getter>(PlaneProjection_get_LocalOffsetZ), reinterpret_cast<setter>(PlaneProjection_put_LocalOffsetZ), nullptr, nullptr },
        { "local_offset_y", reinterpret_cast<getter>(PlaneProjection_get_LocalOffsetY), reinterpret_cast<setter>(PlaneProjection_put_LocalOffsetY), nullptr, nullptr },
        { "local_offset_x", reinterpret_cast<getter>(PlaneProjection_get_LocalOffsetX), reinterpret_cast<setter>(PlaneProjection_put_LocalOffsetX), nullptr, nullptr },
        { "global_offset_z", reinterpret_cast<getter>(PlaneProjection_get_GlobalOffsetZ), reinterpret_cast<setter>(PlaneProjection_put_GlobalOffsetZ), nullptr, nullptr },
        { "global_offset_y", reinterpret_cast<getter>(PlaneProjection_get_GlobalOffsetY), reinterpret_cast<setter>(PlaneProjection_put_GlobalOffsetY), nullptr, nullptr },
        { "global_offset_x", reinterpret_cast<getter>(PlaneProjection_get_GlobalOffsetX), reinterpret_cast<setter>(PlaneProjection_put_GlobalOffsetX), nullptr, nullptr },
        { "center_of_rotation_z", reinterpret_cast<getter>(PlaneProjection_get_CenterOfRotationZ), reinterpret_cast<setter>(PlaneProjection_put_CenterOfRotationZ), nullptr, nullptr },
        { "center_of_rotation_y", reinterpret_cast<getter>(PlaneProjection_get_CenterOfRotationY), reinterpret_cast<setter>(PlaneProjection_put_CenterOfRotationY), nullptr, nullptr },
        { "center_of_rotation_x", reinterpret_cast<getter>(PlaneProjection_get_CenterOfRotationX), reinterpret_cast<setter>(PlaneProjection_put_CenterOfRotationX), nullptr, nullptr },
        { "projection_matrix", reinterpret_cast<getter>(PlaneProjection_get_ProjectionMatrix), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PlaneProjection[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlaneProjection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlaneProjection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlaneProjection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlaneProjection) },
        { }
    };

    static PyType_Spec type_spec_PlaneProjection = {
        "winrt._winrt_windows_ui_xaml_media.PlaneProjection",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::PlaneProjection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlaneProjection};

    static PyGetSetDef getset_PlaneProjection_Static[] = {
        { "center_of_rotation_x_property", reinterpret_cast<getter>(PlaneProjection_get_CenterOfRotationXProperty), nullptr, nullptr, nullptr },
        { "center_of_rotation_y_property", reinterpret_cast<getter>(PlaneProjection_get_CenterOfRotationYProperty), nullptr, nullptr, nullptr },
        { "center_of_rotation_z_property", reinterpret_cast<getter>(PlaneProjection_get_CenterOfRotationZProperty), nullptr, nullptr, nullptr },
        { "global_offset_x_property", reinterpret_cast<getter>(PlaneProjection_get_GlobalOffsetXProperty), nullptr, nullptr, nullptr },
        { "global_offset_y_property", reinterpret_cast<getter>(PlaneProjection_get_GlobalOffsetYProperty), nullptr, nullptr, nullptr },
        { "global_offset_z_property", reinterpret_cast<getter>(PlaneProjection_get_GlobalOffsetZProperty), nullptr, nullptr, nullptr },
        { "local_offset_x_property", reinterpret_cast<getter>(PlaneProjection_get_LocalOffsetXProperty), nullptr, nullptr, nullptr },
        { "local_offset_y_property", reinterpret_cast<getter>(PlaneProjection_get_LocalOffsetYProperty), nullptr, nullptr, nullptr },
        { "local_offset_z_property", reinterpret_cast<getter>(PlaneProjection_get_LocalOffsetZProperty), nullptr, nullptr, nullptr },
        { "projection_matrix_property", reinterpret_cast<getter>(PlaneProjection_get_ProjectionMatrixProperty), nullptr, nullptr, nullptr },
        { "rotation_x_property", reinterpret_cast<getter>(PlaneProjection_get_RotationXProperty), nullptr, nullptr, nullptr },
        { "rotation_y_property", reinterpret_cast<getter>(PlaneProjection_get_RotationYProperty), nullptr, nullptr, nullptr },
        { "rotation_z_property", reinterpret_cast<getter>(PlaneProjection_get_RotationZProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_PlaneProjection_Static[] = {
        { }
    };

    static PyType_Slot type_slots_PlaneProjection_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PlaneProjection_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PlaneProjection_Static) },
        { }
    };

    static PyType_Spec type_spec_PlaneProjection_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.PlaneProjection_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PlaneProjection_Static
    };

    // ----- PointCollection class --------------------

    static PyObject* _new_PointCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::PointCollection instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PointCollection(py::wrapper::Windows::UI::Xaml::Media::PointCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PointCollection_Append(py::wrapper::Windows::UI::Xaml::Media::PointCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.PointCollection", L"Append", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointCollection_Clear(py::wrapper::Windows::UI::Xaml::Media::PointCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.PointCollection", L"Clear", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointCollection_First(py::wrapper::Windows::UI::Xaml::Media::PointCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.PointCollection", L"First", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointCollection_GetAt(py::wrapper::Windows::UI::Xaml::Media::PointCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.PointCollection", L"GetAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointCollection_GetMany(py::wrapper::Windows::UI::Xaml::Media::PointCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.PointCollection", L"GetMany", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointCollection_GetView(py::wrapper::Windows::UI::Xaml::Media::PointCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.PointCollection", L"GetView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointCollection_IndexOf(py::wrapper::Windows::UI::Xaml::Media::PointCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.PointCollection", L"IndexOf", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                uint32_t param1{};

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointCollection_InsertAt(py::wrapper::Windows::UI::Xaml::Media::PointCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.PointCollection", L"InsertAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointCollection_RemoveAt(py::wrapper::Windows::UI::Xaml::Media::PointCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.PointCollection", L"RemoveAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointCollection_RemoveAtEnd(py::wrapper::Windows::UI::Xaml::Media::PointCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.PointCollection", L"RemoveAtEnd", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointCollection_ReplaceAll(py::wrapper::Windows::UI::Xaml::Media::PointCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.PointCollection", L"ReplaceAll", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointCollection_SetAt(py::wrapper::Windows::UI::Xaml::Media::PointCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.PointCollection", L"SetAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointCollection_get_Size(py::wrapper::Windows::UI::Xaml::Media::PointCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PointCollection", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PointCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::PointCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PointCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::PointCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_PointCollection(py::wrapper::Windows::UI::Xaml::Media::PointCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_PointCollection(py::wrapper::Windows::UI::Xaml::Media::PointCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_PointCollection(py::wrapper::Windows::UI::Xaml::Media::PointCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_PointCollection(py::wrapper::Windows::UI::Xaml::Media::PointCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_PointCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(PyExc_TypeError, "indices must be integers, not '%s'", Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(slice, self->obj.Size(), &start, &stop, &step, &length) < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(PyExc_NotImplementedError, "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::Foundation::Point> items(static_cast<uint32_t>(length), empty_instance<winrt::Windows::Foundation::Point>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(PyExc_RuntimeError, "returned count %d did not match requested length %zd", count, length);
                return nullptr;
            }

            return convert(items);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_PointCollection(py::wrapper::Windows::UI::Xaml::Media::PointCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (!value)
            {
                self->obj.RemoveAt(static_cast<uint32_t>(i));
            }
            else
            {
                self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::Foundation::Point>(value));
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_PointCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(PointCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(PointCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(PointCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(PointCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(PointCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(PointCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(PointCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(PointCollection_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(PointCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(PointCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(PointCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(PointCollection_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PointCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PointCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PointCollection[] = {
        { "size", reinterpret_cast<getter>(PointCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PointCollection[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PointCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PointCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PointCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PointCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_PointCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_PointCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_PointCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_PointCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_PointCollection) },
        { }
    };

    static PyType_Spec type_spec_PointCollection = {
        "winrt._winrt_windows_ui_xaml_media.PointCollection",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::PointCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PointCollection};

    // ----- PolyBezierSegment class --------------------

    static PyObject* _new_PolyBezierSegment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::PolyBezierSegment instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PolyBezierSegment(py::wrapper::Windows::UI::Xaml::Media::PolyBezierSegment* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PolyBezierSegment_get_Points(py::wrapper::Windows::UI::Xaml::Media::PolyBezierSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PolyBezierSegment", L"Points");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Points());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PolyBezierSegment_put_Points(py::wrapper::Windows::UI::Xaml::Media::PolyBezierSegment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PolyBezierSegment", L"Points");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::PointCollection>(arg);

            self->obj.Points(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PolyBezierSegment_get_PointsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PolyBezierSegment", L"PointsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::PolyBezierSegment::PointsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PolyBezierSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::PolyBezierSegment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PolyBezierSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::PolyBezierSegment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PolyBezierSegment[] = {
        { "_assign_array_", _assign_array_PolyBezierSegment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PolyBezierSegment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PolyBezierSegment[] = {
        { "points", reinterpret_cast<getter>(PolyBezierSegment_get_Points), reinterpret_cast<setter>(PolyBezierSegment_put_Points), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PolyBezierSegment[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PolyBezierSegment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PolyBezierSegment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PolyBezierSegment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PolyBezierSegment) },
        { }
    };

    static PyType_Spec type_spec_PolyBezierSegment = {
        "winrt._winrt_windows_ui_xaml_media.PolyBezierSegment",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::PolyBezierSegment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PolyBezierSegment};

    static PyGetSetDef getset_PolyBezierSegment_Static[] = {
        { "points_property", reinterpret_cast<getter>(PolyBezierSegment_get_PointsProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_PolyBezierSegment_Static[] = {
        { }
    };

    static PyType_Slot type_slots_PolyBezierSegment_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PolyBezierSegment_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PolyBezierSegment_Static) },
        { }
    };

    static PyType_Spec type_spec_PolyBezierSegment_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.PolyBezierSegment_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PolyBezierSegment_Static
    };

    // ----- PolyLineSegment class --------------------

    static PyObject* _new_PolyLineSegment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::PolyLineSegment instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PolyLineSegment(py::wrapper::Windows::UI::Xaml::Media::PolyLineSegment* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PolyLineSegment_get_Points(py::wrapper::Windows::UI::Xaml::Media::PolyLineSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PolyLineSegment", L"Points");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Points());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PolyLineSegment_put_Points(py::wrapper::Windows::UI::Xaml::Media::PolyLineSegment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PolyLineSegment", L"Points");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::PointCollection>(arg);

            self->obj.Points(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PolyLineSegment_get_PointsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PolyLineSegment", L"PointsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::PolyLineSegment::PointsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PolyLineSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::PolyLineSegment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PolyLineSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::PolyLineSegment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PolyLineSegment[] = {
        { "_assign_array_", _assign_array_PolyLineSegment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PolyLineSegment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PolyLineSegment[] = {
        { "points", reinterpret_cast<getter>(PolyLineSegment_get_Points), reinterpret_cast<setter>(PolyLineSegment_put_Points), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PolyLineSegment[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PolyLineSegment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PolyLineSegment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PolyLineSegment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PolyLineSegment) },
        { }
    };

    static PyType_Spec type_spec_PolyLineSegment = {
        "winrt._winrt_windows_ui_xaml_media.PolyLineSegment",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::PolyLineSegment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PolyLineSegment};

    static PyGetSetDef getset_PolyLineSegment_Static[] = {
        { "points_property", reinterpret_cast<getter>(PolyLineSegment_get_PointsProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_PolyLineSegment_Static[] = {
        { }
    };

    static PyType_Slot type_slots_PolyLineSegment_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PolyLineSegment_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PolyLineSegment_Static) },
        { }
    };

    static PyType_Spec type_spec_PolyLineSegment_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.PolyLineSegment_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PolyLineSegment_Static
    };

    // ----- PolyQuadraticBezierSegment class --------------------

    static PyObject* _new_PolyQuadraticBezierSegment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::PolyQuadraticBezierSegment instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PolyQuadraticBezierSegment(py::wrapper::Windows::UI::Xaml::Media::PolyQuadraticBezierSegment* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PolyQuadraticBezierSegment_get_Points(py::wrapper::Windows::UI::Xaml::Media::PolyQuadraticBezierSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PolyQuadraticBezierSegment", L"Points");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Points());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PolyQuadraticBezierSegment_put_Points(py::wrapper::Windows::UI::Xaml::Media::PolyQuadraticBezierSegment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PolyQuadraticBezierSegment", L"Points");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::PointCollection>(arg);

            self->obj.Points(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PolyQuadraticBezierSegment_get_PointsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.PolyQuadraticBezierSegment", L"PointsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::PolyQuadraticBezierSegment::PointsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PolyQuadraticBezierSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::PolyQuadraticBezierSegment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PolyQuadraticBezierSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::PolyQuadraticBezierSegment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PolyQuadraticBezierSegment[] = {
        { "_assign_array_", _assign_array_PolyQuadraticBezierSegment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PolyQuadraticBezierSegment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PolyQuadraticBezierSegment[] = {
        { "points", reinterpret_cast<getter>(PolyQuadraticBezierSegment_get_Points), reinterpret_cast<setter>(PolyQuadraticBezierSegment_put_Points), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PolyQuadraticBezierSegment[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PolyQuadraticBezierSegment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PolyQuadraticBezierSegment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PolyQuadraticBezierSegment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PolyQuadraticBezierSegment) },
        { }
    };

    static PyType_Spec type_spec_PolyQuadraticBezierSegment = {
        "winrt._winrt_windows_ui_xaml_media.PolyQuadraticBezierSegment",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::PolyQuadraticBezierSegment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PolyQuadraticBezierSegment};

    static PyGetSetDef getset_PolyQuadraticBezierSegment_Static[] = {
        { "points_property", reinterpret_cast<getter>(PolyQuadraticBezierSegment_get_PointsProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_PolyQuadraticBezierSegment_Static[] = {
        { }
    };

    static PyType_Slot type_slots_PolyQuadraticBezierSegment_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PolyQuadraticBezierSegment_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PolyQuadraticBezierSegment_Static) },
        { }
    };

    static PyType_Spec type_spec_PolyQuadraticBezierSegment_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.PolyQuadraticBezierSegment_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PolyQuadraticBezierSegment_Static
    };

    // ----- Projection class --------------------

    struct PyWinrtProjection;
    using BasePyWinrtProjection = winrt::Windows::UI::Xaml::Media::ProjectionT<PyWinrtProjection, py::IPywinrtObject>;

    struct PyWinrtProjection : py::py_obj_ref, BasePyWinrtProjection
    {

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtProjection* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_Projection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Media::Projection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Media::Projection>::type_name);
        return nullptr;
    }

    static void _dealloc_Projection(py::wrapper::Windows::UI::Xaml::Media::Projection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Projection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Projection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Projection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Projection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Projection[] = {
        { "_assign_array_", _assign_array_Projection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Projection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Projection[] = {
        { }
    };

    static PyType_Slot _type_slots_Projection[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Projection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Projection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Projection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Projection) },
        { }
    };

    static PyType_Spec type_spec_Projection = {
        "winrt._winrt_windows_ui_xaml_media.Projection",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Projection),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_Projection};

    static PyGetSetDef getset_Projection_Static[] = {
        { }
    };

    static PyMethodDef methods_Projection_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Projection_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Projection_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Projection_Static) },
        { }
    };

    static PyType_Spec type_spec_Projection_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.Projection_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_Projection_Static
    };

    // ----- QuadraticBezierSegment class --------------------

    static PyObject* _new_QuadraticBezierSegment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::QuadraticBezierSegment instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_QuadraticBezierSegment(py::wrapper::Windows::UI::Xaml::Media::QuadraticBezierSegment* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* QuadraticBezierSegment_get_Point2(py::wrapper::Windows::UI::Xaml::Media::QuadraticBezierSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.QuadraticBezierSegment", L"Point2");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Point2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int QuadraticBezierSegment_put_Point2(py::wrapper::Windows::UI::Xaml::Media::QuadraticBezierSegment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.QuadraticBezierSegment", L"Point2");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.Point2(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* QuadraticBezierSegment_get_Point1(py::wrapper::Windows::UI::Xaml::Media::QuadraticBezierSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.QuadraticBezierSegment", L"Point1");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Point1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int QuadraticBezierSegment_put_Point1(py::wrapper::Windows::UI::Xaml::Media::QuadraticBezierSegment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.QuadraticBezierSegment", L"Point1");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.Point1(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* QuadraticBezierSegment_get_Point1Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.QuadraticBezierSegment", L"Point1Property");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::QuadraticBezierSegment::Point1Property());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* QuadraticBezierSegment_get_Point2Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.QuadraticBezierSegment", L"Point2Property");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::QuadraticBezierSegment::Point2Property());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_QuadraticBezierSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::QuadraticBezierSegment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_QuadraticBezierSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::QuadraticBezierSegment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_QuadraticBezierSegment[] = {
        { "_assign_array_", _assign_array_QuadraticBezierSegment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_QuadraticBezierSegment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_QuadraticBezierSegment[] = {
        { "point2", reinterpret_cast<getter>(QuadraticBezierSegment_get_Point2), reinterpret_cast<setter>(QuadraticBezierSegment_put_Point2), nullptr, nullptr },
        { "point1", reinterpret_cast<getter>(QuadraticBezierSegment_get_Point1), reinterpret_cast<setter>(QuadraticBezierSegment_put_Point1), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_QuadraticBezierSegment[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_QuadraticBezierSegment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_QuadraticBezierSegment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_QuadraticBezierSegment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_QuadraticBezierSegment) },
        { }
    };

    static PyType_Spec type_spec_QuadraticBezierSegment = {
        "winrt._winrt_windows_ui_xaml_media.QuadraticBezierSegment",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::QuadraticBezierSegment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_QuadraticBezierSegment};

    static PyGetSetDef getset_QuadraticBezierSegment_Static[] = {
        { "point1_property", reinterpret_cast<getter>(QuadraticBezierSegment_get_Point1Property), nullptr, nullptr, nullptr },
        { "point2_property", reinterpret_cast<getter>(QuadraticBezierSegment_get_Point2Property), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_QuadraticBezierSegment_Static[] = {
        { }
    };

    static PyType_Slot type_slots_QuadraticBezierSegment_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_QuadraticBezierSegment_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_QuadraticBezierSegment_Static) },
        { }
    };

    static PyType_Spec type_spec_QuadraticBezierSegment_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.QuadraticBezierSegment_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_QuadraticBezierSegment_Static
    };

    // ----- RateChangedRoutedEventArgs class --------------------

    static PyObject* _new_RateChangedRoutedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::RateChangedRoutedEventArgs instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RateChangedRoutedEventArgs(py::wrapper::Windows::UI::Xaml::Media::RateChangedRoutedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_RateChangedRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::RateChangedRoutedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RateChangedRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::RateChangedRoutedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RateChangedRoutedEventArgs[] = {
        { "_assign_array_", _assign_array_RateChangedRoutedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RateChangedRoutedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RateChangedRoutedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_RateChangedRoutedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RateChangedRoutedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RateChangedRoutedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RateChangedRoutedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RateChangedRoutedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_RateChangedRoutedEventArgs = {
        "winrt._winrt_windows_ui_xaml_media.RateChangedRoutedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::RateChangedRoutedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RateChangedRoutedEventArgs};

    // ----- RectangleGeometry class --------------------

    static PyObject* _new_RectangleGeometry(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::RectangleGeometry instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RectangleGeometry(py::wrapper::Windows::UI::Xaml::Media::RectangleGeometry* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RectangleGeometry_get_Rect(py::wrapper::Windows::UI::Xaml::Media::RectangleGeometry* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.RectangleGeometry", L"Rect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Rect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RectangleGeometry_put_Rect(py::wrapper::Windows::UI::Xaml::Media::RectangleGeometry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.RectangleGeometry", L"Rect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(arg);

            self->obj.Rect(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RectangleGeometry_get_RectProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.RectangleGeometry", L"RectProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::RectangleGeometry::RectProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RectangleGeometry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::RectangleGeometry>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RectangleGeometry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::RectangleGeometry>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RectangleGeometry[] = {
        { "_assign_array_", _assign_array_RectangleGeometry, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RectangleGeometry), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RectangleGeometry[] = {
        { "rect", reinterpret_cast<getter>(RectangleGeometry_get_Rect), reinterpret_cast<setter>(RectangleGeometry_put_Rect), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RectangleGeometry[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RectangleGeometry) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RectangleGeometry) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RectangleGeometry) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RectangleGeometry) },
        { }
    };

    static PyType_Spec type_spec_RectangleGeometry = {
        "winrt._winrt_windows_ui_xaml_media.RectangleGeometry",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::RectangleGeometry),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RectangleGeometry};

    static PyGetSetDef getset_RectangleGeometry_Static[] = {
        { "rect_property", reinterpret_cast<getter>(RectangleGeometry_get_RectProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_RectangleGeometry_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RectangleGeometry_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RectangleGeometry_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RectangleGeometry_Static) },
        { }
    };

    static PyType_Spec type_spec_RectangleGeometry_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.RectangleGeometry_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RectangleGeometry_Static
    };

    // ----- RenderedEventArgs class --------------------

    static PyObject* _new_RenderedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Media::RenderedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Media::RenderedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RenderedEventArgs(py::wrapper::Windows::UI::Xaml::Media::RenderedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RenderedEventArgs_get_FrameDuration(py::wrapper::Windows::UI::Xaml::Media::RenderedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.RenderedEventArgs", L"FrameDuration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FrameDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RenderedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::RenderedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RenderedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::RenderedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RenderedEventArgs[] = {
        { "_assign_array_", _assign_array_RenderedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RenderedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RenderedEventArgs[] = {
        { "frame_duration", reinterpret_cast<getter>(RenderedEventArgs_get_FrameDuration), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RenderedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RenderedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RenderedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RenderedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RenderedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_RenderedEventArgs = {
        "winrt._winrt_windows_ui_xaml_media.RenderedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::RenderedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RenderedEventArgs};

    // ----- RenderingEventArgs class --------------------

    static PyObject* _new_RenderingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Media::RenderingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Media::RenderingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RenderingEventArgs(py::wrapper::Windows::UI::Xaml::Media::RenderingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RenderingEventArgs_get_RenderingTime(py::wrapper::Windows::UI::Xaml::Media::RenderingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.RenderingEventArgs", L"RenderingTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RenderingTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RenderingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::RenderingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RenderingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::RenderingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RenderingEventArgs[] = {
        { "_assign_array_", _assign_array_RenderingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RenderingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RenderingEventArgs[] = {
        { "rendering_time", reinterpret_cast<getter>(RenderingEventArgs_get_RenderingTime), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RenderingEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RenderingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RenderingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RenderingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RenderingEventArgs) },
        { }
    };

    static PyType_Spec type_spec_RenderingEventArgs = {
        "winrt._winrt_windows_ui_xaml_media.RenderingEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::RenderingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RenderingEventArgs};

    // ----- RevealBackgroundBrush class --------------------

    struct PyWinrtRevealBackgroundBrush;
    using BasePyWinrtRevealBackgroundBrush = winrt::Windows::UI::Xaml::Media::RevealBackgroundBrushT<PyWinrtRevealBackgroundBrush, py::IPywinrtObject>;

    struct PyWinrtRevealBackgroundBrush : py::py_obj_ref, BasePyWinrtRevealBackgroundBrush
    {
        PyWinrtRevealBackgroundBrush(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtRevealBackgroundBrush() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtRevealBackgroundBrush* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_RevealBackgroundBrush(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Media::RevealBackgroundBrush>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Media::RevealBackgroundBrush*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Media::RevealBackgroundBrush*>(self.get())->obj = winrt::make<PyWinrtRevealBackgroundBrush>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Media::RevealBackgroundBrush instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RevealBackgroundBrush(py::wrapper::Windows::UI::Xaml::Media::RevealBackgroundBrush* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_RevealBackgroundBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::RevealBackgroundBrush>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RevealBackgroundBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::RevealBackgroundBrush>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RevealBackgroundBrush[] = {
        { "_assign_array_", _assign_array_RevealBackgroundBrush, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RevealBackgroundBrush), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RevealBackgroundBrush[] = {
        { }
    };

    static PyType_Slot _type_slots_RevealBackgroundBrush[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RevealBackgroundBrush) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RevealBackgroundBrush) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RevealBackgroundBrush) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RevealBackgroundBrush) },
        { }
    };

    static PyType_Spec type_spec_RevealBackgroundBrush = {
        "winrt._winrt_windows_ui_xaml_media.RevealBackgroundBrush",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::RevealBackgroundBrush),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_RevealBackgroundBrush};

    static PyGetSetDef getset_RevealBackgroundBrush_Static[] = {
        { }
    };

    static PyMethodDef methods_RevealBackgroundBrush_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RevealBackgroundBrush_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RevealBackgroundBrush_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RevealBackgroundBrush_Static) },
        { }
    };

    static PyType_Spec type_spec_RevealBackgroundBrush_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.RevealBackgroundBrush_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_RevealBackgroundBrush_Static
    };

    // ----- RevealBorderBrush class --------------------

    struct PyWinrtRevealBorderBrush;
    using BasePyWinrtRevealBorderBrush = winrt::Windows::UI::Xaml::Media::RevealBorderBrushT<PyWinrtRevealBorderBrush, py::IPywinrtObject>;

    struct PyWinrtRevealBorderBrush : py::py_obj_ref, BasePyWinrtRevealBorderBrush
    {
        PyWinrtRevealBorderBrush(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtRevealBorderBrush() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtRevealBorderBrush* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_RevealBorderBrush(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Media::RevealBorderBrush>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Media::RevealBorderBrush*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Media::RevealBorderBrush*>(self.get())->obj = winrt::make<PyWinrtRevealBorderBrush>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Media::RevealBorderBrush instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RevealBorderBrush(py::wrapper::Windows::UI::Xaml::Media::RevealBorderBrush* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_RevealBorderBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::RevealBorderBrush>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RevealBorderBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::RevealBorderBrush>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RevealBorderBrush[] = {
        { "_assign_array_", _assign_array_RevealBorderBrush, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RevealBorderBrush), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RevealBorderBrush[] = {
        { }
    };

    static PyType_Slot _type_slots_RevealBorderBrush[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RevealBorderBrush) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RevealBorderBrush) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RevealBorderBrush) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RevealBorderBrush) },
        { }
    };

    static PyType_Spec type_spec_RevealBorderBrush = {
        "winrt._winrt_windows_ui_xaml_media.RevealBorderBrush",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::RevealBorderBrush),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_RevealBorderBrush};

    static PyGetSetDef getset_RevealBorderBrush_Static[] = {
        { }
    };

    static PyMethodDef methods_RevealBorderBrush_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RevealBorderBrush_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RevealBorderBrush_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RevealBorderBrush_Static) },
        { }
    };

    static PyType_Spec type_spec_RevealBorderBrush_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.RevealBorderBrush_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_RevealBorderBrush_Static
    };

    // ----- RevealBrush class --------------------

    struct PyWinrtRevealBrush;
    using BasePyWinrtRevealBrush = winrt::Windows::UI::Xaml::Media::RevealBrushT<PyWinrtRevealBrush, py::IPywinrtObject>;

    struct PyWinrtRevealBrush : py::py_obj_ref, BasePyWinrtRevealBrush
    {

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtRevealBrush* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_RevealBrush(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Media::RevealBrush>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Media::RevealBrush>::type_name);
        return nullptr;
    }

    static void _dealloc_RevealBrush(py::wrapper::Windows::UI::Xaml::Media::RevealBrush* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RevealBrush_GetState(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.RevealBrush", L"GetState", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Media::RevealBrush::GetState(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RevealBrush_SetState(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.RevealBrush", L"SetState", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Media::RevealBrushState>(args, 1);

                winrt::Windows::UI::Xaml::Media::RevealBrush::SetState(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RevealBrush_get_TargetTheme(py::wrapper::Windows::UI::Xaml::Media::RevealBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.RevealBrush", L"TargetTheme");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Media::RevealBrush>().TargetTheme());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RevealBrush_put_TargetTheme(py::wrapper::Windows::UI::Xaml::Media::RevealBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.RevealBrush", L"TargetTheme");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::ApplicationTheme>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Media::RevealBrush>().TargetTheme(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RevealBrush_get_Color(py::wrapper::Windows::UI::Xaml::Media::RevealBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.RevealBrush", L"Color");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Media::RevealBrush>().Color());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RevealBrush_put_Color(py::wrapper::Windows::UI::Xaml::Media::RevealBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.RevealBrush", L"Color");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Media::RevealBrush>().Color(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RevealBrush_get_AlwaysUseFallback(py::wrapper::Windows::UI::Xaml::Media::RevealBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.RevealBrush", L"AlwaysUseFallback");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Media::RevealBrush>().AlwaysUseFallback());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RevealBrush_put_AlwaysUseFallback(py::wrapper::Windows::UI::Xaml::Media::RevealBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.RevealBrush", L"AlwaysUseFallback");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Media::RevealBrush>().AlwaysUseFallback(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RevealBrush_get_AlwaysUseFallbackProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.RevealBrush", L"AlwaysUseFallbackProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::RevealBrush::AlwaysUseFallbackProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RevealBrush_get_ColorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.RevealBrush", L"ColorProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::RevealBrush::ColorProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RevealBrush_get_StateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.RevealBrush", L"StateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::RevealBrush::StateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RevealBrush_get_TargetThemeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.RevealBrush", L"TargetThemeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::RevealBrush::TargetThemeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RevealBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::RevealBrush>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RevealBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::RevealBrush>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RevealBrush[] = {
        { "_assign_array_", _assign_array_RevealBrush, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RevealBrush), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RevealBrush[] = {
        { "target_theme", reinterpret_cast<getter>(RevealBrush_get_TargetTheme), reinterpret_cast<setter>(RevealBrush_put_TargetTheme), nullptr, nullptr },
        { "color", reinterpret_cast<getter>(RevealBrush_get_Color), reinterpret_cast<setter>(RevealBrush_put_Color), nullptr, nullptr },
        { "always_use_fallback", reinterpret_cast<getter>(RevealBrush_get_AlwaysUseFallback), reinterpret_cast<setter>(RevealBrush_put_AlwaysUseFallback), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RevealBrush[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RevealBrush) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RevealBrush) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RevealBrush) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RevealBrush) },
        { }
    };

    static PyType_Spec type_spec_RevealBrush = {
        "winrt._winrt_windows_ui_xaml_media.RevealBrush",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::RevealBrush),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_RevealBrush};

    static PyGetSetDef getset_RevealBrush_Static[] = {
        { "always_use_fallback_property", reinterpret_cast<getter>(RevealBrush_get_AlwaysUseFallbackProperty), nullptr, nullptr, nullptr },
        { "color_property", reinterpret_cast<getter>(RevealBrush_get_ColorProperty), nullptr, nullptr, nullptr },
        { "state_property", reinterpret_cast<getter>(RevealBrush_get_StateProperty), nullptr, nullptr, nullptr },
        { "target_theme_property", reinterpret_cast<getter>(RevealBrush_get_TargetThemeProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_RevealBrush_Static[] = {
        { "get_state", reinterpret_cast<PyCFunction>(RevealBrush_GetState), METH_VARARGS, nullptr },
        { "set_state", reinterpret_cast<PyCFunction>(RevealBrush_SetState), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_RevealBrush_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RevealBrush_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RevealBrush_Static) },
        { }
    };

    static PyType_Spec type_spec_RevealBrush_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.RevealBrush_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_RevealBrush_Static
    };

    // ----- RotateTransform class --------------------

    static PyObject* _new_RotateTransform(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::RotateTransform instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RotateTransform(py::wrapper::Windows::UI::Xaml::Media::RotateTransform* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RotateTransform_get_CenterY(py::wrapper::Windows::UI::Xaml::Media::RotateTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.RotateTransform", L"CenterY");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CenterY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RotateTransform_put_CenterY(py::wrapper::Windows::UI::Xaml::Media::RotateTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.RotateTransform", L"CenterY");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.CenterY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RotateTransform_get_CenterX(py::wrapper::Windows::UI::Xaml::Media::RotateTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.RotateTransform", L"CenterX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CenterX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RotateTransform_put_CenterX(py::wrapper::Windows::UI::Xaml::Media::RotateTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.RotateTransform", L"CenterX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.CenterX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RotateTransform_get_Angle(py::wrapper::Windows::UI::Xaml::Media::RotateTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.RotateTransform", L"Angle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Angle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RotateTransform_put_Angle(py::wrapper::Windows::UI::Xaml::Media::RotateTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.RotateTransform", L"Angle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.Angle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RotateTransform_get_AngleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.RotateTransform", L"AngleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::RotateTransform::AngleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RotateTransform_get_CenterXProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.RotateTransform", L"CenterXProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::RotateTransform::CenterXProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RotateTransform_get_CenterYProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.RotateTransform", L"CenterYProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::RotateTransform::CenterYProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RotateTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::RotateTransform>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RotateTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::RotateTransform>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RotateTransform[] = {
        { "_assign_array_", _assign_array_RotateTransform, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RotateTransform), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RotateTransform[] = {
        { "center_y", reinterpret_cast<getter>(RotateTransform_get_CenterY), reinterpret_cast<setter>(RotateTransform_put_CenterY), nullptr, nullptr },
        { "center_x", reinterpret_cast<getter>(RotateTransform_get_CenterX), reinterpret_cast<setter>(RotateTransform_put_CenterX), nullptr, nullptr },
        { "angle", reinterpret_cast<getter>(RotateTransform_get_Angle), reinterpret_cast<setter>(RotateTransform_put_Angle), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RotateTransform[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RotateTransform) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RotateTransform) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RotateTransform) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RotateTransform) },
        { }
    };

    static PyType_Spec type_spec_RotateTransform = {
        "winrt._winrt_windows_ui_xaml_media.RotateTransform",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::RotateTransform),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RotateTransform};

    static PyGetSetDef getset_RotateTransform_Static[] = {
        { "angle_property", reinterpret_cast<getter>(RotateTransform_get_AngleProperty), nullptr, nullptr, nullptr },
        { "center_x_property", reinterpret_cast<getter>(RotateTransform_get_CenterXProperty), nullptr, nullptr, nullptr },
        { "center_y_property", reinterpret_cast<getter>(RotateTransform_get_CenterYProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_RotateTransform_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RotateTransform_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RotateTransform_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RotateTransform_Static) },
        { }
    };

    static PyType_Spec type_spec_RotateTransform_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.RotateTransform_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RotateTransform_Static
    };

    // ----- ScaleTransform class --------------------

    static PyObject* _new_ScaleTransform(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::ScaleTransform instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ScaleTransform(py::wrapper::Windows::UI::Xaml::Media::ScaleTransform* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScaleTransform_get_ScaleY(py::wrapper::Windows::UI::Xaml::Media::ScaleTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.ScaleTransform", L"ScaleY");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ScaleY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScaleTransform_put_ScaleY(py::wrapper::Windows::UI::Xaml::Media::ScaleTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.ScaleTransform", L"ScaleY");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.ScaleY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScaleTransform_get_ScaleX(py::wrapper::Windows::UI::Xaml::Media::ScaleTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.ScaleTransform", L"ScaleX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ScaleX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScaleTransform_put_ScaleX(py::wrapper::Windows::UI::Xaml::Media::ScaleTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.ScaleTransform", L"ScaleX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.ScaleX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScaleTransform_get_CenterY(py::wrapper::Windows::UI::Xaml::Media::ScaleTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.ScaleTransform", L"CenterY");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CenterY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScaleTransform_put_CenterY(py::wrapper::Windows::UI::Xaml::Media::ScaleTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.ScaleTransform", L"CenterY");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.CenterY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScaleTransform_get_CenterX(py::wrapper::Windows::UI::Xaml::Media::ScaleTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.ScaleTransform", L"CenterX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CenterX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScaleTransform_put_CenterX(py::wrapper::Windows::UI::Xaml::Media::ScaleTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.ScaleTransform", L"CenterX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.CenterX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScaleTransform_get_CenterXProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.ScaleTransform", L"CenterXProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::ScaleTransform::CenterXProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScaleTransform_get_CenterYProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.ScaleTransform", L"CenterYProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::ScaleTransform::CenterYProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScaleTransform_get_ScaleXProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.ScaleTransform", L"ScaleXProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::ScaleTransform::ScaleXProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScaleTransform_get_ScaleYProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.ScaleTransform", L"ScaleYProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::ScaleTransform::ScaleYProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ScaleTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::ScaleTransform>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScaleTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::ScaleTransform>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScaleTransform[] = {
        { "_assign_array_", _assign_array_ScaleTransform, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScaleTransform), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScaleTransform[] = {
        { "scale_y", reinterpret_cast<getter>(ScaleTransform_get_ScaleY), reinterpret_cast<setter>(ScaleTransform_put_ScaleY), nullptr, nullptr },
        { "scale_x", reinterpret_cast<getter>(ScaleTransform_get_ScaleX), reinterpret_cast<setter>(ScaleTransform_put_ScaleX), nullptr, nullptr },
        { "center_y", reinterpret_cast<getter>(ScaleTransform_get_CenterY), reinterpret_cast<setter>(ScaleTransform_put_CenterY), nullptr, nullptr },
        { "center_x", reinterpret_cast<getter>(ScaleTransform_get_CenterX), reinterpret_cast<setter>(ScaleTransform_put_CenterX), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ScaleTransform[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScaleTransform) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScaleTransform) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScaleTransform) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScaleTransform) },
        { }
    };

    static PyType_Spec type_spec_ScaleTransform = {
        "winrt._winrt_windows_ui_xaml_media.ScaleTransform",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::ScaleTransform),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScaleTransform};

    static PyGetSetDef getset_ScaleTransform_Static[] = {
        { "center_x_property", reinterpret_cast<getter>(ScaleTransform_get_CenterXProperty), nullptr, nullptr, nullptr },
        { "center_y_property", reinterpret_cast<getter>(ScaleTransform_get_CenterYProperty), nullptr, nullptr, nullptr },
        { "scale_x_property", reinterpret_cast<getter>(ScaleTransform_get_ScaleXProperty), nullptr, nullptr, nullptr },
        { "scale_y_property", reinterpret_cast<getter>(ScaleTransform_get_ScaleYProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ScaleTransform_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ScaleTransform_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ScaleTransform_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ScaleTransform_Static) },
        { }
    };

    static PyType_Spec type_spec_ScaleTransform_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.ScaleTransform_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ScaleTransform_Static
    };

    // ----- Shadow class --------------------

    static PyObject* _new_Shadow(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Media::Shadow>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Media::Shadow>::type_name);
        return nullptr;
    }

    static void _dealloc_Shadow(py::wrapper::Windows::UI::Xaml::Media::Shadow* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Shadow(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Shadow>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Shadow(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Shadow>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Shadow[] = {
        { "_assign_array_", _assign_array_Shadow, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Shadow), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Shadow[] = {
        { }
    };

    static PyType_Slot _type_slots_Shadow[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Shadow) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Shadow) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Shadow) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Shadow) },
        { }
    };

    static PyType_Spec type_spec_Shadow = {
        "winrt._winrt_windows_ui_xaml_media.Shadow",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Shadow),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_Shadow};

    static PyGetSetDef getset_Shadow_Static[] = {
        { }
    };

    static PyMethodDef methods_Shadow_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Shadow_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Shadow_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Shadow_Static) },
        { }
    };

    static PyType_Spec type_spec_Shadow_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.Shadow_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_Shadow_Static
    };

    // ----- SkewTransform class --------------------

    static PyObject* _new_SkewTransform(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::SkewTransform instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SkewTransform(py::wrapper::Windows::UI::Xaml::Media::SkewTransform* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SkewTransform_get_CenterY(py::wrapper::Windows::UI::Xaml::Media::SkewTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.SkewTransform", L"CenterY");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CenterY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SkewTransform_put_CenterY(py::wrapper::Windows::UI::Xaml::Media::SkewTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.SkewTransform", L"CenterY");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.CenterY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SkewTransform_get_CenterX(py::wrapper::Windows::UI::Xaml::Media::SkewTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.SkewTransform", L"CenterX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CenterX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SkewTransform_put_CenterX(py::wrapper::Windows::UI::Xaml::Media::SkewTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.SkewTransform", L"CenterX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.CenterX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SkewTransform_get_AngleY(py::wrapper::Windows::UI::Xaml::Media::SkewTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.SkewTransform", L"AngleY");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AngleY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SkewTransform_put_AngleY(py::wrapper::Windows::UI::Xaml::Media::SkewTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.SkewTransform", L"AngleY");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.AngleY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SkewTransform_get_AngleX(py::wrapper::Windows::UI::Xaml::Media::SkewTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.SkewTransform", L"AngleX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AngleX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SkewTransform_put_AngleX(py::wrapper::Windows::UI::Xaml::Media::SkewTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.SkewTransform", L"AngleX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.AngleX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SkewTransform_get_AngleXProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.SkewTransform", L"AngleXProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::SkewTransform::AngleXProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SkewTransform_get_AngleYProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.SkewTransform", L"AngleYProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::SkewTransform::AngleYProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SkewTransform_get_CenterXProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.SkewTransform", L"CenterXProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::SkewTransform::CenterXProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SkewTransform_get_CenterYProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.SkewTransform", L"CenterYProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::SkewTransform::CenterYProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SkewTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::SkewTransform>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SkewTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::SkewTransform>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SkewTransform[] = {
        { "_assign_array_", _assign_array_SkewTransform, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SkewTransform), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SkewTransform[] = {
        { "center_y", reinterpret_cast<getter>(SkewTransform_get_CenterY), reinterpret_cast<setter>(SkewTransform_put_CenterY), nullptr, nullptr },
        { "center_x", reinterpret_cast<getter>(SkewTransform_get_CenterX), reinterpret_cast<setter>(SkewTransform_put_CenterX), nullptr, nullptr },
        { "angle_y", reinterpret_cast<getter>(SkewTransform_get_AngleY), reinterpret_cast<setter>(SkewTransform_put_AngleY), nullptr, nullptr },
        { "angle_x", reinterpret_cast<getter>(SkewTransform_get_AngleX), reinterpret_cast<setter>(SkewTransform_put_AngleX), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SkewTransform[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SkewTransform) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SkewTransform) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SkewTransform) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SkewTransform) },
        { }
    };

    static PyType_Spec type_spec_SkewTransform = {
        "winrt._winrt_windows_ui_xaml_media.SkewTransform",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::SkewTransform),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SkewTransform};

    static PyGetSetDef getset_SkewTransform_Static[] = {
        { "angle_x_property", reinterpret_cast<getter>(SkewTransform_get_AngleXProperty), nullptr, nullptr, nullptr },
        { "angle_y_property", reinterpret_cast<getter>(SkewTransform_get_AngleYProperty), nullptr, nullptr, nullptr },
        { "center_x_property", reinterpret_cast<getter>(SkewTransform_get_CenterXProperty), nullptr, nullptr, nullptr },
        { "center_y_property", reinterpret_cast<getter>(SkewTransform_get_CenterYProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_SkewTransform_Static[] = {
        { }
    };

    static PyType_Slot type_slots_SkewTransform_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SkewTransform_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SkewTransform_Static) },
        { }
    };

    static PyType_Spec type_spec_SkewTransform_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.SkewTransform_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SkewTransform_Static
    };

    // ----- SolidColorBrush class --------------------

    static PyObject* _new_SolidColorBrush(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Color>(args, 0);

                winrt::Windows::UI::Xaml::Media::SolidColorBrush instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::SolidColorBrush instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SolidColorBrush(py::wrapper::Windows::UI::Xaml::Media::SolidColorBrush* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SolidColorBrush_get_Color(py::wrapper::Windows::UI::Xaml::Media::SolidColorBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.SolidColorBrush", L"Color");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Color());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SolidColorBrush_put_Color(py::wrapper::Windows::UI::Xaml::Media::SolidColorBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.SolidColorBrush", L"Color");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Color(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SolidColorBrush_get_ColorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.SolidColorBrush", L"ColorProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::SolidColorBrush::ColorProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SolidColorBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::SolidColorBrush>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SolidColorBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::SolidColorBrush>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SolidColorBrush[] = {
        { "_assign_array_", _assign_array_SolidColorBrush, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SolidColorBrush), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SolidColorBrush[] = {
        { "color", reinterpret_cast<getter>(SolidColorBrush_get_Color), reinterpret_cast<setter>(SolidColorBrush_put_Color), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SolidColorBrush[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SolidColorBrush) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SolidColorBrush) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SolidColorBrush) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SolidColorBrush) },
        { }
    };

    static PyType_Spec type_spec_SolidColorBrush = {
        "winrt._winrt_windows_ui_xaml_media.SolidColorBrush",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::SolidColorBrush),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SolidColorBrush};

    static PyGetSetDef getset_SolidColorBrush_Static[] = {
        { "color_property", reinterpret_cast<getter>(SolidColorBrush_get_ColorProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_SolidColorBrush_Static[] = {
        { }
    };

    static PyType_Slot type_slots_SolidColorBrush_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SolidColorBrush_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SolidColorBrush_Static) },
        { }
    };

    static PyType_Spec type_spec_SolidColorBrush_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.SolidColorBrush_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SolidColorBrush_Static
    };

    // ----- ThemeShadow class --------------------

    struct PyWinrtThemeShadow;
    using BasePyWinrtThemeShadow = winrt::Windows::UI::Xaml::Media::ThemeShadowT<PyWinrtThemeShadow, py::IPywinrtObject>;

    struct PyWinrtThemeShadow : py::py_obj_ref, BasePyWinrtThemeShadow
    {
        PyWinrtThemeShadow(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtThemeShadow() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtThemeShadow* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_ThemeShadow(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Media::ThemeShadow>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Media::ThemeShadow*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Media::ThemeShadow*>(self.get())->obj = winrt::make<PyWinrtThemeShadow>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Media::ThemeShadow instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ThemeShadow(py::wrapper::Windows::UI::Xaml::Media::ThemeShadow* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ThemeShadow_get_Receivers(py::wrapper::Windows::UI::Xaml::Media::ThemeShadow* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.ThemeShadow", L"Receivers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Media::ThemeShadow>().Receivers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ThemeShadow(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::ThemeShadow>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ThemeShadow(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::ThemeShadow>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ThemeShadow[] = {
        { "_assign_array_", _assign_array_ThemeShadow, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ThemeShadow), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ThemeShadow[] = {
        { "receivers", reinterpret_cast<getter>(ThemeShadow_get_Receivers), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ThemeShadow[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ThemeShadow) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ThemeShadow) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ThemeShadow) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ThemeShadow) },
        { }
    };

    static PyType_Spec type_spec_ThemeShadow = {
        "winrt._winrt_windows_ui_xaml_media.ThemeShadow",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::ThemeShadow),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ThemeShadow};

    static PyGetSetDef getset_ThemeShadow_Static[] = {
        { }
    };

    static PyMethodDef methods_ThemeShadow_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ThemeShadow_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ThemeShadow_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ThemeShadow_Static) },
        { }
    };

    static PyType_Spec type_spec_ThemeShadow_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.ThemeShadow_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ThemeShadow_Static
    };

    // ----- TileBrush class --------------------

    struct PyWinrtTileBrush;
    using BasePyWinrtTileBrush = winrt::Windows::UI::Xaml::Media::TileBrushT<PyWinrtTileBrush, py::IPywinrtObject>;

    struct PyWinrtTileBrush : py::py_obj_ref, BasePyWinrtTileBrush
    {

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtTileBrush* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_TileBrush(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Media::TileBrush>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Media::TileBrush>::type_name);
        return nullptr;
    }

    static void _dealloc_TileBrush(py::wrapper::Windows::UI::Xaml::Media::TileBrush* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TileBrush_get_Stretch(py::wrapper::Windows::UI::Xaml::Media::TileBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.TileBrush", L"Stretch");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Media::TileBrush>().Stretch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TileBrush_put_Stretch(py::wrapper::Windows::UI::Xaml::Media::TileBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.TileBrush", L"Stretch");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Stretch>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Media::TileBrush>().Stretch(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TileBrush_get_AlignmentY(py::wrapper::Windows::UI::Xaml::Media::TileBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.TileBrush", L"AlignmentY");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Media::TileBrush>().AlignmentY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TileBrush_put_AlignmentY(py::wrapper::Windows::UI::Xaml::Media::TileBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.TileBrush", L"AlignmentY");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::AlignmentY>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Media::TileBrush>().AlignmentY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TileBrush_get_AlignmentX(py::wrapper::Windows::UI::Xaml::Media::TileBrush* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.TileBrush", L"AlignmentX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Media::TileBrush>().AlignmentX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TileBrush_put_AlignmentX(py::wrapper::Windows::UI::Xaml::Media::TileBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.TileBrush", L"AlignmentX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::AlignmentX>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Media::TileBrush>().AlignmentX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TileBrush_get_AlignmentXProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.TileBrush", L"AlignmentXProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::TileBrush::AlignmentXProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TileBrush_get_AlignmentYProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.TileBrush", L"AlignmentYProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::TileBrush::AlignmentYProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TileBrush_get_StretchProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.TileBrush", L"StretchProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::TileBrush::StretchProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TileBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::TileBrush>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TileBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::TileBrush>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TileBrush[] = {
        { "_assign_array_", _assign_array_TileBrush, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TileBrush), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TileBrush[] = {
        { "stretch", reinterpret_cast<getter>(TileBrush_get_Stretch), reinterpret_cast<setter>(TileBrush_put_Stretch), nullptr, nullptr },
        { "alignment_y", reinterpret_cast<getter>(TileBrush_get_AlignmentY), reinterpret_cast<setter>(TileBrush_put_AlignmentY), nullptr, nullptr },
        { "alignment_x", reinterpret_cast<getter>(TileBrush_get_AlignmentX), reinterpret_cast<setter>(TileBrush_put_AlignmentX), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TileBrush[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TileBrush) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TileBrush) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TileBrush) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TileBrush) },
        { }
    };

    static PyType_Spec type_spec_TileBrush = {
        "winrt._winrt_windows_ui_xaml_media.TileBrush",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::TileBrush),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_TileBrush};

    static PyGetSetDef getset_TileBrush_Static[] = {
        { "alignment_x_property", reinterpret_cast<getter>(TileBrush_get_AlignmentXProperty), nullptr, nullptr, nullptr },
        { "alignment_y_property", reinterpret_cast<getter>(TileBrush_get_AlignmentYProperty), nullptr, nullptr, nullptr },
        { "stretch_property", reinterpret_cast<getter>(TileBrush_get_StretchProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_TileBrush_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TileBrush_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TileBrush_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TileBrush_Static) },
        { }
    };

    static PyType_Spec type_spec_TileBrush_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.TileBrush_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_TileBrush_Static
    };

    // ----- TimelineMarker class --------------------

    static PyObject* _new_TimelineMarker(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::TimelineMarker instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimelineMarker(py::wrapper::Windows::UI::Xaml::Media::TimelineMarker* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimelineMarker_get_Type(py::wrapper::Windows::UI::Xaml::Media::TimelineMarker* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.TimelineMarker", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimelineMarker_put_Type(py::wrapper::Windows::UI::Xaml::Media::TimelineMarker* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.TimelineMarker", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Type(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimelineMarker_get_Time(py::wrapper::Windows::UI::Xaml::Media::TimelineMarker* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.TimelineMarker", L"Time");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Time());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimelineMarker_put_Time(py::wrapper::Windows::UI::Xaml::Media::TimelineMarker* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.TimelineMarker", L"Time");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Time(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimelineMarker_get_Text(py::wrapper::Windows::UI::Xaml::Media::TimelineMarker* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.TimelineMarker", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimelineMarker_put_Text(py::wrapper::Windows::UI::Xaml::Media::TimelineMarker* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.TimelineMarker", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimelineMarker_get_TextProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.TimelineMarker", L"TextProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::TimelineMarker::TextProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimelineMarker_get_TimeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.TimelineMarker", L"TimeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::TimelineMarker::TimeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimelineMarker_get_TypeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.TimelineMarker", L"TypeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::TimelineMarker::TypeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TimelineMarker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::TimelineMarker>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimelineMarker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::TimelineMarker>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimelineMarker[] = {
        { "_assign_array_", _assign_array_TimelineMarker, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimelineMarker), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimelineMarker[] = {
        { "type", reinterpret_cast<getter>(TimelineMarker_get_Type), reinterpret_cast<setter>(TimelineMarker_put_Type), nullptr, nullptr },
        { "time", reinterpret_cast<getter>(TimelineMarker_get_Time), reinterpret_cast<setter>(TimelineMarker_put_Time), nullptr, nullptr },
        { "text", reinterpret_cast<getter>(TimelineMarker_get_Text), reinterpret_cast<setter>(TimelineMarker_put_Text), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimelineMarker[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimelineMarker) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimelineMarker) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimelineMarker) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimelineMarker) },
        { }
    };

    static PyType_Spec type_spec_TimelineMarker = {
        "winrt._winrt_windows_ui_xaml_media.TimelineMarker",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::TimelineMarker),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimelineMarker};

    static PyGetSetDef getset_TimelineMarker_Static[] = {
        { "text_property", reinterpret_cast<getter>(TimelineMarker_get_TextProperty), nullptr, nullptr, nullptr },
        { "time_property", reinterpret_cast<getter>(TimelineMarker_get_TimeProperty), nullptr, nullptr, nullptr },
        { "type_property", reinterpret_cast<getter>(TimelineMarker_get_TypeProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_TimelineMarker_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TimelineMarker_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TimelineMarker_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TimelineMarker_Static) },
        { }
    };

    static PyType_Spec type_spec_TimelineMarker_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.TimelineMarker_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TimelineMarker_Static
    };

    // ----- TimelineMarkerCollection class --------------------

    static PyObject* _new_TimelineMarkerCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::TimelineMarkerCollection instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimelineMarkerCollection(py::wrapper::Windows::UI::Xaml::Media::TimelineMarkerCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimelineMarkerCollection_Append(py::wrapper::Windows::UI::Xaml::Media::TimelineMarkerCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.TimelineMarkerCollection", L"Append", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::TimelineMarker>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimelineMarkerCollection_Clear(py::wrapper::Windows::UI::Xaml::Media::TimelineMarkerCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.TimelineMarkerCollection", L"Clear", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimelineMarkerCollection_First(py::wrapper::Windows::UI::Xaml::Media::TimelineMarkerCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.TimelineMarkerCollection", L"First", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimelineMarkerCollection_GetAt(py::wrapper::Windows::UI::Xaml::Media::TimelineMarkerCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.TimelineMarkerCollection", L"GetAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimelineMarkerCollection_GetMany(py::wrapper::Windows::UI::Xaml::Media::TimelineMarkerCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.TimelineMarkerCollection", L"GetMany", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Media::TimelineMarker, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimelineMarkerCollection_GetView(py::wrapper::Windows::UI::Xaml::Media::TimelineMarkerCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.TimelineMarkerCollection", L"GetView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimelineMarkerCollection_IndexOf(py::wrapper::Windows::UI::Xaml::Media::TimelineMarkerCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.TimelineMarkerCollection", L"IndexOf", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::TimelineMarker>(args, 0);
                uint32_t param1{};

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimelineMarkerCollection_InsertAt(py::wrapper::Windows::UI::Xaml::Media::TimelineMarkerCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.TimelineMarkerCollection", L"InsertAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Media::TimelineMarker>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimelineMarkerCollection_RemoveAt(py::wrapper::Windows::UI::Xaml::Media::TimelineMarkerCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.TimelineMarkerCollection", L"RemoveAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimelineMarkerCollection_RemoveAtEnd(py::wrapper::Windows::UI::Xaml::Media::TimelineMarkerCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.TimelineMarkerCollection", L"RemoveAtEnd", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimelineMarkerCollection_ReplaceAll(py::wrapper::Windows::UI::Xaml::Media::TimelineMarkerCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.TimelineMarkerCollection", L"ReplaceAll", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Media::TimelineMarker, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimelineMarkerCollection_SetAt(py::wrapper::Windows::UI::Xaml::Media::TimelineMarkerCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.TimelineMarkerCollection", L"SetAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Media::TimelineMarker>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimelineMarkerCollection_get_Size(py::wrapper::Windows::UI::Xaml::Media::TimelineMarkerCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.TimelineMarkerCollection", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TimelineMarkerCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::TimelineMarkerCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimelineMarkerCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::TimelineMarkerCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_TimelineMarkerCollection(py::wrapper::Windows::UI::Xaml::Media::TimelineMarkerCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_TimelineMarkerCollection(py::wrapper::Windows::UI::Xaml::Media::TimelineMarkerCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_TimelineMarkerCollection(py::wrapper::Windows::UI::Xaml::Media::TimelineMarkerCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_TimelineMarkerCollection(py::wrapper::Windows::UI::Xaml::Media::TimelineMarkerCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_TimelineMarkerCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(PyExc_TypeError, "indices must be integers, not '%s'", Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(slice, self->obj.Size(), &start, &stop, &step, &length) < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(PyExc_NotImplementedError, "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::UI::Xaml::Media::TimelineMarker> items(static_cast<uint32_t>(length), empty_instance<winrt::Windows::UI::Xaml::Media::TimelineMarker>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(PyExc_RuntimeError, "returned count %d did not match requested length %zd", count, length);
                return nullptr;
            }

            return convert(items);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_TimelineMarkerCollection(py::wrapper::Windows::UI::Xaml::Media::TimelineMarkerCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (!value)
            {
                self->obj.RemoveAt(static_cast<uint32_t>(i));
            }
            else
            {
                self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::UI::Xaml::Media::TimelineMarker>(value));
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_TimelineMarkerCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(TimelineMarkerCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(TimelineMarkerCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(TimelineMarkerCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(TimelineMarkerCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(TimelineMarkerCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(TimelineMarkerCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(TimelineMarkerCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(TimelineMarkerCollection_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(TimelineMarkerCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(TimelineMarkerCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(TimelineMarkerCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(TimelineMarkerCollection_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TimelineMarkerCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimelineMarkerCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimelineMarkerCollection[] = {
        { "size", reinterpret_cast<getter>(TimelineMarkerCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimelineMarkerCollection[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimelineMarkerCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimelineMarkerCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimelineMarkerCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimelineMarkerCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_TimelineMarkerCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_TimelineMarkerCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_TimelineMarkerCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_TimelineMarkerCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_TimelineMarkerCollection) },
        { }
    };

    static PyType_Spec type_spec_TimelineMarkerCollection = {
        "winrt._winrt_windows_ui_xaml_media.TimelineMarkerCollection",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::TimelineMarkerCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimelineMarkerCollection};

    // ----- TimelineMarkerRoutedEventArgs class --------------------

    static PyObject* _new_TimelineMarkerRoutedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::TimelineMarkerRoutedEventArgs instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimelineMarkerRoutedEventArgs(py::wrapper::Windows::UI::Xaml::Media::TimelineMarkerRoutedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimelineMarkerRoutedEventArgs_get_Marker(py::wrapper::Windows::UI::Xaml::Media::TimelineMarkerRoutedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.TimelineMarkerRoutedEventArgs", L"Marker");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Marker());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimelineMarkerRoutedEventArgs_put_Marker(py::wrapper::Windows::UI::Xaml::Media::TimelineMarkerRoutedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.TimelineMarkerRoutedEventArgs", L"Marker");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::TimelineMarker>(arg);

            self->obj.Marker(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_TimelineMarkerRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::TimelineMarkerRoutedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimelineMarkerRoutedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::TimelineMarkerRoutedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimelineMarkerRoutedEventArgs[] = {
        { "_assign_array_", _assign_array_TimelineMarkerRoutedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimelineMarkerRoutedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimelineMarkerRoutedEventArgs[] = {
        { "marker", reinterpret_cast<getter>(TimelineMarkerRoutedEventArgs_get_Marker), reinterpret_cast<setter>(TimelineMarkerRoutedEventArgs_put_Marker), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimelineMarkerRoutedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimelineMarkerRoutedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimelineMarkerRoutedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimelineMarkerRoutedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimelineMarkerRoutedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_TimelineMarkerRoutedEventArgs = {
        "winrt._winrt_windows_ui_xaml_media.TimelineMarkerRoutedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::TimelineMarkerRoutedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimelineMarkerRoutedEventArgs};

    // ----- Transform class --------------------

    static PyObject* _new_Transform(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Media::Transform>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Media::Transform>::type_name);
        return nullptr;
    }

    static void _dealloc_Transform(py::wrapper::Windows::UI::Xaml::Media::Transform* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Transform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Transform>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Transform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::Transform>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Transform[] = {
        { "_assign_array_", _assign_array_Transform, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Transform), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Transform[] = {
        { }
    };

    static PyType_Slot _type_slots_Transform[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Transform) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Transform) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Transform) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Transform) },
        { }
    };

    static PyType_Spec type_spec_Transform = {
        "winrt._winrt_windows_ui_xaml_media.Transform",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Transform),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_Transform};

    static PyGetSetDef getset_Transform_Static[] = {
        { }
    };

    static PyMethodDef methods_Transform_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Transform_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Transform_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Transform_Static) },
        { }
    };

    static PyType_Spec type_spec_Transform_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.Transform_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_Transform_Static
    };

    // ----- TransformCollection class --------------------

    static PyObject* _new_TransformCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::TransformCollection instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TransformCollection(py::wrapper::Windows::UI::Xaml::Media::TransformCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TransformCollection_Append(py::wrapper::Windows::UI::Xaml::Media::TransformCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.TransformCollection", L"Append", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Transform>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TransformCollection_Clear(py::wrapper::Windows::UI::Xaml::Media::TransformCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.TransformCollection", L"Clear", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TransformCollection_First(py::wrapper::Windows::UI::Xaml::Media::TransformCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.TransformCollection", L"First", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TransformCollection_GetAt(py::wrapper::Windows::UI::Xaml::Media::TransformCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.TransformCollection", L"GetAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TransformCollection_GetMany(py::wrapper::Windows::UI::Xaml::Media::TransformCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.TransformCollection", L"GetMany", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Media::Transform, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TransformCollection_GetView(py::wrapper::Windows::UI::Xaml::Media::TransformCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.TransformCollection", L"GetView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TransformCollection_IndexOf(py::wrapper::Windows::UI::Xaml::Media::TransformCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.TransformCollection", L"IndexOf", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::Transform>(args, 0);
                uint32_t param1{};

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TransformCollection_InsertAt(py::wrapper::Windows::UI::Xaml::Media::TransformCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.TransformCollection", L"InsertAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Media::Transform>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TransformCollection_RemoveAt(py::wrapper::Windows::UI::Xaml::Media::TransformCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.TransformCollection", L"RemoveAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TransformCollection_RemoveAtEnd(py::wrapper::Windows::UI::Xaml::Media::TransformCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.TransformCollection", L"RemoveAtEnd", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TransformCollection_ReplaceAll(py::wrapper::Windows::UI::Xaml::Media::TransformCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.TransformCollection", L"ReplaceAll", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::UI::Xaml::Media::Transform, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TransformCollection_SetAt(py::wrapper::Windows::UI::Xaml::Media::TransformCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.TransformCollection", L"SetAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Media::Transform>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TransformCollection_get_Size(py::wrapper::Windows::UI::Xaml::Media::TransformCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.TransformCollection", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TransformCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::TransformCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TransformCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::TransformCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_TransformCollection(py::wrapper::Windows::UI::Xaml::Media::TransformCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_TransformCollection(py::wrapper::Windows::UI::Xaml::Media::TransformCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_TransformCollection(py::wrapper::Windows::UI::Xaml::Media::TransformCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_TransformCollection(py::wrapper::Windows::UI::Xaml::Media::TransformCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_TransformCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(PyExc_TypeError, "indices must be integers, not '%s'", Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(slice, self->obj.Size(), &start, &stop, &step, &length) < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(PyExc_NotImplementedError, "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::UI::Xaml::Media::Transform> items(static_cast<uint32_t>(length), empty_instance<winrt::Windows::UI::Xaml::Media::Transform>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(PyExc_RuntimeError, "returned count %d did not match requested length %zd", count, length);
                return nullptr;
            }

            return convert(items);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_TransformCollection(py::wrapper::Windows::UI::Xaml::Media::TransformCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (!value)
            {
                self->obj.RemoveAt(static_cast<uint32_t>(i));
            }
            else
            {
                self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::UI::Xaml::Media::Transform>(value));
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_TransformCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(TransformCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(TransformCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(TransformCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(TransformCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(TransformCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(TransformCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(TransformCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(TransformCollection_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(TransformCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(TransformCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(TransformCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(TransformCollection_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TransformCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TransformCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TransformCollection[] = {
        { "size", reinterpret_cast<getter>(TransformCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TransformCollection[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TransformCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TransformCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TransformCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TransformCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_TransformCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_TransformCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_TransformCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_TransformCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_TransformCollection) },
        { }
    };

    static PyType_Spec type_spec_TransformCollection = {
        "winrt._winrt_windows_ui_xaml_media.TransformCollection",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::TransformCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TransformCollection};

    // ----- TransformGroup class --------------------

    static PyObject* _new_TransformGroup(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::TransformGroup instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TransformGroup(py::wrapper::Windows::UI::Xaml::Media::TransformGroup* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TransformGroup_get_Children(py::wrapper::Windows::UI::Xaml::Media::TransformGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.TransformGroup", L"Children");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Children());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TransformGroup_put_Children(py::wrapper::Windows::UI::Xaml::Media::TransformGroup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.TransformGroup", L"Children");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Media::TransformCollection>(arg);

            self->obj.Children(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TransformGroup_get_Value(py::wrapper::Windows::UI::Xaml::Media::TransformGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.TransformGroup", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TransformGroup_get_ChildrenProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.TransformGroup", L"ChildrenProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::TransformGroup::ChildrenProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TransformGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::TransformGroup>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TransformGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::TransformGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TransformGroup[] = {
        { "_assign_array_", _assign_array_TransformGroup, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TransformGroup), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TransformGroup[] = {
        { "children", reinterpret_cast<getter>(TransformGroup_get_Children), reinterpret_cast<setter>(TransformGroup_put_Children), nullptr, nullptr },
        { "value", reinterpret_cast<getter>(TransformGroup_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TransformGroup[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TransformGroup) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TransformGroup) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TransformGroup) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TransformGroup) },
        { }
    };

    static PyType_Spec type_spec_TransformGroup = {
        "winrt._winrt_windows_ui_xaml_media.TransformGroup",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::TransformGroup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TransformGroup};

    static PyGetSetDef getset_TransformGroup_Static[] = {
        { "children_property", reinterpret_cast<getter>(TransformGroup_get_ChildrenProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_TransformGroup_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TransformGroup_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TransformGroup_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TransformGroup_Static) },
        { }
    };

    static PyType_Spec type_spec_TransformGroup_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.TransformGroup_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TransformGroup_Static
    };

    // ----- TranslateTransform class --------------------

    static PyObject* _new_TranslateTransform(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Xaml::Media::TranslateTransform instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TranslateTransform(py::wrapper::Windows::UI::Xaml::Media::TranslateTransform* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TranslateTransform_get_Y(py::wrapper::Windows::UI::Xaml::Media::TranslateTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.TranslateTransform", L"Y");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Y());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TranslateTransform_put_Y(py::wrapper::Windows::UI::Xaml::Media::TranslateTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.TranslateTransform", L"Y");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.Y(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TranslateTransform_get_X(py::wrapper::Windows::UI::Xaml::Media::TranslateTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.TranslateTransform", L"X");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.X());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TranslateTransform_put_X(py::wrapper::Windows::UI::Xaml::Media::TranslateTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.TranslateTransform", L"X");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            self->obj.X(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TranslateTransform_get_XProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.TranslateTransform", L"XProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::TranslateTransform::XProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TranslateTransform_get_YProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.TranslateTransform", L"YProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::TranslateTransform::YProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TranslateTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::TranslateTransform>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TranslateTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::TranslateTransform>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TranslateTransform[] = {
        { "_assign_array_", _assign_array_TranslateTransform, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TranslateTransform), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TranslateTransform[] = {
        { "y", reinterpret_cast<getter>(TranslateTransform_get_Y), reinterpret_cast<setter>(TranslateTransform_put_Y), nullptr, nullptr },
        { "x", reinterpret_cast<getter>(TranslateTransform_get_X), reinterpret_cast<setter>(TranslateTransform_put_X), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TranslateTransform[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TranslateTransform) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TranslateTransform) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TranslateTransform) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TranslateTransform) },
        { }
    };

    static PyType_Spec type_spec_TranslateTransform = {
        "winrt._winrt_windows_ui_xaml_media.TranslateTransform",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::TranslateTransform),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TranslateTransform};

    static PyGetSetDef getset_TranslateTransform_Static[] = {
        { "x_property", reinterpret_cast<getter>(TranslateTransform_get_XProperty), nullptr, nullptr, nullptr },
        { "y_property", reinterpret_cast<getter>(TranslateTransform_get_YProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_TranslateTransform_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TranslateTransform_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TranslateTransform_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TranslateTransform_Static) },
        { }
    };

    static PyType_Spec type_spec_TranslateTransform_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.TranslateTransform_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TranslateTransform_Static
    };

    // ----- VisualTreeHelper class --------------------

    static PyObject* _new_VisualTreeHelper(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Media::VisualTreeHelper>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Media::VisualTreeHelper>::type_name);
        return nullptr;
    }

    static void _dealloc_VisualTreeHelper(py::wrapper::Windows::UI::Xaml::Media::VisualTreeHelper* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VisualTreeHelper_DisconnectChildrenRecursive(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.VisualTreeHelper", L"DisconnectChildrenRecursive", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 0);

                winrt::Windows::UI::Xaml::Media::VisualTreeHelper::DisconnectChildrenRecursive(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualTreeHelper_FindAllElementsInHostCoordinatesPoint(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.VisualTreeHelper", L"FindElementsInHostCoordinates", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                return py::convert(winrt::Windows::UI::Xaml::Media::VisualTreeHelper::FindElementsInHostCoordinates(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualTreeHelper_FindAllElementsInHostCoordinatesRect(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.VisualTreeHelper", L"FindElementsInHostCoordinates", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                return py::convert(winrt::Windows::UI::Xaml::Media::VisualTreeHelper::FindElementsInHostCoordinates(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualTreeHelper_FindElementsInHostCoordinatesPoint(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.VisualTreeHelper", L"FindElementsInHostCoordinates", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 1);

                return py::convert(winrt::Windows::UI::Xaml::Media::VisualTreeHelper::FindElementsInHostCoordinates(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualTreeHelper_FindElementsInHostCoordinatesRect(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.VisualTreeHelper", L"FindElementsInHostCoordinates", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 1);

                return py::convert(winrt::Windows::UI::Xaml::Media::VisualTreeHelper::FindElementsInHostCoordinates(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualTreeHelper_GetChild(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.VisualTreeHelper", L"GetChild", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(winrt::Windows::UI::Xaml::Media::VisualTreeHelper::GetChild(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualTreeHelper_GetChildrenCount(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.VisualTreeHelper", L"GetChildrenCount", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Media::VisualTreeHelper::GetChildrenCount(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualTreeHelper_GetOpenPopups(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.VisualTreeHelper", L"GetOpenPopups", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Window>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Media::VisualTreeHelper::GetOpenPopups(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualTreeHelper_GetOpenPopupsForXamlRoot(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.VisualTreeHelper", L"GetOpenPopupsForXamlRoot", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::XamlRoot>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Media::VisualTreeHelper::GetOpenPopupsForXamlRoot(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualTreeHelper_GetParent(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.VisualTreeHelper", L"GetParent", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Windows::UI::Xaml::Media::VisualTreeHelper::GetParent(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_VisualTreeHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::VisualTreeHelper>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VisualTreeHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::VisualTreeHelper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VisualTreeHelper[] = {
        { "_assign_array_", _assign_array_VisualTreeHelper, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VisualTreeHelper), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VisualTreeHelper[] = {
        { }
    };

    static PyType_Slot _type_slots_VisualTreeHelper[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VisualTreeHelper) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VisualTreeHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VisualTreeHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VisualTreeHelper) },
        { }
    };

    static PyType_Spec type_spec_VisualTreeHelper = {
        "winrt._winrt_windows_ui_xaml_media.VisualTreeHelper",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::VisualTreeHelper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VisualTreeHelper};

    static PyGetSetDef getset_VisualTreeHelper_Static[] = {
        { }
    };

    static PyMethodDef methods_VisualTreeHelper_Static[] = {
        { "disconnect_children_recursive", reinterpret_cast<PyCFunction>(VisualTreeHelper_DisconnectChildrenRecursive), METH_VARARGS, nullptr },
        { "find_all_elements_in_host_coordinates_point", reinterpret_cast<PyCFunction>(VisualTreeHelper_FindAllElementsInHostCoordinatesPoint), METH_VARARGS, nullptr },
        { "find_all_elements_in_host_coordinates_rect", reinterpret_cast<PyCFunction>(VisualTreeHelper_FindAllElementsInHostCoordinatesRect), METH_VARARGS, nullptr },
        { "find_elements_in_host_coordinates_point", reinterpret_cast<PyCFunction>(VisualTreeHelper_FindElementsInHostCoordinatesPoint), METH_VARARGS, nullptr },
        { "find_elements_in_host_coordinates_rect", reinterpret_cast<PyCFunction>(VisualTreeHelper_FindElementsInHostCoordinatesRect), METH_VARARGS, nullptr },
        { "get_child", reinterpret_cast<PyCFunction>(VisualTreeHelper_GetChild), METH_VARARGS, nullptr },
        { "get_children_count", reinterpret_cast<PyCFunction>(VisualTreeHelper_GetChildrenCount), METH_VARARGS, nullptr },
        { "get_open_popups", reinterpret_cast<PyCFunction>(VisualTreeHelper_GetOpenPopups), METH_VARARGS, nullptr },
        { "get_open_popups_for_xaml_root", reinterpret_cast<PyCFunction>(VisualTreeHelper_GetOpenPopupsForXamlRoot), METH_VARARGS, nullptr },
        { "get_parent", reinterpret_cast<PyCFunction>(VisualTreeHelper_GetParent), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_VisualTreeHelper_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_VisualTreeHelper_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_VisualTreeHelper_Static) },
        { }
    };

    static PyType_Spec type_spec_VisualTreeHelper_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.VisualTreeHelper_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_VisualTreeHelper_Static
    };

    // ----- XamlCompositionBrushBase class --------------------

    struct PyWinrtXamlCompositionBrushBase;
    using BasePyWinrtXamlCompositionBrushBase = winrt::Windows::UI::Xaml::Media::XamlCompositionBrushBaseT<PyWinrtXamlCompositionBrushBase, py::IPywinrtObject>;

    struct PyWinrtXamlCompositionBrushBase : py::py_obj_ref, BasePyWinrtXamlCompositionBrushBase
    {

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtXamlCompositionBrushBase* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_XamlCompositionBrushBase(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Media::XamlCompositionBrushBase>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Media::XamlCompositionBrushBase>::type_name);
        return nullptr;
    }

    static void _dealloc_XamlCompositionBrushBase(py::wrapper::Windows::UI::Xaml::Media::XamlCompositionBrushBase* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* XamlCompositionBrushBase_OnConnected(PyObject* /*unused*/, PyObject* /* unused */) noexcept
    {
        PyErr_SetString(PyExc_RuntimeError, "cannot call protected method");
        return nullptr;
    }

    static PyObject* XamlCompositionBrushBase_OnDisconnected(PyObject* /*unused*/, PyObject* /* unused */) noexcept
    {
        PyErr_SetString(PyExc_RuntimeError, "cannot call protected method");
        return nullptr;
    }

    static PyObject* XamlCompositionBrushBase_get_FallbackColor(py::wrapper::Windows::UI::Xaml::Media::XamlCompositionBrushBase* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.XamlCompositionBrushBase", L"FallbackColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.try_as<winrt::Windows::UI::Xaml::Media::XamlCompositionBrushBase>().FallbackColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int XamlCompositionBrushBase_put_FallbackColor(py::wrapper::Windows::UI::Xaml::Media::XamlCompositionBrushBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.XamlCompositionBrushBase", L"FallbackColor");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.try_as<winrt::Windows::UI::Xaml::Media::XamlCompositionBrushBase>().FallbackColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* XamlCompositionBrushBase_get_FallbackColorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Media.XamlCompositionBrushBase", L"FallbackColorProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::UI::Xaml::Media::XamlCompositionBrushBase::FallbackColorProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_XamlCompositionBrushBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::XamlCompositionBrushBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XamlCompositionBrushBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::XamlCompositionBrushBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XamlCompositionBrushBase[] = {
        { "_on_connected", reinterpret_cast<PyCFunction>(XamlCompositionBrushBase_OnConnected), METH_VARARGS, nullptr },
        { "_on_disconnected", reinterpret_cast<PyCFunction>(XamlCompositionBrushBase_OnDisconnected), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_XamlCompositionBrushBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XamlCompositionBrushBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_XamlCompositionBrushBase[] = {
        { "fallback_color", reinterpret_cast<getter>(XamlCompositionBrushBase_get_FallbackColor), reinterpret_cast<setter>(XamlCompositionBrushBase_put_FallbackColor), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_XamlCompositionBrushBase[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_XamlCompositionBrushBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XamlCompositionBrushBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XamlCompositionBrushBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XamlCompositionBrushBase) },
        { }
    };

    static PyType_Spec type_spec_XamlCompositionBrushBase = {
        "winrt._winrt_windows_ui_xaml_media.XamlCompositionBrushBase",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::XamlCompositionBrushBase),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_XamlCompositionBrushBase};

    static PyGetSetDef getset_XamlCompositionBrushBase_Static[] = {
        { "fallback_color_property", reinterpret_cast<getter>(XamlCompositionBrushBase_get_FallbackColorProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_XamlCompositionBrushBase_Static[] = {
        { }
    };

    static PyType_Slot type_slots_XamlCompositionBrushBase_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_XamlCompositionBrushBase_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_XamlCompositionBrushBase_Static) },
        { }
    };

    static PyType_Spec type_spec_XamlCompositionBrushBase_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.XamlCompositionBrushBase_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_XamlCompositionBrushBase_Static
    };

    // ----- XamlLight class --------------------

    struct PyWinrtXamlLight;
    using BasePyWinrtXamlLight = winrt::Windows::UI::Xaml::Media::XamlLightT<PyWinrtXamlLight, py::IPywinrtObject>;

    struct PyWinrtXamlLight : py::py_obj_ref, BasePyWinrtXamlLight
    {
        PyWinrtXamlLight(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtXamlLight() {}

        using py::py_obj_ref::get_py_obj;

        int32_t GetPyObject(PyObject*& obj)
        {
            obj = get_py_obj();
            return 0;
        }

        static void toggle_reference(PyWinrtXamlLight* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }
    };

    static PyObject* _new_XamlLight(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);

        auto self_type = get_python_type_for<winrt::Windows::UI::Xaml::Media::XamlLight>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::wrapper::Windows::UI::Xaml::Media::XamlLight*>(self.get())->obj, nullptr);
                    reinterpret_cast<py::wrapper::Windows::UI::Xaml::Media::XamlLight*>(self.get())->obj = winrt::make<PyWinrtXamlLight>(self.get());

                    return self.detach();
                }

                winrt::Windows::UI::Xaml::Media::XamlLight instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_XamlLight(py::wrapper::Windows::UI::Xaml::Media::XamlLight* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* XamlLight_AddTargetBrush(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.XamlLight", L"AddTargetBrush", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(args, 1);

                winrt::Windows::UI::Xaml::Media::XamlLight::AddTargetBrush(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlLight_AddTargetElement(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.XamlLight", L"AddTargetElement", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 1);

                winrt::Windows::UI::Xaml::Media::XamlLight::AddTargetElement(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlLight_GetId(PyObject* /*unused*/, PyObject* /* unused */) noexcept
    {
        PyErr_SetString(PyExc_RuntimeError, "cannot call protected method");
        return nullptr;
    }

    static PyObject* XamlLight_OnConnected(PyObject* /*unused*/, PyObject* /* unused */) noexcept
    {
        PyErr_SetString(PyExc_RuntimeError, "cannot call protected method");
        return nullptr;
    }

    static PyObject* XamlLight_OnDisconnected(PyObject* /*unused*/, PyObject* /* unused */) noexcept
    {
        PyErr_SetString(PyExc_RuntimeError, "cannot call protected method");
        return nullptr;
    }

    static PyObject* XamlLight_RemoveTargetBrush(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.XamlLight", L"RemoveTargetBrush", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Media::Brush>(args, 1);

                winrt::Windows::UI::Xaml::Media::XamlLight::RemoveTargetBrush(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlLight_RemoveTargetElement(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Media.XamlLight", L"RemoveTargetElement", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::UIElement>(args, 1);

                winrt::Windows::UI::Xaml::Media::XamlLight::RemoveTargetElement(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_XamlLight(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::XamlLight>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XamlLight(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Media::XamlLight>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XamlLight[] = {
        { "_get_id", reinterpret_cast<PyCFunction>(XamlLight_GetId), METH_VARARGS, nullptr },
        { "_on_connected", reinterpret_cast<PyCFunction>(XamlLight_OnConnected), METH_VARARGS, nullptr },
        { "_on_disconnected", reinterpret_cast<PyCFunction>(XamlLight_OnDisconnected), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_XamlLight, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XamlLight), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_XamlLight[] = {
        { }
    };

    static PyType_Slot _type_slots_XamlLight[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_XamlLight) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XamlLight) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XamlLight) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XamlLight) },
        { }
    };

    static PyType_Spec type_spec_XamlLight = {
        "winrt._winrt_windows_ui_xaml_media.XamlLight",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::XamlLight),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_XamlLight};

    static PyGetSetDef getset_XamlLight_Static[] = {
        { }
    };

    static PyMethodDef methods_XamlLight_Static[] = {
        { "add_target_brush", reinterpret_cast<PyCFunction>(XamlLight_AddTargetBrush), METH_VARARGS, nullptr },
        { "add_target_element", reinterpret_cast<PyCFunction>(XamlLight_AddTargetElement), METH_VARARGS, nullptr },
        { "remove_target_brush", reinterpret_cast<PyCFunction>(XamlLight_RemoveTargetBrush), METH_VARARGS, nullptr },
        { "remove_target_element", reinterpret_cast<PyCFunction>(XamlLight_RemoveTargetElement), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_XamlLight_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_XamlLight_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_XamlLight_Static) },
        { }
    };

    static PyType_Spec type_spec_XamlLight_Static =
    {
        "winrt._winrt_windows_ui_xaml_media.XamlLight_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_XamlLight_Static
    };

    // ----- Matrix struct --------------------

    winrt_struct_wrapper<winrt::Windows::UI::Xaml::Media::Matrix>* _new_Matrix(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::UI::Xaml::Media::Matrix>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_Matrix(winrt_struct_wrapper<winrt::Windows::UI::Xaml::Media::Matrix>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        double _M11{};
        double _M12{};
        double _M21{};
        double _M22{};
        double _OffsetX{};
        double _OffsetY{};

        static const char* kwlist[] = {"m11", "m12", "m21", "m22", "offset_x", "offset_y", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "dddddd", const_cast<char**>(kwlist), &_M11, &_M12, &_M21, &_M22, &_OffsetX, &_OffsetY))
        {
            return -1;
        }

        try
        {
            self->obj.M11 = _M11;
            self->obj.M12 = _M12;
            self->obj.M21 = _M21;
            self->obj.M22 = _M22;
            self->obj.OffsetX = _OffsetX;
            self->obj.OffsetY = _OffsetY;

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_Matrix(py::wrapper::Windows::UI::Xaml::Media::Matrix* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Matrix(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Media::Matrix>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_Matrix[] = {
        { "_assign_array_", _assign_array_Matrix, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* Matrix_get_M11(py::wrapper::Windows::UI::Xaml::Media::Matrix* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.M11);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix_set_M11(py::wrapper::Windows::UI::Xaml::Media::Matrix* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.M11 = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix_get_M12(py::wrapper::Windows::UI::Xaml::Media::Matrix* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.M12);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix_set_M12(py::wrapper::Windows::UI::Xaml::Media::Matrix* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.M12 = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix_get_M21(py::wrapper::Windows::UI::Xaml::Media::Matrix* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.M21);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix_set_M21(py::wrapper::Windows::UI::Xaml::Media::Matrix* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.M21 = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix_get_M22(py::wrapper::Windows::UI::Xaml::Media::Matrix* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.M22);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix_set_M22(py::wrapper::Windows::UI::Xaml::Media::Matrix* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.M22 = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix_get_OffsetX(py::wrapper::Windows::UI::Xaml::Media::Matrix* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OffsetX);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix_set_OffsetX(py::wrapper::Windows::UI::Xaml::Media::Matrix* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.OffsetX = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix_get_OffsetY(py::wrapper::Windows::UI::Xaml::Media::Matrix* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OffsetY);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix_set_OffsetY(py::wrapper::Windows::UI::Xaml::Media::Matrix* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.OffsetY = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_Matrix[] = {
        { "m11", reinterpret_cast<getter>(Matrix_get_M11), reinterpret_cast<setter>(Matrix_set_M11), nullptr, nullptr },
        { "m12", reinterpret_cast<getter>(Matrix_get_M12), reinterpret_cast<setter>(Matrix_set_M12), nullptr, nullptr },
        { "m21", reinterpret_cast<getter>(Matrix_get_M21), reinterpret_cast<setter>(Matrix_set_M21), nullptr, nullptr },
        { "m22", reinterpret_cast<getter>(Matrix_get_M22), reinterpret_cast<setter>(Matrix_set_M22), nullptr, nullptr },
        { "offset_x", reinterpret_cast<getter>(Matrix_get_OffsetX), reinterpret_cast<setter>(Matrix_set_OffsetX), nullptr, nullptr },
        { "offset_y", reinterpret_cast<getter>(Matrix_get_OffsetY), reinterpret_cast<setter>(Matrix_set_OffsetY), nullptr, nullptr },
        { }
    };

    static PyObject* _richcompare_Matrix(py::wrapper::Windows::UI::Xaml::Media::Matrix* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::converter<winrt::Windows::UI::Xaml::Media::Matrix>::convert_to(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_Matrix(PyObject* self) noexcept
    {
        py::pyobj_handle M11{PyObject_GetAttrString(self, "m11")};
        if (!M11)
        {
            return nullptr;
        }

        py::pyobj_handle M12{PyObject_GetAttrString(self, "m12")};
        if (!M12)
        {
            return nullptr;
        }

        py::pyobj_handle M21{PyObject_GetAttrString(self, "m21")};
        if (!M21)
        {
            return nullptr;
        }

        py::pyobj_handle M22{PyObject_GetAttrString(self, "m22")};
        if (!M22)
        {
            return nullptr;
        }

        py::pyobj_handle OffsetX{PyObject_GetAttrString(self, "offset_x")};
        if (!OffsetX)
        {
            return nullptr;
        }

        py::pyobj_handle OffsetY{PyObject_GetAttrString(self, "offset_y")};
        if (!OffsetY)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("Matrix(m11=%R, m12=%R, m21=%R, m22=%R, offset_x=%R, offset_y=%R)", M11.get(), M12.get(), M21.get(), M22.get(), OffsetX.get(), OffsetY.get());
    }

    static PyType_Slot _type_slots_Matrix[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Matrix) },
        { Py_tp_init, reinterpret_cast<void*>(_init_Matrix) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Matrix) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Matrix) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Matrix) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_Matrix) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_Matrix) },
        { }
    };

    static PyType_Spec type_spec_Matrix = {
        "winrt._winrt_windows_ui_xaml_media.Matrix",
        sizeof(py::wrapper::Windows::UI::Xaml::Media::Matrix),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Matrix};

    // ----- Windows.UI.Xaml.Media Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.UI.Xaml.Media");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_ui_xaml_media",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::UI::Xaml::Media

PyMODINIT_FUNC PyInit__winrt_windows_ui_xaml_media(void) noexcept
{
    using namespace py::cpp::Windows::UI::Xaml::Media;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_module{PyImport_ImportModule("winrt._winrt_windows_ui_xaml")};
    if (!windows_ui_xaml_module)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_DependencyObject_type{PyObject_GetAttrString(windows_ui_xaml_module.get(), "DependencyObject")};
    if (!windows_ui_xaml_DependencyObject_type)
    {
        return nullptr;
    }

    py::pyobj_handle windows_ui_xaml_RoutedEventArgs_type{PyObject_GetAttrString(windows_ui_xaml_module.get(), "RoutedEventArgs")};
    if (!windows_ui_xaml_RoutedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle Brush_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!Brush_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Brush_Static{PyType_FromSpecWithBases(&type_spec_Brush_Static, Brush_Static_bases.get())};
    if (!type_Brush_Static)
    {
        return nullptr;
    }

    py::pyobj_handle Brush_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!Brush_bases)
    {
        return nullptr;
    }

    py::pytype_handle Brush_type{py::register_python_type(module.get(), &type_spec_Brush, Brush_bases.get(), reinterpret_cast<PyTypeObject*>(type_Brush_Static.get()))};
    if (!Brush_type)
    {
        return nullptr;
    }

    py::pyobj_handle XamlCompositionBrushBase_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(Brush_type.get())))};
    if (!XamlCompositionBrushBase_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_XamlCompositionBrushBase_Static{PyType_FromSpecWithBases(&type_spec_XamlCompositionBrushBase_Static, XamlCompositionBrushBase_Static_bases.get())};
    if (!type_XamlCompositionBrushBase_Static)
    {
        return nullptr;
    }

    py::pyobj_handle XamlCompositionBrushBase_bases{PyTuple_Pack(1, Brush_type.get())};
    if (!XamlCompositionBrushBase_bases)
    {
        return nullptr;
    }

    py::pytype_handle XamlCompositionBrushBase_type{py::register_python_type(module.get(), &type_spec_XamlCompositionBrushBase, XamlCompositionBrushBase_bases.get(), reinterpret_cast<PyTypeObject*>(type_XamlCompositionBrushBase_Static.get()))};
    if (!XamlCompositionBrushBase_type)
    {
        return nullptr;
    }

    py::pyobj_handle AcrylicBrush_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(XamlCompositionBrushBase_type.get())))};
    if (!AcrylicBrush_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AcrylicBrush_Static{PyType_FromSpecWithBases(&type_spec_AcrylicBrush_Static, AcrylicBrush_Static_bases.get())};
    if (!type_AcrylicBrush_Static)
    {
        return nullptr;
    }

    py::pyobj_handle AcrylicBrush_bases{PyTuple_Pack(1, XamlCompositionBrushBase_type.get())};
    if (!AcrylicBrush_bases)
    {
        return nullptr;
    }

    py::pytype_handle AcrylicBrush_type{py::register_python_type(module.get(), &type_spec_AcrylicBrush, AcrylicBrush_bases.get(), reinterpret_cast<PyTypeObject*>(type_AcrylicBrush_Static.get()))};
    if (!AcrylicBrush_type)
    {
        return nullptr;
    }

    py::pyobj_handle PathSegment_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!PathSegment_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PathSegment_Static{PyType_FromSpecWithBases(&type_spec_PathSegment_Static, PathSegment_Static_bases.get())};
    if (!type_PathSegment_Static)
    {
        return nullptr;
    }

    py::pyobj_handle PathSegment_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!PathSegment_bases)
    {
        return nullptr;
    }

    py::pytype_handle PathSegment_type{py::register_python_type(module.get(), &type_spec_PathSegment, PathSegment_bases.get(), reinterpret_cast<PyTypeObject*>(type_PathSegment_Static.get()))};
    if (!PathSegment_type)
    {
        return nullptr;
    }

    py::pyobj_handle ArcSegment_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(PathSegment_type.get())))};
    if (!ArcSegment_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ArcSegment_Static{PyType_FromSpecWithBases(&type_spec_ArcSegment_Static, ArcSegment_Static_bases.get())};
    if (!type_ArcSegment_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ArcSegment_bases{PyTuple_Pack(1, PathSegment_type.get())};
    if (!ArcSegment_bases)
    {
        return nullptr;
    }

    py::pytype_handle ArcSegment_type{py::register_python_type(module.get(), &type_spec_ArcSegment, ArcSegment_bases.get(), reinterpret_cast<PyTypeObject*>(type_ArcSegment_Static.get()))};
    if (!ArcSegment_type)
    {
        return nullptr;
    }

    py::pyobj_handle BezierSegment_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(PathSegment_type.get())))};
    if (!BezierSegment_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_BezierSegment_Static{PyType_FromSpecWithBases(&type_spec_BezierSegment_Static, BezierSegment_Static_bases.get())};
    if (!type_BezierSegment_Static)
    {
        return nullptr;
    }

    py::pyobj_handle BezierSegment_bases{PyTuple_Pack(1, PathSegment_type.get())};
    if (!BezierSegment_bases)
    {
        return nullptr;
    }

    py::pytype_handle BezierSegment_type{py::register_python_type(module.get(), &type_spec_BezierSegment, BezierSegment_bases.get(), reinterpret_cast<PyTypeObject*>(type_BezierSegment_Static.get()))};
    if (!BezierSegment_type)
    {
        return nullptr;
    }

    py::pyobj_handle CacheMode_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!CacheMode_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CacheMode_Static{PyType_FromSpecWithBases(&type_spec_CacheMode_Static, CacheMode_Static_bases.get())};
    if (!type_CacheMode_Static)
    {
        return nullptr;
    }

    py::pyobj_handle CacheMode_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!CacheMode_bases)
    {
        return nullptr;
    }

    py::pytype_handle CacheMode_type{py::register_python_type(module.get(), &type_spec_CacheMode, CacheMode_bases.get(), reinterpret_cast<PyTypeObject*>(type_CacheMode_Static.get()))};
    if (!CacheMode_type)
    {
        return nullptr;
    }

    py::pyobj_handle BitmapCache_bases{PyTuple_Pack(1, CacheMode_type.get())};
    if (!BitmapCache_bases)
    {
        return nullptr;
    }

    py::pytype_handle BitmapCache_type{py::register_python_type(module.get(), &type_spec_BitmapCache, BitmapCache_bases.get(), nullptr)};
    if (!BitmapCache_type)
    {
        return nullptr;
    }

    py::pytype_handle BrushCollection_type{py::register_python_type(module.get(), &type_spec_BrushCollection, object_bases.get(), nullptr)};
    if (!BrushCollection_type)
    {
        return nullptr;
    }

    py::pyobj_handle GeneralTransform_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!GeneralTransform_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_GeneralTransform_Static{PyType_FromSpecWithBases(&type_spec_GeneralTransform_Static, GeneralTransform_Static_bases.get())};
    if (!type_GeneralTransform_Static)
    {
        return nullptr;
    }

    py::pyobj_handle GeneralTransform_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!GeneralTransform_bases)
    {
        return nullptr;
    }

    py::pytype_handle GeneralTransform_type{py::register_python_type(module.get(), &type_spec_GeneralTransform, GeneralTransform_bases.get(), reinterpret_cast<PyTypeObject*>(type_GeneralTransform_Static.get()))};
    if (!GeneralTransform_type)
    {
        return nullptr;
    }

    py::pyobj_handle Transform_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(GeneralTransform_type.get())))};
    if (!Transform_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Transform_Static{PyType_FromSpecWithBases(&type_spec_Transform_Static, Transform_Static_bases.get())};
    if (!type_Transform_Static)
    {
        return nullptr;
    }

    py::pyobj_handle Transform_bases{PyTuple_Pack(1, GeneralTransform_type.get())};
    if (!Transform_bases)
    {
        return nullptr;
    }

    py::pytype_handle Transform_type{py::register_python_type(module.get(), &type_spec_Transform, Transform_bases.get(), reinterpret_cast<PyTypeObject*>(type_Transform_Static.get()))};
    if (!Transform_type)
    {
        return nullptr;
    }

    py::pyobj_handle CompositeTransform_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(Transform_type.get())))};
    if (!CompositeTransform_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_CompositeTransform_Static{PyType_FromSpecWithBases(&type_spec_CompositeTransform_Static, CompositeTransform_Static_bases.get())};
    if (!type_CompositeTransform_Static)
    {
        return nullptr;
    }

    py::pyobj_handle CompositeTransform_bases{PyTuple_Pack(1, Transform_type.get())};
    if (!CompositeTransform_bases)
    {
        return nullptr;
    }

    py::pytype_handle CompositeTransform_type{py::register_python_type(module.get(), &type_spec_CompositeTransform, CompositeTransform_bases.get(), reinterpret_cast<PyTypeObject*>(type_CompositeTransform_Static.get()))};
    if (!CompositeTransform_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_CompositionTarget_Static{PyType_FromSpec(&type_spec_CompositionTarget_Static)};
    if (!type_CompositionTarget_Static)
    {
        return nullptr;
    }

    py::pytype_handle CompositionTarget_type{py::register_python_type(module.get(), &type_spec_CompositionTarget, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CompositionTarget_Static.get()))};
    if (!CompositionTarget_type)
    {
        return nullptr;
    }

    py::pytype_handle DoubleCollection_type{py::register_python_type(module.get(), &type_spec_DoubleCollection, object_bases.get(), nullptr)};
    if (!DoubleCollection_type)
    {
        return nullptr;
    }

    py::pyobj_handle Geometry_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!Geometry_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Geometry_Static{PyType_FromSpecWithBases(&type_spec_Geometry_Static, Geometry_Static_bases.get())};
    if (!type_Geometry_Static)
    {
        return nullptr;
    }

    py::pyobj_handle Geometry_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!Geometry_bases)
    {
        return nullptr;
    }

    py::pytype_handle Geometry_type{py::register_python_type(module.get(), &type_spec_Geometry, Geometry_bases.get(), reinterpret_cast<PyTypeObject*>(type_Geometry_Static.get()))};
    if (!Geometry_type)
    {
        return nullptr;
    }

    py::pyobj_handle EllipseGeometry_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(Geometry_type.get())))};
    if (!EllipseGeometry_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_EllipseGeometry_Static{PyType_FromSpecWithBases(&type_spec_EllipseGeometry_Static, EllipseGeometry_Static_bases.get())};
    if (!type_EllipseGeometry_Static)
    {
        return nullptr;
    }

    py::pyobj_handle EllipseGeometry_bases{PyTuple_Pack(1, Geometry_type.get())};
    if (!EllipseGeometry_bases)
    {
        return nullptr;
    }

    py::pytype_handle EllipseGeometry_type{py::register_python_type(module.get(), &type_spec_EllipseGeometry, EllipseGeometry_bases.get(), reinterpret_cast<PyTypeObject*>(type_EllipseGeometry_Static.get()))};
    if (!EllipseGeometry_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_FontFamily_Static{PyType_FromSpec(&type_spec_FontFamily_Static)};
    if (!type_FontFamily_Static)
    {
        return nullptr;
    }

    py::pytype_handle FontFamily_type{py::register_python_type(module.get(), &type_spec_FontFamily, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_FontFamily_Static.get()))};
    if (!FontFamily_type)
    {
        return nullptr;
    }

    py::pytype_handle GeometryCollection_type{py::register_python_type(module.get(), &type_spec_GeometryCollection, object_bases.get(), nullptr)};
    if (!GeometryCollection_type)
    {
        return nullptr;
    }

    py::pyobj_handle GeometryGroup_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(Geometry_type.get())))};
    if (!GeometryGroup_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_GeometryGroup_Static{PyType_FromSpecWithBases(&type_spec_GeometryGroup_Static, GeometryGroup_Static_bases.get())};
    if (!type_GeometryGroup_Static)
    {
        return nullptr;
    }

    py::pyobj_handle GeometryGroup_bases{PyTuple_Pack(1, Geometry_type.get())};
    if (!GeometryGroup_bases)
    {
        return nullptr;
    }

    py::pytype_handle GeometryGroup_type{py::register_python_type(module.get(), &type_spec_GeometryGroup, GeometryGroup_bases.get(), reinterpret_cast<PyTypeObject*>(type_GeometryGroup_Static.get()))};
    if (!GeometryGroup_type)
    {
        return nullptr;
    }

    py::pyobj_handle GradientBrush_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(Brush_type.get())))};
    if (!GradientBrush_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_GradientBrush_Static{PyType_FromSpecWithBases(&type_spec_GradientBrush_Static, GradientBrush_Static_bases.get())};
    if (!type_GradientBrush_Static)
    {
        return nullptr;
    }

    py::pyobj_handle GradientBrush_bases{PyTuple_Pack(1, Brush_type.get())};
    if (!GradientBrush_bases)
    {
        return nullptr;
    }

    py::pytype_handle GradientBrush_type{py::register_python_type(module.get(), &type_spec_GradientBrush, GradientBrush_bases.get(), reinterpret_cast<PyTypeObject*>(type_GradientBrush_Static.get()))};
    if (!GradientBrush_type)
    {
        return nullptr;
    }

    py::pyobj_handle GradientStop_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!GradientStop_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_GradientStop_Static{PyType_FromSpecWithBases(&type_spec_GradientStop_Static, GradientStop_Static_bases.get())};
    if (!type_GradientStop_Static)
    {
        return nullptr;
    }

    py::pyobj_handle GradientStop_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!GradientStop_bases)
    {
        return nullptr;
    }

    py::pytype_handle GradientStop_type{py::register_python_type(module.get(), &type_spec_GradientStop, GradientStop_bases.get(), reinterpret_cast<PyTypeObject*>(type_GradientStop_Static.get()))};
    if (!GradientStop_type)
    {
        return nullptr;
    }

    py::pytype_handle GradientStopCollection_type{py::register_python_type(module.get(), &type_spec_GradientStopCollection, object_bases.get(), nullptr)};
    if (!GradientStopCollection_type)
    {
        return nullptr;
    }

    py::pyobj_handle TileBrush_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(Brush_type.get())))};
    if (!TileBrush_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TileBrush_Static{PyType_FromSpecWithBases(&type_spec_TileBrush_Static, TileBrush_Static_bases.get())};
    if (!type_TileBrush_Static)
    {
        return nullptr;
    }

    py::pyobj_handle TileBrush_bases{PyTuple_Pack(1, Brush_type.get())};
    if (!TileBrush_bases)
    {
        return nullptr;
    }

    py::pytype_handle TileBrush_type{py::register_python_type(module.get(), &type_spec_TileBrush, TileBrush_bases.get(), reinterpret_cast<PyTypeObject*>(type_TileBrush_Static.get()))};
    if (!TileBrush_type)
    {
        return nullptr;
    }

    py::pyobj_handle ImageBrush_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(TileBrush_type.get())))};
    if (!ImageBrush_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ImageBrush_Static{PyType_FromSpecWithBases(&type_spec_ImageBrush_Static, ImageBrush_Static_bases.get())};
    if (!type_ImageBrush_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ImageBrush_bases{PyTuple_Pack(1, TileBrush_type.get())};
    if (!ImageBrush_bases)
    {
        return nullptr;
    }

    py::pytype_handle ImageBrush_type{py::register_python_type(module.get(), &type_spec_ImageBrush, ImageBrush_bases.get(), reinterpret_cast<PyTypeObject*>(type_ImageBrush_Static.get()))};
    if (!ImageBrush_type)
    {
        return nullptr;
    }

    py::pyobj_handle ImageSource_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!ImageSource_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ImageSource_Static{PyType_FromSpecWithBases(&type_spec_ImageSource_Static, ImageSource_Static_bases.get())};
    if (!type_ImageSource_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ImageSource_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!ImageSource_bases)
    {
        return nullptr;
    }

    py::pytype_handle ImageSource_type{py::register_python_type(module.get(), &type_spec_ImageSource, ImageSource_bases.get(), reinterpret_cast<PyTypeObject*>(type_ImageSource_Static.get()))};
    if (!ImageSource_type)
    {
        return nullptr;
    }

    py::pyobj_handle LineGeometry_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(Geometry_type.get())))};
    if (!LineGeometry_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_LineGeometry_Static{PyType_FromSpecWithBases(&type_spec_LineGeometry_Static, LineGeometry_Static_bases.get())};
    if (!type_LineGeometry_Static)
    {
        return nullptr;
    }

    py::pyobj_handle LineGeometry_bases{PyTuple_Pack(1, Geometry_type.get())};
    if (!LineGeometry_bases)
    {
        return nullptr;
    }

    py::pytype_handle LineGeometry_type{py::register_python_type(module.get(), &type_spec_LineGeometry, LineGeometry_bases.get(), reinterpret_cast<PyTypeObject*>(type_LineGeometry_Static.get()))};
    if (!LineGeometry_type)
    {
        return nullptr;
    }

    py::pyobj_handle LineSegment_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(PathSegment_type.get())))};
    if (!LineSegment_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_LineSegment_Static{PyType_FromSpecWithBases(&type_spec_LineSegment_Static, LineSegment_Static_bases.get())};
    if (!type_LineSegment_Static)
    {
        return nullptr;
    }

    py::pyobj_handle LineSegment_bases{PyTuple_Pack(1, PathSegment_type.get())};
    if (!LineSegment_bases)
    {
        return nullptr;
    }

    py::pytype_handle LineSegment_type{py::register_python_type(module.get(), &type_spec_LineSegment, LineSegment_bases.get(), reinterpret_cast<PyTypeObject*>(type_LineSegment_Static.get()))};
    if (!LineSegment_type)
    {
        return nullptr;
    }

    py::pyobj_handle LinearGradientBrush_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(GradientBrush_type.get())))};
    if (!LinearGradientBrush_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_LinearGradientBrush_Static{PyType_FromSpecWithBases(&type_spec_LinearGradientBrush_Static, LinearGradientBrush_Static_bases.get())};
    if (!type_LinearGradientBrush_Static)
    {
        return nullptr;
    }

    py::pyobj_handle LinearGradientBrush_bases{PyTuple_Pack(1, GradientBrush_type.get())};
    if (!LinearGradientBrush_bases)
    {
        return nullptr;
    }

    py::pytype_handle LinearGradientBrush_type{py::register_python_type(module.get(), &type_spec_LinearGradientBrush, LinearGradientBrush_bases.get(), reinterpret_cast<PyTypeObject*>(type_LinearGradientBrush_Static.get()))};
    if (!LinearGradientBrush_type)
    {
        return nullptr;
    }

    py::pytype_handle LoadedImageSourceLoadCompletedEventArgs_type{py::register_python_type(module.get(), &type_spec_LoadedImageSourceLoadCompletedEventArgs, object_bases.get(), nullptr)};
    if (!LoadedImageSourceLoadCompletedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_LoadedImageSurface_Static{PyType_FromSpec(&type_spec_LoadedImageSurface_Static)};
    if (!type_LoadedImageSurface_Static)
    {
        return nullptr;
    }

    py::pytype_handle LoadedImageSurface_type{py::register_python_type(module.get(), &type_spec_LoadedImageSurface, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_LoadedImageSurface_Static.get()))};
    if (!LoadedImageSurface_type)
    {
        return nullptr;
    }

    py::pyobj_handle Projection_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!Projection_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Projection_Static{PyType_FromSpecWithBases(&type_spec_Projection_Static, Projection_Static_bases.get())};
    if (!type_Projection_Static)
    {
        return nullptr;
    }

    py::pyobj_handle Projection_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!Projection_bases)
    {
        return nullptr;
    }

    py::pytype_handle Projection_type{py::register_python_type(module.get(), &type_spec_Projection, Projection_bases.get(), reinterpret_cast<PyTypeObject*>(type_Projection_Static.get()))};
    if (!Projection_type)
    {
        return nullptr;
    }

    py::pyobj_handle Matrix3DProjection_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(Projection_type.get())))};
    if (!Matrix3DProjection_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Matrix3DProjection_Static{PyType_FromSpecWithBases(&type_spec_Matrix3DProjection_Static, Matrix3DProjection_Static_bases.get())};
    if (!type_Matrix3DProjection_Static)
    {
        return nullptr;
    }

    py::pyobj_handle Matrix3DProjection_bases{PyTuple_Pack(1, Projection_type.get())};
    if (!Matrix3DProjection_bases)
    {
        return nullptr;
    }

    py::pytype_handle Matrix3DProjection_type{py::register_python_type(module.get(), &type_spec_Matrix3DProjection, Matrix3DProjection_bases.get(), reinterpret_cast<PyTypeObject*>(type_Matrix3DProjection_Static.get()))};
    if (!Matrix3DProjection_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_MatrixHelper_Static{PyType_FromSpec(&type_spec_MatrixHelper_Static)};
    if (!type_MatrixHelper_Static)
    {
        return nullptr;
    }

    py::pytype_handle MatrixHelper_type{py::register_python_type(module.get(), &type_spec_MatrixHelper, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MatrixHelper_Static.get()))};
    if (!MatrixHelper_type)
    {
        return nullptr;
    }

    py::pyobj_handle MatrixTransform_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(Transform_type.get())))};
    if (!MatrixTransform_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_MatrixTransform_Static{PyType_FromSpecWithBases(&type_spec_MatrixTransform_Static, MatrixTransform_Static_bases.get())};
    if (!type_MatrixTransform_Static)
    {
        return nullptr;
    }

    py::pyobj_handle MatrixTransform_bases{PyTuple_Pack(1, Transform_type.get())};
    if (!MatrixTransform_bases)
    {
        return nullptr;
    }

    py::pytype_handle MatrixTransform_type{py::register_python_type(module.get(), &type_spec_MatrixTransform, MatrixTransform_bases.get(), reinterpret_cast<PyTypeObject*>(type_MatrixTransform_Static.get()))};
    if (!MatrixTransform_type)
    {
        return nullptr;
    }

    py::pytype_handle MediaTransportControlsThumbnailRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_MediaTransportControlsThumbnailRequestedEventArgs, object_bases.get(), nullptr)};
    if (!MediaTransportControlsThumbnailRequestedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PartialMediaFailureDetectedEventArgs_type{py::register_python_type(module.get(), &type_spec_PartialMediaFailureDetectedEventArgs, object_bases.get(), nullptr)};
    if (!PartialMediaFailureDetectedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle PathFigure_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!PathFigure_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PathFigure_Static{PyType_FromSpecWithBases(&type_spec_PathFigure_Static, PathFigure_Static_bases.get())};
    if (!type_PathFigure_Static)
    {
        return nullptr;
    }

    py::pyobj_handle PathFigure_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!PathFigure_bases)
    {
        return nullptr;
    }

    py::pytype_handle PathFigure_type{py::register_python_type(module.get(), &type_spec_PathFigure, PathFigure_bases.get(), reinterpret_cast<PyTypeObject*>(type_PathFigure_Static.get()))};
    if (!PathFigure_type)
    {
        return nullptr;
    }

    py::pytype_handle PathFigureCollection_type{py::register_python_type(module.get(), &type_spec_PathFigureCollection, object_bases.get(), nullptr)};
    if (!PathFigureCollection_type)
    {
        return nullptr;
    }

    py::pyobj_handle PathGeometry_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(Geometry_type.get())))};
    if (!PathGeometry_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PathGeometry_Static{PyType_FromSpecWithBases(&type_spec_PathGeometry_Static, PathGeometry_Static_bases.get())};
    if (!type_PathGeometry_Static)
    {
        return nullptr;
    }

    py::pyobj_handle PathGeometry_bases{PyTuple_Pack(1, Geometry_type.get())};
    if (!PathGeometry_bases)
    {
        return nullptr;
    }

    py::pytype_handle PathGeometry_type{py::register_python_type(module.get(), &type_spec_PathGeometry, PathGeometry_bases.get(), reinterpret_cast<PyTypeObject*>(type_PathGeometry_Static.get()))};
    if (!PathGeometry_type)
    {
        return nullptr;
    }

    py::pytype_handle PathSegmentCollection_type{py::register_python_type(module.get(), &type_spec_PathSegmentCollection, object_bases.get(), nullptr)};
    if (!PathSegmentCollection_type)
    {
        return nullptr;
    }

    py::pyobj_handle PlaneProjection_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(Projection_type.get())))};
    if (!PlaneProjection_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PlaneProjection_Static{PyType_FromSpecWithBases(&type_spec_PlaneProjection_Static, PlaneProjection_Static_bases.get())};
    if (!type_PlaneProjection_Static)
    {
        return nullptr;
    }

    py::pyobj_handle PlaneProjection_bases{PyTuple_Pack(1, Projection_type.get())};
    if (!PlaneProjection_bases)
    {
        return nullptr;
    }

    py::pytype_handle PlaneProjection_type{py::register_python_type(module.get(), &type_spec_PlaneProjection, PlaneProjection_bases.get(), reinterpret_cast<PyTypeObject*>(type_PlaneProjection_Static.get()))};
    if (!PlaneProjection_type)
    {
        return nullptr;
    }

    py::pytype_handle PointCollection_type{py::register_python_type(module.get(), &type_spec_PointCollection, object_bases.get(), nullptr)};
    if (!PointCollection_type)
    {
        return nullptr;
    }

    py::pyobj_handle PolyBezierSegment_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(PathSegment_type.get())))};
    if (!PolyBezierSegment_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PolyBezierSegment_Static{PyType_FromSpecWithBases(&type_spec_PolyBezierSegment_Static, PolyBezierSegment_Static_bases.get())};
    if (!type_PolyBezierSegment_Static)
    {
        return nullptr;
    }

    py::pyobj_handle PolyBezierSegment_bases{PyTuple_Pack(1, PathSegment_type.get())};
    if (!PolyBezierSegment_bases)
    {
        return nullptr;
    }

    py::pytype_handle PolyBezierSegment_type{py::register_python_type(module.get(), &type_spec_PolyBezierSegment, PolyBezierSegment_bases.get(), reinterpret_cast<PyTypeObject*>(type_PolyBezierSegment_Static.get()))};
    if (!PolyBezierSegment_type)
    {
        return nullptr;
    }

    py::pyobj_handle PolyLineSegment_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(PathSegment_type.get())))};
    if (!PolyLineSegment_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PolyLineSegment_Static{PyType_FromSpecWithBases(&type_spec_PolyLineSegment_Static, PolyLineSegment_Static_bases.get())};
    if (!type_PolyLineSegment_Static)
    {
        return nullptr;
    }

    py::pyobj_handle PolyLineSegment_bases{PyTuple_Pack(1, PathSegment_type.get())};
    if (!PolyLineSegment_bases)
    {
        return nullptr;
    }

    py::pytype_handle PolyLineSegment_type{py::register_python_type(module.get(), &type_spec_PolyLineSegment, PolyLineSegment_bases.get(), reinterpret_cast<PyTypeObject*>(type_PolyLineSegment_Static.get()))};
    if (!PolyLineSegment_type)
    {
        return nullptr;
    }

    py::pyobj_handle PolyQuadraticBezierSegment_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(PathSegment_type.get())))};
    if (!PolyQuadraticBezierSegment_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PolyQuadraticBezierSegment_Static{PyType_FromSpecWithBases(&type_spec_PolyQuadraticBezierSegment_Static, PolyQuadraticBezierSegment_Static_bases.get())};
    if (!type_PolyQuadraticBezierSegment_Static)
    {
        return nullptr;
    }

    py::pyobj_handle PolyQuadraticBezierSegment_bases{PyTuple_Pack(1, PathSegment_type.get())};
    if (!PolyQuadraticBezierSegment_bases)
    {
        return nullptr;
    }

    py::pytype_handle PolyQuadraticBezierSegment_type{py::register_python_type(module.get(), &type_spec_PolyQuadraticBezierSegment, PolyQuadraticBezierSegment_bases.get(), reinterpret_cast<PyTypeObject*>(type_PolyQuadraticBezierSegment_Static.get()))};
    if (!PolyQuadraticBezierSegment_type)
    {
        return nullptr;
    }

    py::pyobj_handle QuadraticBezierSegment_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(PathSegment_type.get())))};
    if (!QuadraticBezierSegment_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_QuadraticBezierSegment_Static{PyType_FromSpecWithBases(&type_spec_QuadraticBezierSegment_Static, QuadraticBezierSegment_Static_bases.get())};
    if (!type_QuadraticBezierSegment_Static)
    {
        return nullptr;
    }

    py::pyobj_handle QuadraticBezierSegment_bases{PyTuple_Pack(1, PathSegment_type.get())};
    if (!QuadraticBezierSegment_bases)
    {
        return nullptr;
    }

    py::pytype_handle QuadraticBezierSegment_type{py::register_python_type(module.get(), &type_spec_QuadraticBezierSegment, QuadraticBezierSegment_bases.get(), reinterpret_cast<PyTypeObject*>(type_QuadraticBezierSegment_Static.get()))};
    if (!QuadraticBezierSegment_type)
    {
        return nullptr;
    }

    py::pyobj_handle RateChangedRoutedEventArgs_bases{PyTuple_Pack(1, windows_ui_xaml_RoutedEventArgs_type.get())};
    if (!RateChangedRoutedEventArgs_bases)
    {
        return nullptr;
    }

    py::pytype_handle RateChangedRoutedEventArgs_type{py::register_python_type(module.get(), &type_spec_RateChangedRoutedEventArgs, RateChangedRoutedEventArgs_bases.get(), nullptr)};
    if (!RateChangedRoutedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle RectangleGeometry_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(Geometry_type.get())))};
    if (!RectangleGeometry_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_RectangleGeometry_Static{PyType_FromSpecWithBases(&type_spec_RectangleGeometry_Static, RectangleGeometry_Static_bases.get())};
    if (!type_RectangleGeometry_Static)
    {
        return nullptr;
    }

    py::pyobj_handle RectangleGeometry_bases{PyTuple_Pack(1, Geometry_type.get())};
    if (!RectangleGeometry_bases)
    {
        return nullptr;
    }

    py::pytype_handle RectangleGeometry_type{py::register_python_type(module.get(), &type_spec_RectangleGeometry, RectangleGeometry_bases.get(), reinterpret_cast<PyTypeObject*>(type_RectangleGeometry_Static.get()))};
    if (!RectangleGeometry_type)
    {
        return nullptr;
    }

    py::pytype_handle RenderedEventArgs_type{py::register_python_type(module.get(), &type_spec_RenderedEventArgs, object_bases.get(), nullptr)};
    if (!RenderedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle RenderingEventArgs_type{py::register_python_type(module.get(), &type_spec_RenderingEventArgs, object_bases.get(), nullptr)};
    if (!RenderingEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle RevealBrush_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(XamlCompositionBrushBase_type.get())))};
    if (!RevealBrush_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_RevealBrush_Static{PyType_FromSpecWithBases(&type_spec_RevealBrush_Static, RevealBrush_Static_bases.get())};
    if (!type_RevealBrush_Static)
    {
        return nullptr;
    }

    py::pyobj_handle RevealBrush_bases{PyTuple_Pack(1, XamlCompositionBrushBase_type.get())};
    if (!RevealBrush_bases)
    {
        return nullptr;
    }

    py::pytype_handle RevealBrush_type{py::register_python_type(module.get(), &type_spec_RevealBrush, RevealBrush_bases.get(), reinterpret_cast<PyTypeObject*>(type_RevealBrush_Static.get()))};
    if (!RevealBrush_type)
    {
        return nullptr;
    }

    py::pyobj_handle RevealBackgroundBrush_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(RevealBrush_type.get())))};
    if (!RevealBackgroundBrush_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_RevealBackgroundBrush_Static{PyType_FromSpecWithBases(&type_spec_RevealBackgroundBrush_Static, RevealBackgroundBrush_Static_bases.get())};
    if (!type_RevealBackgroundBrush_Static)
    {
        return nullptr;
    }

    py::pyobj_handle RevealBackgroundBrush_bases{PyTuple_Pack(1, RevealBrush_type.get())};
    if (!RevealBackgroundBrush_bases)
    {
        return nullptr;
    }

    py::pytype_handle RevealBackgroundBrush_type{py::register_python_type(module.get(), &type_spec_RevealBackgroundBrush, RevealBackgroundBrush_bases.get(), reinterpret_cast<PyTypeObject*>(type_RevealBackgroundBrush_Static.get()))};
    if (!RevealBackgroundBrush_type)
    {
        return nullptr;
    }

    py::pyobj_handle RevealBorderBrush_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(RevealBrush_type.get())))};
    if (!RevealBorderBrush_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_RevealBorderBrush_Static{PyType_FromSpecWithBases(&type_spec_RevealBorderBrush_Static, RevealBorderBrush_Static_bases.get())};
    if (!type_RevealBorderBrush_Static)
    {
        return nullptr;
    }

    py::pyobj_handle RevealBorderBrush_bases{PyTuple_Pack(1, RevealBrush_type.get())};
    if (!RevealBorderBrush_bases)
    {
        return nullptr;
    }

    py::pytype_handle RevealBorderBrush_type{py::register_python_type(module.get(), &type_spec_RevealBorderBrush, RevealBorderBrush_bases.get(), reinterpret_cast<PyTypeObject*>(type_RevealBorderBrush_Static.get()))};
    if (!RevealBorderBrush_type)
    {
        return nullptr;
    }

    py::pyobj_handle RotateTransform_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(Transform_type.get())))};
    if (!RotateTransform_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_RotateTransform_Static{PyType_FromSpecWithBases(&type_spec_RotateTransform_Static, RotateTransform_Static_bases.get())};
    if (!type_RotateTransform_Static)
    {
        return nullptr;
    }

    py::pyobj_handle RotateTransform_bases{PyTuple_Pack(1, Transform_type.get())};
    if (!RotateTransform_bases)
    {
        return nullptr;
    }

    py::pytype_handle RotateTransform_type{py::register_python_type(module.get(), &type_spec_RotateTransform, RotateTransform_bases.get(), reinterpret_cast<PyTypeObject*>(type_RotateTransform_Static.get()))};
    if (!RotateTransform_type)
    {
        return nullptr;
    }

    py::pyobj_handle ScaleTransform_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(Transform_type.get())))};
    if (!ScaleTransform_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ScaleTransform_Static{PyType_FromSpecWithBases(&type_spec_ScaleTransform_Static, ScaleTransform_Static_bases.get())};
    if (!type_ScaleTransform_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ScaleTransform_bases{PyTuple_Pack(1, Transform_type.get())};
    if (!ScaleTransform_bases)
    {
        return nullptr;
    }

    py::pytype_handle ScaleTransform_type{py::register_python_type(module.get(), &type_spec_ScaleTransform, ScaleTransform_bases.get(), reinterpret_cast<PyTypeObject*>(type_ScaleTransform_Static.get()))};
    if (!ScaleTransform_type)
    {
        return nullptr;
    }

    py::pyobj_handle Shadow_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!Shadow_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Shadow_Static{PyType_FromSpecWithBases(&type_spec_Shadow_Static, Shadow_Static_bases.get())};
    if (!type_Shadow_Static)
    {
        return nullptr;
    }

    py::pyobj_handle Shadow_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!Shadow_bases)
    {
        return nullptr;
    }

    py::pytype_handle Shadow_type{py::register_python_type(module.get(), &type_spec_Shadow, Shadow_bases.get(), reinterpret_cast<PyTypeObject*>(type_Shadow_Static.get()))};
    if (!Shadow_type)
    {
        return nullptr;
    }

    py::pyobj_handle SkewTransform_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(Transform_type.get())))};
    if (!SkewTransform_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SkewTransform_Static{PyType_FromSpecWithBases(&type_spec_SkewTransform_Static, SkewTransform_Static_bases.get())};
    if (!type_SkewTransform_Static)
    {
        return nullptr;
    }

    py::pyobj_handle SkewTransform_bases{PyTuple_Pack(1, Transform_type.get())};
    if (!SkewTransform_bases)
    {
        return nullptr;
    }

    py::pytype_handle SkewTransform_type{py::register_python_type(module.get(), &type_spec_SkewTransform, SkewTransform_bases.get(), reinterpret_cast<PyTypeObject*>(type_SkewTransform_Static.get()))};
    if (!SkewTransform_type)
    {
        return nullptr;
    }

    py::pyobj_handle SolidColorBrush_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(Brush_type.get())))};
    if (!SolidColorBrush_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SolidColorBrush_Static{PyType_FromSpecWithBases(&type_spec_SolidColorBrush_Static, SolidColorBrush_Static_bases.get())};
    if (!type_SolidColorBrush_Static)
    {
        return nullptr;
    }

    py::pyobj_handle SolidColorBrush_bases{PyTuple_Pack(1, Brush_type.get())};
    if (!SolidColorBrush_bases)
    {
        return nullptr;
    }

    py::pytype_handle SolidColorBrush_type{py::register_python_type(module.get(), &type_spec_SolidColorBrush, SolidColorBrush_bases.get(), reinterpret_cast<PyTypeObject*>(type_SolidColorBrush_Static.get()))};
    if (!SolidColorBrush_type)
    {
        return nullptr;
    }

    py::pyobj_handle ThemeShadow_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(Shadow_type.get())))};
    if (!ThemeShadow_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ThemeShadow_Static{PyType_FromSpecWithBases(&type_spec_ThemeShadow_Static, ThemeShadow_Static_bases.get())};
    if (!type_ThemeShadow_Static)
    {
        return nullptr;
    }

    py::pyobj_handle ThemeShadow_bases{PyTuple_Pack(1, Shadow_type.get())};
    if (!ThemeShadow_bases)
    {
        return nullptr;
    }

    py::pytype_handle ThemeShadow_type{py::register_python_type(module.get(), &type_spec_ThemeShadow, ThemeShadow_bases.get(), reinterpret_cast<PyTypeObject*>(type_ThemeShadow_Static.get()))};
    if (!ThemeShadow_type)
    {
        return nullptr;
    }

    py::pyobj_handle TimelineMarker_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!TimelineMarker_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TimelineMarker_Static{PyType_FromSpecWithBases(&type_spec_TimelineMarker_Static, TimelineMarker_Static_bases.get())};
    if (!type_TimelineMarker_Static)
    {
        return nullptr;
    }

    py::pyobj_handle TimelineMarker_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!TimelineMarker_bases)
    {
        return nullptr;
    }

    py::pytype_handle TimelineMarker_type{py::register_python_type(module.get(), &type_spec_TimelineMarker, TimelineMarker_bases.get(), reinterpret_cast<PyTypeObject*>(type_TimelineMarker_Static.get()))};
    if (!TimelineMarker_type)
    {
        return nullptr;
    }

    py::pytype_handle TimelineMarkerCollection_type{py::register_python_type(module.get(), &type_spec_TimelineMarkerCollection, object_bases.get(), nullptr)};
    if (!TimelineMarkerCollection_type)
    {
        return nullptr;
    }

    py::pyobj_handle TimelineMarkerRoutedEventArgs_bases{PyTuple_Pack(1, windows_ui_xaml_RoutedEventArgs_type.get())};
    if (!TimelineMarkerRoutedEventArgs_bases)
    {
        return nullptr;
    }

    py::pytype_handle TimelineMarkerRoutedEventArgs_type{py::register_python_type(module.get(), &type_spec_TimelineMarkerRoutedEventArgs, TimelineMarkerRoutedEventArgs_bases.get(), nullptr)};
    if (!TimelineMarkerRoutedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle TransformCollection_type{py::register_python_type(module.get(), &type_spec_TransformCollection, object_bases.get(), nullptr)};
    if (!TransformCollection_type)
    {
        return nullptr;
    }

    py::pyobj_handle TransformGroup_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(Transform_type.get())))};
    if (!TransformGroup_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TransformGroup_Static{PyType_FromSpecWithBases(&type_spec_TransformGroup_Static, TransformGroup_Static_bases.get())};
    if (!type_TransformGroup_Static)
    {
        return nullptr;
    }

    py::pyobj_handle TransformGroup_bases{PyTuple_Pack(1, Transform_type.get())};
    if (!TransformGroup_bases)
    {
        return nullptr;
    }

    py::pytype_handle TransformGroup_type{py::register_python_type(module.get(), &type_spec_TransformGroup, TransformGroup_bases.get(), reinterpret_cast<PyTypeObject*>(type_TransformGroup_Static.get()))};
    if (!TransformGroup_type)
    {
        return nullptr;
    }

    py::pyobj_handle TranslateTransform_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(Transform_type.get())))};
    if (!TranslateTransform_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TranslateTransform_Static{PyType_FromSpecWithBases(&type_spec_TranslateTransform_Static, TranslateTransform_Static_bases.get())};
    if (!type_TranslateTransform_Static)
    {
        return nullptr;
    }

    py::pyobj_handle TranslateTransform_bases{PyTuple_Pack(1, Transform_type.get())};
    if (!TranslateTransform_bases)
    {
        return nullptr;
    }

    py::pytype_handle TranslateTransform_type{py::register_python_type(module.get(), &type_spec_TranslateTransform, TranslateTransform_bases.get(), reinterpret_cast<PyTypeObject*>(type_TranslateTransform_Static.get()))};
    if (!TranslateTransform_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_VisualTreeHelper_Static{PyType_FromSpec(&type_spec_VisualTreeHelper_Static)};
    if (!type_VisualTreeHelper_Static)
    {
        return nullptr;
    }

    py::pytype_handle VisualTreeHelper_type{py::register_python_type(module.get(), &type_spec_VisualTreeHelper, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_VisualTreeHelper_Static.get()))};
    if (!VisualTreeHelper_type)
    {
        return nullptr;
    }

    py::pyobj_handle XamlLight_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(windows_ui_xaml_DependencyObject_type.get())))};
    if (!XamlLight_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_XamlLight_Static{PyType_FromSpecWithBases(&type_spec_XamlLight_Static, XamlLight_Static_bases.get())};
    if (!type_XamlLight_Static)
    {
        return nullptr;
    }

    py::pyobj_handle XamlLight_bases{PyTuple_Pack(1, windows_ui_xaml_DependencyObject_type.get())};
    if (!XamlLight_bases)
    {
        return nullptr;
    }

    py::pytype_handle XamlLight_type{py::register_python_type(module.get(), &type_spec_XamlLight, XamlLight_bases.get(), reinterpret_cast<PyTypeObject*>(type_XamlLight_Static.get()))};
    if (!XamlLight_type)
    {
        return nullptr;
    }

    py::pytype_handle Matrix_type{py::register_python_type(module.get(), &type_spec_Matrix, nullptr, nullptr)};
    if (!Matrix_type)
    {
        return nullptr;
    }


    return module.detach();
}
