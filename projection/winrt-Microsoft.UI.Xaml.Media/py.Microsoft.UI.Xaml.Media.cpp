// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Microsoft.UI.Xaml.Media.h"


namespace py::cpp::Microsoft::UI::Xaml::Media
{
    // ----- AcrylicBrush class --------------------

    static PyObject* _new_AcrylicBrush(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::AcrylicBrush instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AcrylicBrush(py::wrapper::Microsoft::UI::Xaml::Media::AcrylicBrush* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AcrylicBrush_get_TintTransitionDuration(py::wrapper::Microsoft::UI::Xaml::Media::AcrylicBrush* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.AcrylicBrush", L"TintTransitionDuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TintTransitionDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AcrylicBrush_put_TintTransitionDuration(py::wrapper::Microsoft::UI::Xaml::Media::AcrylicBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.AcrylicBrush", L"TintTransitionDuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.TintTransitionDuration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AcrylicBrush_get_TintOpacity(py::wrapper::Microsoft::UI::Xaml::Media::AcrylicBrush* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.AcrylicBrush", L"TintOpacity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TintOpacity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AcrylicBrush_put_TintOpacity(py::wrapper::Microsoft::UI::Xaml::Media::AcrylicBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.AcrylicBrush", L"TintOpacity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.TintOpacity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AcrylicBrush_get_TintColor(py::wrapper::Microsoft::UI::Xaml::Media::AcrylicBrush* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.AcrylicBrush", L"TintColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TintColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AcrylicBrush_put_TintColor(py::wrapper::Microsoft::UI::Xaml::Media::AcrylicBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.AcrylicBrush", L"TintColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.TintColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AcrylicBrush_get_AlwaysUseFallback(py::wrapper::Microsoft::UI::Xaml::Media::AcrylicBrush* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.AcrylicBrush", L"AlwaysUseFallback"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AlwaysUseFallback());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AcrylicBrush_put_AlwaysUseFallback(py::wrapper::Microsoft::UI::Xaml::Media::AcrylicBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.AcrylicBrush", L"AlwaysUseFallback"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AlwaysUseFallback(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AcrylicBrush_get_TintLuminosityOpacity(py::wrapper::Microsoft::UI::Xaml::Media::AcrylicBrush* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.AcrylicBrush", L"TintLuminosityOpacity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TintLuminosityOpacity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AcrylicBrush_put_TintLuminosityOpacity(py::wrapper::Microsoft::UI::Xaml::Media::AcrylicBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.AcrylicBrush", L"TintLuminosityOpacity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<double>>(arg);

            self->obj.TintLuminosityOpacity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AcrylicBrush_get_AlwaysUseFallbackProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.AcrylicBrush", L"AlwaysUseFallbackProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::AcrylicBrush::AlwaysUseFallbackProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AcrylicBrush_get_TintColorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.AcrylicBrush", L"TintColorProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::AcrylicBrush::TintColorProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AcrylicBrush_get_TintOpacityProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.AcrylicBrush", L"TintOpacityProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::AcrylicBrush::TintOpacityProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AcrylicBrush_get_TintTransitionDurationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.AcrylicBrush", L"TintTransitionDurationProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::AcrylicBrush::TintTransitionDurationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AcrylicBrush_get_TintLuminosityOpacityProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.AcrylicBrush", L"TintLuminosityOpacityProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::AcrylicBrush::TintLuminosityOpacityProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AcrylicBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::AcrylicBrush>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AcrylicBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::AcrylicBrush>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AcrylicBrush[] = {
        { "_assign_array_", _assign_array_AcrylicBrush, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AcrylicBrush), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AcrylicBrush[] = {
        { "tint_transition_duration", reinterpret_cast<getter>(AcrylicBrush_get_TintTransitionDuration), reinterpret_cast<setter>(AcrylicBrush_put_TintTransitionDuration), nullptr, nullptr },
        { "tint_opacity", reinterpret_cast<getter>(AcrylicBrush_get_TintOpacity), reinterpret_cast<setter>(AcrylicBrush_put_TintOpacity), nullptr, nullptr },
        { "tint_color", reinterpret_cast<getter>(AcrylicBrush_get_TintColor), reinterpret_cast<setter>(AcrylicBrush_put_TintColor), nullptr, nullptr },
        { "always_use_fallback", reinterpret_cast<getter>(AcrylicBrush_get_AlwaysUseFallback), reinterpret_cast<setter>(AcrylicBrush_put_AlwaysUseFallback), nullptr, nullptr },
        { "tint_luminosity_opacity", reinterpret_cast<getter>(AcrylicBrush_get_TintLuminosityOpacity), reinterpret_cast<setter>(AcrylicBrush_put_TintLuminosityOpacity), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AcrylicBrush[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AcrylicBrush) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AcrylicBrush) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AcrylicBrush) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AcrylicBrush) },
        { },
    };

    static PyType_Spec type_spec_AcrylicBrush =
    {
        "winrt._winrt_microsoft_ui_xaml_media.AcrylicBrush",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::AcrylicBrush),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AcrylicBrush
    };

    static PyGetSetDef getset_AcrylicBrush_Static[] = {
        { "always_use_fallback_property", reinterpret_cast<getter>(AcrylicBrush_get_AlwaysUseFallbackProperty), nullptr, nullptr, nullptr },
        { "tint_color_property", reinterpret_cast<getter>(AcrylicBrush_get_TintColorProperty), nullptr, nullptr, nullptr },
        { "tint_opacity_property", reinterpret_cast<getter>(AcrylicBrush_get_TintOpacityProperty), nullptr, nullptr, nullptr },
        { "tint_transition_duration_property", reinterpret_cast<getter>(AcrylicBrush_get_TintTransitionDurationProperty), nullptr, nullptr, nullptr },
        { "tint_luminosity_opacity_property", reinterpret_cast<getter>(AcrylicBrush_get_TintLuminosityOpacityProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_AcrylicBrush_Static[] = {
        { }
    };

    static PyType_Slot type_slots_AcrylicBrush_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AcrylicBrush_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AcrylicBrush_Static) },
        { }
    };

    static PyType_Spec type_spec_AcrylicBrush_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.AcrylicBrush_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AcrylicBrush_Static
    };

    // ----- ArcSegment class --------------------

    static PyObject* _new_ArcSegment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::ArcSegment instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ArcSegment(py::wrapper::Microsoft::UI::Xaml::Media::ArcSegment* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ArcSegment_get_SweepDirection(py::wrapper::Microsoft::UI::Xaml::Media::ArcSegment* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.ArcSegment", L"SweepDirection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SweepDirection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ArcSegment_put_SweepDirection(py::wrapper::Microsoft::UI::Xaml::Media::ArcSegment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.ArcSegment", L"SweepDirection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::SweepDirection>(arg);

            self->obj.SweepDirection(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ArcSegment_get_Size(py::wrapper::Microsoft::UI::Xaml::Media::ArcSegment* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.ArcSegment", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ArcSegment_put_Size(py::wrapper::Microsoft::UI::Xaml::Media::ArcSegment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.ArcSegment", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(arg);

            self->obj.Size(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ArcSegment_get_RotationAngle(py::wrapper::Microsoft::UI::Xaml::Media::ArcSegment* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.ArcSegment", L"RotationAngle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RotationAngle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ArcSegment_put_RotationAngle(py::wrapper::Microsoft::UI::Xaml::Media::ArcSegment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.ArcSegment", L"RotationAngle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.RotationAngle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ArcSegment_get_Point(py::wrapper::Microsoft::UI::Xaml::Media::ArcSegment* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.ArcSegment", L"Point"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Point());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ArcSegment_put_Point(py::wrapper::Microsoft::UI::Xaml::Media::ArcSegment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.ArcSegment", L"Point"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.Point(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ArcSegment_get_IsLargeArc(py::wrapper::Microsoft::UI::Xaml::Media::ArcSegment* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.ArcSegment", L"IsLargeArc"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsLargeArc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ArcSegment_put_IsLargeArc(py::wrapper::Microsoft::UI::Xaml::Media::ArcSegment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.ArcSegment", L"IsLargeArc"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsLargeArc(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ArcSegment_get_IsLargeArcProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.ArcSegment", L"IsLargeArcProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::ArcSegment::IsLargeArcProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcSegment_get_PointProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.ArcSegment", L"PointProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::ArcSegment::PointProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcSegment_get_RotationAngleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.ArcSegment", L"RotationAngleProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::ArcSegment::RotationAngleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcSegment_get_SizeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.ArcSegment", L"SizeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::ArcSegment::SizeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcSegment_get_SweepDirectionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.ArcSegment", L"SweepDirectionProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::ArcSegment::SweepDirectionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ArcSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::ArcSegment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ArcSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::ArcSegment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ArcSegment[] = {
        { "_assign_array_", _assign_array_ArcSegment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ArcSegment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ArcSegment[] = {
        { "sweep_direction", reinterpret_cast<getter>(ArcSegment_get_SweepDirection), reinterpret_cast<setter>(ArcSegment_put_SweepDirection), nullptr, nullptr },
        { "size", reinterpret_cast<getter>(ArcSegment_get_Size), reinterpret_cast<setter>(ArcSegment_put_Size), nullptr, nullptr },
        { "rotation_angle", reinterpret_cast<getter>(ArcSegment_get_RotationAngle), reinterpret_cast<setter>(ArcSegment_put_RotationAngle), nullptr, nullptr },
        { "point", reinterpret_cast<getter>(ArcSegment_get_Point), reinterpret_cast<setter>(ArcSegment_put_Point), nullptr, nullptr },
        { "is_large_arc", reinterpret_cast<getter>(ArcSegment_get_IsLargeArc), reinterpret_cast<setter>(ArcSegment_put_IsLargeArc), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ArcSegment[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ArcSegment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ArcSegment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ArcSegment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ArcSegment) },
        { },
    };

    static PyType_Spec type_spec_ArcSegment =
    {
        "winrt._winrt_microsoft_ui_xaml_media.ArcSegment",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::ArcSegment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ArcSegment
    };

    static PyGetSetDef getset_ArcSegment_Static[] = {
        { "is_large_arc_property", reinterpret_cast<getter>(ArcSegment_get_IsLargeArcProperty), nullptr, nullptr, nullptr },
        { "point_property", reinterpret_cast<getter>(ArcSegment_get_PointProperty), nullptr, nullptr, nullptr },
        { "rotation_angle_property", reinterpret_cast<getter>(ArcSegment_get_RotationAngleProperty), nullptr, nullptr, nullptr },
        { "size_property", reinterpret_cast<getter>(ArcSegment_get_SizeProperty), nullptr, nullptr, nullptr },
        { "sweep_direction_property", reinterpret_cast<getter>(ArcSegment_get_SweepDirectionProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ArcSegment_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ArcSegment_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ArcSegment_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ArcSegment_Static) },
        { }
    };

    static PyType_Spec type_spec_ArcSegment_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.ArcSegment_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ArcSegment_Static
    };

    // ----- BezierSegment class --------------------

    static PyObject* _new_BezierSegment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::BezierSegment instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BezierSegment(py::wrapper::Microsoft::UI::Xaml::Media::BezierSegment* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BezierSegment_get_Point3(py::wrapper::Microsoft::UI::Xaml::Media::BezierSegment* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.BezierSegment", L"Point3"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Point3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BezierSegment_put_Point3(py::wrapper::Microsoft::UI::Xaml::Media::BezierSegment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.BezierSegment", L"Point3"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.Point3(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BezierSegment_get_Point2(py::wrapper::Microsoft::UI::Xaml::Media::BezierSegment* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.BezierSegment", L"Point2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Point2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BezierSegment_put_Point2(py::wrapper::Microsoft::UI::Xaml::Media::BezierSegment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.BezierSegment", L"Point2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.Point2(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BezierSegment_get_Point1(py::wrapper::Microsoft::UI::Xaml::Media::BezierSegment* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.BezierSegment", L"Point1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Point1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BezierSegment_put_Point1(py::wrapper::Microsoft::UI::Xaml::Media::BezierSegment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.BezierSegment", L"Point1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.Point1(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BezierSegment_get_Point1Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.BezierSegment", L"Point1Property"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::BezierSegment::Point1Property());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BezierSegment_get_Point2Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.BezierSegment", L"Point2Property"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::BezierSegment::Point2Property());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BezierSegment_get_Point3Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.BezierSegment", L"Point3Property"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::BezierSegment::Point3Property());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BezierSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::BezierSegment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BezierSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::BezierSegment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BezierSegment[] = {
        { "_assign_array_", _assign_array_BezierSegment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BezierSegment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BezierSegment[] = {
        { "point3", reinterpret_cast<getter>(BezierSegment_get_Point3), reinterpret_cast<setter>(BezierSegment_put_Point3), nullptr, nullptr },
        { "point2", reinterpret_cast<getter>(BezierSegment_get_Point2), reinterpret_cast<setter>(BezierSegment_put_Point2), nullptr, nullptr },
        { "point1", reinterpret_cast<getter>(BezierSegment_get_Point1), reinterpret_cast<setter>(BezierSegment_put_Point1), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BezierSegment[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BezierSegment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BezierSegment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BezierSegment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BezierSegment) },
        { },
    };

    static PyType_Spec type_spec_BezierSegment =
    {
        "winrt._winrt_microsoft_ui_xaml_media.BezierSegment",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::BezierSegment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BezierSegment
    };

    static PyGetSetDef getset_BezierSegment_Static[] = {
        { "point1_property", reinterpret_cast<getter>(BezierSegment_get_Point1Property), nullptr, nullptr, nullptr },
        { "point2_property", reinterpret_cast<getter>(BezierSegment_get_Point2Property), nullptr, nullptr, nullptr },
        { "point3_property", reinterpret_cast<getter>(BezierSegment_get_Point3Property), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_BezierSegment_Static[] = {
        { }
    };

    static PyType_Slot type_slots_BezierSegment_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BezierSegment_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BezierSegment_Static) },
        { }
    };

    static PyType_Spec type_spec_BezierSegment_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.BezierSegment_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BezierSegment_Static
    };

    // ----- BitmapCache class --------------------

    static PyObject* _new_BitmapCache(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::BitmapCache instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BitmapCache(py::wrapper::Microsoft::UI::Xaml::Media::BitmapCache* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_BitmapCache(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::BitmapCache>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BitmapCache(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::BitmapCache>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BitmapCache[] = {
        { "_assign_array_", _assign_array_BitmapCache, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BitmapCache), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BitmapCache[] = {
        { }
    };

    static PyType_Slot _type_slots_BitmapCache[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BitmapCache) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BitmapCache) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BitmapCache) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BitmapCache) },
        { },
    };

    static PyType_Spec type_spec_BitmapCache =
    {
        "winrt._winrt_microsoft_ui_xaml_media.BitmapCache",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::BitmapCache),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapCache
    };

    // ----- Brush class --------------------

    static PyObject* _new_Brush(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Media::Brush>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Media::Brush>::type_name);
        return nullptr;
    }

    static void _dealloc_Brush(py::wrapper::Microsoft::UI::Xaml::Media::Brush* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Brush_PopulatePropertyInfo(py::wrapper::Microsoft::UI::Xaml::Media::Brush* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.Brush", L"PopulatePropertyInfo", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::AnimationPropertyInfo>(args, 1);

                self->obj.PopulatePropertyInfo(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Brush_PopulatePropertyInfoOverride(py::wrapper::Microsoft::UI::Xaml::Media::Brush* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.Brush", L"PopulatePropertyInfoOverride", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Composition::AnimationPropertyInfo>(args, 1);

                self->obj.PopulatePropertyInfoOverride(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Brush_get_Transform(py::wrapper::Microsoft::UI::Xaml::Media::Brush* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Brush", L"Transform"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Transform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Brush_put_Transform(py::wrapper::Microsoft::UI::Xaml::Media::Brush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Brush", L"Transform"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Transform>(arg);

            self->obj.Transform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Brush_get_RelativeTransform(py::wrapper::Microsoft::UI::Xaml::Media::Brush* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Brush", L"RelativeTransform"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RelativeTransform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Brush_put_RelativeTransform(py::wrapper::Microsoft::UI::Xaml::Media::Brush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Brush", L"RelativeTransform"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Transform>(arg);

            self->obj.RelativeTransform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Brush_get_Opacity(py::wrapper::Microsoft::UI::Xaml::Media::Brush* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Brush", L"Opacity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Opacity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Brush_put_Opacity(py::wrapper::Microsoft::UI::Xaml::Media::Brush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Brush", L"Opacity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Opacity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Brush_get_OpacityProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Brush", L"OpacityProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::Brush::OpacityProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Brush_get_RelativeTransformProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Brush", L"RelativeTransformProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::Brush::RelativeTransformProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Brush_get_TransformProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Brush", L"TransformProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::Brush::TransformProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Brush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::Brush>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Brush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::Brush>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Brush[] = {
        { "populate_property_info", reinterpret_cast<PyCFunction>(Brush_PopulatePropertyInfo), METH_VARARGS, nullptr },
        { "populate_property_info_override", reinterpret_cast<PyCFunction>(Brush_PopulatePropertyInfoOverride), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_Brush, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Brush), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Brush[] = {
        { "transform", reinterpret_cast<getter>(Brush_get_Transform), reinterpret_cast<setter>(Brush_put_Transform), nullptr, nullptr },
        { "relative_transform", reinterpret_cast<getter>(Brush_get_RelativeTransform), reinterpret_cast<setter>(Brush_put_RelativeTransform), nullptr, nullptr },
        { "opacity", reinterpret_cast<getter>(Brush_get_Opacity), reinterpret_cast<setter>(Brush_put_Opacity), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Brush[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Brush) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Brush) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Brush) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Brush) },
        { },
    };

    static PyType_Spec type_spec_Brush =
    {
        "winrt._winrt_microsoft_ui_xaml_media.Brush",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::Brush),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Brush
    };

    static PyGetSetDef getset_Brush_Static[] = {
        { "opacity_property", reinterpret_cast<getter>(Brush_get_OpacityProperty), nullptr, nullptr, nullptr },
        { "relative_transform_property", reinterpret_cast<getter>(Brush_get_RelativeTransformProperty), nullptr, nullptr, nullptr },
        { "transform_property", reinterpret_cast<getter>(Brush_get_TransformProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Brush_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Brush_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Brush_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Brush_Static) },
        { }
    };

    static PyType_Spec type_spec_Brush_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.Brush_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Brush_Static
    };

    // ----- BrushCollection class --------------------

    static PyObject* _new_BrushCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::BrushCollection instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BrushCollection(py::wrapper::Microsoft::UI::Xaml::Media::BrushCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BrushCollection_Append(py::wrapper::Microsoft::UI::Xaml::Media::BrushCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.BrushCollection", L"Append", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BrushCollection_Clear(py::wrapper::Microsoft::UI::Xaml::Media::BrushCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.BrushCollection", L"Clear", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BrushCollection_First(py::wrapper::Microsoft::UI::Xaml::Media::BrushCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.BrushCollection", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BrushCollection_GetAt(py::wrapper::Microsoft::UI::Xaml::Media::BrushCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.BrushCollection", L"GetAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BrushCollection_GetMany(py::wrapper::Microsoft::UI::Xaml::Media::BrushCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.BrushCollection", L"GetMany", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Microsoft::UI::Xaml::Media::Brush, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BrushCollection_GetView(py::wrapper::Microsoft::UI::Xaml::Media::BrushCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.BrushCollection", L"GetView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BrushCollection_IndexOf(py::wrapper::Microsoft::UI::Xaml::Media::BrushCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.BrushCollection", L"IndexOf", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BrushCollection_InsertAt(py::wrapper::Microsoft::UI::Xaml::Media::BrushCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.BrushCollection", L"InsertAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BrushCollection_RemoveAt(py::wrapper::Microsoft::UI::Xaml::Media::BrushCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.BrushCollection", L"RemoveAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BrushCollection_RemoveAtEnd(py::wrapper::Microsoft::UI::Xaml::Media::BrushCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.BrushCollection", L"RemoveAtEnd", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BrushCollection_ReplaceAll(py::wrapper::Microsoft::UI::Xaml::Media::BrushCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.BrushCollection", L"ReplaceAll", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Microsoft::UI::Xaml::Media::Brush, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BrushCollection_SetAt(py::wrapper::Microsoft::UI::Xaml::Media::BrushCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.BrushCollection", L"SetAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BrushCollection_get_Size(py::wrapper::Microsoft::UI::Xaml::Media::BrushCollection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.BrushCollection", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BrushCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::BrushCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BrushCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::BrushCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_BrushCollection(py::wrapper::Microsoft::UI::Xaml::Media::BrushCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_BrushCollection(py::wrapper::Microsoft::UI::Xaml::Media::BrushCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_BrushCollection(py::wrapper::Microsoft::UI::Xaml::Media::BrushCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_BrushCollection(py::wrapper::Microsoft::UI::Xaml::Media::BrushCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_BrushCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(
                    PyExc_NotImplementedError,
                    "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Microsoft::UI::Xaml::Media::Brush> items(static_cast<uint32_t>(length), empty_instance<winrt::Microsoft::UI::Xaml::Media::Brush>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(
                    PyExc_RuntimeError,
                    "returned count %d did not match requested length %zd",
                    count,
                    length);
                return nullptr;
            }

            return convert(items);}
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_BrushCollection(py::wrapper::Microsoft::UI::Xaml::Media::BrushCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_BrushCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(BrushCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(BrushCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(BrushCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(BrushCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(BrushCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(BrushCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(BrushCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(BrushCollection_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(BrushCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(BrushCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(BrushCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(BrushCollection_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BrushCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BrushCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BrushCollection[] = {
        { "size", reinterpret_cast<getter>(BrushCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BrushCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BrushCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BrushCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BrushCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BrushCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_BrushCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_BrushCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_BrushCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_BrushCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_BrushCollection) },
        { },
    };

    static PyType_Spec type_spec_BrushCollection =
    {
        "winrt._winrt_microsoft_ui_xaml_media.BrushCollection",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::BrushCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BrushCollection
    };

    // ----- CacheMode class --------------------

    static PyObject* _new_CacheMode(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Media::CacheMode>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Media::CacheMode>::type_name);
        return nullptr;
    }

    static void _dealloc_CacheMode(py::wrapper::Microsoft::UI::Xaml::Media::CacheMode* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_CacheMode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::CacheMode>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CacheMode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::CacheMode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CacheMode[] = {
        { "_assign_array_", _assign_array_CacheMode, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CacheMode), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CacheMode[] = {
        { }
    };

    static PyType_Slot _type_slots_CacheMode[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CacheMode) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CacheMode) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CacheMode) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CacheMode) },
        { },
    };

    static PyType_Spec type_spec_CacheMode =
    {
        "winrt._winrt_microsoft_ui_xaml_media.CacheMode",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::CacheMode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CacheMode
    };

    // ----- CompositeTransform class --------------------

    static PyObject* _new_CompositeTransform(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::CompositeTransform instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CompositeTransform(py::wrapper::Microsoft::UI::Xaml::Media::CompositeTransform* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositeTransform_get_TranslateY(py::wrapper::Microsoft::UI::Xaml::Media::CompositeTransform* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.CompositeTransform", L"TranslateY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TranslateY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositeTransform_put_TranslateY(py::wrapper::Microsoft::UI::Xaml::Media::CompositeTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.CompositeTransform", L"TranslateY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.TranslateY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositeTransform_get_TranslateX(py::wrapper::Microsoft::UI::Xaml::Media::CompositeTransform* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.CompositeTransform", L"TranslateX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TranslateX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositeTransform_put_TranslateX(py::wrapper::Microsoft::UI::Xaml::Media::CompositeTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.CompositeTransform", L"TranslateX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.TranslateX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositeTransform_get_SkewY(py::wrapper::Microsoft::UI::Xaml::Media::CompositeTransform* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.CompositeTransform", L"SkewY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SkewY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositeTransform_put_SkewY(py::wrapper::Microsoft::UI::Xaml::Media::CompositeTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.CompositeTransform", L"SkewY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.SkewY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositeTransform_get_SkewX(py::wrapper::Microsoft::UI::Xaml::Media::CompositeTransform* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.CompositeTransform", L"SkewX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SkewX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositeTransform_put_SkewX(py::wrapper::Microsoft::UI::Xaml::Media::CompositeTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.CompositeTransform", L"SkewX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.SkewX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositeTransform_get_ScaleY(py::wrapper::Microsoft::UI::Xaml::Media::CompositeTransform* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.CompositeTransform", L"ScaleY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ScaleY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositeTransform_put_ScaleY(py::wrapper::Microsoft::UI::Xaml::Media::CompositeTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.CompositeTransform", L"ScaleY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.ScaleY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositeTransform_get_ScaleX(py::wrapper::Microsoft::UI::Xaml::Media::CompositeTransform* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.CompositeTransform", L"ScaleX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ScaleX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositeTransform_put_ScaleX(py::wrapper::Microsoft::UI::Xaml::Media::CompositeTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.CompositeTransform", L"ScaleX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.ScaleX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositeTransform_get_Rotation(py::wrapper::Microsoft::UI::Xaml::Media::CompositeTransform* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.CompositeTransform", L"Rotation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Rotation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositeTransform_put_Rotation(py::wrapper::Microsoft::UI::Xaml::Media::CompositeTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.CompositeTransform", L"Rotation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Rotation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositeTransform_get_CenterY(py::wrapper::Microsoft::UI::Xaml::Media::CompositeTransform* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.CompositeTransform", L"CenterY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CenterY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositeTransform_put_CenterY(py::wrapper::Microsoft::UI::Xaml::Media::CompositeTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.CompositeTransform", L"CenterY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.CenterY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositeTransform_get_CenterX(py::wrapper::Microsoft::UI::Xaml::Media::CompositeTransform* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.CompositeTransform", L"CenterX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CenterX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CompositeTransform_put_CenterX(py::wrapper::Microsoft::UI::Xaml::Media::CompositeTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.CompositeTransform", L"CenterX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.CenterX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CompositeTransform_get_CenterXProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.CompositeTransform", L"CenterXProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::CompositeTransform::CenterXProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositeTransform_get_CenterYProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.CompositeTransform", L"CenterYProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::CompositeTransform::CenterYProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositeTransform_get_RotationProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.CompositeTransform", L"RotationProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::CompositeTransform::RotationProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositeTransform_get_ScaleXProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.CompositeTransform", L"ScaleXProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::CompositeTransform::ScaleXProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositeTransform_get_ScaleYProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.CompositeTransform", L"ScaleYProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::CompositeTransform::ScaleYProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositeTransform_get_SkewXProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.CompositeTransform", L"SkewXProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::CompositeTransform::SkewXProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositeTransform_get_SkewYProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.CompositeTransform", L"SkewYProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::CompositeTransform::SkewYProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositeTransform_get_TranslateXProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.CompositeTransform", L"TranslateXProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::CompositeTransform::TranslateXProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositeTransform_get_TranslateYProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.CompositeTransform", L"TranslateYProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::CompositeTransform::TranslateYProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CompositeTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::CompositeTransform>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositeTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::CompositeTransform>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositeTransform[] = {
        { "_assign_array_", _assign_array_CompositeTransform, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositeTransform), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositeTransform[] = {
        { "translate_y", reinterpret_cast<getter>(CompositeTransform_get_TranslateY), reinterpret_cast<setter>(CompositeTransform_put_TranslateY), nullptr, nullptr },
        { "translate_x", reinterpret_cast<getter>(CompositeTransform_get_TranslateX), reinterpret_cast<setter>(CompositeTransform_put_TranslateX), nullptr, nullptr },
        { "skew_y", reinterpret_cast<getter>(CompositeTransform_get_SkewY), reinterpret_cast<setter>(CompositeTransform_put_SkewY), nullptr, nullptr },
        { "skew_x", reinterpret_cast<getter>(CompositeTransform_get_SkewX), reinterpret_cast<setter>(CompositeTransform_put_SkewX), nullptr, nullptr },
        { "scale_y", reinterpret_cast<getter>(CompositeTransform_get_ScaleY), reinterpret_cast<setter>(CompositeTransform_put_ScaleY), nullptr, nullptr },
        { "scale_x", reinterpret_cast<getter>(CompositeTransform_get_ScaleX), reinterpret_cast<setter>(CompositeTransform_put_ScaleX), nullptr, nullptr },
        { "rotation", reinterpret_cast<getter>(CompositeTransform_get_Rotation), reinterpret_cast<setter>(CompositeTransform_put_Rotation), nullptr, nullptr },
        { "center_y", reinterpret_cast<getter>(CompositeTransform_get_CenterY), reinterpret_cast<setter>(CompositeTransform_put_CenterY), nullptr, nullptr },
        { "center_x", reinterpret_cast<getter>(CompositeTransform_get_CenterX), reinterpret_cast<setter>(CompositeTransform_put_CenterX), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositeTransform[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositeTransform) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositeTransform) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositeTransform) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositeTransform) },
        { },
    };

    static PyType_Spec type_spec_CompositeTransform =
    {
        "winrt._winrt_microsoft_ui_xaml_media.CompositeTransform",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::CompositeTransform),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositeTransform
    };

    static PyGetSetDef getset_CompositeTransform_Static[] = {
        { "center_x_property", reinterpret_cast<getter>(CompositeTransform_get_CenterXProperty), nullptr, nullptr, nullptr },
        { "center_y_property", reinterpret_cast<getter>(CompositeTransform_get_CenterYProperty), nullptr, nullptr, nullptr },
        { "rotation_property", reinterpret_cast<getter>(CompositeTransform_get_RotationProperty), nullptr, nullptr, nullptr },
        { "scale_x_property", reinterpret_cast<getter>(CompositeTransform_get_ScaleXProperty), nullptr, nullptr, nullptr },
        { "scale_y_property", reinterpret_cast<getter>(CompositeTransform_get_ScaleYProperty), nullptr, nullptr, nullptr },
        { "skew_x_property", reinterpret_cast<getter>(CompositeTransform_get_SkewXProperty), nullptr, nullptr, nullptr },
        { "skew_y_property", reinterpret_cast<getter>(CompositeTransform_get_SkewYProperty), nullptr, nullptr, nullptr },
        { "translate_x_property", reinterpret_cast<getter>(CompositeTransform_get_TranslateXProperty), nullptr, nullptr, nullptr },
        { "translate_y_property", reinterpret_cast<getter>(CompositeTransform_get_TranslateYProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_CompositeTransform_Static[] = {
        { }
    };

    static PyType_Slot type_slots_CompositeTransform_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CompositeTransform_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CompositeTransform_Static) },
        { }
    };

    static PyType_Spec type_spec_CompositeTransform_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.CompositeTransform_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CompositeTransform_Static
    };

    // ----- CompositionTarget class --------------------

    static PyObject* _new_CompositionTarget(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Media::CompositionTarget>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Media::CompositionTarget>::type_name);
        return nullptr;
    }

    static void _dealloc_CompositionTarget(py::wrapper::Microsoft::UI::Xaml::Media::CompositionTarget* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CompositionTarget_GetCompositorForCurrentThread(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.CompositionTarget", L"GetCompositorForCurrentThread", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Microsoft::UI::Xaml::Media::CompositionTarget::GetCompositorForCurrentThread());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositionTarget_add_Rendered(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Media.CompositionTarget", L"Rendered"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Microsoft::UI::Xaml::Media::RenderedEventArgs>>(arg);

            return py::convert(winrt::Microsoft::UI::Xaml::Media::CompositionTarget::Rendered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositionTarget_remove_Rendered(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Media.CompositionTarget", L"Rendered"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Microsoft::UI::Xaml::Media::CompositionTarget::Rendered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositionTarget_add_Rendering(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Media.CompositionTarget", L"Rendering"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Microsoft::UI::Xaml::Media::CompositionTarget::Rendering(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositionTarget_remove_Rendering(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Media.CompositionTarget", L"Rendering"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Microsoft::UI::Xaml::Media::CompositionTarget::Rendering(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositionTarget_add_SurfaceContentsLost(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Media.CompositionTarget", L"SurfaceContentsLost"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Microsoft::UI::Xaml::Media::CompositionTarget::SurfaceContentsLost(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositionTarget_remove_SurfaceContentsLost(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Media.CompositionTarget", L"SurfaceContentsLost"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Microsoft::UI::Xaml::Media::CompositionTarget::SurfaceContentsLost(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CompositionTarget(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::CompositionTarget>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CompositionTarget(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::CompositionTarget>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositionTarget[] = {
        { "add_rendered", reinterpret_cast<PyCFunction>(CompositionTarget_add_Rendered), METH_O | METH_STATIC, nullptr },
        { "remove_rendered", reinterpret_cast<PyCFunction>(CompositionTarget_remove_Rendered), METH_O | METH_STATIC, nullptr },
        { "add_rendering", reinterpret_cast<PyCFunction>(CompositionTarget_add_Rendering), METH_O | METH_STATIC, nullptr },
        { "remove_rendering", reinterpret_cast<PyCFunction>(CompositionTarget_remove_Rendering), METH_O | METH_STATIC, nullptr },
        { "add_surface_contents_lost", reinterpret_cast<PyCFunction>(CompositionTarget_add_SurfaceContentsLost), METH_O | METH_STATIC, nullptr },
        { "remove_surface_contents_lost", reinterpret_cast<PyCFunction>(CompositionTarget_remove_SurfaceContentsLost), METH_O | METH_STATIC, nullptr },
        { "_assign_array_", _assign_array_CompositionTarget, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositionTarget), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositionTarget[] = {
        { }
    };

    static PyType_Slot _type_slots_CompositionTarget[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CompositionTarget) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CompositionTarget) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CompositionTarget) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CompositionTarget) },
        { },
    };

    static PyType_Spec type_spec_CompositionTarget =
    {
        "winrt._winrt_microsoft_ui_xaml_media.CompositionTarget",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::CompositionTarget),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositionTarget
    };

    static PyGetSetDef getset_CompositionTarget_Static[] = {
        { }
    };

    static PyMethodDef methods_CompositionTarget_Static[] = {
        { "get_compositor_for_current_thread", reinterpret_cast<PyCFunction>(CompositionTarget_GetCompositorForCurrentThread), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_CompositionTarget_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CompositionTarget_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CompositionTarget_Static) },
        { }
    };

    static PyType_Spec type_spec_CompositionTarget_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.CompositionTarget_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CompositionTarget_Static
    };

    // ----- DesktopAcrylicBackdrop class --------------------

    static PyObject* _new_DesktopAcrylicBackdrop(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::DesktopAcrylicBackdrop instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DesktopAcrylicBackdrop(py::wrapper::Microsoft::UI::Xaml::Media::DesktopAcrylicBackdrop* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_DesktopAcrylicBackdrop(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::DesktopAcrylicBackdrop>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DesktopAcrylicBackdrop(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::DesktopAcrylicBackdrop>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DesktopAcrylicBackdrop[] = {
        { "_assign_array_", _assign_array_DesktopAcrylicBackdrop, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DesktopAcrylicBackdrop), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DesktopAcrylicBackdrop[] = {
        { }
    };

    static PyType_Slot _type_slots_DesktopAcrylicBackdrop[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DesktopAcrylicBackdrop) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DesktopAcrylicBackdrop) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DesktopAcrylicBackdrop) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DesktopAcrylicBackdrop) },
        { },
    };

    static PyType_Spec type_spec_DesktopAcrylicBackdrop =
    {
        "winrt._winrt_microsoft_ui_xaml_media.DesktopAcrylicBackdrop",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::DesktopAcrylicBackdrop),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DesktopAcrylicBackdrop
    };

    // ----- DoubleCollection class --------------------

    static PyObject* _new_DoubleCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::DoubleCollection instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DoubleCollection(py::wrapper::Microsoft::UI::Xaml::Media::DoubleCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DoubleCollection_Append(py::wrapper::Microsoft::UI::Xaml::Media::DoubleCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.DoubleCollection", L"Append", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DoubleCollection_Clear(py::wrapper::Microsoft::UI::Xaml::Media::DoubleCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.DoubleCollection", L"Clear", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DoubleCollection_First(py::wrapper::Microsoft::UI::Xaml::Media::DoubleCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.DoubleCollection", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DoubleCollection_GetAt(py::wrapper::Microsoft::UI::Xaml::Media::DoubleCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.DoubleCollection", L"GetAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DoubleCollection_GetMany(py::wrapper::Microsoft::UI::Xaml::Media::DoubleCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.DoubleCollection", L"GetMany", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<double, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DoubleCollection_GetView(py::wrapper::Microsoft::UI::Xaml::Media::DoubleCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.DoubleCollection", L"GetView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DoubleCollection_IndexOf(py::wrapper::Microsoft::UI::Xaml::Media::DoubleCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.DoubleCollection", L"IndexOf", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DoubleCollection_InsertAt(py::wrapper::Microsoft::UI::Xaml::Media::DoubleCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.DoubleCollection", L"InsertAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DoubleCollection_RemoveAt(py::wrapper::Microsoft::UI::Xaml::Media::DoubleCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.DoubleCollection", L"RemoveAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DoubleCollection_RemoveAtEnd(py::wrapper::Microsoft::UI::Xaml::Media::DoubleCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.DoubleCollection", L"RemoveAtEnd", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DoubleCollection_ReplaceAll(py::wrapper::Microsoft::UI::Xaml::Media::DoubleCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.DoubleCollection", L"ReplaceAll", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<double, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DoubleCollection_SetAt(py::wrapper::Microsoft::UI::Xaml::Media::DoubleCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.DoubleCollection", L"SetAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DoubleCollection_get_Size(py::wrapper::Microsoft::UI::Xaml::Media::DoubleCollection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.DoubleCollection", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DoubleCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::DoubleCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DoubleCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::DoubleCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_DoubleCollection(py::wrapper::Microsoft::UI::Xaml::Media::DoubleCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_DoubleCollection(py::wrapper::Microsoft::UI::Xaml::Media::DoubleCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_DoubleCollection(py::wrapper::Microsoft::UI::Xaml::Media::DoubleCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_DoubleCollection(py::wrapper::Microsoft::UI::Xaml::Media::DoubleCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_DoubleCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(
                    PyExc_NotImplementedError,
                    "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<double> items(static_cast<uint32_t>(length), empty_instance<double>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(
                    PyExc_RuntimeError,
                    "returned count %d did not match requested length %zd",
                    count,
                    length);
                return nullptr;
            }

            return convert(items);}
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_DoubleCollection(py::wrapper::Microsoft::UI::Xaml::Media::DoubleCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<double>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_DoubleCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(DoubleCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(DoubleCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(DoubleCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(DoubleCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(DoubleCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(DoubleCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(DoubleCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(DoubleCollection_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(DoubleCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(DoubleCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(DoubleCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(DoubleCollection_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DoubleCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DoubleCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DoubleCollection[] = {
        { "size", reinterpret_cast<getter>(DoubleCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DoubleCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DoubleCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DoubleCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DoubleCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DoubleCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_DoubleCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_DoubleCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_DoubleCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_DoubleCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_DoubleCollection) },
        { },
    };

    static PyType_Spec type_spec_DoubleCollection =
    {
        "winrt._winrt_microsoft_ui_xaml_media.DoubleCollection",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::DoubleCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DoubleCollection
    };

    // ----- EllipseGeometry class --------------------

    static PyObject* _new_EllipseGeometry(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::EllipseGeometry instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EllipseGeometry(py::wrapper::Microsoft::UI::Xaml::Media::EllipseGeometry* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EllipseGeometry_get_RadiusY(py::wrapper::Microsoft::UI::Xaml::Media::EllipseGeometry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.EllipseGeometry", L"RadiusY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RadiusY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EllipseGeometry_put_RadiusY(py::wrapper::Microsoft::UI::Xaml::Media::EllipseGeometry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.EllipseGeometry", L"RadiusY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.RadiusY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EllipseGeometry_get_RadiusX(py::wrapper::Microsoft::UI::Xaml::Media::EllipseGeometry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.EllipseGeometry", L"RadiusX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RadiusX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EllipseGeometry_put_RadiusX(py::wrapper::Microsoft::UI::Xaml::Media::EllipseGeometry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.EllipseGeometry", L"RadiusX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.RadiusX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EllipseGeometry_get_Center(py::wrapper::Microsoft::UI::Xaml::Media::EllipseGeometry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.EllipseGeometry", L"Center"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Center());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EllipseGeometry_put_Center(py::wrapper::Microsoft::UI::Xaml::Media::EllipseGeometry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.EllipseGeometry", L"Center"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.Center(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EllipseGeometry_get_CenterProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.EllipseGeometry", L"CenterProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::EllipseGeometry::CenterProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EllipseGeometry_get_RadiusXProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.EllipseGeometry", L"RadiusXProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::EllipseGeometry::RadiusXProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EllipseGeometry_get_RadiusYProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.EllipseGeometry", L"RadiusYProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::EllipseGeometry::RadiusYProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EllipseGeometry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::EllipseGeometry>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EllipseGeometry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::EllipseGeometry>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EllipseGeometry[] = {
        { "_assign_array_", _assign_array_EllipseGeometry, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EllipseGeometry), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EllipseGeometry[] = {
        { "radius_y", reinterpret_cast<getter>(EllipseGeometry_get_RadiusY), reinterpret_cast<setter>(EllipseGeometry_put_RadiusY), nullptr, nullptr },
        { "radius_x", reinterpret_cast<getter>(EllipseGeometry_get_RadiusX), reinterpret_cast<setter>(EllipseGeometry_put_RadiusX), nullptr, nullptr },
        { "center", reinterpret_cast<getter>(EllipseGeometry_get_Center), reinterpret_cast<setter>(EllipseGeometry_put_Center), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EllipseGeometry[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EllipseGeometry) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EllipseGeometry) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EllipseGeometry) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EllipseGeometry) },
        { },
    };

    static PyType_Spec type_spec_EllipseGeometry =
    {
        "winrt._winrt_microsoft_ui_xaml_media.EllipseGeometry",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::EllipseGeometry),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EllipseGeometry
    };

    static PyGetSetDef getset_EllipseGeometry_Static[] = {
        { "center_property", reinterpret_cast<getter>(EllipseGeometry_get_CenterProperty), nullptr, nullptr, nullptr },
        { "radius_x_property", reinterpret_cast<getter>(EllipseGeometry_get_RadiusXProperty), nullptr, nullptr, nullptr },
        { "radius_y_property", reinterpret_cast<getter>(EllipseGeometry_get_RadiusYProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_EllipseGeometry_Static[] = {
        { }
    };

    static PyType_Slot type_slots_EllipseGeometry_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_EllipseGeometry_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_EllipseGeometry_Static) },
        { }
    };

    static PyType_Spec type_spec_EllipseGeometry_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.EllipseGeometry_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_EllipseGeometry_Static
    };

    // ----- FontFamily class --------------------

    static PyObject* _new_FontFamily(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Microsoft::UI::Xaml::Media::FontFamily instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FontFamily(py::wrapper::Microsoft::UI::Xaml::Media::FontFamily* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FontFamily_get_Source(py::wrapper::Microsoft::UI::Xaml::Media::FontFamily* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.FontFamily", L"Source"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FontFamily_get_XamlAutoFontFamily(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.FontFamily", L"XamlAutoFontFamily"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::FontFamily::XamlAutoFontFamily());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FontFamily(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::FontFamily>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FontFamily(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::FontFamily>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FontFamily[] = {
        { "_assign_array_", _assign_array_FontFamily, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FontFamily), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FontFamily[] = {
        { "source", reinterpret_cast<getter>(FontFamily_get_Source), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FontFamily[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FontFamily) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FontFamily) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FontFamily) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FontFamily) },
        { },
    };

    static PyType_Spec type_spec_FontFamily =
    {
        "winrt._winrt_microsoft_ui_xaml_media.FontFamily",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::FontFamily),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FontFamily
    };

    static PyGetSetDef getset_FontFamily_Static[] = {
        { "xaml_auto_font_family", reinterpret_cast<getter>(FontFamily_get_XamlAutoFontFamily), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_FontFamily_Static[] = {
        { }
    };

    static PyType_Slot type_slots_FontFamily_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FontFamily_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_FontFamily_Static) },
        { }
    };

    static PyType_Spec type_spec_FontFamily_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.FontFamily_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_FontFamily_Static
    };

    // ----- GeneralTransform class --------------------

    static PyObject* _new_GeneralTransform(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Media::GeneralTransform>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Media::GeneralTransform>::type_name);
        return nullptr;
    }

    static void _dealloc_GeneralTransform(py::wrapper::Microsoft::UI::Xaml::Media::GeneralTransform* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GeneralTransform_TransformBounds(py::wrapper::Microsoft::UI::Xaml::Media::GeneralTransform* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.GeneralTransform", L"TransformBounds", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                return py::convert(self->obj.TransformBounds(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeneralTransform_TransformBoundsCore(py::wrapper::Microsoft::UI::Xaml::Media::GeneralTransform* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.GeneralTransform", L"TransformBoundsCore", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                return py::convert(self->obj.TransformBoundsCore(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeneralTransform_TransformPoint(py::wrapper::Microsoft::UI::Xaml::Media::GeneralTransform* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.GeneralTransform", L"TransformPoint", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.TransformPoint(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeneralTransform_TryTransform(py::wrapper::Microsoft::UI::Xaml::Media::GeneralTransform* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.GeneralTransform", L"TryTransform", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                winrt::Windows::Foundation::Point param1 {  };

                auto return_value = self->obj.TryTransform(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeneralTransform_TryTransformCore(py::wrapper::Microsoft::UI::Xaml::Media::GeneralTransform* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.GeneralTransform", L"TryTransformCore", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                winrt::Windows::Foundation::Point param1 {  };

                auto return_value = self->obj.TryTransformCore(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeneralTransform_get_Inverse(py::wrapper::Microsoft::UI::Xaml::Media::GeneralTransform* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.GeneralTransform", L"Inverse"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Inverse());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GeneralTransform_get_InverseCore(py::wrapper::Microsoft::UI::Xaml::Media::GeneralTransform* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.GeneralTransform", L"InverseCore"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InverseCore());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GeneralTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::GeneralTransform>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GeneralTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::GeneralTransform>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GeneralTransform[] = {
        { "transform_bounds", reinterpret_cast<PyCFunction>(GeneralTransform_TransformBounds), METH_VARARGS, nullptr },
        { "transform_bounds_core", reinterpret_cast<PyCFunction>(GeneralTransform_TransformBoundsCore), METH_VARARGS, nullptr },
        { "transform_point", reinterpret_cast<PyCFunction>(GeneralTransform_TransformPoint), METH_VARARGS, nullptr },
        { "try_transform", reinterpret_cast<PyCFunction>(GeneralTransform_TryTransform), METH_VARARGS, nullptr },
        { "try_transform_core", reinterpret_cast<PyCFunction>(GeneralTransform_TryTransformCore), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_GeneralTransform, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GeneralTransform), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GeneralTransform[] = {
        { "inverse", reinterpret_cast<getter>(GeneralTransform_get_Inverse), nullptr, nullptr, nullptr },
        { "inverse_core", reinterpret_cast<getter>(GeneralTransform_get_InverseCore), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GeneralTransform[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GeneralTransform) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GeneralTransform) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GeneralTransform) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GeneralTransform) },
        { },
    };

    static PyType_Spec type_spec_GeneralTransform =
    {
        "winrt._winrt_microsoft_ui_xaml_media.GeneralTransform",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::GeneralTransform),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GeneralTransform
    };

    // ----- Geometry class --------------------

    static PyObject* _new_Geometry(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Media::Geometry>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Media::Geometry>::type_name);
        return nullptr;
    }

    static void _dealloc_Geometry(py::wrapper::Microsoft::UI::Xaml::Media::Geometry* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Geometry_get_Transform(py::wrapper::Microsoft::UI::Xaml::Media::Geometry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Geometry", L"Transform"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Transform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Geometry_put_Transform(py::wrapper::Microsoft::UI::Xaml::Media::Geometry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Geometry", L"Transform"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Transform>(arg);

            self->obj.Transform(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Geometry_get_Bounds(py::wrapper::Microsoft::UI::Xaml::Media::Geometry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Geometry", L"Bounds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Bounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geometry_get_Empty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Geometry", L"Empty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::Geometry::Empty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geometry_get_StandardFlatteningTolerance(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Geometry", L"StandardFlatteningTolerance"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::Geometry::StandardFlatteningTolerance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geometry_get_TransformProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Geometry", L"TransformProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::Geometry::TransformProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Geometry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::Geometry>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Geometry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::Geometry>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Geometry[] = {
        { "_assign_array_", _assign_array_Geometry, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Geometry), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Geometry[] = {
        { "transform", reinterpret_cast<getter>(Geometry_get_Transform), reinterpret_cast<setter>(Geometry_put_Transform), nullptr, nullptr },
        { "bounds", reinterpret_cast<getter>(Geometry_get_Bounds), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Geometry[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Geometry) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Geometry) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Geometry) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Geometry) },
        { },
    };

    static PyType_Spec type_spec_Geometry =
    {
        "winrt._winrt_microsoft_ui_xaml_media.Geometry",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::Geometry),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Geometry
    };

    static PyGetSetDef getset_Geometry_Static[] = {
        { "empty", reinterpret_cast<getter>(Geometry_get_Empty), nullptr, nullptr, nullptr },
        { "standard_flattening_tolerance", reinterpret_cast<getter>(Geometry_get_StandardFlatteningTolerance), nullptr, nullptr, nullptr },
        { "transform_property", reinterpret_cast<getter>(Geometry_get_TransformProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Geometry_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Geometry_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Geometry_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Geometry_Static) },
        { }
    };

    static PyType_Spec type_spec_Geometry_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.Geometry_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Geometry_Static
    };

    // ----- GeometryCollection class --------------------

    static PyObject* _new_GeometryCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::GeometryCollection instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GeometryCollection(py::wrapper::Microsoft::UI::Xaml::Media::GeometryCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GeometryCollection_Append(py::wrapper::Microsoft::UI::Xaml::Media::GeometryCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.GeometryCollection", L"Append", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Geometry>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeometryCollection_Clear(py::wrapper::Microsoft::UI::Xaml::Media::GeometryCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.GeometryCollection", L"Clear", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeometryCollection_First(py::wrapper::Microsoft::UI::Xaml::Media::GeometryCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.GeometryCollection", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeometryCollection_GetAt(py::wrapper::Microsoft::UI::Xaml::Media::GeometryCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.GeometryCollection", L"GetAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeometryCollection_GetMany(py::wrapper::Microsoft::UI::Xaml::Media::GeometryCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.GeometryCollection", L"GetMany", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Microsoft::UI::Xaml::Media::Geometry, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeometryCollection_GetView(py::wrapper::Microsoft::UI::Xaml::Media::GeometryCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.GeometryCollection", L"GetView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeometryCollection_IndexOf(py::wrapper::Microsoft::UI::Xaml::Media::GeometryCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.GeometryCollection", L"IndexOf", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Geometry>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeometryCollection_InsertAt(py::wrapper::Microsoft::UI::Xaml::Media::GeometryCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.GeometryCollection", L"InsertAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Geometry>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeometryCollection_RemoveAt(py::wrapper::Microsoft::UI::Xaml::Media::GeometryCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.GeometryCollection", L"RemoveAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeometryCollection_RemoveAtEnd(py::wrapper::Microsoft::UI::Xaml::Media::GeometryCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.GeometryCollection", L"RemoveAtEnd", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeometryCollection_ReplaceAll(py::wrapper::Microsoft::UI::Xaml::Media::GeometryCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.GeometryCollection", L"ReplaceAll", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Microsoft::UI::Xaml::Media::Geometry, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeometryCollection_SetAt(py::wrapper::Microsoft::UI::Xaml::Media::GeometryCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.GeometryCollection", L"SetAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Geometry>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeometryCollection_get_Size(py::wrapper::Microsoft::UI::Xaml::Media::GeometryCollection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.GeometryCollection", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GeometryCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::GeometryCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GeometryCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::GeometryCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_GeometryCollection(py::wrapper::Microsoft::UI::Xaml::Media::GeometryCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_GeometryCollection(py::wrapper::Microsoft::UI::Xaml::Media::GeometryCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_GeometryCollection(py::wrapper::Microsoft::UI::Xaml::Media::GeometryCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_GeometryCollection(py::wrapper::Microsoft::UI::Xaml::Media::GeometryCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_GeometryCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(
                    PyExc_NotImplementedError,
                    "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Microsoft::UI::Xaml::Media::Geometry> items(static_cast<uint32_t>(length), empty_instance<winrt::Microsoft::UI::Xaml::Media::Geometry>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(
                    PyExc_RuntimeError,
                    "returned count %d did not match requested length %zd",
                    count,
                    length);
                return nullptr;
            }

            return convert(items);}
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_GeometryCollection(py::wrapper::Microsoft::UI::Xaml::Media::GeometryCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Microsoft::UI::Xaml::Media::Geometry>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_GeometryCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(GeometryCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(GeometryCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(GeometryCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(GeometryCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(GeometryCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(GeometryCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(GeometryCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(GeometryCollection_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(GeometryCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(GeometryCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(GeometryCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(GeometryCollection_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_GeometryCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GeometryCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GeometryCollection[] = {
        { "size", reinterpret_cast<getter>(GeometryCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GeometryCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GeometryCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GeometryCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GeometryCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GeometryCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_GeometryCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_GeometryCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_GeometryCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_GeometryCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_GeometryCollection) },
        { },
    };

    static PyType_Spec type_spec_GeometryCollection =
    {
        "winrt._winrt_microsoft_ui_xaml_media.GeometryCollection",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::GeometryCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GeometryCollection
    };

    // ----- GeometryGroup class --------------------

    static PyObject* _new_GeometryGroup(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::GeometryGroup instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GeometryGroup(py::wrapper::Microsoft::UI::Xaml::Media::GeometryGroup* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GeometryGroup_get_FillRule(py::wrapper::Microsoft::UI::Xaml::Media::GeometryGroup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.GeometryGroup", L"FillRule"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FillRule());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GeometryGroup_put_FillRule(py::wrapper::Microsoft::UI::Xaml::Media::GeometryGroup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.GeometryGroup", L"FillRule"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::FillRule>(arg);

            self->obj.FillRule(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GeometryGroup_get_Children(py::wrapper::Microsoft::UI::Xaml::Media::GeometryGroup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.GeometryGroup", L"Children"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Children());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GeometryGroup_put_Children(py::wrapper::Microsoft::UI::Xaml::Media::GeometryGroup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.GeometryGroup", L"Children"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::GeometryCollection>(arg);

            self->obj.Children(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GeometryGroup_get_ChildrenProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.GeometryGroup", L"ChildrenProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::GeometryGroup::ChildrenProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GeometryGroup_get_FillRuleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.GeometryGroup", L"FillRuleProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::GeometryGroup::FillRuleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GeometryGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::GeometryGroup>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GeometryGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::GeometryGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GeometryGroup[] = {
        { "_assign_array_", _assign_array_GeometryGroup, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GeometryGroup), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GeometryGroup[] = {
        { "fill_rule", reinterpret_cast<getter>(GeometryGroup_get_FillRule), reinterpret_cast<setter>(GeometryGroup_put_FillRule), nullptr, nullptr },
        { "children", reinterpret_cast<getter>(GeometryGroup_get_Children), reinterpret_cast<setter>(GeometryGroup_put_Children), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GeometryGroup[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GeometryGroup) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GeometryGroup) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GeometryGroup) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GeometryGroup) },
        { },
    };

    static PyType_Spec type_spec_GeometryGroup =
    {
        "winrt._winrt_microsoft_ui_xaml_media.GeometryGroup",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::GeometryGroup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GeometryGroup
    };

    static PyGetSetDef getset_GeometryGroup_Static[] = {
        { "children_property", reinterpret_cast<getter>(GeometryGroup_get_ChildrenProperty), nullptr, nullptr, nullptr },
        { "fill_rule_property", reinterpret_cast<getter>(GeometryGroup_get_FillRuleProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_GeometryGroup_Static[] = {
        { }
    };

    static PyType_Slot type_slots_GeometryGroup_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GeometryGroup_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GeometryGroup_Static) },
        { }
    };

    static PyType_Spec type_spec_GeometryGroup_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.GeometryGroup_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GeometryGroup_Static
    };

    // ----- GradientBrush class --------------------

    static PyObject* _new_GradientBrush(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Media::GradientBrush>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Media::GradientBrush>::type_name);
        return nullptr;
    }

    static void _dealloc_GradientBrush(py::wrapper::Microsoft::UI::Xaml::Media::GradientBrush* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GradientBrush_get_SpreadMethod(py::wrapper::Microsoft::UI::Xaml::Media::GradientBrush* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.GradientBrush", L"SpreadMethod"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SpreadMethod());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GradientBrush_put_SpreadMethod(py::wrapper::Microsoft::UI::Xaml::Media::GradientBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.GradientBrush", L"SpreadMethod"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::GradientSpreadMethod>(arg);

            self->obj.SpreadMethod(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GradientBrush_get_MappingMode(py::wrapper::Microsoft::UI::Xaml::Media::GradientBrush* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.GradientBrush", L"MappingMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MappingMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GradientBrush_put_MappingMode(py::wrapper::Microsoft::UI::Xaml::Media::GradientBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.GradientBrush", L"MappingMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::BrushMappingMode>(arg);

            self->obj.MappingMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GradientBrush_get_GradientStops(py::wrapper::Microsoft::UI::Xaml::Media::GradientBrush* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.GradientBrush", L"GradientStops"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.GradientStops());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GradientBrush_put_GradientStops(py::wrapper::Microsoft::UI::Xaml::Media::GradientBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.GradientBrush", L"GradientStops"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::GradientStopCollection>(arg);

            self->obj.GradientStops(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GradientBrush_get_ColorInterpolationMode(py::wrapper::Microsoft::UI::Xaml::Media::GradientBrush* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.GradientBrush", L"ColorInterpolationMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ColorInterpolationMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GradientBrush_put_ColorInterpolationMode(py::wrapper::Microsoft::UI::Xaml::Media::GradientBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.GradientBrush", L"ColorInterpolationMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::ColorInterpolationMode>(arg);

            self->obj.ColorInterpolationMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GradientBrush_get_ColorInterpolationModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.GradientBrush", L"ColorInterpolationModeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::GradientBrush::ColorInterpolationModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GradientBrush_get_GradientStopsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.GradientBrush", L"GradientStopsProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::GradientBrush::GradientStopsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GradientBrush_get_MappingModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.GradientBrush", L"MappingModeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::GradientBrush::MappingModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GradientBrush_get_SpreadMethodProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.GradientBrush", L"SpreadMethodProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::GradientBrush::SpreadMethodProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GradientBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::GradientBrush>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GradientBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::GradientBrush>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GradientBrush[] = {
        { "_assign_array_", _assign_array_GradientBrush, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GradientBrush), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GradientBrush[] = {
        { "spread_method", reinterpret_cast<getter>(GradientBrush_get_SpreadMethod), reinterpret_cast<setter>(GradientBrush_put_SpreadMethod), nullptr, nullptr },
        { "mapping_mode", reinterpret_cast<getter>(GradientBrush_get_MappingMode), reinterpret_cast<setter>(GradientBrush_put_MappingMode), nullptr, nullptr },
        { "gradient_stops", reinterpret_cast<getter>(GradientBrush_get_GradientStops), reinterpret_cast<setter>(GradientBrush_put_GradientStops), nullptr, nullptr },
        { "color_interpolation_mode", reinterpret_cast<getter>(GradientBrush_get_ColorInterpolationMode), reinterpret_cast<setter>(GradientBrush_put_ColorInterpolationMode), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GradientBrush[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GradientBrush) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GradientBrush) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GradientBrush) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GradientBrush) },
        { },
    };

    static PyType_Spec type_spec_GradientBrush =
    {
        "winrt._winrt_microsoft_ui_xaml_media.GradientBrush",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::GradientBrush),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GradientBrush
    };

    static PyGetSetDef getset_GradientBrush_Static[] = {
        { "color_interpolation_mode_property", reinterpret_cast<getter>(GradientBrush_get_ColorInterpolationModeProperty), nullptr, nullptr, nullptr },
        { "gradient_stops_property", reinterpret_cast<getter>(GradientBrush_get_GradientStopsProperty), nullptr, nullptr, nullptr },
        { "mapping_mode_property", reinterpret_cast<getter>(GradientBrush_get_MappingModeProperty), nullptr, nullptr, nullptr },
        { "spread_method_property", reinterpret_cast<getter>(GradientBrush_get_SpreadMethodProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_GradientBrush_Static[] = {
        { }
    };

    static PyType_Slot type_slots_GradientBrush_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GradientBrush_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GradientBrush_Static) },
        { }
    };

    static PyType_Spec type_spec_GradientBrush_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.GradientBrush_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GradientBrush_Static
    };

    // ----- GradientStop class --------------------

    static PyObject* _new_GradientStop(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::GradientStop instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GradientStop(py::wrapper::Microsoft::UI::Xaml::Media::GradientStop* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GradientStop_get_Offset(py::wrapper::Microsoft::UI::Xaml::Media::GradientStop* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.GradientStop", L"Offset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Offset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GradientStop_put_Offset(py::wrapper::Microsoft::UI::Xaml::Media::GradientStop* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.GradientStop", L"Offset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Offset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GradientStop_get_Color(py::wrapper::Microsoft::UI::Xaml::Media::GradientStop* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.GradientStop", L"Color"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Color());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GradientStop_put_Color(py::wrapper::Microsoft::UI::Xaml::Media::GradientStop* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.GradientStop", L"Color"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Color(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GradientStop_get_ColorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.GradientStop", L"ColorProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::GradientStop::ColorProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GradientStop_get_OffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.GradientStop", L"OffsetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::GradientStop::OffsetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GradientStop(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::GradientStop>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GradientStop(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::GradientStop>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GradientStop[] = {
        { "_assign_array_", _assign_array_GradientStop, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GradientStop), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GradientStop[] = {
        { "offset", reinterpret_cast<getter>(GradientStop_get_Offset), reinterpret_cast<setter>(GradientStop_put_Offset), nullptr, nullptr },
        { "color", reinterpret_cast<getter>(GradientStop_get_Color), reinterpret_cast<setter>(GradientStop_put_Color), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GradientStop[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GradientStop) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GradientStop) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GradientStop) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GradientStop) },
        { },
    };

    static PyType_Spec type_spec_GradientStop =
    {
        "winrt._winrt_microsoft_ui_xaml_media.GradientStop",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::GradientStop),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GradientStop
    };

    static PyGetSetDef getset_GradientStop_Static[] = {
        { "color_property", reinterpret_cast<getter>(GradientStop_get_ColorProperty), nullptr, nullptr, nullptr },
        { "offset_property", reinterpret_cast<getter>(GradientStop_get_OffsetProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_GradientStop_Static[] = {
        { }
    };

    static PyType_Slot type_slots_GradientStop_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GradientStop_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GradientStop_Static) },
        { }
    };

    static PyType_Spec type_spec_GradientStop_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.GradientStop_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GradientStop_Static
    };

    // ----- GradientStopCollection class --------------------

    static PyObject* _new_GradientStopCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::GradientStopCollection instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GradientStopCollection(py::wrapper::Microsoft::UI::Xaml::Media::GradientStopCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GradientStopCollection_Append(py::wrapper::Microsoft::UI::Xaml::Media::GradientStopCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.GradientStopCollection", L"Append", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::GradientStop>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GradientStopCollection_Clear(py::wrapper::Microsoft::UI::Xaml::Media::GradientStopCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.GradientStopCollection", L"Clear", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GradientStopCollection_First(py::wrapper::Microsoft::UI::Xaml::Media::GradientStopCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.GradientStopCollection", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GradientStopCollection_GetAt(py::wrapper::Microsoft::UI::Xaml::Media::GradientStopCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.GradientStopCollection", L"GetAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GradientStopCollection_GetMany(py::wrapper::Microsoft::UI::Xaml::Media::GradientStopCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.GradientStopCollection", L"GetMany", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Microsoft::UI::Xaml::Media::GradientStop, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GradientStopCollection_GetView(py::wrapper::Microsoft::UI::Xaml::Media::GradientStopCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.GradientStopCollection", L"GetView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GradientStopCollection_IndexOf(py::wrapper::Microsoft::UI::Xaml::Media::GradientStopCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.GradientStopCollection", L"IndexOf", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::GradientStop>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GradientStopCollection_InsertAt(py::wrapper::Microsoft::UI::Xaml::Media::GradientStopCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.GradientStopCollection", L"InsertAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::GradientStop>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GradientStopCollection_RemoveAt(py::wrapper::Microsoft::UI::Xaml::Media::GradientStopCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.GradientStopCollection", L"RemoveAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GradientStopCollection_RemoveAtEnd(py::wrapper::Microsoft::UI::Xaml::Media::GradientStopCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.GradientStopCollection", L"RemoveAtEnd", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GradientStopCollection_ReplaceAll(py::wrapper::Microsoft::UI::Xaml::Media::GradientStopCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.GradientStopCollection", L"ReplaceAll", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Microsoft::UI::Xaml::Media::GradientStop, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GradientStopCollection_SetAt(py::wrapper::Microsoft::UI::Xaml::Media::GradientStopCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.GradientStopCollection", L"SetAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::GradientStop>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GradientStopCollection_get_Size(py::wrapper::Microsoft::UI::Xaml::Media::GradientStopCollection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.GradientStopCollection", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_GradientStopCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::GradientStopCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GradientStopCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::GradientStopCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_GradientStopCollection(py::wrapper::Microsoft::UI::Xaml::Media::GradientStopCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_GradientStopCollection(py::wrapper::Microsoft::UI::Xaml::Media::GradientStopCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_GradientStopCollection(py::wrapper::Microsoft::UI::Xaml::Media::GradientStopCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_GradientStopCollection(py::wrapper::Microsoft::UI::Xaml::Media::GradientStopCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_GradientStopCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(
                    PyExc_NotImplementedError,
                    "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Microsoft::UI::Xaml::Media::GradientStop> items(static_cast<uint32_t>(length), empty_instance<winrt::Microsoft::UI::Xaml::Media::GradientStop>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(
                    PyExc_RuntimeError,
                    "returned count %d did not match requested length %zd",
                    count,
                    length);
                return nullptr;
            }

            return convert(items);}
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_GradientStopCollection(py::wrapper::Microsoft::UI::Xaml::Media::GradientStopCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Microsoft::UI::Xaml::Media::GradientStop>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_GradientStopCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(GradientStopCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(GradientStopCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(GradientStopCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(GradientStopCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(GradientStopCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(GradientStopCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(GradientStopCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(GradientStopCollection_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(GradientStopCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(GradientStopCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(GradientStopCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(GradientStopCollection_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_GradientStopCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GradientStopCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GradientStopCollection[] = {
        { "size", reinterpret_cast<getter>(GradientStopCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GradientStopCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_GradientStopCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GradientStopCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GradientStopCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GradientStopCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_GradientStopCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_GradientStopCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_GradientStopCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_GradientStopCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_GradientStopCollection) },
        { },
    };

    static PyType_Spec type_spec_GradientStopCollection =
    {
        "winrt._winrt_microsoft_ui_xaml_media.GradientStopCollection",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::GradientStopCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GradientStopCollection
    };

    // ----- ImageBrush class --------------------

    static PyObject* _new_ImageBrush(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::ImageBrush instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ImageBrush(py::wrapper::Microsoft::UI::Xaml::Media::ImageBrush* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ImageBrush_get_ImageSource(py::wrapper::Microsoft::UI::Xaml::Media::ImageBrush* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.ImageBrush", L"ImageSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ImageSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageBrush_put_ImageSource(py::wrapper::Microsoft::UI::Xaml::Media::ImageBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.ImageBrush", L"ImageSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::ImageSource>(arg);

            self->obj.ImageSource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageBrush_get_ImageSourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.ImageBrush", L"ImageSourceProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::ImageBrush::ImageSourceProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageBrush_add_ImageFailed(py::wrapper::Microsoft::UI::Xaml::Media::ImageBrush* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Media.ImageBrush", L"ImageFailed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::ExceptionRoutedEventHandler>(arg);

            return py::convert(self->obj.ImageFailed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageBrush_remove_ImageFailed(py::wrapper::Microsoft::UI::Xaml::Media::ImageBrush* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Media.ImageBrush", L"ImageFailed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ImageFailed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageBrush_add_ImageOpened(py::wrapper::Microsoft::UI::Xaml::Media::ImageBrush* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Media.ImageBrush", L"ImageOpened"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::RoutedEventHandler>(arg);

            return py::convert(self->obj.ImageOpened(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageBrush_remove_ImageOpened(py::wrapper::Microsoft::UI::Xaml::Media::ImageBrush* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Media.ImageBrush", L"ImageOpened"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ImageOpened(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ImageBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::ImageBrush>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ImageBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::ImageBrush>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageBrush[] = {
        { "add_image_failed", reinterpret_cast<PyCFunction>(ImageBrush_add_ImageFailed), METH_O, nullptr },
        { "remove_image_failed", reinterpret_cast<PyCFunction>(ImageBrush_remove_ImageFailed), METH_O, nullptr },
        { "add_image_opened", reinterpret_cast<PyCFunction>(ImageBrush_add_ImageOpened), METH_O, nullptr },
        { "remove_image_opened", reinterpret_cast<PyCFunction>(ImageBrush_remove_ImageOpened), METH_O, nullptr },
        { "_assign_array_", _assign_array_ImageBrush, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ImageBrush), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ImageBrush[] = {
        { "image_source", reinterpret_cast<getter>(ImageBrush_get_ImageSource), reinterpret_cast<setter>(ImageBrush_put_ImageSource), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ImageBrush[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ImageBrush) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ImageBrush) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ImageBrush) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ImageBrush) },
        { },
    };

    static PyType_Spec type_spec_ImageBrush =
    {
        "winrt._winrt_microsoft_ui_xaml_media.ImageBrush",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::ImageBrush),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageBrush
    };

    static PyGetSetDef getset_ImageBrush_Static[] = {
        { "image_source_property", reinterpret_cast<getter>(ImageBrush_get_ImageSourceProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ImageBrush_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ImageBrush_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ImageBrush_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImageBrush_Static) },
        { }
    };

    static PyType_Spec type_spec_ImageBrush_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.ImageBrush_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ImageBrush_Static
    };

    // ----- ImageSource class --------------------

    static PyObject* _new_ImageSource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Media::ImageSource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Media::ImageSource>::type_name);
        return nullptr;
    }

    static void _dealloc_ImageSource(py::wrapper::Microsoft::UI::Xaml::Media::ImageSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ImageSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::ImageSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ImageSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::ImageSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageSource[] = {
        { "_assign_array_", _assign_array_ImageSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ImageSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ImageSource[] = {
        { }
    };

    static PyType_Slot _type_slots_ImageSource[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ImageSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ImageSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ImageSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ImageSource) },
        { },
    };

    static PyType_Spec type_spec_ImageSource =
    {
        "winrt._winrt_microsoft_ui_xaml_media.ImageSource",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::ImageSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageSource
    };

    // ----- LineGeometry class --------------------

    static PyObject* _new_LineGeometry(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::LineGeometry instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LineGeometry(py::wrapper::Microsoft::UI::Xaml::Media::LineGeometry* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LineGeometry_get_StartPoint(py::wrapper::Microsoft::UI::Xaml::Media::LineGeometry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.LineGeometry", L"StartPoint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineGeometry_put_StartPoint(py::wrapper::Microsoft::UI::Xaml::Media::LineGeometry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.LineGeometry", L"StartPoint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.StartPoint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineGeometry_get_EndPoint(py::wrapper::Microsoft::UI::Xaml::Media::LineGeometry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.LineGeometry", L"EndPoint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineGeometry_put_EndPoint(py::wrapper::Microsoft::UI::Xaml::Media::LineGeometry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.LineGeometry", L"EndPoint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.EndPoint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineGeometry_get_EndPointProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.LineGeometry", L"EndPointProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::LineGeometry::EndPointProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineGeometry_get_StartPointProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.LineGeometry", L"StartPointProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::LineGeometry::StartPointProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LineGeometry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::LineGeometry>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LineGeometry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::LineGeometry>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineGeometry[] = {
        { "_assign_array_", _assign_array_LineGeometry, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LineGeometry), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LineGeometry[] = {
        { "start_point", reinterpret_cast<getter>(LineGeometry_get_StartPoint), reinterpret_cast<setter>(LineGeometry_put_StartPoint), nullptr, nullptr },
        { "end_point", reinterpret_cast<getter>(LineGeometry_get_EndPoint), reinterpret_cast<setter>(LineGeometry_put_EndPoint), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LineGeometry[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LineGeometry) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LineGeometry) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LineGeometry) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LineGeometry) },
        { },
    };

    static PyType_Spec type_spec_LineGeometry =
    {
        "winrt._winrt_microsoft_ui_xaml_media.LineGeometry",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::LineGeometry),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineGeometry
    };

    static PyGetSetDef getset_LineGeometry_Static[] = {
        { "end_point_property", reinterpret_cast<getter>(LineGeometry_get_EndPointProperty), nullptr, nullptr, nullptr },
        { "start_point_property", reinterpret_cast<getter>(LineGeometry_get_StartPointProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_LineGeometry_Static[] = {
        { }
    };

    static PyType_Slot type_slots_LineGeometry_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_LineGeometry_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_LineGeometry_Static) },
        { }
    };

    static PyType_Spec type_spec_LineGeometry_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.LineGeometry_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_LineGeometry_Static
    };

    // ----- LineSegment class --------------------

    static PyObject* _new_LineSegment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::LineSegment instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LineSegment(py::wrapper::Microsoft::UI::Xaml::Media::LineSegment* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LineSegment_get_Point(py::wrapper::Microsoft::UI::Xaml::Media::LineSegment* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.LineSegment", L"Point"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Point());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineSegment_put_Point(py::wrapper::Microsoft::UI::Xaml::Media::LineSegment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.LineSegment", L"Point"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.Point(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineSegment_get_PointProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.LineSegment", L"PointProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::LineSegment::PointProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LineSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::LineSegment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LineSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::LineSegment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineSegment[] = {
        { "_assign_array_", _assign_array_LineSegment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LineSegment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LineSegment[] = {
        { "point", reinterpret_cast<getter>(LineSegment_get_Point), reinterpret_cast<setter>(LineSegment_put_Point), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LineSegment[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LineSegment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LineSegment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LineSegment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LineSegment) },
        { },
    };

    static PyType_Spec type_spec_LineSegment =
    {
        "winrt._winrt_microsoft_ui_xaml_media.LineSegment",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::LineSegment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineSegment
    };

    static PyGetSetDef getset_LineSegment_Static[] = {
        { "point_property", reinterpret_cast<getter>(LineSegment_get_PointProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_LineSegment_Static[] = {
        { }
    };

    static PyType_Slot type_slots_LineSegment_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_LineSegment_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_LineSegment_Static) },
        { }
    };

    static PyType_Spec type_spec_LineSegment_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.LineSegment_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_LineSegment_Static
    };

    // ----- LinearGradientBrush class --------------------

    static PyObject* _new_LinearGradientBrush(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::GradientStopCollection>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                winrt::Microsoft::UI::Xaml::Media::LinearGradientBrush instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::LinearGradientBrush instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LinearGradientBrush(py::wrapper::Microsoft::UI::Xaml::Media::LinearGradientBrush* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LinearGradientBrush_get_StartPoint(py::wrapper::Microsoft::UI::Xaml::Media::LinearGradientBrush* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.LinearGradientBrush", L"StartPoint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LinearGradientBrush_put_StartPoint(py::wrapper::Microsoft::UI::Xaml::Media::LinearGradientBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.LinearGradientBrush", L"StartPoint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.StartPoint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LinearGradientBrush_get_EndPoint(py::wrapper::Microsoft::UI::Xaml::Media::LinearGradientBrush* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.LinearGradientBrush", L"EndPoint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LinearGradientBrush_put_EndPoint(py::wrapper::Microsoft::UI::Xaml::Media::LinearGradientBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.LinearGradientBrush", L"EndPoint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.EndPoint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LinearGradientBrush_get_EndPointProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.LinearGradientBrush", L"EndPointProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::LinearGradientBrush::EndPointProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LinearGradientBrush_get_StartPointProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.LinearGradientBrush", L"StartPointProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::LinearGradientBrush::StartPointProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LinearGradientBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::LinearGradientBrush>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LinearGradientBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::LinearGradientBrush>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LinearGradientBrush[] = {
        { "_assign_array_", _assign_array_LinearGradientBrush, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LinearGradientBrush), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LinearGradientBrush[] = {
        { "start_point", reinterpret_cast<getter>(LinearGradientBrush_get_StartPoint), reinterpret_cast<setter>(LinearGradientBrush_put_StartPoint), nullptr, nullptr },
        { "end_point", reinterpret_cast<getter>(LinearGradientBrush_get_EndPoint), reinterpret_cast<setter>(LinearGradientBrush_put_EndPoint), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LinearGradientBrush[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LinearGradientBrush) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LinearGradientBrush) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LinearGradientBrush) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LinearGradientBrush) },
        { },
    };

    static PyType_Spec type_spec_LinearGradientBrush =
    {
        "winrt._winrt_microsoft_ui_xaml_media.LinearGradientBrush",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::LinearGradientBrush),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LinearGradientBrush
    };

    static PyGetSetDef getset_LinearGradientBrush_Static[] = {
        { "end_point_property", reinterpret_cast<getter>(LinearGradientBrush_get_EndPointProperty), nullptr, nullptr, nullptr },
        { "start_point_property", reinterpret_cast<getter>(LinearGradientBrush_get_StartPointProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_LinearGradientBrush_Static[] = {
        { }
    };

    static PyType_Slot type_slots_LinearGradientBrush_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_LinearGradientBrush_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_LinearGradientBrush_Static) },
        { }
    };

    static PyType_Spec type_spec_LinearGradientBrush_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.LinearGradientBrush_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_LinearGradientBrush_Static
    };

    // ----- LoadedImageSourceLoadCompletedEventArgs class --------------------

    static PyObject* _new_LoadedImageSourceLoadCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Media::LoadedImageSourceLoadCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Media::LoadedImageSourceLoadCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_LoadedImageSourceLoadCompletedEventArgs(py::wrapper::Microsoft::UI::Xaml::Media::LoadedImageSourceLoadCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LoadedImageSourceLoadCompletedEventArgs_get_Status(py::wrapper::Microsoft::UI::Xaml::Media::LoadedImageSourceLoadCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.LoadedImageSourceLoadCompletedEventArgs", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LoadedImageSourceLoadCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::LoadedImageSourceLoadCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LoadedImageSourceLoadCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::LoadedImageSourceLoadCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoadedImageSourceLoadCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_LoadedImageSourceLoadCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LoadedImageSourceLoadCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LoadedImageSourceLoadCompletedEventArgs[] = {
        { "status", reinterpret_cast<getter>(LoadedImageSourceLoadCompletedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LoadedImageSourceLoadCompletedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LoadedImageSourceLoadCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LoadedImageSourceLoadCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LoadedImageSourceLoadCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LoadedImageSourceLoadCompletedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_LoadedImageSourceLoadCompletedEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_media.LoadedImageSourceLoadCompletedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::LoadedImageSourceLoadCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoadedImageSourceLoadCompletedEventArgs
    };

    // ----- LoadedImageSurface class --------------------

    static PyObject* _new_LoadedImageSurface(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Media::LoadedImageSurface>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Media::LoadedImageSurface>::type_name);
        return nullptr;
    }

    static void _dealloc_LoadedImageSurface(py::wrapper::Microsoft::UI::Xaml::Media::LoadedImageSurface* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LoadedImageSurface_Close(py::wrapper::Microsoft::UI::Xaml::Media::LoadedImageSurface* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.LoadedImageSurface", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoadedImageSurface_StartLoadFromStream(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.LoadedImageSurface", L"StartLoadFromStream", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Media::LoadedImageSurface::StartLoadFromStream(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.LoadedImageSurface", L"StartLoadFromStream", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Size>(args, 1);

                return py::convert(winrt::Microsoft::UI::Xaml::Media::LoadedImageSurface::StartLoadFromStream(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoadedImageSurface_StartLoadFromUri(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.LoadedImageSurface", L"StartLoadFromUri", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Media::LoadedImageSurface::StartLoadFromUri(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.LoadedImageSurface", L"StartLoadFromUri", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Size>(args, 1);

                return py::convert(winrt::Microsoft::UI::Xaml::Media::LoadedImageSurface::StartLoadFromUri(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoadedImageSurface_get_DecodedPhysicalSize(py::wrapper::Microsoft::UI::Xaml::Media::LoadedImageSurface* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.LoadedImageSurface", L"DecodedPhysicalSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DecodedPhysicalSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoadedImageSurface_get_DecodedSize(py::wrapper::Microsoft::UI::Xaml::Media::LoadedImageSurface* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.LoadedImageSurface", L"DecodedSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DecodedSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoadedImageSurface_get_NaturalSize(py::wrapper::Microsoft::UI::Xaml::Media::LoadedImageSurface* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.LoadedImageSurface", L"NaturalSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NaturalSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoadedImageSurface_add_LoadCompleted(py::wrapper::Microsoft::UI::Xaml::Media::LoadedImageSurface* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Media.LoadedImageSurface", L"LoadCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Media::LoadedImageSurface, winrt::Microsoft::UI::Xaml::Media::LoadedImageSourceLoadCompletedEventArgs>>(arg);

            return py::convert(self->obj.LoadCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoadedImageSurface_remove_LoadCompleted(py::wrapper::Microsoft::UI::Xaml::Media::LoadedImageSurface* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Media.LoadedImageSurface", L"LoadCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LoadCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LoadedImageSurface(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::LoadedImageSurface>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LoadedImageSurface(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::LoadedImageSurface>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_LoadedImageSurface(py::wrapper::Microsoft::UI::Xaml::Media::LoadedImageSurface* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_LoadedImageSurface(py::wrapper::Microsoft::UI::Xaml::Media::LoadedImageSurface* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoadedImageSurface[] = {
        { "close", reinterpret_cast<PyCFunction>(LoadedImageSurface_Close), METH_VARARGS, nullptr },
        { "add_load_completed", reinterpret_cast<PyCFunction>(LoadedImageSurface_add_LoadCompleted), METH_O, nullptr },
        { "remove_load_completed", reinterpret_cast<PyCFunction>(LoadedImageSurface_remove_LoadCompleted), METH_O, nullptr },
        { "_assign_array_", _assign_array_LoadedImageSurface, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LoadedImageSurface), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_LoadedImageSurface), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_LoadedImageSurface), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_LoadedImageSurface[] = {
        { "decoded_physical_size", reinterpret_cast<getter>(LoadedImageSurface_get_DecodedPhysicalSize), nullptr, nullptr, nullptr },
        { "decoded_size", reinterpret_cast<getter>(LoadedImageSurface_get_DecodedSize), nullptr, nullptr, nullptr },
        { "natural_size", reinterpret_cast<getter>(LoadedImageSurface_get_NaturalSize), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LoadedImageSurface[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LoadedImageSurface) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LoadedImageSurface) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LoadedImageSurface) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LoadedImageSurface) },
        { },
    };

    static PyType_Spec type_spec_LoadedImageSurface =
    {
        "winrt._winrt_microsoft_ui_xaml_media.LoadedImageSurface",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::LoadedImageSurface),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoadedImageSurface
    };

    static PyGetSetDef getset_LoadedImageSurface_Static[] = {
        { }
    };

    static PyMethodDef methods_LoadedImageSurface_Static[] = {
        { "start_load_from_stream", reinterpret_cast<PyCFunction>(LoadedImageSurface_StartLoadFromStream), METH_VARARGS, nullptr },
        { "start_load_from_uri", reinterpret_cast<PyCFunction>(LoadedImageSurface_StartLoadFromUri), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_LoadedImageSurface_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_LoadedImageSurface_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_LoadedImageSurface_Static) },
        { }
    };

    static PyType_Spec type_spec_LoadedImageSurface_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.LoadedImageSurface_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_LoadedImageSurface_Static
    };

    // ----- Matrix3DProjection class --------------------

    static PyObject* _new_Matrix3DProjection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::Matrix3DProjection instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Matrix3DProjection(py::wrapper::Microsoft::UI::Xaml::Media::Matrix3DProjection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Matrix3DProjection_get_ProjectionMatrix(py::wrapper::Microsoft::UI::Xaml::Media::Matrix3DProjection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Matrix3DProjection", L"ProjectionMatrix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProjectionMatrix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix3DProjection_put_ProjectionMatrix(py::wrapper::Microsoft::UI::Xaml::Media::Matrix3DProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Matrix3DProjection", L"ProjectionMatrix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Media3D::Matrix3D>(arg);

            self->obj.ProjectionMatrix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix3DProjection_get_ProjectionMatrixProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Matrix3DProjection", L"ProjectionMatrixProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::Matrix3DProjection::ProjectionMatrixProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Matrix3DProjection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::Matrix3DProjection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Matrix3DProjection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::Matrix3DProjection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Matrix3DProjection[] = {
        { "_assign_array_", _assign_array_Matrix3DProjection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Matrix3DProjection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Matrix3DProjection[] = {
        { "projection_matrix", reinterpret_cast<getter>(Matrix3DProjection_get_ProjectionMatrix), reinterpret_cast<setter>(Matrix3DProjection_put_ProjectionMatrix), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Matrix3DProjection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Matrix3DProjection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Matrix3DProjection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Matrix3DProjection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Matrix3DProjection) },
        { },
    };

    static PyType_Spec type_spec_Matrix3DProjection =
    {
        "winrt._winrt_microsoft_ui_xaml_media.Matrix3DProjection",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::Matrix3DProjection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Matrix3DProjection
    };

    static PyGetSetDef getset_Matrix3DProjection_Static[] = {
        { "projection_matrix_property", reinterpret_cast<getter>(Matrix3DProjection_get_ProjectionMatrixProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Matrix3DProjection_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Matrix3DProjection_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Matrix3DProjection_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Matrix3DProjection_Static) },
        { }
    };

    static PyType_Spec type_spec_Matrix3DProjection_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.Matrix3DProjection_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Matrix3DProjection_Static
    };

    // ----- MatrixHelper class --------------------

    static PyObject* _new_MatrixHelper(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Media::MatrixHelper>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Media::MatrixHelper>::type_name);
        return nullptr;
    }

    static void _dealloc_MatrixHelper(py::wrapper::Microsoft::UI::Xaml::Media::MatrixHelper* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MatrixHelper_FromElements(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.MatrixHelper", L"FromElements", 6))
            {
                py::set_arg_count_version_error(6);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<double>(args, 2);
                auto param3 = py::convert_to<double>(args, 3);
                auto param4 = py::convert_to<double>(args, 4);
                auto param5 = py::convert_to<double>(args, 5);

                return py::convert(winrt::Microsoft::UI::Xaml::Media::MatrixHelper::FromElements(param0, param1, param2, param3, param4, param5));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MatrixHelper_GetIsIdentity(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.MatrixHelper", L"GetIsIdentity", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Matrix>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Media::MatrixHelper::GetIsIdentity(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MatrixHelper_Transform(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.MatrixHelper", L"Transform", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Matrix>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);

                return py::convert(winrt::Microsoft::UI::Xaml::Media::MatrixHelper::Transform(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MatrixHelper_get_Identity(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.MatrixHelper", L"Identity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::MatrixHelper::Identity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MatrixHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::MatrixHelper>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MatrixHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::MatrixHelper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MatrixHelper[] = {
        { "_assign_array_", _assign_array_MatrixHelper, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MatrixHelper), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MatrixHelper[] = {
        { }
    };

    static PyType_Slot _type_slots_MatrixHelper[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MatrixHelper) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MatrixHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MatrixHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MatrixHelper) },
        { },
    };

    static PyType_Spec type_spec_MatrixHelper =
    {
        "winrt._winrt_microsoft_ui_xaml_media.MatrixHelper",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::MatrixHelper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MatrixHelper
    };

    static PyGetSetDef getset_MatrixHelper_Static[] = {
        { "identity", reinterpret_cast<getter>(MatrixHelper_get_Identity), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_MatrixHelper_Static[] = {
        { "from_elements", reinterpret_cast<PyCFunction>(MatrixHelper_FromElements), METH_VARARGS, nullptr },
        { "get_is_identity", reinterpret_cast<PyCFunction>(MatrixHelper_GetIsIdentity), METH_VARARGS, nullptr },
        { "transform", reinterpret_cast<PyCFunction>(MatrixHelper_Transform), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_MatrixHelper_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MatrixHelper_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MatrixHelper_Static) },
        { }
    };

    static PyType_Spec type_spec_MatrixHelper_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.MatrixHelper_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MatrixHelper_Static
    };

    // ----- MatrixTransform class --------------------

    static PyObject* _new_MatrixTransform(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::MatrixTransform instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MatrixTransform(py::wrapper::Microsoft::UI::Xaml::Media::MatrixTransform* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MatrixTransform_get_Matrix(py::wrapper::Microsoft::UI::Xaml::Media::MatrixTransform* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.MatrixTransform", L"Matrix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Matrix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MatrixTransform_put_Matrix(py::wrapper::Microsoft::UI::Xaml::Media::MatrixTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.MatrixTransform", L"Matrix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Matrix>(arg);

            self->obj.Matrix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MatrixTransform_get_MatrixProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.MatrixTransform", L"MatrixProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::MatrixTransform::MatrixProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MatrixTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::MatrixTransform>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MatrixTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::MatrixTransform>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MatrixTransform[] = {
        { "_assign_array_", _assign_array_MatrixTransform, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MatrixTransform), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MatrixTransform[] = {
        { "matrix", reinterpret_cast<getter>(MatrixTransform_get_Matrix), reinterpret_cast<setter>(MatrixTransform_put_Matrix), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MatrixTransform[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MatrixTransform) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MatrixTransform) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MatrixTransform) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MatrixTransform) },
        { },
    };

    static PyType_Spec type_spec_MatrixTransform =
    {
        "winrt._winrt_microsoft_ui_xaml_media.MatrixTransform",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::MatrixTransform),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MatrixTransform
    };

    static PyGetSetDef getset_MatrixTransform_Static[] = {
        { "matrix_property", reinterpret_cast<getter>(MatrixTransform_get_MatrixProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_MatrixTransform_Static[] = {
        { }
    };

    static PyType_Slot type_slots_MatrixTransform_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MatrixTransform_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MatrixTransform_Static) },
        { }
    };

    static PyType_Spec type_spec_MatrixTransform_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.MatrixTransform_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MatrixTransform_Static
    };

    // ----- MediaTransportControlsThumbnailRequestedEventArgs class --------------------

    static PyObject* _new_MediaTransportControlsThumbnailRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Media::MediaTransportControlsThumbnailRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Media::MediaTransportControlsThumbnailRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaTransportControlsThumbnailRequestedEventArgs(py::wrapper::Microsoft::UI::Xaml::Media::MediaTransportControlsThumbnailRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaTransportControlsThumbnailRequestedEventArgs_GetDeferral(py::wrapper::Microsoft::UI::Xaml::Media::MediaTransportControlsThumbnailRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.MediaTransportControlsThumbnailRequestedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaTransportControlsThumbnailRequestedEventArgs_SetThumbnailImage(py::wrapper::Microsoft::UI::Xaml::Media::MediaTransportControlsThumbnailRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.MediaTransportControlsThumbnailRequestedEventArgs", L"SetThumbnailImage", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);

                self->obj.SetThumbnailImage(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaTransportControlsThumbnailRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::MediaTransportControlsThumbnailRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaTransportControlsThumbnailRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::MediaTransportControlsThumbnailRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaTransportControlsThumbnailRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(MediaTransportControlsThumbnailRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "set_thumbnail_image", reinterpret_cast<PyCFunction>(MediaTransportControlsThumbnailRequestedEventArgs_SetThumbnailImage), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MediaTransportControlsThumbnailRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaTransportControlsThumbnailRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaTransportControlsThumbnailRequestedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaTransportControlsThumbnailRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaTransportControlsThumbnailRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaTransportControlsThumbnailRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaTransportControlsThumbnailRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaTransportControlsThumbnailRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_MediaTransportControlsThumbnailRequestedEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_media.MediaTransportControlsThumbnailRequestedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::MediaTransportControlsThumbnailRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaTransportControlsThumbnailRequestedEventArgs
    };

    // ----- MicaBackdrop class --------------------

    static PyObject* _new_MicaBackdrop(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::MicaBackdrop instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MicaBackdrop(py::wrapper::Microsoft::UI::Xaml::Media::MicaBackdrop* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MicaBackdrop_get_Kind(py::wrapper::Microsoft::UI::Xaml::Media::MicaBackdrop* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.MicaBackdrop", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MicaBackdrop_put_Kind(py::wrapper::Microsoft::UI::Xaml::Media::MicaBackdrop* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.MicaBackdrop", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::SystemBackdrops::MicaKind>(arg);

            self->obj.Kind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MicaBackdrop_get_KindProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.MicaBackdrop", L"KindProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::MicaBackdrop::KindProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MicaBackdrop(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::MicaBackdrop>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MicaBackdrop(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::MicaBackdrop>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MicaBackdrop[] = {
        { "_assign_array_", _assign_array_MicaBackdrop, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MicaBackdrop), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MicaBackdrop[] = {
        { "kind", reinterpret_cast<getter>(MicaBackdrop_get_Kind), reinterpret_cast<setter>(MicaBackdrop_put_Kind), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MicaBackdrop[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MicaBackdrop) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MicaBackdrop) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MicaBackdrop) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MicaBackdrop) },
        { },
    };

    static PyType_Spec type_spec_MicaBackdrop =
    {
        "winrt._winrt_microsoft_ui_xaml_media.MicaBackdrop",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::MicaBackdrop),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MicaBackdrop
    };

    static PyGetSetDef getset_MicaBackdrop_Static[] = {
        { "kind_property", reinterpret_cast<getter>(MicaBackdrop_get_KindProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_MicaBackdrop_Static[] = {
        { }
    };

    static PyType_Slot type_slots_MicaBackdrop_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MicaBackdrop_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MicaBackdrop_Static) },
        { }
    };

    static PyType_Spec type_spec_MicaBackdrop_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.MicaBackdrop_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MicaBackdrop_Static
    };

    // ----- PathFigure class --------------------

    static PyObject* _new_PathFigure(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::PathFigure instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PathFigure(py::wrapper::Microsoft::UI::Xaml::Media::PathFigure* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PathFigure_get_StartPoint(py::wrapper::Microsoft::UI::Xaml::Media::PathFigure* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PathFigure", L"StartPoint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PathFigure_put_StartPoint(py::wrapper::Microsoft::UI::Xaml::Media::PathFigure* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PathFigure", L"StartPoint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.StartPoint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PathFigure_get_Segments(py::wrapper::Microsoft::UI::Xaml::Media::PathFigure* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PathFigure", L"Segments"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Segments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PathFigure_put_Segments(py::wrapper::Microsoft::UI::Xaml::Media::PathFigure* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PathFigure", L"Segments"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::PathSegmentCollection>(arg);

            self->obj.Segments(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PathFigure_get_IsFilled(py::wrapper::Microsoft::UI::Xaml::Media::PathFigure* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PathFigure", L"IsFilled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsFilled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PathFigure_put_IsFilled(py::wrapper::Microsoft::UI::Xaml::Media::PathFigure* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PathFigure", L"IsFilled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsFilled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PathFigure_get_IsClosed(py::wrapper::Microsoft::UI::Xaml::Media::PathFigure* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PathFigure", L"IsClosed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsClosed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PathFigure_put_IsClosed(py::wrapper::Microsoft::UI::Xaml::Media::PathFigure* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PathFigure", L"IsClosed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsClosed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PathFigure_get_IsClosedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PathFigure", L"IsClosedProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::PathFigure::IsClosedProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PathFigure_get_IsFilledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PathFigure", L"IsFilledProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::PathFigure::IsFilledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PathFigure_get_SegmentsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PathFigure", L"SegmentsProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::PathFigure::SegmentsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PathFigure_get_StartPointProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PathFigure", L"StartPointProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::PathFigure::StartPointProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PathFigure(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::PathFigure>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PathFigure(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::PathFigure>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PathFigure[] = {
        { "_assign_array_", _assign_array_PathFigure, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PathFigure), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PathFigure[] = {
        { "start_point", reinterpret_cast<getter>(PathFigure_get_StartPoint), reinterpret_cast<setter>(PathFigure_put_StartPoint), nullptr, nullptr },
        { "segments", reinterpret_cast<getter>(PathFigure_get_Segments), reinterpret_cast<setter>(PathFigure_put_Segments), nullptr, nullptr },
        { "is_filled", reinterpret_cast<getter>(PathFigure_get_IsFilled), reinterpret_cast<setter>(PathFigure_put_IsFilled), nullptr, nullptr },
        { "is_closed", reinterpret_cast<getter>(PathFigure_get_IsClosed), reinterpret_cast<setter>(PathFigure_put_IsClosed), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PathFigure[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PathFigure) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PathFigure) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PathFigure) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PathFigure) },
        { },
    };

    static PyType_Spec type_spec_PathFigure =
    {
        "winrt._winrt_microsoft_ui_xaml_media.PathFigure",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::PathFigure),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PathFigure
    };

    static PyGetSetDef getset_PathFigure_Static[] = {
        { "is_closed_property", reinterpret_cast<getter>(PathFigure_get_IsClosedProperty), nullptr, nullptr, nullptr },
        { "is_filled_property", reinterpret_cast<getter>(PathFigure_get_IsFilledProperty), nullptr, nullptr, nullptr },
        { "segments_property", reinterpret_cast<getter>(PathFigure_get_SegmentsProperty), nullptr, nullptr, nullptr },
        { "start_point_property", reinterpret_cast<getter>(PathFigure_get_StartPointProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_PathFigure_Static[] = {
        { }
    };

    static PyType_Slot type_slots_PathFigure_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PathFigure_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PathFigure_Static) },
        { }
    };

    static PyType_Spec type_spec_PathFigure_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.PathFigure_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PathFigure_Static
    };

    // ----- PathFigureCollection class --------------------

    static PyObject* _new_PathFigureCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::PathFigureCollection instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PathFigureCollection(py::wrapper::Microsoft::UI::Xaml::Media::PathFigureCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PathFigureCollection_Append(py::wrapper::Microsoft::UI::Xaml::Media::PathFigureCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.PathFigureCollection", L"Append", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::PathFigure>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathFigureCollection_Clear(py::wrapper::Microsoft::UI::Xaml::Media::PathFigureCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.PathFigureCollection", L"Clear", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathFigureCollection_First(py::wrapper::Microsoft::UI::Xaml::Media::PathFigureCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.PathFigureCollection", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathFigureCollection_GetAt(py::wrapper::Microsoft::UI::Xaml::Media::PathFigureCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.PathFigureCollection", L"GetAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathFigureCollection_GetMany(py::wrapper::Microsoft::UI::Xaml::Media::PathFigureCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.PathFigureCollection", L"GetMany", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Microsoft::UI::Xaml::Media::PathFigure, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathFigureCollection_GetView(py::wrapper::Microsoft::UI::Xaml::Media::PathFigureCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.PathFigureCollection", L"GetView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathFigureCollection_IndexOf(py::wrapper::Microsoft::UI::Xaml::Media::PathFigureCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.PathFigureCollection", L"IndexOf", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::PathFigure>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathFigureCollection_InsertAt(py::wrapper::Microsoft::UI::Xaml::Media::PathFigureCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.PathFigureCollection", L"InsertAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::PathFigure>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathFigureCollection_RemoveAt(py::wrapper::Microsoft::UI::Xaml::Media::PathFigureCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.PathFigureCollection", L"RemoveAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathFigureCollection_RemoveAtEnd(py::wrapper::Microsoft::UI::Xaml::Media::PathFigureCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.PathFigureCollection", L"RemoveAtEnd", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathFigureCollection_ReplaceAll(py::wrapper::Microsoft::UI::Xaml::Media::PathFigureCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.PathFigureCollection", L"ReplaceAll", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Microsoft::UI::Xaml::Media::PathFigure, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathFigureCollection_SetAt(py::wrapper::Microsoft::UI::Xaml::Media::PathFigureCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.PathFigureCollection", L"SetAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::PathFigure>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathFigureCollection_get_Size(py::wrapper::Microsoft::UI::Xaml::Media::PathFigureCollection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PathFigureCollection", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PathFigureCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::PathFigureCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PathFigureCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::PathFigureCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_PathFigureCollection(py::wrapper::Microsoft::UI::Xaml::Media::PathFigureCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_PathFigureCollection(py::wrapper::Microsoft::UI::Xaml::Media::PathFigureCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_PathFigureCollection(py::wrapper::Microsoft::UI::Xaml::Media::PathFigureCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_PathFigureCollection(py::wrapper::Microsoft::UI::Xaml::Media::PathFigureCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_PathFigureCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(
                    PyExc_NotImplementedError,
                    "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Microsoft::UI::Xaml::Media::PathFigure> items(static_cast<uint32_t>(length), empty_instance<winrt::Microsoft::UI::Xaml::Media::PathFigure>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(
                    PyExc_RuntimeError,
                    "returned count %d did not match requested length %zd",
                    count,
                    length);
                return nullptr;
            }

            return convert(items);}
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_PathFigureCollection(py::wrapper::Microsoft::UI::Xaml::Media::PathFigureCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Microsoft::UI::Xaml::Media::PathFigure>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_PathFigureCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(PathFigureCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(PathFigureCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(PathFigureCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(PathFigureCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(PathFigureCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(PathFigureCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(PathFigureCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(PathFigureCollection_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(PathFigureCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(PathFigureCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(PathFigureCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(PathFigureCollection_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PathFigureCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PathFigureCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PathFigureCollection[] = {
        { "size", reinterpret_cast<getter>(PathFigureCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PathFigureCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PathFigureCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PathFigureCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PathFigureCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PathFigureCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_PathFigureCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_PathFigureCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_PathFigureCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_PathFigureCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_PathFigureCollection) },
        { },
    };

    static PyType_Spec type_spec_PathFigureCollection =
    {
        "winrt._winrt_microsoft_ui_xaml_media.PathFigureCollection",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::PathFigureCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PathFigureCollection
    };

    // ----- PathGeometry class --------------------

    static PyObject* _new_PathGeometry(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::PathGeometry instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PathGeometry(py::wrapper::Microsoft::UI::Xaml::Media::PathGeometry* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PathGeometry_get_FillRule(py::wrapper::Microsoft::UI::Xaml::Media::PathGeometry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PathGeometry", L"FillRule"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FillRule());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PathGeometry_put_FillRule(py::wrapper::Microsoft::UI::Xaml::Media::PathGeometry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PathGeometry", L"FillRule"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::FillRule>(arg);

            self->obj.FillRule(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PathGeometry_get_Figures(py::wrapper::Microsoft::UI::Xaml::Media::PathGeometry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PathGeometry", L"Figures"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Figures());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PathGeometry_put_Figures(py::wrapper::Microsoft::UI::Xaml::Media::PathGeometry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PathGeometry", L"Figures"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::PathFigureCollection>(arg);

            self->obj.Figures(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PathGeometry_get_FiguresProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PathGeometry", L"FiguresProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::PathGeometry::FiguresProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PathGeometry_get_FillRuleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PathGeometry", L"FillRuleProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::PathGeometry::FillRuleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PathGeometry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::PathGeometry>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PathGeometry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::PathGeometry>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PathGeometry[] = {
        { "_assign_array_", _assign_array_PathGeometry, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PathGeometry), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PathGeometry[] = {
        { "fill_rule", reinterpret_cast<getter>(PathGeometry_get_FillRule), reinterpret_cast<setter>(PathGeometry_put_FillRule), nullptr, nullptr },
        { "figures", reinterpret_cast<getter>(PathGeometry_get_Figures), reinterpret_cast<setter>(PathGeometry_put_Figures), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PathGeometry[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PathGeometry) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PathGeometry) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PathGeometry) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PathGeometry) },
        { },
    };

    static PyType_Spec type_spec_PathGeometry =
    {
        "winrt._winrt_microsoft_ui_xaml_media.PathGeometry",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::PathGeometry),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PathGeometry
    };

    static PyGetSetDef getset_PathGeometry_Static[] = {
        { "figures_property", reinterpret_cast<getter>(PathGeometry_get_FiguresProperty), nullptr, nullptr, nullptr },
        { "fill_rule_property", reinterpret_cast<getter>(PathGeometry_get_FillRuleProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_PathGeometry_Static[] = {
        { }
    };

    static PyType_Slot type_slots_PathGeometry_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PathGeometry_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PathGeometry_Static) },
        { }
    };

    static PyType_Spec type_spec_PathGeometry_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.PathGeometry_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PathGeometry_Static
    };

    // ----- PathSegment class --------------------

    static PyObject* _new_PathSegment(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Media::PathSegment>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Media::PathSegment>::type_name);
        return nullptr;
    }

    static void _dealloc_PathSegment(py::wrapper::Microsoft::UI::Xaml::Media::PathSegment* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PathSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::PathSegment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PathSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::PathSegment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PathSegment[] = {
        { "_assign_array_", _assign_array_PathSegment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PathSegment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PathSegment[] = {
        { }
    };

    static PyType_Slot _type_slots_PathSegment[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PathSegment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PathSegment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PathSegment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PathSegment) },
        { },
    };

    static PyType_Spec type_spec_PathSegment =
    {
        "winrt._winrt_microsoft_ui_xaml_media.PathSegment",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::PathSegment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PathSegment
    };

    // ----- PathSegmentCollection class --------------------

    static PyObject* _new_PathSegmentCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::PathSegmentCollection instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PathSegmentCollection(py::wrapper::Microsoft::UI::Xaml::Media::PathSegmentCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PathSegmentCollection_Append(py::wrapper::Microsoft::UI::Xaml::Media::PathSegmentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.PathSegmentCollection", L"Append", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::PathSegment>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathSegmentCollection_Clear(py::wrapper::Microsoft::UI::Xaml::Media::PathSegmentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.PathSegmentCollection", L"Clear", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathSegmentCollection_First(py::wrapper::Microsoft::UI::Xaml::Media::PathSegmentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.PathSegmentCollection", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathSegmentCollection_GetAt(py::wrapper::Microsoft::UI::Xaml::Media::PathSegmentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.PathSegmentCollection", L"GetAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathSegmentCollection_GetMany(py::wrapper::Microsoft::UI::Xaml::Media::PathSegmentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.PathSegmentCollection", L"GetMany", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Microsoft::UI::Xaml::Media::PathSegment, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathSegmentCollection_GetView(py::wrapper::Microsoft::UI::Xaml::Media::PathSegmentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.PathSegmentCollection", L"GetView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathSegmentCollection_IndexOf(py::wrapper::Microsoft::UI::Xaml::Media::PathSegmentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.PathSegmentCollection", L"IndexOf", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::PathSegment>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathSegmentCollection_InsertAt(py::wrapper::Microsoft::UI::Xaml::Media::PathSegmentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.PathSegmentCollection", L"InsertAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::PathSegment>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathSegmentCollection_RemoveAt(py::wrapper::Microsoft::UI::Xaml::Media::PathSegmentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.PathSegmentCollection", L"RemoveAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathSegmentCollection_RemoveAtEnd(py::wrapper::Microsoft::UI::Xaml::Media::PathSegmentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.PathSegmentCollection", L"RemoveAtEnd", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathSegmentCollection_ReplaceAll(py::wrapper::Microsoft::UI::Xaml::Media::PathSegmentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.PathSegmentCollection", L"ReplaceAll", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Microsoft::UI::Xaml::Media::PathSegment, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathSegmentCollection_SetAt(py::wrapper::Microsoft::UI::Xaml::Media::PathSegmentCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.PathSegmentCollection", L"SetAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::PathSegment>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PathSegmentCollection_get_Size(py::wrapper::Microsoft::UI::Xaml::Media::PathSegmentCollection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PathSegmentCollection", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PathSegmentCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::PathSegmentCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PathSegmentCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::PathSegmentCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_PathSegmentCollection(py::wrapper::Microsoft::UI::Xaml::Media::PathSegmentCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_PathSegmentCollection(py::wrapper::Microsoft::UI::Xaml::Media::PathSegmentCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_PathSegmentCollection(py::wrapper::Microsoft::UI::Xaml::Media::PathSegmentCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_PathSegmentCollection(py::wrapper::Microsoft::UI::Xaml::Media::PathSegmentCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_PathSegmentCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(
                    PyExc_NotImplementedError,
                    "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Microsoft::UI::Xaml::Media::PathSegment> items(static_cast<uint32_t>(length), empty_instance<winrt::Microsoft::UI::Xaml::Media::PathSegment>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(
                    PyExc_RuntimeError,
                    "returned count %d did not match requested length %zd",
                    count,
                    length);
                return nullptr;
            }

            return convert(items);}
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_PathSegmentCollection(py::wrapper::Microsoft::UI::Xaml::Media::PathSegmentCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Microsoft::UI::Xaml::Media::PathSegment>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_PathSegmentCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(PathSegmentCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(PathSegmentCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(PathSegmentCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(PathSegmentCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(PathSegmentCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(PathSegmentCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(PathSegmentCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(PathSegmentCollection_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(PathSegmentCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(PathSegmentCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(PathSegmentCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(PathSegmentCollection_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PathSegmentCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PathSegmentCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PathSegmentCollection[] = {
        { "size", reinterpret_cast<getter>(PathSegmentCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PathSegmentCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PathSegmentCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PathSegmentCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PathSegmentCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PathSegmentCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_PathSegmentCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_PathSegmentCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_PathSegmentCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_PathSegmentCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_PathSegmentCollection) },
        { },
    };

    static PyType_Spec type_spec_PathSegmentCollection =
    {
        "winrt._winrt_microsoft_ui_xaml_media.PathSegmentCollection",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::PathSegmentCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PathSegmentCollection
    };

    // ----- PlaneProjection class --------------------

    static PyObject* _new_PlaneProjection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::PlaneProjection instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlaneProjection(py::wrapper::Microsoft::UI::Xaml::Media::PlaneProjection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PlaneProjection_get_RotationZ(py::wrapper::Microsoft::UI::Xaml::Media::PlaneProjection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PlaneProjection", L"RotationZ"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RotationZ());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlaneProjection_put_RotationZ(py::wrapper::Microsoft::UI::Xaml::Media::PlaneProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PlaneProjection", L"RotationZ"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.RotationZ(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlaneProjection_get_RotationY(py::wrapper::Microsoft::UI::Xaml::Media::PlaneProjection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PlaneProjection", L"RotationY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RotationY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlaneProjection_put_RotationY(py::wrapper::Microsoft::UI::Xaml::Media::PlaneProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PlaneProjection", L"RotationY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.RotationY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlaneProjection_get_RotationX(py::wrapper::Microsoft::UI::Xaml::Media::PlaneProjection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PlaneProjection", L"RotationX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RotationX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlaneProjection_put_RotationX(py::wrapper::Microsoft::UI::Xaml::Media::PlaneProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PlaneProjection", L"RotationX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.RotationX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlaneProjection_get_LocalOffsetZ(py::wrapper::Microsoft::UI::Xaml::Media::PlaneProjection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PlaneProjection", L"LocalOffsetZ"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LocalOffsetZ());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlaneProjection_put_LocalOffsetZ(py::wrapper::Microsoft::UI::Xaml::Media::PlaneProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PlaneProjection", L"LocalOffsetZ"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.LocalOffsetZ(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlaneProjection_get_LocalOffsetY(py::wrapper::Microsoft::UI::Xaml::Media::PlaneProjection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PlaneProjection", L"LocalOffsetY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LocalOffsetY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlaneProjection_put_LocalOffsetY(py::wrapper::Microsoft::UI::Xaml::Media::PlaneProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PlaneProjection", L"LocalOffsetY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.LocalOffsetY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlaneProjection_get_LocalOffsetX(py::wrapper::Microsoft::UI::Xaml::Media::PlaneProjection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PlaneProjection", L"LocalOffsetX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LocalOffsetX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlaneProjection_put_LocalOffsetX(py::wrapper::Microsoft::UI::Xaml::Media::PlaneProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PlaneProjection", L"LocalOffsetX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.LocalOffsetX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlaneProjection_get_GlobalOffsetZ(py::wrapper::Microsoft::UI::Xaml::Media::PlaneProjection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PlaneProjection", L"GlobalOffsetZ"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.GlobalOffsetZ());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlaneProjection_put_GlobalOffsetZ(py::wrapper::Microsoft::UI::Xaml::Media::PlaneProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PlaneProjection", L"GlobalOffsetZ"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.GlobalOffsetZ(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlaneProjection_get_GlobalOffsetY(py::wrapper::Microsoft::UI::Xaml::Media::PlaneProjection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PlaneProjection", L"GlobalOffsetY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.GlobalOffsetY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlaneProjection_put_GlobalOffsetY(py::wrapper::Microsoft::UI::Xaml::Media::PlaneProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PlaneProjection", L"GlobalOffsetY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.GlobalOffsetY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlaneProjection_get_GlobalOffsetX(py::wrapper::Microsoft::UI::Xaml::Media::PlaneProjection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PlaneProjection", L"GlobalOffsetX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.GlobalOffsetX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlaneProjection_put_GlobalOffsetX(py::wrapper::Microsoft::UI::Xaml::Media::PlaneProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PlaneProjection", L"GlobalOffsetX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.GlobalOffsetX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlaneProjection_get_CenterOfRotationZ(py::wrapper::Microsoft::UI::Xaml::Media::PlaneProjection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PlaneProjection", L"CenterOfRotationZ"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CenterOfRotationZ());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlaneProjection_put_CenterOfRotationZ(py::wrapper::Microsoft::UI::Xaml::Media::PlaneProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PlaneProjection", L"CenterOfRotationZ"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.CenterOfRotationZ(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlaneProjection_get_CenterOfRotationY(py::wrapper::Microsoft::UI::Xaml::Media::PlaneProjection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PlaneProjection", L"CenterOfRotationY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CenterOfRotationY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlaneProjection_put_CenterOfRotationY(py::wrapper::Microsoft::UI::Xaml::Media::PlaneProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PlaneProjection", L"CenterOfRotationY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.CenterOfRotationY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlaneProjection_get_CenterOfRotationX(py::wrapper::Microsoft::UI::Xaml::Media::PlaneProjection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PlaneProjection", L"CenterOfRotationX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CenterOfRotationX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlaneProjection_put_CenterOfRotationX(py::wrapper::Microsoft::UI::Xaml::Media::PlaneProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PlaneProjection", L"CenterOfRotationX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.CenterOfRotationX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlaneProjection_get_ProjectionMatrix(py::wrapper::Microsoft::UI::Xaml::Media::PlaneProjection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PlaneProjection", L"ProjectionMatrix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProjectionMatrix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlaneProjection_get_CenterOfRotationXProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PlaneProjection", L"CenterOfRotationXProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::PlaneProjection::CenterOfRotationXProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlaneProjection_get_CenterOfRotationYProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PlaneProjection", L"CenterOfRotationYProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::PlaneProjection::CenterOfRotationYProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlaneProjection_get_CenterOfRotationZProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PlaneProjection", L"CenterOfRotationZProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::PlaneProjection::CenterOfRotationZProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlaneProjection_get_GlobalOffsetXProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PlaneProjection", L"GlobalOffsetXProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::PlaneProjection::GlobalOffsetXProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlaneProjection_get_GlobalOffsetYProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PlaneProjection", L"GlobalOffsetYProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::PlaneProjection::GlobalOffsetYProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlaneProjection_get_GlobalOffsetZProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PlaneProjection", L"GlobalOffsetZProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::PlaneProjection::GlobalOffsetZProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlaneProjection_get_LocalOffsetXProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PlaneProjection", L"LocalOffsetXProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::PlaneProjection::LocalOffsetXProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlaneProjection_get_LocalOffsetYProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PlaneProjection", L"LocalOffsetYProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::PlaneProjection::LocalOffsetYProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlaneProjection_get_LocalOffsetZProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PlaneProjection", L"LocalOffsetZProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::PlaneProjection::LocalOffsetZProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlaneProjection_get_ProjectionMatrixProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PlaneProjection", L"ProjectionMatrixProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::PlaneProjection::ProjectionMatrixProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlaneProjection_get_RotationXProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PlaneProjection", L"RotationXProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::PlaneProjection::RotationXProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlaneProjection_get_RotationYProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PlaneProjection", L"RotationYProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::PlaneProjection::RotationYProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlaneProjection_get_RotationZProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PlaneProjection", L"RotationZProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::PlaneProjection::RotationZProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PlaneProjection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::PlaneProjection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PlaneProjection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::PlaneProjection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlaneProjection[] = {
        { "_assign_array_", _assign_array_PlaneProjection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlaneProjection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlaneProjection[] = {
        { "rotation_z", reinterpret_cast<getter>(PlaneProjection_get_RotationZ), reinterpret_cast<setter>(PlaneProjection_put_RotationZ), nullptr, nullptr },
        { "rotation_y", reinterpret_cast<getter>(PlaneProjection_get_RotationY), reinterpret_cast<setter>(PlaneProjection_put_RotationY), nullptr, nullptr },
        { "rotation_x", reinterpret_cast<getter>(PlaneProjection_get_RotationX), reinterpret_cast<setter>(PlaneProjection_put_RotationX), nullptr, nullptr },
        { "local_offset_z", reinterpret_cast<getter>(PlaneProjection_get_LocalOffsetZ), reinterpret_cast<setter>(PlaneProjection_put_LocalOffsetZ), nullptr, nullptr },
        { "local_offset_y", reinterpret_cast<getter>(PlaneProjection_get_LocalOffsetY), reinterpret_cast<setter>(PlaneProjection_put_LocalOffsetY), nullptr, nullptr },
        { "local_offset_x", reinterpret_cast<getter>(PlaneProjection_get_LocalOffsetX), reinterpret_cast<setter>(PlaneProjection_put_LocalOffsetX), nullptr, nullptr },
        { "global_offset_z", reinterpret_cast<getter>(PlaneProjection_get_GlobalOffsetZ), reinterpret_cast<setter>(PlaneProjection_put_GlobalOffsetZ), nullptr, nullptr },
        { "global_offset_y", reinterpret_cast<getter>(PlaneProjection_get_GlobalOffsetY), reinterpret_cast<setter>(PlaneProjection_put_GlobalOffsetY), nullptr, nullptr },
        { "global_offset_x", reinterpret_cast<getter>(PlaneProjection_get_GlobalOffsetX), reinterpret_cast<setter>(PlaneProjection_put_GlobalOffsetX), nullptr, nullptr },
        { "center_of_rotation_z", reinterpret_cast<getter>(PlaneProjection_get_CenterOfRotationZ), reinterpret_cast<setter>(PlaneProjection_put_CenterOfRotationZ), nullptr, nullptr },
        { "center_of_rotation_y", reinterpret_cast<getter>(PlaneProjection_get_CenterOfRotationY), reinterpret_cast<setter>(PlaneProjection_put_CenterOfRotationY), nullptr, nullptr },
        { "center_of_rotation_x", reinterpret_cast<getter>(PlaneProjection_get_CenterOfRotationX), reinterpret_cast<setter>(PlaneProjection_put_CenterOfRotationX), nullptr, nullptr },
        { "projection_matrix", reinterpret_cast<getter>(PlaneProjection_get_ProjectionMatrix), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PlaneProjection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlaneProjection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PlaneProjection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlaneProjection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlaneProjection) },
        { },
    };

    static PyType_Spec type_spec_PlaneProjection =
    {
        "winrt._winrt_microsoft_ui_xaml_media.PlaneProjection",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::PlaneProjection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlaneProjection
    };

    static PyGetSetDef getset_PlaneProjection_Static[] = {
        { "center_of_rotation_x_property", reinterpret_cast<getter>(PlaneProjection_get_CenterOfRotationXProperty), nullptr, nullptr, nullptr },
        { "center_of_rotation_y_property", reinterpret_cast<getter>(PlaneProjection_get_CenterOfRotationYProperty), nullptr, nullptr, nullptr },
        { "center_of_rotation_z_property", reinterpret_cast<getter>(PlaneProjection_get_CenterOfRotationZProperty), nullptr, nullptr, nullptr },
        { "global_offset_x_property", reinterpret_cast<getter>(PlaneProjection_get_GlobalOffsetXProperty), nullptr, nullptr, nullptr },
        { "global_offset_y_property", reinterpret_cast<getter>(PlaneProjection_get_GlobalOffsetYProperty), nullptr, nullptr, nullptr },
        { "global_offset_z_property", reinterpret_cast<getter>(PlaneProjection_get_GlobalOffsetZProperty), nullptr, nullptr, nullptr },
        { "local_offset_x_property", reinterpret_cast<getter>(PlaneProjection_get_LocalOffsetXProperty), nullptr, nullptr, nullptr },
        { "local_offset_y_property", reinterpret_cast<getter>(PlaneProjection_get_LocalOffsetYProperty), nullptr, nullptr, nullptr },
        { "local_offset_z_property", reinterpret_cast<getter>(PlaneProjection_get_LocalOffsetZProperty), nullptr, nullptr, nullptr },
        { "projection_matrix_property", reinterpret_cast<getter>(PlaneProjection_get_ProjectionMatrixProperty), nullptr, nullptr, nullptr },
        { "rotation_x_property", reinterpret_cast<getter>(PlaneProjection_get_RotationXProperty), nullptr, nullptr, nullptr },
        { "rotation_y_property", reinterpret_cast<getter>(PlaneProjection_get_RotationYProperty), nullptr, nullptr, nullptr },
        { "rotation_z_property", reinterpret_cast<getter>(PlaneProjection_get_RotationZProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_PlaneProjection_Static[] = {
        { }
    };

    static PyType_Slot type_slots_PlaneProjection_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PlaneProjection_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PlaneProjection_Static) },
        { }
    };

    static PyType_Spec type_spec_PlaneProjection_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.PlaneProjection_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PlaneProjection_Static
    };

    // ----- PointCollection class --------------------

    static PyObject* _new_PointCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::PointCollection instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PointCollection(py::wrapper::Microsoft::UI::Xaml::Media::PointCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PointCollection_Append(py::wrapper::Microsoft::UI::Xaml::Media::PointCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.PointCollection", L"Append", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointCollection_Clear(py::wrapper::Microsoft::UI::Xaml::Media::PointCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.PointCollection", L"Clear", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointCollection_First(py::wrapper::Microsoft::UI::Xaml::Media::PointCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.PointCollection", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointCollection_GetAt(py::wrapper::Microsoft::UI::Xaml::Media::PointCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.PointCollection", L"GetAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointCollection_GetMany(py::wrapper::Microsoft::UI::Xaml::Media::PointCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.PointCollection", L"GetMany", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointCollection_GetView(py::wrapper::Microsoft::UI::Xaml::Media::PointCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.PointCollection", L"GetView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointCollection_IndexOf(py::wrapper::Microsoft::UI::Xaml::Media::PointCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.PointCollection", L"IndexOf", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointCollection_InsertAt(py::wrapper::Microsoft::UI::Xaml::Media::PointCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.PointCollection", L"InsertAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointCollection_RemoveAt(py::wrapper::Microsoft::UI::Xaml::Media::PointCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.PointCollection", L"RemoveAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointCollection_RemoveAtEnd(py::wrapper::Microsoft::UI::Xaml::Media::PointCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.PointCollection", L"RemoveAtEnd", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointCollection_ReplaceAll(py::wrapper::Microsoft::UI::Xaml::Media::PointCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.PointCollection", L"ReplaceAll", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointCollection_SetAt(py::wrapper::Microsoft::UI::Xaml::Media::PointCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.PointCollection", L"SetAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PointCollection_get_Size(py::wrapper::Microsoft::UI::Xaml::Media::PointCollection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PointCollection", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PointCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::PointCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PointCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::PointCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_PointCollection(py::wrapper::Microsoft::UI::Xaml::Media::PointCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_PointCollection(py::wrapper::Microsoft::UI::Xaml::Media::PointCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_PointCollection(py::wrapper::Microsoft::UI::Xaml::Media::PointCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_PointCollection(py::wrapper::Microsoft::UI::Xaml::Media::PointCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_PointCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(
                    PyExc_NotImplementedError,
                    "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Windows::Foundation::Point> items(static_cast<uint32_t>(length), empty_instance<winrt::Windows::Foundation::Point>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(
                    PyExc_RuntimeError,
                    "returned count %d did not match requested length %zd",
                    count,
                    length);
                return nullptr;
            }

            return convert(items);}
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_PointCollection(py::wrapper::Microsoft::UI::Xaml::Media::PointCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Windows::Foundation::Point>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_PointCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(PointCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(PointCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(PointCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(PointCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(PointCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(PointCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(PointCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(PointCollection_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(PointCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(PointCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(PointCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(PointCollection_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PointCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PointCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PointCollection[] = {
        { "size", reinterpret_cast<getter>(PointCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PointCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PointCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PointCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PointCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PointCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_PointCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_PointCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_PointCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_PointCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_PointCollection) },
        { },
    };

    static PyType_Spec type_spec_PointCollection =
    {
        "winrt._winrt_microsoft_ui_xaml_media.PointCollection",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::PointCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PointCollection
    };

    // ----- PolyBezierSegment class --------------------

    static PyObject* _new_PolyBezierSegment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::PolyBezierSegment instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PolyBezierSegment(py::wrapper::Microsoft::UI::Xaml::Media::PolyBezierSegment* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PolyBezierSegment_get_Points(py::wrapper::Microsoft::UI::Xaml::Media::PolyBezierSegment* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PolyBezierSegment", L"Points"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Points());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PolyBezierSegment_put_Points(py::wrapper::Microsoft::UI::Xaml::Media::PolyBezierSegment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PolyBezierSegment", L"Points"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::PointCollection>(arg);

            self->obj.Points(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PolyBezierSegment_get_PointsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PolyBezierSegment", L"PointsProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::PolyBezierSegment::PointsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PolyBezierSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::PolyBezierSegment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PolyBezierSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::PolyBezierSegment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PolyBezierSegment[] = {
        { "_assign_array_", _assign_array_PolyBezierSegment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PolyBezierSegment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PolyBezierSegment[] = {
        { "points", reinterpret_cast<getter>(PolyBezierSegment_get_Points), reinterpret_cast<setter>(PolyBezierSegment_put_Points), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PolyBezierSegment[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PolyBezierSegment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PolyBezierSegment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PolyBezierSegment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PolyBezierSegment) },
        { },
    };

    static PyType_Spec type_spec_PolyBezierSegment =
    {
        "winrt._winrt_microsoft_ui_xaml_media.PolyBezierSegment",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::PolyBezierSegment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PolyBezierSegment
    };

    static PyGetSetDef getset_PolyBezierSegment_Static[] = {
        { "points_property", reinterpret_cast<getter>(PolyBezierSegment_get_PointsProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_PolyBezierSegment_Static[] = {
        { }
    };

    static PyType_Slot type_slots_PolyBezierSegment_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PolyBezierSegment_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PolyBezierSegment_Static) },
        { }
    };

    static PyType_Spec type_spec_PolyBezierSegment_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.PolyBezierSegment_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PolyBezierSegment_Static
    };

    // ----- PolyLineSegment class --------------------

    static PyObject* _new_PolyLineSegment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::PolyLineSegment instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PolyLineSegment(py::wrapper::Microsoft::UI::Xaml::Media::PolyLineSegment* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PolyLineSegment_get_Points(py::wrapper::Microsoft::UI::Xaml::Media::PolyLineSegment* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PolyLineSegment", L"Points"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Points());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PolyLineSegment_put_Points(py::wrapper::Microsoft::UI::Xaml::Media::PolyLineSegment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PolyLineSegment", L"Points"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::PointCollection>(arg);

            self->obj.Points(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PolyLineSegment_get_PointsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PolyLineSegment", L"PointsProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::PolyLineSegment::PointsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PolyLineSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::PolyLineSegment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PolyLineSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::PolyLineSegment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PolyLineSegment[] = {
        { "_assign_array_", _assign_array_PolyLineSegment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PolyLineSegment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PolyLineSegment[] = {
        { "points", reinterpret_cast<getter>(PolyLineSegment_get_Points), reinterpret_cast<setter>(PolyLineSegment_put_Points), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PolyLineSegment[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PolyLineSegment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PolyLineSegment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PolyLineSegment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PolyLineSegment) },
        { },
    };

    static PyType_Spec type_spec_PolyLineSegment =
    {
        "winrt._winrt_microsoft_ui_xaml_media.PolyLineSegment",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::PolyLineSegment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PolyLineSegment
    };

    static PyGetSetDef getset_PolyLineSegment_Static[] = {
        { "points_property", reinterpret_cast<getter>(PolyLineSegment_get_PointsProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_PolyLineSegment_Static[] = {
        { }
    };

    static PyType_Slot type_slots_PolyLineSegment_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PolyLineSegment_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PolyLineSegment_Static) },
        { }
    };

    static PyType_Spec type_spec_PolyLineSegment_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.PolyLineSegment_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PolyLineSegment_Static
    };

    // ----- PolyQuadraticBezierSegment class --------------------

    static PyObject* _new_PolyQuadraticBezierSegment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::PolyQuadraticBezierSegment instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PolyQuadraticBezierSegment(py::wrapper::Microsoft::UI::Xaml::Media::PolyQuadraticBezierSegment* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PolyQuadraticBezierSegment_get_Points(py::wrapper::Microsoft::UI::Xaml::Media::PolyQuadraticBezierSegment* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PolyQuadraticBezierSegment", L"Points"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Points());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PolyQuadraticBezierSegment_put_Points(py::wrapper::Microsoft::UI::Xaml::Media::PolyQuadraticBezierSegment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PolyQuadraticBezierSegment", L"Points"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::PointCollection>(arg);

            self->obj.Points(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PolyQuadraticBezierSegment_get_PointsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.PolyQuadraticBezierSegment", L"PointsProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::PolyQuadraticBezierSegment::PointsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PolyQuadraticBezierSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::PolyQuadraticBezierSegment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PolyQuadraticBezierSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::PolyQuadraticBezierSegment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PolyQuadraticBezierSegment[] = {
        { "_assign_array_", _assign_array_PolyQuadraticBezierSegment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PolyQuadraticBezierSegment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PolyQuadraticBezierSegment[] = {
        { "points", reinterpret_cast<getter>(PolyQuadraticBezierSegment_get_Points), reinterpret_cast<setter>(PolyQuadraticBezierSegment_put_Points), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PolyQuadraticBezierSegment[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PolyQuadraticBezierSegment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PolyQuadraticBezierSegment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PolyQuadraticBezierSegment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PolyQuadraticBezierSegment) },
        { },
    };

    static PyType_Spec type_spec_PolyQuadraticBezierSegment =
    {
        "winrt._winrt_microsoft_ui_xaml_media.PolyQuadraticBezierSegment",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::PolyQuadraticBezierSegment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PolyQuadraticBezierSegment
    };

    static PyGetSetDef getset_PolyQuadraticBezierSegment_Static[] = {
        { "points_property", reinterpret_cast<getter>(PolyQuadraticBezierSegment_get_PointsProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_PolyQuadraticBezierSegment_Static[] = {
        { }
    };

    static PyType_Slot type_slots_PolyQuadraticBezierSegment_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PolyQuadraticBezierSegment_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PolyQuadraticBezierSegment_Static) },
        { }
    };

    static PyType_Spec type_spec_PolyQuadraticBezierSegment_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.PolyQuadraticBezierSegment_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PolyQuadraticBezierSegment_Static
    };

    // ----- Projection class --------------------

    static PyObject* _new_Projection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Media::Projection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Media::Projection>::type_name);
        return nullptr;
    }

    static void _dealloc_Projection(py::wrapper::Microsoft::UI::Xaml::Media::Projection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Projection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::Projection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Projection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::Projection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Projection[] = {
        { "_assign_array_", _assign_array_Projection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Projection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Projection[] = {
        { }
    };

    static PyType_Slot _type_slots_Projection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Projection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Projection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Projection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Projection) },
        { },
    };

    static PyType_Spec type_spec_Projection =
    {
        "winrt._winrt_microsoft_ui_xaml_media.Projection",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::Projection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Projection
    };

    // ----- QuadraticBezierSegment class --------------------

    static PyObject* _new_QuadraticBezierSegment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::QuadraticBezierSegment instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_QuadraticBezierSegment(py::wrapper::Microsoft::UI::Xaml::Media::QuadraticBezierSegment* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* QuadraticBezierSegment_get_Point2(py::wrapper::Microsoft::UI::Xaml::Media::QuadraticBezierSegment* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.QuadraticBezierSegment", L"Point2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Point2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int QuadraticBezierSegment_put_Point2(py::wrapper::Microsoft::UI::Xaml::Media::QuadraticBezierSegment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.QuadraticBezierSegment", L"Point2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.Point2(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* QuadraticBezierSegment_get_Point1(py::wrapper::Microsoft::UI::Xaml::Media::QuadraticBezierSegment* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.QuadraticBezierSegment", L"Point1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Point1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int QuadraticBezierSegment_put_Point1(py::wrapper::Microsoft::UI::Xaml::Media::QuadraticBezierSegment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.QuadraticBezierSegment", L"Point1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.Point1(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* QuadraticBezierSegment_get_Point1Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.QuadraticBezierSegment", L"Point1Property"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::QuadraticBezierSegment::Point1Property());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* QuadraticBezierSegment_get_Point2Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.QuadraticBezierSegment", L"Point2Property"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::QuadraticBezierSegment::Point2Property());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_QuadraticBezierSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::QuadraticBezierSegment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_QuadraticBezierSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::QuadraticBezierSegment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_QuadraticBezierSegment[] = {
        { "_assign_array_", _assign_array_QuadraticBezierSegment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_QuadraticBezierSegment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_QuadraticBezierSegment[] = {
        { "point2", reinterpret_cast<getter>(QuadraticBezierSegment_get_Point2), reinterpret_cast<setter>(QuadraticBezierSegment_put_Point2), nullptr, nullptr },
        { "point1", reinterpret_cast<getter>(QuadraticBezierSegment_get_Point1), reinterpret_cast<setter>(QuadraticBezierSegment_put_Point1), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_QuadraticBezierSegment[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_QuadraticBezierSegment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_QuadraticBezierSegment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_QuadraticBezierSegment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_QuadraticBezierSegment) },
        { },
    };

    static PyType_Spec type_spec_QuadraticBezierSegment =
    {
        "winrt._winrt_microsoft_ui_xaml_media.QuadraticBezierSegment",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::QuadraticBezierSegment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_QuadraticBezierSegment
    };

    static PyGetSetDef getset_QuadraticBezierSegment_Static[] = {
        { "point1_property", reinterpret_cast<getter>(QuadraticBezierSegment_get_Point1Property), nullptr, nullptr, nullptr },
        { "point2_property", reinterpret_cast<getter>(QuadraticBezierSegment_get_Point2Property), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_QuadraticBezierSegment_Static[] = {
        { }
    };

    static PyType_Slot type_slots_QuadraticBezierSegment_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_QuadraticBezierSegment_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_QuadraticBezierSegment_Static) },
        { }
    };

    static PyType_Spec type_spec_QuadraticBezierSegment_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.QuadraticBezierSegment_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_QuadraticBezierSegment_Static
    };

    // ----- RadialGradientBrush class --------------------

    static PyObject* _new_RadialGradientBrush(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::RadialGradientBrush instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RadialGradientBrush(py::wrapper::Microsoft::UI::Xaml::Media::RadialGradientBrush* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RadialGradientBrush_get_SpreadMethod(py::wrapper::Microsoft::UI::Xaml::Media::RadialGradientBrush* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.RadialGradientBrush", L"SpreadMethod"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SpreadMethod());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RadialGradientBrush_put_SpreadMethod(py::wrapper::Microsoft::UI::Xaml::Media::RadialGradientBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.RadialGradientBrush", L"SpreadMethod"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::GradientSpreadMethod>(arg);

            self->obj.SpreadMethod(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RadialGradientBrush_get_RadiusY(py::wrapper::Microsoft::UI::Xaml::Media::RadialGradientBrush* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.RadialGradientBrush", L"RadiusY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RadiusY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RadialGradientBrush_put_RadiusY(py::wrapper::Microsoft::UI::Xaml::Media::RadialGradientBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.RadialGradientBrush", L"RadiusY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.RadiusY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RadialGradientBrush_get_RadiusX(py::wrapper::Microsoft::UI::Xaml::Media::RadialGradientBrush* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.RadialGradientBrush", L"RadiusX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RadiusX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RadialGradientBrush_put_RadiusX(py::wrapper::Microsoft::UI::Xaml::Media::RadialGradientBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.RadialGradientBrush", L"RadiusX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.RadiusX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RadialGradientBrush_get_MappingMode(py::wrapper::Microsoft::UI::Xaml::Media::RadialGradientBrush* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.RadialGradientBrush", L"MappingMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MappingMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RadialGradientBrush_put_MappingMode(py::wrapper::Microsoft::UI::Xaml::Media::RadialGradientBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.RadialGradientBrush", L"MappingMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::BrushMappingMode>(arg);

            self->obj.MappingMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RadialGradientBrush_get_InterpolationSpace(py::wrapper::Microsoft::UI::Xaml::Media::RadialGradientBrush* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.RadialGradientBrush", L"InterpolationSpace"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InterpolationSpace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RadialGradientBrush_put_InterpolationSpace(py::wrapper::Microsoft::UI::Xaml::Media::RadialGradientBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.RadialGradientBrush", L"InterpolationSpace"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionColorSpace>(arg);

            self->obj.InterpolationSpace(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RadialGradientBrush_get_GradientOrigin(py::wrapper::Microsoft::UI::Xaml::Media::RadialGradientBrush* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.RadialGradientBrush", L"GradientOrigin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.GradientOrigin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RadialGradientBrush_put_GradientOrigin(py::wrapper::Microsoft::UI::Xaml::Media::RadialGradientBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.RadialGradientBrush", L"GradientOrigin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.GradientOrigin(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RadialGradientBrush_get_Center(py::wrapper::Microsoft::UI::Xaml::Media::RadialGradientBrush* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.RadialGradientBrush", L"Center"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Center());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RadialGradientBrush_put_Center(py::wrapper::Microsoft::UI::Xaml::Media::RadialGradientBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.RadialGradientBrush", L"Center"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.Center(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RadialGradientBrush_get_GradientStops(py::wrapper::Microsoft::UI::Xaml::Media::RadialGradientBrush* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.RadialGradientBrush", L"GradientStops"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.GradientStops());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialGradientBrush_get_CenterProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.RadialGradientBrush", L"CenterProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::RadialGradientBrush::CenterProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialGradientBrush_get_GradientOriginProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.RadialGradientBrush", L"GradientOriginProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::RadialGradientBrush::GradientOriginProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialGradientBrush_get_InterpolationSpaceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.RadialGradientBrush", L"InterpolationSpaceProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::RadialGradientBrush::InterpolationSpaceProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialGradientBrush_get_MappingModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.RadialGradientBrush", L"MappingModeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::RadialGradientBrush::MappingModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialGradientBrush_get_RadiusXProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.RadialGradientBrush", L"RadiusXProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::RadialGradientBrush::RadiusXProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialGradientBrush_get_RadiusYProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.RadialGradientBrush", L"RadiusYProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::RadialGradientBrush::RadiusYProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadialGradientBrush_get_SpreadMethodProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.RadialGradientBrush", L"SpreadMethodProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::RadialGradientBrush::SpreadMethodProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RadialGradientBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::RadialGradientBrush>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RadialGradientBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::RadialGradientBrush>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadialGradientBrush[] = {
        { "_assign_array_", _assign_array_RadialGradientBrush, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RadialGradientBrush), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RadialGradientBrush[] = {
        { "spread_method", reinterpret_cast<getter>(RadialGradientBrush_get_SpreadMethod), reinterpret_cast<setter>(RadialGradientBrush_put_SpreadMethod), nullptr, nullptr },
        { "radius_y", reinterpret_cast<getter>(RadialGradientBrush_get_RadiusY), reinterpret_cast<setter>(RadialGradientBrush_put_RadiusY), nullptr, nullptr },
        { "radius_x", reinterpret_cast<getter>(RadialGradientBrush_get_RadiusX), reinterpret_cast<setter>(RadialGradientBrush_put_RadiusX), nullptr, nullptr },
        { "mapping_mode", reinterpret_cast<getter>(RadialGradientBrush_get_MappingMode), reinterpret_cast<setter>(RadialGradientBrush_put_MappingMode), nullptr, nullptr },
        { "interpolation_space", reinterpret_cast<getter>(RadialGradientBrush_get_InterpolationSpace), reinterpret_cast<setter>(RadialGradientBrush_put_InterpolationSpace), nullptr, nullptr },
        { "gradient_origin", reinterpret_cast<getter>(RadialGradientBrush_get_GradientOrigin), reinterpret_cast<setter>(RadialGradientBrush_put_GradientOrigin), nullptr, nullptr },
        { "center", reinterpret_cast<getter>(RadialGradientBrush_get_Center), reinterpret_cast<setter>(RadialGradientBrush_put_Center), nullptr, nullptr },
        { "gradient_stops", reinterpret_cast<getter>(RadialGradientBrush_get_GradientStops), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RadialGradientBrush[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RadialGradientBrush) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RadialGradientBrush) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RadialGradientBrush) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RadialGradientBrush) },
        { },
    };

    static PyType_Spec type_spec_RadialGradientBrush =
    {
        "winrt._winrt_microsoft_ui_xaml_media.RadialGradientBrush",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::RadialGradientBrush),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RadialGradientBrush
    };

    static PyGetSetDef getset_RadialGradientBrush_Static[] = {
        { "center_property", reinterpret_cast<getter>(RadialGradientBrush_get_CenterProperty), nullptr, nullptr, nullptr },
        { "gradient_origin_property", reinterpret_cast<getter>(RadialGradientBrush_get_GradientOriginProperty), nullptr, nullptr, nullptr },
        { "interpolation_space_property", reinterpret_cast<getter>(RadialGradientBrush_get_InterpolationSpaceProperty), nullptr, nullptr, nullptr },
        { "mapping_mode_property", reinterpret_cast<getter>(RadialGradientBrush_get_MappingModeProperty), nullptr, nullptr, nullptr },
        { "radius_x_property", reinterpret_cast<getter>(RadialGradientBrush_get_RadiusXProperty), nullptr, nullptr, nullptr },
        { "radius_y_property", reinterpret_cast<getter>(RadialGradientBrush_get_RadiusYProperty), nullptr, nullptr, nullptr },
        { "spread_method_property", reinterpret_cast<getter>(RadialGradientBrush_get_SpreadMethodProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_RadialGradientBrush_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RadialGradientBrush_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RadialGradientBrush_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RadialGradientBrush_Static) },
        { }
    };

    static PyType_Spec type_spec_RadialGradientBrush_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.RadialGradientBrush_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RadialGradientBrush_Static
    };

    // ----- RectangleGeometry class --------------------

    static PyObject* _new_RectangleGeometry(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::RectangleGeometry instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RectangleGeometry(py::wrapper::Microsoft::UI::Xaml::Media::RectangleGeometry* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RectangleGeometry_get_Rect(py::wrapper::Microsoft::UI::Xaml::Media::RectangleGeometry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.RectangleGeometry", L"Rect"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Rect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RectangleGeometry_put_Rect(py::wrapper::Microsoft::UI::Xaml::Media::RectangleGeometry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.RectangleGeometry", L"Rect"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(arg);

            self->obj.Rect(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RectangleGeometry_get_RectProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.RectangleGeometry", L"RectProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::RectangleGeometry::RectProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RectangleGeometry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::RectangleGeometry>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RectangleGeometry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::RectangleGeometry>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RectangleGeometry[] = {
        { "_assign_array_", _assign_array_RectangleGeometry, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RectangleGeometry), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RectangleGeometry[] = {
        { "rect", reinterpret_cast<getter>(RectangleGeometry_get_Rect), reinterpret_cast<setter>(RectangleGeometry_put_Rect), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RectangleGeometry[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RectangleGeometry) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RectangleGeometry) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RectangleGeometry) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RectangleGeometry) },
        { },
    };

    static PyType_Spec type_spec_RectangleGeometry =
    {
        "winrt._winrt_microsoft_ui_xaml_media.RectangleGeometry",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::RectangleGeometry),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RectangleGeometry
    };

    static PyGetSetDef getset_RectangleGeometry_Static[] = {
        { "rect_property", reinterpret_cast<getter>(RectangleGeometry_get_RectProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_RectangleGeometry_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RectangleGeometry_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RectangleGeometry_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RectangleGeometry_Static) },
        { }
    };

    static PyType_Spec type_spec_RectangleGeometry_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.RectangleGeometry_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RectangleGeometry_Static
    };

    // ----- RenderedEventArgs class --------------------

    static PyObject* _new_RenderedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Media::RenderedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Media::RenderedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RenderedEventArgs(py::wrapper::Microsoft::UI::Xaml::Media::RenderedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RenderedEventArgs_get_FrameDuration(py::wrapper::Microsoft::UI::Xaml::Media::RenderedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.RenderedEventArgs", L"FrameDuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FrameDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RenderedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::RenderedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RenderedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::RenderedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RenderedEventArgs[] = {
        { "_assign_array_", _assign_array_RenderedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RenderedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RenderedEventArgs[] = {
        { "frame_duration", reinterpret_cast<getter>(RenderedEventArgs_get_FrameDuration), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RenderedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RenderedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RenderedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RenderedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RenderedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_RenderedEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_media.RenderedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::RenderedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RenderedEventArgs
    };

    // ----- RenderingEventArgs class --------------------

    static PyObject* _new_RenderingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Media::RenderingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Media::RenderingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RenderingEventArgs(py::wrapper::Microsoft::UI::Xaml::Media::RenderingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RenderingEventArgs_get_RenderingTime(py::wrapper::Microsoft::UI::Xaml::Media::RenderingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.RenderingEventArgs", L"RenderingTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RenderingTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RenderingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::RenderingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RenderingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::RenderingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RenderingEventArgs[] = {
        { "_assign_array_", _assign_array_RenderingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RenderingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RenderingEventArgs[] = {
        { "rendering_time", reinterpret_cast<getter>(RenderingEventArgs_get_RenderingTime), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RenderingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RenderingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RenderingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RenderingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RenderingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_RenderingEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_media.RenderingEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::RenderingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RenderingEventArgs
    };

    // ----- RotateTransform class --------------------

    static PyObject* _new_RotateTransform(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::RotateTransform instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RotateTransform(py::wrapper::Microsoft::UI::Xaml::Media::RotateTransform* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RotateTransform_get_CenterY(py::wrapper::Microsoft::UI::Xaml::Media::RotateTransform* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.RotateTransform", L"CenterY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CenterY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RotateTransform_put_CenterY(py::wrapper::Microsoft::UI::Xaml::Media::RotateTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.RotateTransform", L"CenterY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.CenterY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RotateTransform_get_CenterX(py::wrapper::Microsoft::UI::Xaml::Media::RotateTransform* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.RotateTransform", L"CenterX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CenterX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RotateTransform_put_CenterX(py::wrapper::Microsoft::UI::Xaml::Media::RotateTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.RotateTransform", L"CenterX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.CenterX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RotateTransform_get_Angle(py::wrapper::Microsoft::UI::Xaml::Media::RotateTransform* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.RotateTransform", L"Angle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Angle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RotateTransform_put_Angle(py::wrapper::Microsoft::UI::Xaml::Media::RotateTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.RotateTransform", L"Angle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Angle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RotateTransform_get_AngleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.RotateTransform", L"AngleProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::RotateTransform::AngleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RotateTransform_get_CenterXProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.RotateTransform", L"CenterXProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::RotateTransform::CenterXProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RotateTransform_get_CenterYProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.RotateTransform", L"CenterYProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::RotateTransform::CenterYProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RotateTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::RotateTransform>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RotateTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::RotateTransform>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RotateTransform[] = {
        { "_assign_array_", _assign_array_RotateTransform, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RotateTransform), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RotateTransform[] = {
        { "center_y", reinterpret_cast<getter>(RotateTransform_get_CenterY), reinterpret_cast<setter>(RotateTransform_put_CenterY), nullptr, nullptr },
        { "center_x", reinterpret_cast<getter>(RotateTransform_get_CenterX), reinterpret_cast<setter>(RotateTransform_put_CenterX), nullptr, nullptr },
        { "angle", reinterpret_cast<getter>(RotateTransform_get_Angle), reinterpret_cast<setter>(RotateTransform_put_Angle), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RotateTransform[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RotateTransform) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RotateTransform) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RotateTransform) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RotateTransform) },
        { },
    };

    static PyType_Spec type_spec_RotateTransform =
    {
        "winrt._winrt_microsoft_ui_xaml_media.RotateTransform",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::RotateTransform),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RotateTransform
    };

    static PyGetSetDef getset_RotateTransform_Static[] = {
        { "angle_property", reinterpret_cast<getter>(RotateTransform_get_AngleProperty), nullptr, nullptr, nullptr },
        { "center_x_property", reinterpret_cast<getter>(RotateTransform_get_CenterXProperty), nullptr, nullptr, nullptr },
        { "center_y_property", reinterpret_cast<getter>(RotateTransform_get_CenterYProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_RotateTransform_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RotateTransform_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RotateTransform_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RotateTransform_Static) },
        { }
    };

    static PyType_Spec type_spec_RotateTransform_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.RotateTransform_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RotateTransform_Static
    };

    // ----- ScaleTransform class --------------------

    static PyObject* _new_ScaleTransform(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::ScaleTransform instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ScaleTransform(py::wrapper::Microsoft::UI::Xaml::Media::ScaleTransform* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScaleTransform_get_ScaleY(py::wrapper::Microsoft::UI::Xaml::Media::ScaleTransform* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.ScaleTransform", L"ScaleY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ScaleY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScaleTransform_put_ScaleY(py::wrapper::Microsoft::UI::Xaml::Media::ScaleTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.ScaleTransform", L"ScaleY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.ScaleY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScaleTransform_get_ScaleX(py::wrapper::Microsoft::UI::Xaml::Media::ScaleTransform* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.ScaleTransform", L"ScaleX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ScaleX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScaleTransform_put_ScaleX(py::wrapper::Microsoft::UI::Xaml::Media::ScaleTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.ScaleTransform", L"ScaleX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.ScaleX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScaleTransform_get_CenterY(py::wrapper::Microsoft::UI::Xaml::Media::ScaleTransform* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.ScaleTransform", L"CenterY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CenterY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScaleTransform_put_CenterY(py::wrapper::Microsoft::UI::Xaml::Media::ScaleTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.ScaleTransform", L"CenterY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.CenterY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScaleTransform_get_CenterX(py::wrapper::Microsoft::UI::Xaml::Media::ScaleTransform* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.ScaleTransform", L"CenterX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CenterX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ScaleTransform_put_CenterX(py::wrapper::Microsoft::UI::Xaml::Media::ScaleTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.ScaleTransform", L"CenterX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.CenterX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ScaleTransform_get_CenterXProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.ScaleTransform", L"CenterXProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::ScaleTransform::CenterXProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScaleTransform_get_CenterYProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.ScaleTransform", L"CenterYProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::ScaleTransform::CenterYProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScaleTransform_get_ScaleXProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.ScaleTransform", L"ScaleXProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::ScaleTransform::ScaleXProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScaleTransform_get_ScaleYProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.ScaleTransform", L"ScaleYProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::ScaleTransform::ScaleYProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ScaleTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::ScaleTransform>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScaleTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::ScaleTransform>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScaleTransform[] = {
        { "_assign_array_", _assign_array_ScaleTransform, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScaleTransform), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScaleTransform[] = {
        { "scale_y", reinterpret_cast<getter>(ScaleTransform_get_ScaleY), reinterpret_cast<setter>(ScaleTransform_put_ScaleY), nullptr, nullptr },
        { "scale_x", reinterpret_cast<getter>(ScaleTransform_get_ScaleX), reinterpret_cast<setter>(ScaleTransform_put_ScaleX), nullptr, nullptr },
        { "center_y", reinterpret_cast<getter>(ScaleTransform_get_CenterY), reinterpret_cast<setter>(ScaleTransform_put_CenterY), nullptr, nullptr },
        { "center_x", reinterpret_cast<getter>(ScaleTransform_get_CenterX), reinterpret_cast<setter>(ScaleTransform_put_CenterX), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ScaleTransform[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScaleTransform) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScaleTransform) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScaleTransform) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScaleTransform) },
        { },
    };

    static PyType_Spec type_spec_ScaleTransform =
    {
        "winrt._winrt_microsoft_ui_xaml_media.ScaleTransform",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::ScaleTransform),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScaleTransform
    };

    static PyGetSetDef getset_ScaleTransform_Static[] = {
        { "center_x_property", reinterpret_cast<getter>(ScaleTransform_get_CenterXProperty), nullptr, nullptr, nullptr },
        { "center_y_property", reinterpret_cast<getter>(ScaleTransform_get_CenterYProperty), nullptr, nullptr, nullptr },
        { "scale_x_property", reinterpret_cast<getter>(ScaleTransform_get_ScaleXProperty), nullptr, nullptr, nullptr },
        { "scale_y_property", reinterpret_cast<getter>(ScaleTransform_get_ScaleYProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ScaleTransform_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ScaleTransform_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ScaleTransform_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ScaleTransform_Static) },
        { }
    };

    static PyType_Spec type_spec_ScaleTransform_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.ScaleTransform_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ScaleTransform_Static
    };

    // ----- Shadow class --------------------

    static PyObject* _new_Shadow(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Media::Shadow>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Media::Shadow>::type_name);
        return nullptr;
    }

    static void _dealloc_Shadow(py::wrapper::Microsoft::UI::Xaml::Media::Shadow* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Shadow(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::Shadow>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Shadow(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::Shadow>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Shadow[] = {
        { "_assign_array_", _assign_array_Shadow, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Shadow), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Shadow[] = {
        { }
    };

    static PyType_Slot _type_slots_Shadow[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Shadow) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Shadow) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Shadow) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Shadow) },
        { },
    };

    static PyType_Spec type_spec_Shadow =
    {
        "winrt._winrt_microsoft_ui_xaml_media.Shadow",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::Shadow),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Shadow
    };

    // ----- SkewTransform class --------------------

    static PyObject* _new_SkewTransform(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::SkewTransform instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SkewTransform(py::wrapper::Microsoft::UI::Xaml::Media::SkewTransform* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SkewTransform_get_CenterY(py::wrapper::Microsoft::UI::Xaml::Media::SkewTransform* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.SkewTransform", L"CenterY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CenterY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SkewTransform_put_CenterY(py::wrapper::Microsoft::UI::Xaml::Media::SkewTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.SkewTransform", L"CenterY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.CenterY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SkewTransform_get_CenterX(py::wrapper::Microsoft::UI::Xaml::Media::SkewTransform* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.SkewTransform", L"CenterX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CenterX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SkewTransform_put_CenterX(py::wrapper::Microsoft::UI::Xaml::Media::SkewTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.SkewTransform", L"CenterX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.CenterX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SkewTransform_get_AngleY(py::wrapper::Microsoft::UI::Xaml::Media::SkewTransform* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.SkewTransform", L"AngleY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AngleY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SkewTransform_put_AngleY(py::wrapper::Microsoft::UI::Xaml::Media::SkewTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.SkewTransform", L"AngleY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.AngleY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SkewTransform_get_AngleX(py::wrapper::Microsoft::UI::Xaml::Media::SkewTransform* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.SkewTransform", L"AngleX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AngleX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SkewTransform_put_AngleX(py::wrapper::Microsoft::UI::Xaml::Media::SkewTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.SkewTransform", L"AngleX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.AngleX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SkewTransform_get_AngleXProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.SkewTransform", L"AngleXProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::SkewTransform::AngleXProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SkewTransform_get_AngleYProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.SkewTransform", L"AngleYProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::SkewTransform::AngleYProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SkewTransform_get_CenterXProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.SkewTransform", L"CenterXProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::SkewTransform::CenterXProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SkewTransform_get_CenterYProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.SkewTransform", L"CenterYProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::SkewTransform::CenterYProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SkewTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::SkewTransform>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SkewTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::SkewTransform>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SkewTransform[] = {
        { "_assign_array_", _assign_array_SkewTransform, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SkewTransform), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SkewTransform[] = {
        { "center_y", reinterpret_cast<getter>(SkewTransform_get_CenterY), reinterpret_cast<setter>(SkewTransform_put_CenterY), nullptr, nullptr },
        { "center_x", reinterpret_cast<getter>(SkewTransform_get_CenterX), reinterpret_cast<setter>(SkewTransform_put_CenterX), nullptr, nullptr },
        { "angle_y", reinterpret_cast<getter>(SkewTransform_get_AngleY), reinterpret_cast<setter>(SkewTransform_put_AngleY), nullptr, nullptr },
        { "angle_x", reinterpret_cast<getter>(SkewTransform_get_AngleX), reinterpret_cast<setter>(SkewTransform_put_AngleX), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SkewTransform[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SkewTransform) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SkewTransform) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SkewTransform) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SkewTransform) },
        { },
    };

    static PyType_Spec type_spec_SkewTransform =
    {
        "winrt._winrt_microsoft_ui_xaml_media.SkewTransform",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::SkewTransform),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SkewTransform
    };

    static PyGetSetDef getset_SkewTransform_Static[] = {
        { "angle_x_property", reinterpret_cast<getter>(SkewTransform_get_AngleXProperty), nullptr, nullptr, nullptr },
        { "angle_y_property", reinterpret_cast<getter>(SkewTransform_get_AngleYProperty), nullptr, nullptr, nullptr },
        { "center_x_property", reinterpret_cast<getter>(SkewTransform_get_CenterXProperty), nullptr, nullptr, nullptr },
        { "center_y_property", reinterpret_cast<getter>(SkewTransform_get_CenterYProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_SkewTransform_Static[] = {
        { }
    };

    static PyType_Slot type_slots_SkewTransform_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SkewTransform_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SkewTransform_Static) },
        { }
    };

    static PyType_Spec type_spec_SkewTransform_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.SkewTransform_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SkewTransform_Static
    };

    // ----- SolidColorBrush class --------------------

    static PyObject* _new_SolidColorBrush(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Color>(args, 0);

                winrt::Microsoft::UI::Xaml::Media::SolidColorBrush instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::SolidColorBrush instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SolidColorBrush(py::wrapper::Microsoft::UI::Xaml::Media::SolidColorBrush* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SolidColorBrush_get_Color(py::wrapper::Microsoft::UI::Xaml::Media::SolidColorBrush* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.SolidColorBrush", L"Color"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Color());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SolidColorBrush_put_Color(py::wrapper::Microsoft::UI::Xaml::Media::SolidColorBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.SolidColorBrush", L"Color"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Color(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SolidColorBrush_get_ColorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.SolidColorBrush", L"ColorProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::SolidColorBrush::ColorProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SolidColorBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::SolidColorBrush>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SolidColorBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::SolidColorBrush>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SolidColorBrush[] = {
        { "_assign_array_", _assign_array_SolidColorBrush, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SolidColorBrush), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SolidColorBrush[] = {
        { "color", reinterpret_cast<getter>(SolidColorBrush_get_Color), reinterpret_cast<setter>(SolidColorBrush_put_Color), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SolidColorBrush[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SolidColorBrush) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SolidColorBrush) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SolidColorBrush) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SolidColorBrush) },
        { },
    };

    static PyType_Spec type_spec_SolidColorBrush =
    {
        "winrt._winrt_microsoft_ui_xaml_media.SolidColorBrush",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::SolidColorBrush),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SolidColorBrush
    };

    static PyGetSetDef getset_SolidColorBrush_Static[] = {
        { "color_property", reinterpret_cast<getter>(SolidColorBrush_get_ColorProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_SolidColorBrush_Static[] = {
        { }
    };

    static PyType_Slot type_slots_SolidColorBrush_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SolidColorBrush_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SolidColorBrush_Static) },
        { }
    };

    static PyType_Spec type_spec_SolidColorBrush_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.SolidColorBrush_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SolidColorBrush_Static
    };

    // ----- SystemBackdrop class --------------------

    static PyObject* _new_SystemBackdrop(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Media::SystemBackdrop>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Media::SystemBackdrop>::type_name);
        return nullptr;
    }

    static void _dealloc_SystemBackdrop(py::wrapper::Microsoft::UI::Xaml::Media::SystemBackdrop* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemBackdrop_GetDefaultSystemBackdropConfiguration(py::wrapper::Microsoft::UI::Xaml::Media::SystemBackdrop* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.SystemBackdrop", L"GetDefaultSystemBackdropConfiguration", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::ICompositionSupportsSystemBackdrop>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::XamlRoot>(args, 1);

                return py::convert(self->obj.GetDefaultSystemBackdropConfiguration(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SystemBackdrop_OnDefaultSystemBackdropConfigurationChanged(py::wrapper::Microsoft::UI::Xaml::Media::SystemBackdrop* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.SystemBackdrop", L"OnDefaultSystemBackdropConfigurationChanged", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::ICompositionSupportsSystemBackdrop>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::XamlRoot>(args, 1);

                self->obj.OnDefaultSystemBackdropConfigurationChanged(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SystemBackdrop_OnTargetConnected(py::wrapper::Microsoft::UI::Xaml::Media::SystemBackdrop* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.SystemBackdrop", L"OnTargetConnected", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::ICompositionSupportsSystemBackdrop>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::XamlRoot>(args, 1);

                self->obj.OnTargetConnected(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SystemBackdrop_OnTargetDisconnected(py::wrapper::Microsoft::UI::Xaml::Media::SystemBackdrop* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.SystemBackdrop", L"OnTargetDisconnected", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::ICompositionSupportsSystemBackdrop>(args, 0);

                self->obj.OnTargetDisconnected(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemBackdrop(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::SystemBackdrop>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemBackdrop(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::SystemBackdrop>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemBackdrop[] = {
        { "get_default_system_backdrop_configuration", reinterpret_cast<PyCFunction>(SystemBackdrop_GetDefaultSystemBackdropConfiguration), METH_VARARGS, nullptr },
        { "on_default_system_backdrop_configuration_changed", reinterpret_cast<PyCFunction>(SystemBackdrop_OnDefaultSystemBackdropConfigurationChanged), METH_VARARGS, nullptr },
        { "on_target_connected", reinterpret_cast<PyCFunction>(SystemBackdrop_OnTargetConnected), METH_VARARGS, nullptr },
        { "on_target_disconnected", reinterpret_cast<PyCFunction>(SystemBackdrop_OnTargetDisconnected), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SystemBackdrop, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemBackdrop), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemBackdrop[] = {
        { }
    };

    static PyType_Slot _type_slots_SystemBackdrop[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemBackdrop) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemBackdrop) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemBackdrop) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemBackdrop) },
        { },
    };

    static PyType_Spec type_spec_SystemBackdrop =
    {
        "winrt._winrt_microsoft_ui_xaml_media.SystemBackdrop",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::SystemBackdrop),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemBackdrop
    };

    // ----- ThemeShadow class --------------------

    static PyObject* _new_ThemeShadow(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::ThemeShadow instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ThemeShadow(py::wrapper::Microsoft::UI::Xaml::Media::ThemeShadow* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ThemeShadow_get_Receivers(py::wrapper::Microsoft::UI::Xaml::Media::ThemeShadow* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.ThemeShadow", L"Receivers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Receivers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ThemeShadow(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::ThemeShadow>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ThemeShadow(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::ThemeShadow>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ThemeShadow[] = {
        { "_assign_array_", _assign_array_ThemeShadow, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ThemeShadow), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ThemeShadow[] = {
        { "receivers", reinterpret_cast<getter>(ThemeShadow_get_Receivers), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ThemeShadow[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ThemeShadow) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ThemeShadow) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ThemeShadow) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ThemeShadow) },
        { },
    };

    static PyType_Spec type_spec_ThemeShadow =
    {
        "winrt._winrt_microsoft_ui_xaml_media.ThemeShadow",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::ThemeShadow),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ThemeShadow
    };

    // ----- TileBrush class --------------------

    static PyObject* _new_TileBrush(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Media::TileBrush>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Media::TileBrush>::type_name);
        return nullptr;
    }

    static void _dealloc_TileBrush(py::wrapper::Microsoft::UI::Xaml::Media::TileBrush* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TileBrush_get_Stretch(py::wrapper::Microsoft::UI::Xaml::Media::TileBrush* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.TileBrush", L"Stretch"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Stretch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TileBrush_put_Stretch(py::wrapper::Microsoft::UI::Xaml::Media::TileBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.TileBrush", L"Stretch"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Stretch>(arg);

            self->obj.Stretch(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TileBrush_get_AlignmentY(py::wrapper::Microsoft::UI::Xaml::Media::TileBrush* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.TileBrush", L"AlignmentY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AlignmentY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TileBrush_put_AlignmentY(py::wrapper::Microsoft::UI::Xaml::Media::TileBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.TileBrush", L"AlignmentY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::AlignmentY>(arg);

            self->obj.AlignmentY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TileBrush_get_AlignmentX(py::wrapper::Microsoft::UI::Xaml::Media::TileBrush* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.TileBrush", L"AlignmentX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AlignmentX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TileBrush_put_AlignmentX(py::wrapper::Microsoft::UI::Xaml::Media::TileBrush* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.TileBrush", L"AlignmentX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::AlignmentX>(arg);

            self->obj.AlignmentX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TileBrush_get_AlignmentXProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.TileBrush", L"AlignmentXProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::TileBrush::AlignmentXProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TileBrush_get_AlignmentYProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.TileBrush", L"AlignmentYProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::TileBrush::AlignmentYProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TileBrush_get_StretchProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.TileBrush", L"StretchProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::TileBrush::StretchProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TileBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::TileBrush>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TileBrush(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::TileBrush>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TileBrush[] = {
        { "_assign_array_", _assign_array_TileBrush, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TileBrush), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TileBrush[] = {
        { "stretch", reinterpret_cast<getter>(TileBrush_get_Stretch), reinterpret_cast<setter>(TileBrush_put_Stretch), nullptr, nullptr },
        { "alignment_y", reinterpret_cast<getter>(TileBrush_get_AlignmentY), reinterpret_cast<setter>(TileBrush_put_AlignmentY), nullptr, nullptr },
        { "alignment_x", reinterpret_cast<getter>(TileBrush_get_AlignmentX), reinterpret_cast<setter>(TileBrush_put_AlignmentX), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TileBrush[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TileBrush) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TileBrush) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TileBrush) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TileBrush) },
        { },
    };

    static PyType_Spec type_spec_TileBrush =
    {
        "winrt._winrt_microsoft_ui_xaml_media.TileBrush",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::TileBrush),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TileBrush
    };

    static PyGetSetDef getset_TileBrush_Static[] = {
        { "alignment_x_property", reinterpret_cast<getter>(TileBrush_get_AlignmentXProperty), nullptr, nullptr, nullptr },
        { "alignment_y_property", reinterpret_cast<getter>(TileBrush_get_AlignmentYProperty), nullptr, nullptr, nullptr },
        { "stretch_property", reinterpret_cast<getter>(TileBrush_get_StretchProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_TileBrush_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TileBrush_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TileBrush_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TileBrush_Static) },
        { }
    };

    static PyType_Spec type_spec_TileBrush_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.TileBrush_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TileBrush_Static
    };

    // ----- Transform class --------------------

    static PyObject* _new_Transform(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Media::Transform>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Media::Transform>::type_name);
        return nullptr;
    }

    static void _dealloc_Transform(py::wrapper::Microsoft::UI::Xaml::Media::Transform* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Transform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::Transform>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Transform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::Transform>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Transform[] = {
        { "_assign_array_", _assign_array_Transform, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Transform), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Transform[] = {
        { }
    };

    static PyType_Slot _type_slots_Transform[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Transform) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Transform) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Transform) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Transform) },
        { },
    };

    static PyType_Spec type_spec_Transform =
    {
        "winrt._winrt_microsoft_ui_xaml_media.Transform",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::Transform),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Transform
    };

    // ----- TransformCollection class --------------------

    static PyObject* _new_TransformCollection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::TransformCollection instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TransformCollection(py::wrapper::Microsoft::UI::Xaml::Media::TransformCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TransformCollection_Append(py::wrapper::Microsoft::UI::Xaml::Media::TransformCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.TransformCollection", L"Append", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Transform>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TransformCollection_Clear(py::wrapper::Microsoft::UI::Xaml::Media::TransformCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.TransformCollection", L"Clear", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TransformCollection_First(py::wrapper::Microsoft::UI::Xaml::Media::TransformCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.TransformCollection", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TransformCollection_GetAt(py::wrapper::Microsoft::UI::Xaml::Media::TransformCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.TransformCollection", L"GetAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TransformCollection_GetMany(py::wrapper::Microsoft::UI::Xaml::Media::TransformCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.TransformCollection", L"GetMany", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Microsoft::UI::Xaml::Media::Transform, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TransformCollection_GetView(py::wrapper::Microsoft::UI::Xaml::Media::TransformCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.TransformCollection", L"GetView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TransformCollection_IndexOf(py::wrapper::Microsoft::UI::Xaml::Media::TransformCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.TransformCollection", L"IndexOf", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Transform>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TransformCollection_InsertAt(py::wrapper::Microsoft::UI::Xaml::Media::TransformCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.TransformCollection", L"InsertAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Transform>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TransformCollection_RemoveAt(py::wrapper::Microsoft::UI::Xaml::Media::TransformCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.TransformCollection", L"RemoveAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TransformCollection_RemoveAtEnd(py::wrapper::Microsoft::UI::Xaml::Media::TransformCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.TransformCollection", L"RemoveAtEnd", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TransformCollection_ReplaceAll(py::wrapper::Microsoft::UI::Xaml::Media::TransformCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.TransformCollection", L"ReplaceAll", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Microsoft::UI::Xaml::Media::Transform, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TransformCollection_SetAt(py::wrapper::Microsoft::UI::Xaml::Media::TransformCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.TransformCollection", L"SetAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Transform>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TransformCollection_get_Size(py::wrapper::Microsoft::UI::Xaml::Media::TransformCollection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.TransformCollection", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TransformCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::TransformCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TransformCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::TransformCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_TransformCollection(py::wrapper::Microsoft::UI::Xaml::Media::TransformCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_TransformCollection(py::wrapper::Microsoft::UI::Xaml::Media::TransformCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_TransformCollection(py::wrapper::Microsoft::UI::Xaml::Media::TransformCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_TransformCollection(py::wrapper::Microsoft::UI::Xaml::Media::TransformCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_TransformCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(
                    PyExc_NotImplementedError,
                    "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Microsoft::UI::Xaml::Media::Transform> items(static_cast<uint32_t>(length), empty_instance<winrt::Microsoft::UI::Xaml::Media::Transform>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(
                    PyExc_RuntimeError,
                    "returned count %d did not match requested length %zd",
                    count,
                    length);
                return nullptr;
            }

            return convert(items);}
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_TransformCollection(py::wrapper::Microsoft::UI::Xaml::Media::TransformCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Microsoft::UI::Xaml::Media::Transform>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_TransformCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(TransformCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(TransformCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(TransformCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(TransformCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(TransformCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(TransformCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(TransformCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(TransformCollection_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(TransformCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(TransformCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(TransformCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(TransformCollection_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TransformCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TransformCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TransformCollection[] = {
        { "size", reinterpret_cast<getter>(TransformCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TransformCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TransformCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TransformCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TransformCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TransformCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_TransformCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_TransformCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_TransformCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_TransformCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_TransformCollection) },
        { },
    };

    static PyType_Spec type_spec_TransformCollection =
    {
        "winrt._winrt_microsoft_ui_xaml_media.TransformCollection",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::TransformCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TransformCollection
    };

    // ----- TransformGroup class --------------------

    static PyObject* _new_TransformGroup(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::TransformGroup instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TransformGroup(py::wrapper::Microsoft::UI::Xaml::Media::TransformGroup* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TransformGroup_get_Children(py::wrapper::Microsoft::UI::Xaml::Media::TransformGroup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.TransformGroup", L"Children"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Children());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TransformGroup_put_Children(py::wrapper::Microsoft::UI::Xaml::Media::TransformGroup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.TransformGroup", L"Children"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::TransformCollection>(arg);

            self->obj.Children(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TransformGroup_get_Value(py::wrapper::Microsoft::UI::Xaml::Media::TransformGroup* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.TransformGroup", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TransformGroup_get_ChildrenProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.TransformGroup", L"ChildrenProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::TransformGroup::ChildrenProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TransformGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::TransformGroup>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TransformGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::TransformGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TransformGroup[] = {
        { "_assign_array_", _assign_array_TransformGroup, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TransformGroup), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TransformGroup[] = {
        { "children", reinterpret_cast<getter>(TransformGroup_get_Children), reinterpret_cast<setter>(TransformGroup_put_Children), nullptr, nullptr },
        { "value", reinterpret_cast<getter>(TransformGroup_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TransformGroup[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TransformGroup) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TransformGroup) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TransformGroup) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TransformGroup) },
        { },
    };

    static PyType_Spec type_spec_TransformGroup =
    {
        "winrt._winrt_microsoft_ui_xaml_media.TransformGroup",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::TransformGroup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TransformGroup
    };

    static PyGetSetDef getset_TransformGroup_Static[] = {
        { "children_property", reinterpret_cast<getter>(TransformGroup_get_ChildrenProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_TransformGroup_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TransformGroup_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TransformGroup_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TransformGroup_Static) },
        { }
    };

    static PyType_Spec type_spec_TransformGroup_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.TransformGroup_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TransformGroup_Static
    };

    // ----- TranslateTransform class --------------------

    static PyObject* _new_TranslateTransform(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::TranslateTransform instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TranslateTransform(py::wrapper::Microsoft::UI::Xaml::Media::TranslateTransform* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TranslateTransform_get_Y(py::wrapper::Microsoft::UI::Xaml::Media::TranslateTransform* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.TranslateTransform", L"Y"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Y());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TranslateTransform_put_Y(py::wrapper::Microsoft::UI::Xaml::Media::TranslateTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.TranslateTransform", L"Y"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Y(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TranslateTransform_get_X(py::wrapper::Microsoft::UI::Xaml::Media::TranslateTransform* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.TranslateTransform", L"X"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.X());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TranslateTransform_put_X(py::wrapper::Microsoft::UI::Xaml::Media::TranslateTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.TranslateTransform", L"X"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.X(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TranslateTransform_get_XProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.TranslateTransform", L"XProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::TranslateTransform::XProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TranslateTransform_get_YProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.TranslateTransform", L"YProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::TranslateTransform::YProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TranslateTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::TranslateTransform>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TranslateTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::TranslateTransform>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TranslateTransform[] = {
        { "_assign_array_", _assign_array_TranslateTransform, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TranslateTransform), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TranslateTransform[] = {
        { "y", reinterpret_cast<getter>(TranslateTransform_get_Y), reinterpret_cast<setter>(TranslateTransform_put_Y), nullptr, nullptr },
        { "x", reinterpret_cast<getter>(TranslateTransform_get_X), reinterpret_cast<setter>(TranslateTransform_put_X), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TranslateTransform[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TranslateTransform) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TranslateTransform) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TranslateTransform) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TranslateTransform) },
        { },
    };

    static PyType_Spec type_spec_TranslateTransform =
    {
        "winrt._winrt_microsoft_ui_xaml_media.TranslateTransform",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::TranslateTransform),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TranslateTransform
    };

    static PyGetSetDef getset_TranslateTransform_Static[] = {
        { "x_property", reinterpret_cast<getter>(TranslateTransform_get_XProperty), nullptr, nullptr, nullptr },
        { "y_property", reinterpret_cast<getter>(TranslateTransform_get_YProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_TranslateTransform_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TranslateTransform_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TranslateTransform_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TranslateTransform_Static) },
        { }
    };

    static PyType_Spec type_spec_TranslateTransform_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.TranslateTransform_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TranslateTransform_Static
    };

    // ----- VisualTreeHelper class --------------------

    static PyObject* _new_VisualTreeHelper(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Media::VisualTreeHelper>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Media::VisualTreeHelper>::type_name);
        return nullptr;
    }

    static void _dealloc_VisualTreeHelper(py::wrapper::Microsoft::UI::Xaml::Media::VisualTreeHelper* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VisualTreeHelper_DisconnectChildrenRecursive(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.VisualTreeHelper", L"DisconnectChildrenRecursive", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 0);

                winrt::Microsoft::UI::Xaml::Media::VisualTreeHelper::DisconnectChildrenRecursive(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualTreeHelper_FindElementsInHostCoordinates(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.VisualTreeHelper", L"FindElementsInHostCoordinates", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 1);

                return py::convert(winrt::Microsoft::UI::Xaml::Media::VisualTreeHelper::FindElementsInHostCoordinates(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.VisualTreeHelper", L"FindElementsInHostCoordinates", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                return py::convert(winrt::Microsoft::UI::Xaml::Media::VisualTreeHelper::FindElementsInHostCoordinates(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualTreeHelper_GetChild(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.VisualTreeHelper", L"GetChild", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(winrt::Microsoft::UI::Xaml::Media::VisualTreeHelper::GetChild(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualTreeHelper_GetChildrenCount(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.VisualTreeHelper", L"GetChildrenCount", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Media::VisualTreeHelper::GetChildrenCount(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualTreeHelper_GetOpenPopups(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.VisualTreeHelper", L"GetOpenPopups", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Window>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Media::VisualTreeHelper::GetOpenPopups(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualTreeHelper_GetOpenPopupsForXamlRoot(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.VisualTreeHelper", L"GetOpenPopupsForXamlRoot", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::XamlRoot>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Media::VisualTreeHelper::GetOpenPopupsForXamlRoot(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VisualTreeHelper_GetParent(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.VisualTreeHelper", L"GetParent", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Media::VisualTreeHelper::GetParent(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_VisualTreeHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::VisualTreeHelper>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VisualTreeHelper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::VisualTreeHelper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VisualTreeHelper[] = {
        { "_assign_array_", _assign_array_VisualTreeHelper, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VisualTreeHelper), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VisualTreeHelper[] = {
        { }
    };

    static PyType_Slot _type_slots_VisualTreeHelper[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VisualTreeHelper) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VisualTreeHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VisualTreeHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VisualTreeHelper) },
        { },
    };

    static PyType_Spec type_spec_VisualTreeHelper =
    {
        "winrt._winrt_microsoft_ui_xaml_media.VisualTreeHelper",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::VisualTreeHelper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VisualTreeHelper
    };

    static PyGetSetDef getset_VisualTreeHelper_Static[] = {
        { }
    };

    static PyMethodDef methods_VisualTreeHelper_Static[] = {
        { "disconnect_children_recursive", reinterpret_cast<PyCFunction>(VisualTreeHelper_DisconnectChildrenRecursive), METH_VARARGS, nullptr },
        { "find_elements_in_host_coordinates", reinterpret_cast<PyCFunction>(VisualTreeHelper_FindElementsInHostCoordinates), METH_VARARGS, nullptr },
        { "get_child", reinterpret_cast<PyCFunction>(VisualTreeHelper_GetChild), METH_VARARGS, nullptr },
        { "get_children_count", reinterpret_cast<PyCFunction>(VisualTreeHelper_GetChildrenCount), METH_VARARGS, nullptr },
        { "get_open_popups", reinterpret_cast<PyCFunction>(VisualTreeHelper_GetOpenPopups), METH_VARARGS, nullptr },
        { "get_open_popups_for_xaml_root", reinterpret_cast<PyCFunction>(VisualTreeHelper_GetOpenPopupsForXamlRoot), METH_VARARGS, nullptr },
        { "get_parent", reinterpret_cast<PyCFunction>(VisualTreeHelper_GetParent), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_VisualTreeHelper_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_VisualTreeHelper_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_VisualTreeHelper_Static) },
        { }
    };

    static PyType_Spec type_spec_VisualTreeHelper_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.VisualTreeHelper_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_VisualTreeHelper_Static
    };

    // ----- XamlCompositionBrushBase class --------------------

    static PyObject* _new_XamlCompositionBrushBase(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Media::XamlCompositionBrushBase>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Media::XamlCompositionBrushBase>::type_name);
        return nullptr;
    }

    static void _dealloc_XamlCompositionBrushBase(py::wrapper::Microsoft::UI::Xaml::Media::XamlCompositionBrushBase* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* XamlCompositionBrushBase_OnConnected(py::wrapper::Microsoft::UI::Xaml::Media::XamlCompositionBrushBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.XamlCompositionBrushBase", L"OnConnected", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.OnConnected();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlCompositionBrushBase_OnDisconnected(py::wrapper::Microsoft::UI::Xaml::Media::XamlCompositionBrushBase* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.XamlCompositionBrushBase", L"OnDisconnected", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.OnDisconnected();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlCompositionBrushBase_get_FallbackColor(py::wrapper::Microsoft::UI::Xaml::Media::XamlCompositionBrushBase* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.XamlCompositionBrushBase", L"FallbackColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FallbackColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int XamlCompositionBrushBase_put_FallbackColor(py::wrapper::Microsoft::UI::Xaml::Media::XamlCompositionBrushBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.XamlCompositionBrushBase", L"FallbackColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.FallbackColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* XamlCompositionBrushBase_get_CompositionBrush(py::wrapper::Microsoft::UI::Xaml::Media::XamlCompositionBrushBase* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.XamlCompositionBrushBase", L"CompositionBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CompositionBrush());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int XamlCompositionBrushBase_put_CompositionBrush(py::wrapper::Microsoft::UI::Xaml::Media::XamlCompositionBrushBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.XamlCompositionBrushBase", L"CompositionBrush"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionBrush>(arg);

            self->obj.CompositionBrush(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* XamlCompositionBrushBase_get_FallbackColorProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.XamlCompositionBrushBase", L"FallbackColorProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Media::XamlCompositionBrushBase::FallbackColorProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_XamlCompositionBrushBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::XamlCompositionBrushBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XamlCompositionBrushBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::XamlCompositionBrushBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XamlCompositionBrushBase[] = {
        { "on_connected", reinterpret_cast<PyCFunction>(XamlCompositionBrushBase_OnConnected), METH_VARARGS, nullptr },
        { "on_disconnected", reinterpret_cast<PyCFunction>(XamlCompositionBrushBase_OnDisconnected), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_XamlCompositionBrushBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XamlCompositionBrushBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_XamlCompositionBrushBase[] = {
        { "fallback_color", reinterpret_cast<getter>(XamlCompositionBrushBase_get_FallbackColor), reinterpret_cast<setter>(XamlCompositionBrushBase_put_FallbackColor), nullptr, nullptr },
        { "composition_brush", reinterpret_cast<getter>(XamlCompositionBrushBase_get_CompositionBrush), reinterpret_cast<setter>(XamlCompositionBrushBase_put_CompositionBrush), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_XamlCompositionBrushBase[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_XamlCompositionBrushBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XamlCompositionBrushBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XamlCompositionBrushBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XamlCompositionBrushBase) },
        { },
    };

    static PyType_Spec type_spec_XamlCompositionBrushBase =
    {
        "winrt._winrt_microsoft_ui_xaml_media.XamlCompositionBrushBase",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::XamlCompositionBrushBase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XamlCompositionBrushBase
    };

    static PyGetSetDef getset_XamlCompositionBrushBase_Static[] = {
        { "fallback_color_property", reinterpret_cast<getter>(XamlCompositionBrushBase_get_FallbackColorProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_XamlCompositionBrushBase_Static[] = {
        { }
    };

    static PyType_Slot type_slots_XamlCompositionBrushBase_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_XamlCompositionBrushBase_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_XamlCompositionBrushBase_Static) },
        { }
    };

    static PyType_Spec type_spec_XamlCompositionBrushBase_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.XamlCompositionBrushBase_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_XamlCompositionBrushBase_Static
    };

    // ----- XamlLight class --------------------

    static PyObject* _new_XamlLight(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::XamlLight instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_XamlLight(py::wrapper::Microsoft::UI::Xaml::Media::XamlLight* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* XamlLight_AddTargetBrush(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.XamlLight", L"AddTargetBrush", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(args, 1);

                winrt::Microsoft::UI::Xaml::Media::XamlLight::AddTargetBrush(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlLight_AddTargetElement(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.XamlLight", L"AddTargetElement", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 1);

                winrt::Microsoft::UI::Xaml::Media::XamlLight::AddTargetElement(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlLight_GetId(py::wrapper::Microsoft::UI::Xaml::Media::XamlLight* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.XamlLight", L"GetId", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetId());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlLight_OnConnected(py::wrapper::Microsoft::UI::Xaml::Media::XamlLight* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.XamlLight", L"OnConnected", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 0);

                self->obj.OnConnected(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlLight_OnDisconnected(py::wrapper::Microsoft::UI::Xaml::Media::XamlLight* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.XamlLight", L"OnDisconnected", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 0);

                self->obj.OnDisconnected(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlLight_RemoveTargetBrush(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.XamlLight", L"RemoveTargetBrush", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(args, 1);

                winrt::Microsoft::UI::Xaml::Media::XamlLight::RemoveTargetBrush(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlLight_RemoveTargetElement(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.XamlLight", L"RemoveTargetElement", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 1);

                winrt::Microsoft::UI::Xaml::Media::XamlLight::RemoveTargetElement(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XamlLight_get_CompositionLight(py::wrapper::Microsoft::UI::Xaml::Media::XamlLight* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.XamlLight", L"CompositionLight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CompositionLight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int XamlLight_put_CompositionLight(py::wrapper::Microsoft::UI::Xaml::Media::XamlLight* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.XamlLight", L"CompositionLight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::CompositionLight>(arg);

            self->obj.CompositionLight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_XamlLight(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::XamlLight>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XamlLight(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::XamlLight>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XamlLight[] = {
        { "get_id", reinterpret_cast<PyCFunction>(XamlLight_GetId), METH_VARARGS, nullptr },
        { "on_connected", reinterpret_cast<PyCFunction>(XamlLight_OnConnected), METH_VARARGS, nullptr },
        { "on_disconnected", reinterpret_cast<PyCFunction>(XamlLight_OnDisconnected), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_XamlLight, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XamlLight), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_XamlLight[] = {
        { "composition_light", reinterpret_cast<getter>(XamlLight_get_CompositionLight), reinterpret_cast<setter>(XamlLight_put_CompositionLight), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_XamlLight[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_XamlLight) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XamlLight) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XamlLight) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XamlLight) },
        { },
    };

    static PyType_Spec type_spec_XamlLight =
    {
        "winrt._winrt_microsoft_ui_xaml_media.XamlLight",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::XamlLight),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XamlLight
    };

    static PyGetSetDef getset_XamlLight_Static[] = {
        { }
    };

    static PyMethodDef methods_XamlLight_Static[] = {
        { "add_target_brush", reinterpret_cast<PyCFunction>(XamlLight_AddTargetBrush), METH_VARARGS, nullptr },
        { "add_target_element", reinterpret_cast<PyCFunction>(XamlLight_AddTargetElement), METH_VARARGS, nullptr },
        { "remove_target_brush", reinterpret_cast<PyCFunction>(XamlLight_RemoveTargetBrush), METH_VARARGS, nullptr },
        { "remove_target_element", reinterpret_cast<PyCFunction>(XamlLight_RemoveTargetElement), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_XamlLight_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_XamlLight_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_XamlLight_Static) },
        { }
    };

    static PyType_Spec type_spec_XamlLight_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_media.XamlLight_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_XamlLight_Static
    };

    // ----- Matrix struct --------------------

    winrt_struct_wrapper<winrt::Microsoft::UI::Xaml::Media::Matrix>* _new_Matrix(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Microsoft::UI::Xaml::Media::Matrix>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_Matrix(winrt_struct_wrapper<winrt::Microsoft::UI::Xaml::Media::Matrix>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        double _M11{};
        double _M12{};
        double _M21{};
        double _M22{};
        double _OffsetX{};
        double _OffsetY{};

        static const char* kwlist[] = {"m11", "m12", "m21", "m22", "offset_x", "offset_y", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "dddddd", const_cast<char**>(kwlist), &_M11, &_M12, &_M21, &_M22, &_OffsetX, &_OffsetY))
        {
            return -1;
        }

        try
        {
            self->obj = {_M11, _M12, _M21, _M22, _OffsetX, _OffsetY};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_Matrix(py::wrapper::Microsoft::UI::Xaml::Media::Matrix* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Matrix(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::Matrix>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_Matrix[] = {
        { "_assign_array_", _assign_array_Matrix, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* Matrix_get_M11(py::wrapper::Microsoft::UI::Xaml::Media::Matrix* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.M11);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix_set_M11(py::wrapper::Microsoft::UI::Xaml::Media::Matrix* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.M11 = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix_get_M12(py::wrapper::Microsoft::UI::Xaml::Media::Matrix* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.M12);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix_set_M12(py::wrapper::Microsoft::UI::Xaml::Media::Matrix* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.M12 = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix_get_M21(py::wrapper::Microsoft::UI::Xaml::Media::Matrix* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.M21);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix_set_M21(py::wrapper::Microsoft::UI::Xaml::Media::Matrix* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.M21 = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix_get_M22(py::wrapper::Microsoft::UI::Xaml::Media::Matrix* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.M22);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix_set_M22(py::wrapper::Microsoft::UI::Xaml::Media::Matrix* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.M22 = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix_get_OffsetX(py::wrapper::Microsoft::UI::Xaml::Media::Matrix* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OffsetX);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix_set_OffsetX(py::wrapper::Microsoft::UI::Xaml::Media::Matrix* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.OffsetX = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Matrix_get_OffsetY(py::wrapper::Microsoft::UI::Xaml::Media::Matrix* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OffsetY);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Matrix_set_OffsetY(py::wrapper::Microsoft::UI::Xaml::Media::Matrix* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.OffsetY = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_Matrix[] = {
        { "m11", reinterpret_cast<getter>(Matrix_get_M11), reinterpret_cast<setter>(Matrix_set_M11), nullptr, nullptr },
        { "m12", reinterpret_cast<getter>(Matrix_get_M12), reinterpret_cast<setter>(Matrix_set_M12), nullptr, nullptr },
        { "m21", reinterpret_cast<getter>(Matrix_get_M21), reinterpret_cast<setter>(Matrix_set_M21), nullptr, nullptr },
        { "m22", reinterpret_cast<getter>(Matrix_get_M22), reinterpret_cast<setter>(Matrix_set_M22), nullptr, nullptr },
        { "offset_x", reinterpret_cast<getter>(Matrix_get_OffsetX), reinterpret_cast<setter>(Matrix_set_OffsetX), nullptr, nullptr },
        { "offset_y", reinterpret_cast<getter>(Matrix_get_OffsetY), reinterpret_cast<setter>(Matrix_set_OffsetY), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Matrix[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Matrix) },
        { Py_tp_init, reinterpret_cast<void*>(_init_Matrix) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Matrix) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Matrix) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Matrix) },
        { },
    };

    static PyType_Spec type_spec_Matrix =
    {
        "winrt._winrt_microsoft_ui_xaml_media.Matrix",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::Matrix),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Matrix
    };

    // ----- Microsoft.UI.Xaml.Media Initialization --------------------
    PyDoc_STRVAR(module_doc, "Microsoft::UI::Xaml::Media");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_microsoft_ui_xaml_media",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Microsoft::UI::Xaml::Media

PyMODINIT_FUNC PyInit__winrt_microsoft_ui_xaml_media(void) noexcept
{
    using namespace py::cpp::Microsoft::UI::Xaml::Media;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AcrylicBrush_Static{PyType_FromSpec(&type_spec_AcrylicBrush_Static)};
    if (!type_AcrylicBrush_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AcrylicBrush, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AcrylicBrush_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ArcSegment_Static{PyType_FromSpec(&type_spec_ArcSegment_Static)};
    if (!type_ArcSegment_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ArcSegment, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ArcSegment_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_BezierSegment_Static{PyType_FromSpec(&type_spec_BezierSegment_Static)};
    if (!type_BezierSegment_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BezierSegment, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BezierSegment_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BitmapCache, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_Brush_Static{PyType_FromSpec(&type_spec_Brush_Static)};
    if (!type_Brush_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Brush, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Brush_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BrushCollection, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CacheMode, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_CompositeTransform_Static{PyType_FromSpec(&type_spec_CompositeTransform_Static)};
    if (!type_CompositeTransform_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CompositeTransform, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CompositeTransform_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_CompositionTarget_Static{PyType_FromSpec(&type_spec_CompositionTarget_Static)};
    if (!type_CompositionTarget_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CompositionTarget, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CompositionTarget_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DesktopAcrylicBackdrop, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DoubleCollection, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_EllipseGeometry_Static{PyType_FromSpec(&type_spec_EllipseGeometry_Static)};
    if (!type_EllipseGeometry_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EllipseGeometry, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_EllipseGeometry_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_FontFamily_Static{PyType_FromSpec(&type_spec_FontFamily_Static)};
    if (!type_FontFamily_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_FontFamily, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_FontFamily_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GeneralTransform, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_Geometry_Static{PyType_FromSpec(&type_spec_Geometry_Static)};
    if (!type_Geometry_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Geometry, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Geometry_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GeometryCollection, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_GeometryGroup_Static{PyType_FromSpec(&type_spec_GeometryGroup_Static)};
    if (!type_GeometryGroup_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GeometryGroup, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GeometryGroup_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_GradientBrush_Static{PyType_FromSpec(&type_spec_GradientBrush_Static)};
    if (!type_GradientBrush_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GradientBrush, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GradientBrush_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_GradientStop_Static{PyType_FromSpec(&type_spec_GradientStop_Static)};
    if (!type_GradientStop_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GradientStop, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GradientStop_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_GradientStopCollection, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ImageBrush_Static{PyType_FromSpec(&type_spec_ImageBrush_Static)};
    if (!type_ImageBrush_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ImageBrush, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ImageBrush_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ImageSource, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_LineGeometry_Static{PyType_FromSpec(&type_spec_LineGeometry_Static)};
    if (!type_LineGeometry_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LineGeometry, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_LineGeometry_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_LineSegment_Static{PyType_FromSpec(&type_spec_LineSegment_Static)};
    if (!type_LineSegment_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LineSegment, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_LineSegment_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_LinearGradientBrush_Static{PyType_FromSpec(&type_spec_LinearGradientBrush_Static)};
    if (!type_LinearGradientBrush_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LinearGradientBrush, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_LinearGradientBrush_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LoadedImageSourceLoadCompletedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_LoadedImageSurface_Static{PyType_FromSpec(&type_spec_LoadedImageSurface_Static)};
    if (!type_LoadedImageSurface_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LoadedImageSurface, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_LoadedImageSurface_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_Matrix3DProjection_Static{PyType_FromSpec(&type_spec_Matrix3DProjection_Static)};
    if (!type_Matrix3DProjection_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Matrix3DProjection, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Matrix3DProjection_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MatrixHelper_Static{PyType_FromSpec(&type_spec_MatrixHelper_Static)};
    if (!type_MatrixHelper_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MatrixHelper, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MatrixHelper_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MatrixTransform_Static{PyType_FromSpec(&type_spec_MatrixTransform_Static)};
    if (!type_MatrixTransform_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MatrixTransform, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MatrixTransform_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaTransportControlsThumbnailRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MicaBackdrop_Static{PyType_FromSpec(&type_spec_MicaBackdrop_Static)};
    if (!type_MicaBackdrop_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MicaBackdrop, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MicaBackdrop_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_PathFigure_Static{PyType_FromSpec(&type_spec_PathFigure_Static)};
    if (!type_PathFigure_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PathFigure, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PathFigure_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PathFigureCollection, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_PathGeometry_Static{PyType_FromSpec(&type_spec_PathGeometry_Static)};
    if (!type_PathGeometry_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PathGeometry, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PathGeometry_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PathSegment, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PathSegmentCollection, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_PlaneProjection_Static{PyType_FromSpec(&type_spec_PlaneProjection_Static)};
    if (!type_PlaneProjection_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PlaneProjection, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PlaneProjection_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PointCollection, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_PolyBezierSegment_Static{PyType_FromSpec(&type_spec_PolyBezierSegment_Static)};
    if (!type_PolyBezierSegment_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PolyBezierSegment, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PolyBezierSegment_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_PolyLineSegment_Static{PyType_FromSpec(&type_spec_PolyLineSegment_Static)};
    if (!type_PolyLineSegment_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PolyLineSegment, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PolyLineSegment_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_PolyQuadraticBezierSegment_Static{PyType_FromSpec(&type_spec_PolyQuadraticBezierSegment_Static)};
    if (!type_PolyQuadraticBezierSegment_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PolyQuadraticBezierSegment, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PolyQuadraticBezierSegment_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Projection, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_QuadraticBezierSegment_Static{PyType_FromSpec(&type_spec_QuadraticBezierSegment_Static)};
    if (!type_QuadraticBezierSegment_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_QuadraticBezierSegment, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_QuadraticBezierSegment_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_RadialGradientBrush_Static{PyType_FromSpec(&type_spec_RadialGradientBrush_Static)};
    if (!type_RadialGradientBrush_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RadialGradientBrush, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RadialGradientBrush_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_RectangleGeometry_Static{PyType_FromSpec(&type_spec_RectangleGeometry_Static)};
    if (!type_RectangleGeometry_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RectangleGeometry, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RectangleGeometry_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RenderedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RenderingEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_RotateTransform_Static{PyType_FromSpec(&type_spec_RotateTransform_Static)};
    if (!type_RotateTransform_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RotateTransform, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RotateTransform_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ScaleTransform_Static{PyType_FromSpec(&type_spec_ScaleTransform_Static)};
    if (!type_ScaleTransform_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ScaleTransform, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ScaleTransform_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Shadow, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_SkewTransform_Static{PyType_FromSpec(&type_spec_SkewTransform_Static)};
    if (!type_SkewTransform_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SkewTransform, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SkewTransform_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_SolidColorBrush_Static{PyType_FromSpec(&type_spec_SolidColorBrush_Static)};
    if (!type_SolidColorBrush_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SolidColorBrush, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SolidColorBrush_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SystemBackdrop, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ThemeShadow, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_TileBrush_Static{PyType_FromSpec(&type_spec_TileBrush_Static)};
    if (!type_TileBrush_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TileBrush, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TileBrush_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Transform, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TransformCollection, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_TransformGroup_Static{PyType_FromSpec(&type_spec_TransformGroup_Static)};
    if (!type_TransformGroup_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TransformGroup, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TransformGroup_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_TranslateTransform_Static{PyType_FromSpec(&type_spec_TranslateTransform_Static)};
    if (!type_TranslateTransform_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TranslateTransform, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TranslateTransform_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_VisualTreeHelper_Static{PyType_FromSpec(&type_spec_VisualTreeHelper_Static)};
    if (!type_VisualTreeHelper_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VisualTreeHelper, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_VisualTreeHelper_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_XamlCompositionBrushBase_Static{PyType_FromSpec(&type_spec_XamlCompositionBrushBase_Static)};
    if (!type_XamlCompositionBrushBase_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_XamlCompositionBrushBase, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_XamlCompositionBrushBase_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_XamlLight_Static{PyType_FromSpec(&type_spec_XamlLight_Static)};
    if (!type_XamlLight_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_XamlLight, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_XamlLight_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Matrix, nullptr, nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
