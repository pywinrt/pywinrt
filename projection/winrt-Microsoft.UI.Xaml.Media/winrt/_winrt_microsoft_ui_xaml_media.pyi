# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.microsoft.ui.composition
import winrt.microsoft.ui.composition.systembackdrops
import winrt.microsoft.ui.xaml
import winrt.microsoft.ui.xaml.controls.primitives
import winrt.microsoft.ui.xaml.media.media3d
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.storage.streams
import winrt.windows.ui

from winrt.microsoft.ui.xaml.media import AlignmentX, AlignmentY, BrushMappingMode, ColorInterpolationMode, ElementCompositeMode, FastPlayFallbackBehaviour, FillRule, GradientSpreadMethod, LoadedImageSourceLoadStatus, PenLineCap, PenLineJoin, Stretch, StyleSimulations, SweepDirection

Self = typing.TypeVar('Self')

@typing.final
class Matrix:
    m11: winrt.system.Double
    m12: winrt.system.Double
    m21: winrt.system.Double
    m22: winrt.system.Double
    offset_x: winrt.system.Double
    offset_y: winrt.system.Double
    def __init__(self, m11: winrt.system.Double, m12: winrt.system.Double, m21: winrt.system.Double, m22: winrt.system.Double, offset_x: winrt.system.Double, offset_y: winrt.system.Double) -> None: ...

@typing.final
class AcrylicBrush_Static(type):
    @_property
    def always_use_fallback_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def tint_color_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def tint_opacity_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def tint_transition_duration_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def tint_luminosity_opacity_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...

@typing.final
class AcrylicBrush(winrt.system.Object, metaclass=AcrylicBrush_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AcrylicBrush: ...
    def __new__(cls: typing.Type[AcrylicBrush]) -> AcrylicBrush:...
    @_property
    def tint_transition_duration(self) -> datetime.timedelta: ...
    @tint_transition_duration.setter
    def tint_transition_duration(self, value: datetime.timedelta) -> None: ...
    @_property
    def tint_opacity(self) -> winrt.system.Double: ...
    @tint_opacity.setter
    def tint_opacity(self, value: winrt.system.Double) -> None: ...
    @_property
    def tint_color(self) -> winrt.windows.ui.Color: ...
    @tint_color.setter
    def tint_color(self, value: winrt.windows.ui.Color) -> None: ...
    @_property
    def always_use_fallback(self) -> bool: ...
    @always_use_fallback.setter
    def always_use_fallback(self, value: bool) -> None: ...
    @_property
    def tint_luminosity_opacity(self) -> typing.Optional[typing.Optional[winrt.system.Double]]: ...
    @tint_luminosity_opacity.setter
    def tint_luminosity_opacity(self, value: typing.Optional[typing.Optional[winrt.system.Double]]) -> None: ...

@typing.final
class ArcSegment_Static(type):
    @_property
    def is_large_arc_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def point_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def rotation_angle_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def size_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def sweep_direction_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...

@typing.final
class ArcSegment(winrt.system.Object, metaclass=ArcSegment_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ArcSegment: ...
    def __new__(cls: typing.Type[ArcSegment]) -> ArcSegment:...
    @_property
    def sweep_direction(self) -> SweepDirection: ...
    @sweep_direction.setter
    def sweep_direction(self, value: SweepDirection) -> None: ...
    @_property
    def size(self) -> winrt.windows.foundation.Size: ...
    @size.setter
    def size(self, value: winrt.windows.foundation.Size) -> None: ...
    @_property
    def rotation_angle(self) -> winrt.system.Double: ...
    @rotation_angle.setter
    def rotation_angle(self, value: winrt.system.Double) -> None: ...
    @_property
    def point(self) -> winrt.windows.foundation.Point: ...
    @point.setter
    def point(self, value: winrt.windows.foundation.Point) -> None: ...
    @_property
    def is_large_arc(self) -> bool: ...
    @is_large_arc.setter
    def is_large_arc(self, value: bool) -> None: ...

@typing.final
class BezierSegment_Static(type):
    @_property
    def point1_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def point2_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def point3_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...

@typing.final
class BezierSegment(winrt.system.Object, metaclass=BezierSegment_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BezierSegment: ...
    def __new__(cls: typing.Type[BezierSegment]) -> BezierSegment:...
    @_property
    def point3(self) -> winrt.windows.foundation.Point: ...
    @point3.setter
    def point3(self, value: winrt.windows.foundation.Point) -> None: ...
    @_property
    def point2(self) -> winrt.windows.foundation.Point: ...
    @point2.setter
    def point2(self, value: winrt.windows.foundation.Point) -> None: ...
    @_property
    def point1(self) -> winrt.windows.foundation.Point: ...
    @point1.setter
    def point1(self, value: winrt.windows.foundation.Point) -> None: ...

@typing.final
class BitmapCache(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BitmapCache: ...
    def __new__(cls: typing.Type[BitmapCache]) -> BitmapCache:...

@typing.final
class Brush_Static(type):
    @_property
    def opacity_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def relative_transform_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def transform_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...

@typing.final
class Brush(winrt.system.Object, metaclass=Brush_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Brush: ...
    def populate_property_info(self, property_name: str, property_info: typing.Optional[winrt.microsoft.ui.composition.AnimationPropertyInfo], /) -> None: ...
    def populate_property_info_override(self, property_name: str, animation_property_info: typing.Optional[winrt.microsoft.ui.composition.AnimationPropertyInfo], /) -> None: ...
    @_property
    def transform(self) -> typing.Optional[Transform]: ...
    @transform.setter
    def transform(self, value: typing.Optional[Transform]) -> None: ...
    @_property
    def relative_transform(self) -> typing.Optional[Transform]: ...
    @relative_transform.setter
    def relative_transform(self, value: typing.Optional[Transform]) -> None: ...
    @_property
    def opacity(self) -> winrt.system.Double: ...
    @opacity.setter
    def opacity(self, value: winrt.system.Double) -> None: ...

@typing.final
class BrushCollection(winrt.system.Object, winrt._winrt.MutableSequence[Brush]):
    def __len__(self) -> int: ...
    def __iter__(self) -> winrt.windows.foundation.collections.IIterator[Brush]: ...
    @typing.overload
    def __getitem__(self, index: typing.SupportsIndex) -> Brush: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[Brush]: ...
    @typing.overload
    def __delitem__(self, index: typing.SupportsIndex) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: typing.SupportsIndex, value: Brush) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[Brush]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BrushCollection: ...
    def __new__(cls: typing.Type[BrushCollection]) -> BrushCollection:...
    def append(self, value: typing.Optional[Brush], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[Brush]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[Brush]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[Brush], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[Brush]]: ...
    def index_of(self, value: typing.Optional[Brush], /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[Brush], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[Brush], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[Brush], /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

@typing.final
class CacheMode(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CacheMode: ...

@typing.final
class CompositeTransform_Static(type):
    @_property
    def center_x_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def center_y_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def rotation_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def scale_x_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def scale_y_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def skew_x_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def skew_y_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def translate_x_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def translate_y_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...

@typing.final
class CompositeTransform(winrt.system.Object, metaclass=CompositeTransform_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositeTransform: ...
    def __new__(cls: typing.Type[CompositeTransform]) -> CompositeTransform:...
    @_property
    def translate_y(self) -> winrt.system.Double: ...
    @translate_y.setter
    def translate_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def translate_x(self) -> winrt.system.Double: ...
    @translate_x.setter
    def translate_x(self, value: winrt.system.Double) -> None: ...
    @_property
    def skew_y(self) -> winrt.system.Double: ...
    @skew_y.setter
    def skew_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def skew_x(self) -> winrt.system.Double: ...
    @skew_x.setter
    def skew_x(self, value: winrt.system.Double) -> None: ...
    @_property
    def scale_y(self) -> winrt.system.Double: ...
    @scale_y.setter
    def scale_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def scale_x(self) -> winrt.system.Double: ...
    @scale_x.setter
    def scale_x(self, value: winrt.system.Double) -> None: ...
    @_property
    def rotation(self) -> winrt.system.Double: ...
    @rotation.setter
    def rotation(self, value: winrt.system.Double) -> None: ...
    @_property
    def center_y(self) -> winrt.system.Double: ...
    @center_y.setter
    def center_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def center_x(self) -> winrt.system.Double: ...
    @center_x.setter
    def center_x(self, value: winrt.system.Double) -> None: ...

@typing.final
class CompositionTarget_Static(type):
    def get_compositor_for_current_thread(cls) -> typing.Optional[winrt.microsoft.ui.composition.Compositor]: ...
    def add_rendered(cls, handler: winrt.windows.foundation.EventHandler[RenderedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_rendered(cls, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_rendering(cls, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_rendering(cls, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_surface_contents_lost(cls, handler: winrt.windows.foundation.EventHandler[winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_surface_contents_lost(cls, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...

@typing.final
class CompositionTarget(winrt.system.Object, metaclass=CompositionTarget_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionTarget: ...

@typing.final
class DesktopAcrylicBackdrop(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DesktopAcrylicBackdrop: ...
    def __new__(cls: typing.Type[DesktopAcrylicBackdrop]) -> DesktopAcrylicBackdrop:...

@typing.final
class DoubleCollection(winrt.system.Object, winrt._winrt.MutableSequence[winrt.system.Double]):
    def __len__(self) -> int: ...
    def __iter__(self) -> winrt.windows.foundation.collections.IIterator[winrt.system.Double]: ...
    @typing.overload
    def __getitem__(self, index: typing.SupportsIndex) -> winrt.system.Double: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[winrt.system.Double]: ...
    @typing.overload
    def __delitem__(self, index: typing.SupportsIndex) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: typing.SupportsIndex, value: winrt.system.Double) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[winrt.system.Double]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DoubleCollection: ...
    def __new__(cls: typing.Type[DoubleCollection]) -> DoubleCollection:...
    def append(self, value: winrt.system.Double, /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[winrt.system.Double]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> winrt.system.Double: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[winrt.system.Double], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.system.Double]]: ...
    def index_of(self, value: winrt.system.Double, /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: winrt.system.Double, /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[winrt.system.Double], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: winrt.system.Double, /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

@typing.final
class EllipseGeometry_Static(type):
    @_property
    def center_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def radius_x_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def radius_y_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...

@typing.final
class EllipseGeometry(winrt.system.Object, metaclass=EllipseGeometry_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EllipseGeometry: ...
    def __new__(cls: typing.Type[EllipseGeometry]) -> EllipseGeometry:...
    @_property
    def radius_y(self) -> winrt.system.Double: ...
    @radius_y.setter
    def radius_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def radius_x(self) -> winrt.system.Double: ...
    @radius_x.setter
    def radius_x(self, value: winrt.system.Double) -> None: ...
    @_property
    def center(self) -> winrt.windows.foundation.Point: ...
    @center.setter
    def center(self, value: winrt.windows.foundation.Point) -> None: ...

@typing.final
class FontFamily_Static(type):
    @_property
    def xaml_auto_font_family(cls) -> typing.Optional[FontFamily]: ...

@typing.final
class FontFamily(winrt.system.Object, metaclass=FontFamily_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FontFamily: ...
    def __new__(cls: typing.Type[FontFamily], family_name: str) -> FontFamily:...
    @_property
    def source(self) -> str: ...

@typing.final
class GeneralTransform(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GeneralTransform: ...
    def transform_bounds(self, rect: winrt.windows.foundation.Rect, /) -> winrt.windows.foundation.Rect: ...
    def transform_bounds_core(self, rect: winrt.windows.foundation.Rect, /) -> winrt.windows.foundation.Rect: ...
    def transform_point(self, point: winrt.windows.foundation.Point, /) -> winrt.windows.foundation.Point: ...
    def try_transform(self, in_point: winrt.windows.foundation.Point, /) -> typing.Tuple[bool, winrt.windows.foundation.Point]: ...
    def try_transform_core(self, in_point: winrt.windows.foundation.Point, /) -> typing.Tuple[bool, winrt.windows.foundation.Point]: ...
    @_property
    def inverse(self) -> typing.Optional[GeneralTransform]: ...
    @_property
    def inverse_core(self) -> typing.Optional[GeneralTransform]: ...

@typing.final
class Geometry_Static(type):
    @_property
    def empty(cls) -> typing.Optional[Geometry]: ...
    @_property
    def standard_flattening_tolerance(cls) -> winrt.system.Double: ...
    @_property
    def transform_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...

@typing.final
class Geometry(winrt.system.Object, metaclass=Geometry_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Geometry: ...
    @_property
    def transform(self) -> typing.Optional[Transform]: ...
    @transform.setter
    def transform(self, value: typing.Optional[Transform]) -> None: ...
    @_property
    def bounds(self) -> winrt.windows.foundation.Rect: ...

@typing.final
class GeometryCollection(winrt.system.Object, winrt._winrt.MutableSequence[Geometry]):
    def __len__(self) -> int: ...
    def __iter__(self) -> winrt.windows.foundation.collections.IIterator[Geometry]: ...
    @typing.overload
    def __getitem__(self, index: typing.SupportsIndex) -> Geometry: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[Geometry]: ...
    @typing.overload
    def __delitem__(self, index: typing.SupportsIndex) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: typing.SupportsIndex, value: Geometry) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[Geometry]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GeometryCollection: ...
    def __new__(cls: typing.Type[GeometryCollection]) -> GeometryCollection:...
    def append(self, value: typing.Optional[Geometry], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[Geometry]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[Geometry]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[Geometry], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[Geometry]]: ...
    def index_of(self, value: typing.Optional[Geometry], /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[Geometry], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[Geometry], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[Geometry], /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

@typing.final
class GeometryGroup_Static(type):
    @_property
    def children_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def fill_rule_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...

@typing.final
class GeometryGroup(winrt.system.Object, metaclass=GeometryGroup_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GeometryGroup: ...
    def __new__(cls: typing.Type[GeometryGroup]) -> GeometryGroup:...
    @_property
    def fill_rule(self) -> FillRule: ...
    @fill_rule.setter
    def fill_rule(self, value: FillRule) -> None: ...
    @_property
    def children(self) -> typing.Optional[GeometryCollection]: ...
    @children.setter
    def children(self, value: typing.Optional[GeometryCollection]) -> None: ...

@typing.final
class GradientBrush_Static(type):
    @_property
    def color_interpolation_mode_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def gradient_stops_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def mapping_mode_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def spread_method_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...

@typing.final
class GradientBrush(winrt.system.Object, metaclass=GradientBrush_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GradientBrush: ...
    @_property
    def spread_method(self) -> GradientSpreadMethod: ...
    @spread_method.setter
    def spread_method(self, value: GradientSpreadMethod) -> None: ...
    @_property
    def mapping_mode(self) -> BrushMappingMode: ...
    @mapping_mode.setter
    def mapping_mode(self, value: BrushMappingMode) -> None: ...
    @_property
    def gradient_stops(self) -> typing.Optional[GradientStopCollection]: ...
    @gradient_stops.setter
    def gradient_stops(self, value: typing.Optional[GradientStopCollection]) -> None: ...
    @_property
    def color_interpolation_mode(self) -> ColorInterpolationMode: ...
    @color_interpolation_mode.setter
    def color_interpolation_mode(self, value: ColorInterpolationMode) -> None: ...

@typing.final
class GradientStop_Static(type):
    @_property
    def color_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def offset_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...

@typing.final
class GradientStop(winrt.system.Object, metaclass=GradientStop_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GradientStop: ...
    def __new__(cls: typing.Type[GradientStop]) -> GradientStop:...
    @_property
    def offset(self) -> winrt.system.Double: ...
    @offset.setter
    def offset(self, value: winrt.system.Double) -> None: ...
    @_property
    def color(self) -> winrt.windows.ui.Color: ...
    @color.setter
    def color(self, value: winrt.windows.ui.Color) -> None: ...

@typing.final
class GradientStopCollection(winrt.system.Object, winrt._winrt.MutableSequence[GradientStop]):
    def __len__(self) -> int: ...
    def __iter__(self) -> winrt.windows.foundation.collections.IIterator[GradientStop]: ...
    @typing.overload
    def __getitem__(self, index: typing.SupportsIndex) -> GradientStop: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[GradientStop]: ...
    @typing.overload
    def __delitem__(self, index: typing.SupportsIndex) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: typing.SupportsIndex, value: GradientStop) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[GradientStop]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GradientStopCollection: ...
    def __new__(cls: typing.Type[GradientStopCollection]) -> GradientStopCollection:...
    def append(self, value: typing.Optional[GradientStop], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[GradientStop]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[GradientStop]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[GradientStop], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[GradientStop]]: ...
    def index_of(self, value: typing.Optional[GradientStop], /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[GradientStop], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[GradientStop], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[GradientStop], /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

@typing.final
class ImageBrush_Static(type):
    @_property
    def image_source_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...

@typing.final
class ImageBrush(winrt.system.Object, metaclass=ImageBrush_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ImageBrush: ...
    def __new__(cls: typing.Type[ImageBrush]) -> ImageBrush:...
    def add_image_failed(self, handler: typing.Optional[winrt.microsoft.ui.xaml.ExceptionRoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_image_failed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    def add_image_opened(self, handler: typing.Optional[winrt.microsoft.ui.xaml.RoutedEventHandler], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_image_opened(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def image_source(self) -> typing.Optional[ImageSource]: ...
    @image_source.setter
    def image_source(self, value: typing.Optional[ImageSource]) -> None: ...

@typing.final
class ImageSource(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ImageSource: ...

@typing.final
class LineGeometry_Static(type):
    @_property
    def end_point_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def start_point_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...

@typing.final
class LineGeometry(winrt.system.Object, metaclass=LineGeometry_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LineGeometry: ...
    def __new__(cls: typing.Type[LineGeometry]) -> LineGeometry:...
    @_property
    def start_point(self) -> winrt.windows.foundation.Point: ...
    @start_point.setter
    def start_point(self, value: winrt.windows.foundation.Point) -> None: ...
    @_property
    def end_point(self) -> winrt.windows.foundation.Point: ...
    @end_point.setter
    def end_point(self, value: winrt.windows.foundation.Point) -> None: ...

@typing.final
class LineSegment_Static(type):
    @_property
    def point_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...

@typing.final
class LineSegment(winrt.system.Object, metaclass=LineSegment_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LineSegment: ...
    def __new__(cls: typing.Type[LineSegment]) -> LineSegment:...
    @_property
    def point(self) -> winrt.windows.foundation.Point: ...
    @point.setter
    def point(self, value: winrt.windows.foundation.Point) -> None: ...

@typing.final
class LinearGradientBrush_Static(type):
    @_property
    def end_point_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def start_point_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...

@typing.final
class LinearGradientBrush(winrt.system.Object, metaclass=LinearGradientBrush_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LinearGradientBrush: ...
    @typing.overload
    def __new__(cls: typing.Type[LinearGradientBrush], gradient_stop_collection: typing.Optional[GradientStopCollection], angle: winrt.system.Double) -> LinearGradientBrush:...
    @typing.overload
    def __new__(cls: typing.Type[LinearGradientBrush]) -> LinearGradientBrush:...
    @_property
    def start_point(self) -> winrt.windows.foundation.Point: ...
    @start_point.setter
    def start_point(self, value: winrt.windows.foundation.Point) -> None: ...
    @_property
    def end_point(self) -> winrt.windows.foundation.Point: ...
    @end_point.setter
    def end_point(self, value: winrt.windows.foundation.Point) -> None: ...

@typing.final
class LoadedImageSourceLoadCompletedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LoadedImageSourceLoadCompletedEventArgs: ...
    @_property
    def status(self) -> LoadedImageSourceLoadStatus: ...

@typing.final
class LoadedImageSurface_Static(type):
    @typing.overload
    def start_load_from_stream(cls, stream: typing.Optional[winrt.windows.storage.streams.IRandomAccessStream], /) -> typing.Optional[LoadedImageSurface]: ...
    @typing.overload
    def start_load_from_stream(cls, stream: typing.Optional[winrt.windows.storage.streams.IRandomAccessStream], desired_max_size: winrt.windows.foundation.Size, /) -> typing.Optional[LoadedImageSurface]: ...
    @typing.overload
    def start_load_from_uri(cls, uri: typing.Optional[winrt.windows.foundation.Uri], /) -> typing.Optional[LoadedImageSurface]: ...
    @typing.overload
    def start_load_from_uri(cls, uri: typing.Optional[winrt.windows.foundation.Uri], desired_max_size: winrt.windows.foundation.Size, /) -> typing.Optional[LoadedImageSurface]: ...

@typing.final
class LoadedImageSurface(winrt.system.Object, metaclass=LoadedImageSurface_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LoadedImageSurface: ...
    def close(self) -> None: ...
    def add_load_completed(self, handler: winrt.windows.foundation.TypedEventHandler[LoadedImageSurface, LoadedImageSourceLoadCompletedEventArgs], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_load_completed(self, token: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def decoded_physical_size(self) -> winrt.windows.foundation.Size: ...
    @_property
    def decoded_size(self) -> winrt.windows.foundation.Size: ...
    @_property
    def natural_size(self) -> winrt.windows.foundation.Size: ...

@typing.final
class Matrix3DProjection_Static(type):
    @_property
    def projection_matrix_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...

@typing.final
class Matrix3DProjection(winrt.system.Object, metaclass=Matrix3DProjection_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Matrix3DProjection: ...
    def __new__(cls: typing.Type[Matrix3DProjection]) -> Matrix3DProjection:...
    @_property
    def projection_matrix(self) -> winrt.microsoft.ui.xaml.media.media3d.Matrix3D: ...
    @projection_matrix.setter
    def projection_matrix(self, value: winrt.microsoft.ui.xaml.media.media3d.Matrix3D) -> None: ...

@typing.final
class MatrixHelper_Static(type):
    def from_elements(cls, m11: winrt.system.Double, m12: winrt.system.Double, m21: winrt.system.Double, m22: winrt.system.Double, offset_x: winrt.system.Double, offset_y: winrt.system.Double, /) -> Matrix: ...
    def get_is_identity(cls, target: Matrix, /) -> bool: ...
    def transform(cls, target: Matrix, point: winrt.windows.foundation.Point, /) -> winrt.windows.foundation.Point: ...
    @_property
    def identity(cls) -> Matrix: ...

@typing.final
class MatrixHelper(winrt.system.Object, metaclass=MatrixHelper_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MatrixHelper: ...

@typing.final
class MatrixTransform_Static(type):
    @_property
    def matrix_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...

@typing.final
class MatrixTransform(winrt.system.Object, metaclass=MatrixTransform_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MatrixTransform: ...
    def __new__(cls: typing.Type[MatrixTransform]) -> MatrixTransform:...
    @_property
    def matrix(self) -> Matrix: ...
    @matrix.setter
    def matrix(self, value: Matrix) -> None: ...

@typing.final
class MediaTransportControlsThumbnailRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaTransportControlsThumbnailRequestedEventArgs: ...
    def get_deferral(self) -> typing.Optional[winrt.windows.foundation.Deferral]: ...
    def set_thumbnail_image(self, source: typing.Optional[winrt.windows.storage.streams.IInputStream], /) -> None: ...

@typing.final
class MicaBackdrop_Static(type):
    @_property
    def kind_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...

@typing.final
class MicaBackdrop(winrt.system.Object, metaclass=MicaBackdrop_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MicaBackdrop: ...
    def __new__(cls: typing.Type[MicaBackdrop]) -> MicaBackdrop:...
    @_property
    def kind(self) -> winrt.microsoft.ui.composition.systembackdrops.MicaKind: ...
    @kind.setter
    def kind(self, value: winrt.microsoft.ui.composition.systembackdrops.MicaKind) -> None: ...

@typing.final
class PathFigure_Static(type):
    @_property
    def is_closed_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def is_filled_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def segments_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def start_point_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...

@typing.final
class PathFigure(winrt.system.Object, metaclass=PathFigure_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PathFigure: ...
    def __new__(cls: typing.Type[PathFigure]) -> PathFigure:...
    @_property
    def start_point(self) -> winrt.windows.foundation.Point: ...
    @start_point.setter
    def start_point(self, value: winrt.windows.foundation.Point) -> None: ...
    @_property
    def segments(self) -> typing.Optional[PathSegmentCollection]: ...
    @segments.setter
    def segments(self, value: typing.Optional[PathSegmentCollection]) -> None: ...
    @_property
    def is_filled(self) -> bool: ...
    @is_filled.setter
    def is_filled(self, value: bool) -> None: ...
    @_property
    def is_closed(self) -> bool: ...
    @is_closed.setter
    def is_closed(self, value: bool) -> None: ...

@typing.final
class PathFigureCollection(winrt.system.Object, winrt._winrt.MutableSequence[PathFigure]):
    def __len__(self) -> int: ...
    def __iter__(self) -> winrt.windows.foundation.collections.IIterator[PathFigure]: ...
    @typing.overload
    def __getitem__(self, index: typing.SupportsIndex) -> PathFigure: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[PathFigure]: ...
    @typing.overload
    def __delitem__(self, index: typing.SupportsIndex) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: typing.SupportsIndex, value: PathFigure) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[PathFigure]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PathFigureCollection: ...
    def __new__(cls: typing.Type[PathFigureCollection]) -> PathFigureCollection:...
    def append(self, value: typing.Optional[PathFigure], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[PathFigure]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[PathFigure]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[PathFigure], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[PathFigure]]: ...
    def index_of(self, value: typing.Optional[PathFigure], /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[PathFigure], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[PathFigure], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[PathFigure], /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

@typing.final
class PathGeometry_Static(type):
    @_property
    def figures_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def fill_rule_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...

@typing.final
class PathGeometry(winrt.system.Object, metaclass=PathGeometry_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PathGeometry: ...
    def __new__(cls: typing.Type[PathGeometry]) -> PathGeometry:...
    @_property
    def fill_rule(self) -> FillRule: ...
    @fill_rule.setter
    def fill_rule(self, value: FillRule) -> None: ...
    @_property
    def figures(self) -> typing.Optional[PathFigureCollection]: ...
    @figures.setter
    def figures(self, value: typing.Optional[PathFigureCollection]) -> None: ...

@typing.final
class PathSegment(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PathSegment: ...

@typing.final
class PathSegmentCollection(winrt.system.Object, winrt._winrt.MutableSequence[PathSegment]):
    def __len__(self) -> int: ...
    def __iter__(self) -> winrt.windows.foundation.collections.IIterator[PathSegment]: ...
    @typing.overload
    def __getitem__(self, index: typing.SupportsIndex) -> PathSegment: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[PathSegment]: ...
    @typing.overload
    def __delitem__(self, index: typing.SupportsIndex) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: typing.SupportsIndex, value: PathSegment) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[PathSegment]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PathSegmentCollection: ...
    def __new__(cls: typing.Type[PathSegmentCollection]) -> PathSegmentCollection:...
    def append(self, value: typing.Optional[PathSegment], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[PathSegment]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[PathSegment]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[PathSegment], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[PathSegment]]: ...
    def index_of(self, value: typing.Optional[PathSegment], /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[PathSegment], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[PathSegment], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[PathSegment], /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

@typing.final
class PlaneProjection_Static(type):
    @_property
    def center_of_rotation_x_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def center_of_rotation_y_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def center_of_rotation_z_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def global_offset_x_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def global_offset_y_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def global_offset_z_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def local_offset_x_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def local_offset_y_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def local_offset_z_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def projection_matrix_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def rotation_x_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def rotation_y_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def rotation_z_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...

@typing.final
class PlaneProjection(winrt.system.Object, metaclass=PlaneProjection_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PlaneProjection: ...
    def __new__(cls: typing.Type[PlaneProjection]) -> PlaneProjection:...
    @_property
    def rotation_z(self) -> winrt.system.Double: ...
    @rotation_z.setter
    def rotation_z(self, value: winrt.system.Double) -> None: ...
    @_property
    def rotation_y(self) -> winrt.system.Double: ...
    @rotation_y.setter
    def rotation_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def rotation_x(self) -> winrt.system.Double: ...
    @rotation_x.setter
    def rotation_x(self, value: winrt.system.Double) -> None: ...
    @_property
    def local_offset_z(self) -> winrt.system.Double: ...
    @local_offset_z.setter
    def local_offset_z(self, value: winrt.system.Double) -> None: ...
    @_property
    def local_offset_y(self) -> winrt.system.Double: ...
    @local_offset_y.setter
    def local_offset_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def local_offset_x(self) -> winrt.system.Double: ...
    @local_offset_x.setter
    def local_offset_x(self, value: winrt.system.Double) -> None: ...
    @_property
    def global_offset_z(self) -> winrt.system.Double: ...
    @global_offset_z.setter
    def global_offset_z(self, value: winrt.system.Double) -> None: ...
    @_property
    def global_offset_y(self) -> winrt.system.Double: ...
    @global_offset_y.setter
    def global_offset_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def global_offset_x(self) -> winrt.system.Double: ...
    @global_offset_x.setter
    def global_offset_x(self, value: winrt.system.Double) -> None: ...
    @_property
    def center_of_rotation_z(self) -> winrt.system.Double: ...
    @center_of_rotation_z.setter
    def center_of_rotation_z(self, value: winrt.system.Double) -> None: ...
    @_property
    def center_of_rotation_y(self) -> winrt.system.Double: ...
    @center_of_rotation_y.setter
    def center_of_rotation_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def center_of_rotation_x(self) -> winrt.system.Double: ...
    @center_of_rotation_x.setter
    def center_of_rotation_x(self, value: winrt.system.Double) -> None: ...
    @_property
    def projection_matrix(self) -> winrt.microsoft.ui.xaml.media.media3d.Matrix3D: ...

@typing.final
class PointCollection(winrt.system.Object, winrt._winrt.MutableSequence[winrt.windows.foundation.Point]):
    def __len__(self) -> int: ...
    def __iter__(self) -> winrt.windows.foundation.collections.IIterator[winrt.windows.foundation.Point]: ...
    @typing.overload
    def __getitem__(self, index: typing.SupportsIndex) -> winrt.windows.foundation.Point: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[winrt.windows.foundation.Point]: ...
    @typing.overload
    def __delitem__(self, index: typing.SupportsIndex) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: typing.SupportsIndex, value: winrt.windows.foundation.Point) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[winrt.windows.foundation.Point]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PointCollection: ...
    def __new__(cls: typing.Type[PointCollection]) -> PointCollection:...
    def append(self, value: winrt.windows.foundation.Point, /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[winrt.windows.foundation.Point]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> winrt.windows.foundation.Point: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[winrt.windows.foundation.Point], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.windows.foundation.Point]]: ...
    def index_of(self, value: winrt.windows.foundation.Point, /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: winrt.windows.foundation.Point, /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[winrt.windows.foundation.Point], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: winrt.windows.foundation.Point, /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

@typing.final
class PolyBezierSegment_Static(type):
    @_property
    def points_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...

@typing.final
class PolyBezierSegment(winrt.system.Object, metaclass=PolyBezierSegment_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PolyBezierSegment: ...
    def __new__(cls: typing.Type[PolyBezierSegment]) -> PolyBezierSegment:...
    @_property
    def points(self) -> typing.Optional[PointCollection]: ...
    @points.setter
    def points(self, value: typing.Optional[PointCollection]) -> None: ...

@typing.final
class PolyLineSegment_Static(type):
    @_property
    def points_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...

@typing.final
class PolyLineSegment(winrt.system.Object, metaclass=PolyLineSegment_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PolyLineSegment: ...
    def __new__(cls: typing.Type[PolyLineSegment]) -> PolyLineSegment:...
    @_property
    def points(self) -> typing.Optional[PointCollection]: ...
    @points.setter
    def points(self, value: typing.Optional[PointCollection]) -> None: ...

@typing.final
class PolyQuadraticBezierSegment_Static(type):
    @_property
    def points_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...

@typing.final
class PolyQuadraticBezierSegment(winrt.system.Object, metaclass=PolyQuadraticBezierSegment_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PolyQuadraticBezierSegment: ...
    def __new__(cls: typing.Type[PolyQuadraticBezierSegment]) -> PolyQuadraticBezierSegment:...
    @_property
    def points(self) -> typing.Optional[PointCollection]: ...
    @points.setter
    def points(self, value: typing.Optional[PointCollection]) -> None: ...

@typing.final
class Projection(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Projection: ...

@typing.final
class QuadraticBezierSegment_Static(type):
    @_property
    def point1_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def point2_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...

@typing.final
class QuadraticBezierSegment(winrt.system.Object, metaclass=QuadraticBezierSegment_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> QuadraticBezierSegment: ...
    def __new__(cls: typing.Type[QuadraticBezierSegment]) -> QuadraticBezierSegment:...
    @_property
    def point2(self) -> winrt.windows.foundation.Point: ...
    @point2.setter
    def point2(self, value: winrt.windows.foundation.Point) -> None: ...
    @_property
    def point1(self) -> winrt.windows.foundation.Point: ...
    @point1.setter
    def point1(self, value: winrt.windows.foundation.Point) -> None: ...

@typing.final
class RadialGradientBrush_Static(type):
    @_property
    def center_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def gradient_origin_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def interpolation_space_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def mapping_mode_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def radius_x_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def radius_y_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def spread_method_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...

@typing.final
class RadialGradientBrush(winrt.system.Object, metaclass=RadialGradientBrush_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialGradientBrush: ...
    def __new__(cls: typing.Type[RadialGradientBrush]) -> RadialGradientBrush:...
    @_property
    def spread_method(self) -> GradientSpreadMethod: ...
    @spread_method.setter
    def spread_method(self, value: GradientSpreadMethod) -> None: ...
    @_property
    def radius_y(self) -> winrt.system.Double: ...
    @radius_y.setter
    def radius_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def radius_x(self) -> winrt.system.Double: ...
    @radius_x.setter
    def radius_x(self, value: winrt.system.Double) -> None: ...
    @_property
    def mapping_mode(self) -> BrushMappingMode: ...
    @mapping_mode.setter
    def mapping_mode(self, value: BrushMappingMode) -> None: ...
    @_property
    def interpolation_space(self) -> winrt.microsoft.ui.composition.CompositionColorSpace: ...
    @interpolation_space.setter
    def interpolation_space(self, value: winrt.microsoft.ui.composition.CompositionColorSpace) -> None: ...
    @_property
    def gradient_origin(self) -> winrt.windows.foundation.Point: ...
    @gradient_origin.setter
    def gradient_origin(self, value: winrt.windows.foundation.Point) -> None: ...
    @_property
    def center(self) -> winrt.windows.foundation.Point: ...
    @center.setter
    def center(self, value: winrt.windows.foundation.Point) -> None: ...
    @_property
    def gradient_stops(self) -> typing.Optional[winrt.windows.foundation.collections.IObservableVector[GradientStop]]: ...

@typing.final
class RectangleGeometry_Static(type):
    @_property
    def rect_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...

@typing.final
class RectangleGeometry(winrt.system.Object, metaclass=RectangleGeometry_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RectangleGeometry: ...
    def __new__(cls: typing.Type[RectangleGeometry]) -> RectangleGeometry:...
    @_property
    def rect(self) -> winrt.windows.foundation.Rect: ...
    @rect.setter
    def rect(self, value: winrt.windows.foundation.Rect) -> None: ...

@typing.final
class RenderedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RenderedEventArgs: ...
    @_property
    def frame_duration(self) -> datetime.timedelta: ...

@typing.final
class RenderingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RenderingEventArgs: ...
    @_property
    def rendering_time(self) -> datetime.timedelta: ...

@typing.final
class RotateTransform_Static(type):
    @_property
    def angle_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def center_x_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def center_y_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...

@typing.final
class RotateTransform(winrt.system.Object, metaclass=RotateTransform_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RotateTransform: ...
    def __new__(cls: typing.Type[RotateTransform]) -> RotateTransform:...
    @_property
    def center_y(self) -> winrt.system.Double: ...
    @center_y.setter
    def center_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def center_x(self) -> winrt.system.Double: ...
    @center_x.setter
    def center_x(self, value: winrt.system.Double) -> None: ...
    @_property
    def angle(self) -> winrt.system.Double: ...
    @angle.setter
    def angle(self, value: winrt.system.Double) -> None: ...

@typing.final
class ScaleTransform_Static(type):
    @_property
    def center_x_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def center_y_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def scale_x_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def scale_y_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...

@typing.final
class ScaleTransform(winrt.system.Object, metaclass=ScaleTransform_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ScaleTransform: ...
    def __new__(cls: typing.Type[ScaleTransform]) -> ScaleTransform:...
    @_property
    def scale_y(self) -> winrt.system.Double: ...
    @scale_y.setter
    def scale_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def scale_x(self) -> winrt.system.Double: ...
    @scale_x.setter
    def scale_x(self, value: winrt.system.Double) -> None: ...
    @_property
    def center_y(self) -> winrt.system.Double: ...
    @center_y.setter
    def center_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def center_x(self) -> winrt.system.Double: ...
    @center_x.setter
    def center_x(self, value: winrt.system.Double) -> None: ...

@typing.final
class Shadow(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Shadow: ...

@typing.final
class SkewTransform_Static(type):
    @_property
    def angle_x_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def angle_y_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def center_x_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def center_y_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...

@typing.final
class SkewTransform(winrt.system.Object, metaclass=SkewTransform_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SkewTransform: ...
    def __new__(cls: typing.Type[SkewTransform]) -> SkewTransform:...
    @_property
    def center_y(self) -> winrt.system.Double: ...
    @center_y.setter
    def center_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def center_x(self) -> winrt.system.Double: ...
    @center_x.setter
    def center_x(self, value: winrt.system.Double) -> None: ...
    @_property
    def angle_y(self) -> winrt.system.Double: ...
    @angle_y.setter
    def angle_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def angle_x(self) -> winrt.system.Double: ...
    @angle_x.setter
    def angle_x(self, value: winrt.system.Double) -> None: ...

@typing.final
class SolidColorBrush_Static(type):
    @_property
    def color_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...

@typing.final
class SolidColorBrush(winrt.system.Object, metaclass=SolidColorBrush_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SolidColorBrush: ...
    @typing.overload
    def __new__(cls: typing.Type[SolidColorBrush], color: winrt.windows.ui.Color) -> SolidColorBrush:...
    @typing.overload
    def __new__(cls: typing.Type[SolidColorBrush]) -> SolidColorBrush:...
    @_property
    def color(self) -> winrt.windows.ui.Color: ...
    @color.setter
    def color(self, value: winrt.windows.ui.Color) -> None: ...

@typing.final
class SystemBackdrop(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemBackdrop: ...
    def get_default_system_backdrop_configuration(self, target: typing.Optional[winrt.microsoft.ui.composition.ICompositionSupportsSystemBackdrop], xaml_root: typing.Optional[winrt.microsoft.ui.xaml.XamlRoot], /) -> typing.Optional[winrt.microsoft.ui.composition.systembackdrops.SystemBackdropConfiguration]: ...
    def on_default_system_backdrop_configuration_changed(self, target: typing.Optional[winrt.microsoft.ui.composition.ICompositionSupportsSystemBackdrop], xaml_root: typing.Optional[winrt.microsoft.ui.xaml.XamlRoot], /) -> None: ...
    def on_target_connected(self, connected_target: typing.Optional[winrt.microsoft.ui.composition.ICompositionSupportsSystemBackdrop], xaml_root: typing.Optional[winrt.microsoft.ui.xaml.XamlRoot], /) -> None: ...
    def on_target_disconnected(self, disconnected_target: typing.Optional[winrt.microsoft.ui.composition.ICompositionSupportsSystemBackdrop], /) -> None: ...

@typing.final
class ThemeShadow(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ThemeShadow: ...
    def __new__(cls: typing.Type[ThemeShadow]) -> ThemeShadow:...
    @_property
    def receivers(self) -> typing.Optional[winrt.microsoft.ui.xaml.UIElementWeakCollection]: ...

@typing.final
class TileBrush_Static(type):
    @_property
    def alignment_x_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def alignment_y_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def stretch_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...

@typing.final
class TileBrush(winrt.system.Object, metaclass=TileBrush_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TileBrush: ...
    @_property
    def stretch(self) -> Stretch: ...
    @stretch.setter
    def stretch(self, value: Stretch) -> None: ...
    @_property
    def alignment_y(self) -> AlignmentY: ...
    @alignment_y.setter
    def alignment_y(self, value: AlignmentY) -> None: ...
    @_property
    def alignment_x(self) -> AlignmentX: ...
    @alignment_x.setter
    def alignment_x(self, value: AlignmentX) -> None: ...

@typing.final
class Transform(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Transform: ...

@typing.final
class TransformCollection(winrt.system.Object, winrt._winrt.MutableSequence[Transform]):
    def __len__(self) -> int: ...
    def __iter__(self) -> winrt.windows.foundation.collections.IIterator[Transform]: ...
    @typing.overload
    def __getitem__(self, index: typing.SupportsIndex) -> Transform: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[Transform]: ...
    @typing.overload
    def __delitem__(self, index: typing.SupportsIndex) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: typing.SupportsIndex, value: Transform) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[Transform]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TransformCollection: ...
    def __new__(cls: typing.Type[TransformCollection]) -> TransformCollection:...
    def append(self, value: typing.Optional[Transform], /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winrt.windows.foundation.collections.IIterator[Transform]]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> typing.Optional[Transform]: ...
    def get_many(self, start_index: winrt.system.UInt32, items: winrt.system.Array[Transform], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[Transform]]: ...
    def index_of(self, value: typing.Optional[Transform], /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: typing.Optional[Transform], /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: winrt.system.Array[Transform], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: typing.Optional[Transform], /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

@typing.final
class TransformGroup_Static(type):
    @_property
    def children_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...

@typing.final
class TransformGroup(winrt.system.Object, metaclass=TransformGroup_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TransformGroup: ...
    def __new__(cls: typing.Type[TransformGroup]) -> TransformGroup:...
    @_property
    def children(self) -> typing.Optional[TransformCollection]: ...
    @children.setter
    def children(self, value: typing.Optional[TransformCollection]) -> None: ...
    @_property
    def value(self) -> Matrix: ...

@typing.final
class TranslateTransform_Static(type):
    @_property
    def x_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...
    @_property
    def y_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...

@typing.final
class TranslateTransform(winrt.system.Object, metaclass=TranslateTransform_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TranslateTransform: ...
    def __new__(cls: typing.Type[TranslateTransform]) -> TranslateTransform:...
    @_property
    def y(self) -> winrt.system.Double: ...
    @y.setter
    def y(self, value: winrt.system.Double) -> None: ...
    @_property
    def x(self) -> winrt.system.Double: ...
    @x.setter
    def x(self, value: winrt.system.Double) -> None: ...

@typing.final
class VisualTreeHelper_Static(type):
    def disconnect_children_recursive(cls, element: typing.Optional[winrt.microsoft.ui.xaml.UIElement], /) -> None: ...
    @typing.overload
    def find_elements_in_host_coordinates(cls, intersecting_point: winrt.windows.foundation.Point, subtree: typing.Optional[winrt.microsoft.ui.xaml.UIElement], /) -> typing.Optional[winrt.windows.foundation.collections.IIterable[winrt.microsoft.ui.xaml.UIElement]]: ...
    @typing.overload
    def find_elements_in_host_coordinates(cls, intersecting_point: winrt.windows.foundation.Point, subtree: typing.Optional[winrt.microsoft.ui.xaml.UIElement], include_all_elements: bool, /) -> typing.Optional[winrt.windows.foundation.collections.IIterable[winrt.microsoft.ui.xaml.UIElement]]: ...
    def get_child(cls, reference: typing.Optional[winrt.microsoft.ui.xaml.DependencyObject], child_index: winrt.system.Int32, /) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyObject]: ...
    def get_children_count(cls, reference: typing.Optional[winrt.microsoft.ui.xaml.DependencyObject], /) -> winrt.system.Int32: ...
    def get_open_popups(cls, window: typing.Optional[winrt.microsoft.ui.xaml.Window], /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.microsoft.ui.xaml.controls.primitives.Popup]]: ...
    def get_open_popups_for_xaml_root(cls, xaml_root: typing.Optional[winrt.microsoft.ui.xaml.XamlRoot], /) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[winrt.microsoft.ui.xaml.controls.primitives.Popup]]: ...
    def get_parent(cls, reference: typing.Optional[winrt.microsoft.ui.xaml.DependencyObject], /) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyObject]: ...

@typing.final
class VisualTreeHelper(winrt.system.Object, metaclass=VisualTreeHelper_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VisualTreeHelper: ...

@typing.final
class XamlCompositionBrushBase_Static(type):
    @_property
    def fallback_color_property(cls) -> typing.Optional[winrt.microsoft.ui.xaml.DependencyProperty]: ...

@typing.final
class XamlCompositionBrushBase(winrt.system.Object, metaclass=XamlCompositionBrushBase_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> XamlCompositionBrushBase: ...
    def on_connected(self) -> None: ...
    def on_disconnected(self) -> None: ...
    @_property
    def fallback_color(self) -> winrt.windows.ui.Color: ...
    @fallback_color.setter
    def fallback_color(self, value: winrt.windows.ui.Color) -> None: ...
    @_property
    def composition_brush(self) -> typing.Optional[winrt.microsoft.ui.composition.CompositionBrush]: ...
    @composition_brush.setter
    def composition_brush(self, value: typing.Optional[winrt.microsoft.ui.composition.CompositionBrush]) -> None: ...

@typing.final
class XamlLight_Static(type):
    def add_target_brush(cls, light_id: str, brush: typing.Optional[Brush], /) -> None: ...
    def add_target_element(cls, light_id: str, element: typing.Optional[winrt.microsoft.ui.xaml.UIElement], /) -> None: ...
    def remove_target_brush(cls, light_id: str, brush: typing.Optional[Brush], /) -> None: ...
    def remove_target_element(cls, light_id: str, element: typing.Optional[winrt.microsoft.ui.xaml.UIElement], /) -> None: ...

@typing.final
class XamlLight(winrt.system.Object, metaclass=XamlLight_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> XamlLight: ...
    def __new__(cls: typing.Type[XamlLight]) -> XamlLight:...
    def get_id(self) -> str: ...
    def on_connected(self, new_element: typing.Optional[winrt.microsoft.ui.xaml.UIElement], /) -> None: ...
    def on_disconnected(self, old_element: typing.Optional[winrt.microsoft.ui.xaml.UIElement], /) -> None: ...
    @_property
    def composition_light(self) -> typing.Optional[winrt.microsoft.ui.composition.CompositionLight]: ...
    @composition_light.setter
    def composition_light(self, value: typing.Optional[winrt.microsoft.ui.composition.CompositionLight]) -> None: ...

