# WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.microsoft.ui.composition as microsoft_ui_composition
import winrt.microsoft.ui.composition.systembackdrops as microsoft_ui_composition_systembackdrops
import winrt.microsoft.ui.xaml as microsoft_ui_xaml
import winrt.microsoft.ui.xaml.controls.primitives as microsoft_ui_xaml_controls_primitives
import winrt.microsoft.ui.xaml.media.media3d as microsoft_ui_xaml_media_media3d
import winrt.windows.foundation as windows_foundation
import winrt.windows.foundation.collections as windows_foundation_collections
import winrt.windows.storage.streams as windows_storage_streams
import winrt.windows.ui as windows_ui

from winrt.microsoft.ui.xaml.media import AlignmentX, AlignmentY, BrushMappingMode, ColorInterpolationMode, ElementCompositeMode, FastPlayFallbackBehaviour, FillRule, GradientSpreadMethod, LoadedImageSourceLoadStatus, PenLineCap, PenLineJoin, Stretch, StyleSimulations, SweepDirection

Self = typing.TypeVar('Self')

@typing.final
class Matrix:
    m11: winrt.system.Double
    m12: winrt.system.Double
    m21: winrt.system.Double
    m22: winrt.system.Double
    offset_x: winrt.system.Double
    offset_y: winrt.system.Double
    def __init__(self, m11: winrt.system.Double = 0, m12: winrt.system.Double = 0, m21: winrt.system.Double = 0, m22: winrt.system.Double = 0, offset_x: winrt.system.Double = 0, offset_y: winrt.system.Double = 0) -> None: ...

class AcrylicBrush_Static(XamlCompositionBrushBase_Static):
    @_property
    def always_use_fallback_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def tint_color_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def tint_opacity_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def tint_transition_duration_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def tint_luminosity_opacity_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...

class AcrylicBrush(XamlCompositionBrushBase, metaclass=AcrylicBrush_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> AcrylicBrush: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...
    @_property
    def tint_transition_duration(self) -> datetime.timedelta: ...
    @tint_transition_duration.setter
    def tint_transition_duration(self, value: datetime.timedelta) -> None: ...
    @_property
    def tint_opacity(self) -> winrt.system.Double: ...
    @tint_opacity.setter
    def tint_opacity(self, value: winrt.system.Double) -> None: ...
    @_property
    def tint_color(self) -> windows_ui.Color: ...
    @tint_color.setter
    def tint_color(self, value: windows_ui.Color) -> None: ...
    @_property
    def always_use_fallback(self) -> bool: ...
    @always_use_fallback.setter
    def always_use_fallback(self, value: bool) -> None: ...
    @_property
    def tint_luminosity_opacity(self) -> typing.Optional[winrt.system.Double]: ...
    @tint_luminosity_opacity.setter
    def tint_luminosity_opacity(self, value: typing.Optional[winrt.system.Double]) -> None: ...

@typing.final
class ArcSegment_Static(PathSegment_Static):
    @_property
    def is_large_arc_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def point_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def rotation_angle_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def size_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def sweep_direction_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...

@typing.final
class ArcSegment(PathSegment, metaclass=ArcSegment_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ArcSegment: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...
    @_property
    def sweep_direction(self) -> SweepDirection: ...
    @sweep_direction.setter
    def sweep_direction(self, value: SweepDirection) -> None: ...
    @_property
    def size(self) -> windows_foundation.Size: ...
    @size.setter
    def size(self, value: windows_foundation.Size) -> None: ...
    @_property
    def rotation_angle(self) -> winrt.system.Double: ...
    @rotation_angle.setter
    def rotation_angle(self, value: winrt.system.Double) -> None: ...
    @_property
    def point(self) -> windows_foundation.Point: ...
    @point.setter
    def point(self, value: windows_foundation.Point) -> None: ...
    @_property
    def is_large_arc(self) -> bool: ...
    @is_large_arc.setter
    def is_large_arc(self, value: bool) -> None: ...

@typing.final
class BezierSegment_Static(PathSegment_Static):
    @_property
    def point1_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def point2_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def point3_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...

@typing.final
class BezierSegment(PathSegment, metaclass=BezierSegment_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BezierSegment: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...
    @_property
    def point3(self) -> windows_foundation.Point: ...
    @point3.setter
    def point3(self, value: windows_foundation.Point) -> None: ...
    @_property
    def point2(self) -> windows_foundation.Point: ...
    @point2.setter
    def point2(self, value: windows_foundation.Point) -> None: ...
    @_property
    def point1(self) -> windows_foundation.Point: ...
    @point1.setter
    def point1(self, value: windows_foundation.Point) -> None: ...

@typing.final
class BitmapCache(CacheMode):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BitmapCache: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...

class Brush_Static(microsoft_ui_xaml.DependencyObject_Static):
    @_property
    def opacity_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def relative_transform_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def transform_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...

class Brush(microsoft_ui_xaml.DependencyObject, microsoft_ui_composition.ImplementsIAnimationObject, metaclass=Brush_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Brush: ...
    def populate_property_info(self, property_name: str, property_info: microsoft_ui_composition.AnimationPropertyInfo, /) -> None: ...
    @_property
    def transform(self) -> Transform: ...
    @transform.setter
    def transform(self, value: Transform) -> None: ...
    @_property
    def relative_transform(self) -> Transform: ...
    @relative_transform.setter
    def relative_transform(self, value: Transform) -> None: ...
    @_property
    def opacity(self) -> winrt.system.Double: ...
    @opacity.setter
    def opacity(self, value: winrt.system.Double) -> None: ...

@typing.final
class BrushCollection(winrt.system.Object, winrt._winrt.MutableSequence[Brush]):
    def __len__(self) -> int: ...
    def __iter__(self) -> windows_foundation_collections.IIterator[Brush]: ...
    @typing.overload
    def __getitem__(self, index: typing.SupportsIndex) -> Brush: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[Brush]: ...
    @typing.overload
    def __delitem__(self, index: typing.SupportsIndex) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: typing.SupportsIndex, value: Brush) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[Brush]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> BrushCollection: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...
    def append(self, value: Brush, /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> windows_foundation_collections.IIterator[Brush]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> Brush: ...
    def get_many(self, start_index: winrt.system.UInt32, items: typing.Union[winrt.system.Array[Brush], winrt.system.WriteableBuffer], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Sequence[Brush]: ...
    def index_of(self, value: Brush, /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: Brush, /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: typing.Union[winrt.system.Array[Brush], winrt.system.ReadableBuffer], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: Brush, /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

class CacheMode_Static(microsoft_ui_xaml.DependencyObject_Static):
    pass

class CacheMode(microsoft_ui_xaml.DependencyObject, metaclass=CacheMode_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CacheMode: ...

@typing.final
class CompositeTransform_Static(Transform_Static):
    @_property
    def center_x_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def center_y_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def rotation_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def scale_x_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def scale_y_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def skew_x_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def skew_y_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def translate_x_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def translate_y_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...

@typing.final
class CompositeTransform(Transform, metaclass=CompositeTransform_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositeTransform: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...
    @_property
    def translate_y(self) -> winrt.system.Double: ...
    @translate_y.setter
    def translate_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def translate_x(self) -> winrt.system.Double: ...
    @translate_x.setter
    def translate_x(self, value: winrt.system.Double) -> None: ...
    @_property
    def skew_y(self) -> winrt.system.Double: ...
    @skew_y.setter
    def skew_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def skew_x(self) -> winrt.system.Double: ...
    @skew_x.setter
    def skew_x(self, value: winrt.system.Double) -> None: ...
    @_property
    def scale_y(self) -> winrt.system.Double: ...
    @scale_y.setter
    def scale_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def scale_x(self) -> winrt.system.Double: ...
    @scale_x.setter
    def scale_x(self, value: winrt.system.Double) -> None: ...
    @_property
    def rotation(self) -> winrt.system.Double: ...
    @rotation.setter
    def rotation(self, value: winrt.system.Double) -> None: ...
    @_property
    def center_y(self) -> winrt.system.Double: ...
    @center_y.setter
    def center_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def center_x(self) -> winrt.system.Double: ...
    @center_x.setter
    def center_x(self, value: winrt.system.Double) -> None: ...

@typing.final
class CompositionTarget_Static(type):
    def get_compositor_for_current_thread(cls) -> microsoft_ui_composition.Compositor: ...
    def add_rendered(cls, handler: windows_foundation.EventHandler[RenderedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_rendered(cls, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_rendering(cls, handler: windows_foundation.EventHandler[winrt.system.Object], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_rendering(cls, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_surface_contents_lost(cls, handler: windows_foundation.EventHandler[winrt.system.Object], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_surface_contents_lost(cls, token: windows_foundation.EventRegistrationToken, /) -> None: ...

@typing.final
class CompositionTarget(winrt.system.Object, metaclass=CompositionTarget_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> CompositionTarget: ...

class DesktopAcrylicBackdrop_Static(SystemBackdrop_Static):
    pass

class DesktopAcrylicBackdrop(SystemBackdrop, metaclass=DesktopAcrylicBackdrop_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DesktopAcrylicBackdrop: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...

@typing.final
class DoubleCollection(winrt.system.Object, winrt._winrt.MutableSequence[winrt.system.Double]):
    def __len__(self) -> int: ...
    def __iter__(self) -> windows_foundation_collections.IIterator[winrt.system.Double]: ...
    @typing.overload
    def __getitem__(self, index: typing.SupportsIndex) -> winrt.system.Double: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[winrt.system.Double]: ...
    @typing.overload
    def __delitem__(self, index: typing.SupportsIndex) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: typing.SupportsIndex, value: winrt.system.Double) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[winrt.system.Double]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> DoubleCollection: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...
    def append(self, value: winrt.system.Double, /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> windows_foundation_collections.IIterator[winrt.system.Double]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> winrt.system.Double: ...
    def get_many(self, start_index: winrt.system.UInt32, items: typing.Union[winrt.system.Array[winrt.system.Double], winrt.system.WriteableBuffer], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Sequence[winrt.system.Double]: ...
    def index_of(self, value: winrt.system.Double, /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: winrt.system.Double, /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: typing.Union[winrt.system.Array[winrt.system.Double], winrt.system.ReadableBuffer], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: winrt.system.Double, /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

@typing.final
class EllipseGeometry_Static(Geometry_Static):
    @_property
    def center_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def radius_x_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def radius_y_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...

@typing.final
class EllipseGeometry(Geometry, metaclass=EllipseGeometry_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> EllipseGeometry: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...
    @_property
    def radius_y(self) -> winrt.system.Double: ...
    @radius_y.setter
    def radius_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def radius_x(self) -> winrt.system.Double: ...
    @radius_x.setter
    def radius_x(self, value: winrt.system.Double) -> None: ...
    @_property
    def center(self) -> windows_foundation.Point: ...
    @center.setter
    def center(self, value: windows_foundation.Point) -> None: ...

class FontFamily_Static(type):
    @_property
    def xaml_auto_font_family(cls) -> FontFamily: ...

class FontFamily(winrt.system.Object, metaclass=FontFamily_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> FontFamily: ...
    def __new__(cls: typing.Type[Self], family_name: str) -> Self: ...
    @_property
    def source(self) -> str: ...

class GeneralTransform_Static(microsoft_ui_xaml.DependencyObject_Static):
    pass

class GeneralTransform(microsoft_ui_xaml.DependencyObject, metaclass=GeneralTransform_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GeneralTransform: ...
    def transform_bounds(self, rect: windows_foundation.Rect, /) -> windows_foundation.Rect: ...
    def transform_point(self, point: windows_foundation.Point, /) -> windows_foundation.Point: ...
    def try_transform(self, in_point: windows_foundation.Point, /) -> typing.Tuple[bool, windows_foundation.Point]: ...
    @_property
    def inverse(self) -> GeneralTransform: ...

class Geometry_Static(microsoft_ui_xaml.DependencyObject_Static):
    @_property
    def empty(cls) -> Geometry: ...
    @_property
    def standard_flattening_tolerance(cls) -> winrt.system.Double: ...
    @_property
    def transform_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...

class Geometry(microsoft_ui_xaml.DependencyObject, metaclass=Geometry_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Geometry: ...
    @_property
    def transform(self) -> Transform: ...
    @transform.setter
    def transform(self, value: Transform) -> None: ...
    @_property
    def bounds(self) -> windows_foundation.Rect: ...

@typing.final
class GeometryCollection(winrt.system.Object, winrt._winrt.MutableSequence[Geometry]):
    def __len__(self) -> int: ...
    def __iter__(self) -> windows_foundation_collections.IIterator[Geometry]: ...
    @typing.overload
    def __getitem__(self, index: typing.SupportsIndex) -> Geometry: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[Geometry]: ...
    @typing.overload
    def __delitem__(self, index: typing.SupportsIndex) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: typing.SupportsIndex, value: Geometry) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[Geometry]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GeometryCollection: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...
    def append(self, value: Geometry, /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> windows_foundation_collections.IIterator[Geometry]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> Geometry: ...
    def get_many(self, start_index: winrt.system.UInt32, items: typing.Union[winrt.system.Array[Geometry], winrt.system.WriteableBuffer], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Sequence[Geometry]: ...
    def index_of(self, value: Geometry, /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: Geometry, /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: typing.Union[winrt.system.Array[Geometry], winrt.system.ReadableBuffer], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: Geometry, /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

@typing.final
class GeometryGroup_Static(Geometry_Static):
    @_property
    def children_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def fill_rule_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...

@typing.final
class GeometryGroup(Geometry, metaclass=GeometryGroup_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GeometryGroup: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...
    @_property
    def fill_rule(self) -> FillRule: ...
    @fill_rule.setter
    def fill_rule(self, value: FillRule) -> None: ...
    @_property
    def children(self) -> GeometryCollection: ...
    @children.setter
    def children(self, value: GeometryCollection) -> None: ...

class GradientBrush_Static(Brush_Static):
    @_property
    def color_interpolation_mode_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def gradient_stops_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def mapping_mode_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def spread_method_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...

class GradientBrush(Brush, metaclass=GradientBrush_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GradientBrush: ...
    @_property
    def spread_method(self) -> GradientSpreadMethod: ...
    @spread_method.setter
    def spread_method(self, value: GradientSpreadMethod) -> None: ...
    @_property
    def mapping_mode(self) -> BrushMappingMode: ...
    @mapping_mode.setter
    def mapping_mode(self, value: BrushMappingMode) -> None: ...
    @_property
    def gradient_stops(self) -> GradientStopCollection: ...
    @gradient_stops.setter
    def gradient_stops(self, value: GradientStopCollection) -> None: ...
    @_property
    def color_interpolation_mode(self) -> ColorInterpolationMode: ...
    @color_interpolation_mode.setter
    def color_interpolation_mode(self, value: ColorInterpolationMode) -> None: ...

@typing.final
class GradientStop_Static(microsoft_ui_xaml.DependencyObject_Static):
    @_property
    def color_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def offset_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...

@typing.final
class GradientStop(microsoft_ui_xaml.DependencyObject, metaclass=GradientStop_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GradientStop: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...
    @_property
    def offset(self) -> winrt.system.Double: ...
    @offset.setter
    def offset(self, value: winrt.system.Double) -> None: ...
    @_property
    def color(self) -> windows_ui.Color: ...
    @color.setter
    def color(self, value: windows_ui.Color) -> None: ...

@typing.final
class GradientStopCollection(winrt.system.Object, winrt._winrt.MutableSequence[GradientStop]):
    def __len__(self) -> int: ...
    def __iter__(self) -> windows_foundation_collections.IIterator[GradientStop]: ...
    @typing.overload
    def __getitem__(self, index: typing.SupportsIndex) -> GradientStop: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[GradientStop]: ...
    @typing.overload
    def __delitem__(self, index: typing.SupportsIndex) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: typing.SupportsIndex, value: GradientStop) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[GradientStop]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> GradientStopCollection: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...
    def append(self, value: GradientStop, /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> windows_foundation_collections.IIterator[GradientStop]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> GradientStop: ...
    def get_many(self, start_index: winrt.system.UInt32, items: typing.Union[winrt.system.Array[GradientStop], winrt.system.WriteableBuffer], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Sequence[GradientStop]: ...
    def index_of(self, value: GradientStop, /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: GradientStop, /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: typing.Union[winrt.system.Array[GradientStop], winrt.system.ReadableBuffer], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: GradientStop, /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

@typing.final
class ImageBrush_Static(TileBrush_Static):
    @_property
    def image_source_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...

@typing.final
class ImageBrush(TileBrush, metaclass=ImageBrush_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ImageBrush: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...
    def add_image_failed(self, handler: microsoft_ui_xaml.ExceptionRoutedEventHandler, /) -> windows_foundation.EventRegistrationToken: ...
    def remove_image_failed(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    def add_image_opened(self, handler: microsoft_ui_xaml.RoutedEventHandler, /) -> windows_foundation.EventRegistrationToken: ...
    def remove_image_opened(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def image_source(self) -> ImageSource: ...
    @image_source.setter
    def image_source(self, value: ImageSource) -> None: ...

class ImageSource_Static(microsoft_ui_xaml.DependencyObject_Static):
    pass

class ImageSource(microsoft_ui_xaml.DependencyObject, metaclass=ImageSource_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ImageSource: ...

@typing.final
class LineGeometry_Static(Geometry_Static):
    @_property
    def end_point_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def start_point_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...

@typing.final
class LineGeometry(Geometry, metaclass=LineGeometry_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LineGeometry: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...
    @_property
    def start_point(self) -> windows_foundation.Point: ...
    @start_point.setter
    def start_point(self, value: windows_foundation.Point) -> None: ...
    @_property
    def end_point(self) -> windows_foundation.Point: ...
    @end_point.setter
    def end_point(self, value: windows_foundation.Point) -> None: ...

@typing.final
class LineSegment_Static(PathSegment_Static):
    @_property
    def point_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...

@typing.final
class LineSegment(PathSegment, metaclass=LineSegment_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LineSegment: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...
    @_property
    def point(self) -> windows_foundation.Point: ...
    @point.setter
    def point(self, value: windows_foundation.Point) -> None: ...

@typing.final
class LinearGradientBrush_Static(GradientBrush_Static):
    @_property
    def end_point_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def start_point_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...

@typing.final
class LinearGradientBrush(GradientBrush, metaclass=LinearGradientBrush_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LinearGradientBrush: ...
    @typing.overload
    def __new__(cls: typing.Type[Self], gradient_stop_collection: GradientStopCollection, angle: winrt.system.Double) -> Self: ...
    @typing.overload
    def __new__(cls: typing.Type[Self]) -> Self: ...
    @_property
    def start_point(self) -> windows_foundation.Point: ...
    @start_point.setter
    def start_point(self, value: windows_foundation.Point) -> None: ...
    @_property
    def end_point(self) -> windows_foundation.Point: ...
    @end_point.setter
    def end_point(self, value: windows_foundation.Point) -> None: ...

@typing.final
class LoadedImageSourceLoadCompletedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LoadedImageSourceLoadCompletedEventArgs: ...
    @_property
    def status(self) -> LoadedImageSourceLoadStatus: ...

@typing.final
class LoadedImageSurface_Static(type):
    def start_load_from_stream(cls, stream: windows_storage_streams.ImplementsIRandomAccessStream, /) -> LoadedImageSurface: ...
    def start_load_from_stream_with_size(cls, stream: windows_storage_streams.ImplementsIRandomAccessStream, desired_max_size: windows_foundation.Size, /) -> LoadedImageSurface: ...
    def start_load_from_uri(cls, uri: windows_foundation.Uri, /) -> LoadedImageSurface: ...
    def start_load_from_uri_with_size(cls, uri: windows_foundation.Uri, desired_max_size: windows_foundation.Size, /) -> LoadedImageSurface: ...

@typing.final
class LoadedImageSurface(winrt.system.Object, microsoft_ui_composition.ImplementsICompositionSurface, windows_foundation.ImplementsIClosable, metaclass=LoadedImageSurface_Static):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> LoadedImageSurface: ...
    def close(self) -> None: ...
    def add_load_completed(self, handler: windows_foundation.TypedEventHandler[LoadedImageSurface, LoadedImageSourceLoadCompletedEventArgs], /) -> windows_foundation.EventRegistrationToken: ...
    def remove_load_completed(self, token: windows_foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def decoded_physical_size(self) -> windows_foundation.Size: ...
    @_property
    def decoded_size(self) -> windows_foundation.Size: ...
    @_property
    def natural_size(self) -> windows_foundation.Size: ...

@typing.final
class Matrix3DProjection_Static(Projection_Static):
    @_property
    def projection_matrix_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...

@typing.final
class Matrix3DProjection(Projection, metaclass=Matrix3DProjection_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Matrix3DProjection: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...
    @_property
    def projection_matrix(self) -> microsoft_ui_xaml_media_media3d.Matrix3D: ...
    @projection_matrix.setter
    def projection_matrix(self, value: microsoft_ui_xaml_media_media3d.Matrix3D) -> None: ...

@typing.final
class MatrixHelper_Static(type):
    def from_elements(cls, m11: winrt.system.Double, m12: winrt.system.Double, m21: winrt.system.Double, m22: winrt.system.Double, offset_x: winrt.system.Double, offset_y: winrt.system.Double, /) -> Matrix: ...
    def get_is_identity(cls, target: Matrix, /) -> bool: ...
    def transform(cls, target: Matrix, point: windows_foundation.Point, /) -> windows_foundation.Point: ...
    @_property
    def identity(cls) -> Matrix: ...

@typing.final
class MatrixHelper(winrt.system.Object, metaclass=MatrixHelper_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MatrixHelper: ...

@typing.final
class MatrixTransform_Static(Transform_Static):
    @_property
    def matrix_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...

@typing.final
class MatrixTransform(Transform, metaclass=MatrixTransform_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MatrixTransform: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...
    @_property
    def matrix(self) -> Matrix: ...
    @matrix.setter
    def matrix(self, value: Matrix) -> None: ...

@typing.final
class MediaTransportControlsThumbnailRequestedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MediaTransportControlsThumbnailRequestedEventArgs: ...
    def get_deferral(self) -> windows_foundation.Deferral: ...
    def set_thumbnail_image(self, source: windows_storage_streams.ImplementsIInputStream, /) -> None: ...

class MicaBackdrop_Static(SystemBackdrop_Static):
    @_property
    def kind_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...

class MicaBackdrop(SystemBackdrop, metaclass=MicaBackdrop_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> MicaBackdrop: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...
    @_property
    def kind(self) -> microsoft_ui_composition_systembackdrops.MicaKind: ...
    @kind.setter
    def kind(self, value: microsoft_ui_composition_systembackdrops.MicaKind) -> None: ...

@typing.final
class PathFigure_Static(microsoft_ui_xaml.DependencyObject_Static):
    @_property
    def is_closed_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def is_filled_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def segments_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def start_point_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...

@typing.final
class PathFigure(microsoft_ui_xaml.DependencyObject, metaclass=PathFigure_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PathFigure: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...
    @_property
    def start_point(self) -> windows_foundation.Point: ...
    @start_point.setter
    def start_point(self, value: windows_foundation.Point) -> None: ...
    @_property
    def segments(self) -> PathSegmentCollection: ...
    @segments.setter
    def segments(self, value: PathSegmentCollection) -> None: ...
    @_property
    def is_filled(self) -> bool: ...
    @is_filled.setter
    def is_filled(self, value: bool) -> None: ...
    @_property
    def is_closed(self) -> bool: ...
    @is_closed.setter
    def is_closed(self, value: bool) -> None: ...

@typing.final
class PathFigureCollection(winrt.system.Object, winrt._winrt.MutableSequence[PathFigure]):
    def __len__(self) -> int: ...
    def __iter__(self) -> windows_foundation_collections.IIterator[PathFigure]: ...
    @typing.overload
    def __getitem__(self, index: typing.SupportsIndex) -> PathFigure: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[PathFigure]: ...
    @typing.overload
    def __delitem__(self, index: typing.SupportsIndex) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: typing.SupportsIndex, value: PathFigure) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[PathFigure]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PathFigureCollection: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...
    def append(self, value: PathFigure, /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> windows_foundation_collections.IIterator[PathFigure]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> PathFigure: ...
    def get_many(self, start_index: winrt.system.UInt32, items: typing.Union[winrt.system.Array[PathFigure], winrt.system.WriteableBuffer], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Sequence[PathFigure]: ...
    def index_of(self, value: PathFigure, /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: PathFigure, /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: typing.Union[winrt.system.Array[PathFigure], winrt.system.ReadableBuffer], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: PathFigure, /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

@typing.final
class PathGeometry_Static(Geometry_Static):
    @_property
    def figures_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def fill_rule_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...

@typing.final
class PathGeometry(Geometry, metaclass=PathGeometry_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PathGeometry: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...
    @_property
    def fill_rule(self) -> FillRule: ...
    @fill_rule.setter
    def fill_rule(self, value: FillRule) -> None: ...
    @_property
    def figures(self) -> PathFigureCollection: ...
    @figures.setter
    def figures(self, value: PathFigureCollection) -> None: ...

class PathSegment_Static(microsoft_ui_xaml.DependencyObject_Static):
    pass

class PathSegment(microsoft_ui_xaml.DependencyObject, metaclass=PathSegment_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PathSegment: ...

@typing.final
class PathSegmentCollection(winrt.system.Object, winrt._winrt.MutableSequence[PathSegment]):
    def __len__(self) -> int: ...
    def __iter__(self) -> windows_foundation_collections.IIterator[PathSegment]: ...
    @typing.overload
    def __getitem__(self, index: typing.SupportsIndex) -> PathSegment: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[PathSegment]: ...
    @typing.overload
    def __delitem__(self, index: typing.SupportsIndex) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: typing.SupportsIndex, value: PathSegment) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[PathSegment]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PathSegmentCollection: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...
    def append(self, value: PathSegment, /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> windows_foundation_collections.IIterator[PathSegment]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> PathSegment: ...
    def get_many(self, start_index: winrt.system.UInt32, items: typing.Union[winrt.system.Array[PathSegment], winrt.system.WriteableBuffer], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Sequence[PathSegment]: ...
    def index_of(self, value: PathSegment, /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: PathSegment, /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: typing.Union[winrt.system.Array[PathSegment], winrt.system.ReadableBuffer], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: PathSegment, /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

@typing.final
class PlaneProjection_Static(Projection_Static):
    @_property
    def center_of_rotation_x_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def center_of_rotation_y_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def center_of_rotation_z_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def global_offset_x_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def global_offset_y_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def global_offset_z_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def local_offset_x_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def local_offset_y_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def local_offset_z_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def projection_matrix_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def rotation_x_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def rotation_y_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def rotation_z_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...

@typing.final
class PlaneProjection(Projection, metaclass=PlaneProjection_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PlaneProjection: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...
    @_property
    def rotation_z(self) -> winrt.system.Double: ...
    @rotation_z.setter
    def rotation_z(self, value: winrt.system.Double) -> None: ...
    @_property
    def rotation_y(self) -> winrt.system.Double: ...
    @rotation_y.setter
    def rotation_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def rotation_x(self) -> winrt.system.Double: ...
    @rotation_x.setter
    def rotation_x(self, value: winrt.system.Double) -> None: ...
    @_property
    def local_offset_z(self) -> winrt.system.Double: ...
    @local_offset_z.setter
    def local_offset_z(self, value: winrt.system.Double) -> None: ...
    @_property
    def local_offset_y(self) -> winrt.system.Double: ...
    @local_offset_y.setter
    def local_offset_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def local_offset_x(self) -> winrt.system.Double: ...
    @local_offset_x.setter
    def local_offset_x(self, value: winrt.system.Double) -> None: ...
    @_property
    def global_offset_z(self) -> winrt.system.Double: ...
    @global_offset_z.setter
    def global_offset_z(self, value: winrt.system.Double) -> None: ...
    @_property
    def global_offset_y(self) -> winrt.system.Double: ...
    @global_offset_y.setter
    def global_offset_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def global_offset_x(self) -> winrt.system.Double: ...
    @global_offset_x.setter
    def global_offset_x(self, value: winrt.system.Double) -> None: ...
    @_property
    def center_of_rotation_z(self) -> winrt.system.Double: ...
    @center_of_rotation_z.setter
    def center_of_rotation_z(self, value: winrt.system.Double) -> None: ...
    @_property
    def center_of_rotation_y(self) -> winrt.system.Double: ...
    @center_of_rotation_y.setter
    def center_of_rotation_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def center_of_rotation_x(self) -> winrt.system.Double: ...
    @center_of_rotation_x.setter
    def center_of_rotation_x(self, value: winrt.system.Double) -> None: ...
    @_property
    def projection_matrix(self) -> microsoft_ui_xaml_media_media3d.Matrix3D: ...

@typing.final
class PointCollection(winrt.system.Object, winrt._winrt.MutableSequence[windows_foundation.Point]):
    def __len__(self) -> int: ...
    def __iter__(self) -> windows_foundation_collections.IIterator[windows_foundation.Point]: ...
    @typing.overload
    def __getitem__(self, index: typing.SupportsIndex) -> windows_foundation.Point: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[windows_foundation.Point]: ...
    @typing.overload
    def __delitem__(self, index: typing.SupportsIndex) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: typing.SupportsIndex, value: windows_foundation.Point) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[windows_foundation.Point]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PointCollection: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...
    def append(self, value: windows_foundation.Point, /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> windows_foundation_collections.IIterator[windows_foundation.Point]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> windows_foundation.Point: ...
    def get_many(self, start_index: winrt.system.UInt32, items: typing.Union[winrt.system.Array[windows_foundation.Point], winrt.system.WriteableBuffer], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Sequence[windows_foundation.Point]: ...
    def index_of(self, value: windows_foundation.Point, /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: windows_foundation.Point, /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: typing.Union[winrt.system.Array[windows_foundation.Point], winrt.system.ReadableBuffer], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: windows_foundation.Point, /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

@typing.final
class PolyBezierSegment_Static(PathSegment_Static):
    @_property
    def points_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...

@typing.final
class PolyBezierSegment(PathSegment, metaclass=PolyBezierSegment_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PolyBezierSegment: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...
    @_property
    def points(self) -> PointCollection: ...
    @points.setter
    def points(self, value: PointCollection) -> None: ...

@typing.final
class PolyLineSegment_Static(PathSegment_Static):
    @_property
    def points_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...

@typing.final
class PolyLineSegment(PathSegment, metaclass=PolyLineSegment_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PolyLineSegment: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...
    @_property
    def points(self) -> PointCollection: ...
    @points.setter
    def points(self, value: PointCollection) -> None: ...

@typing.final
class PolyQuadraticBezierSegment_Static(PathSegment_Static):
    @_property
    def points_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...

@typing.final
class PolyQuadraticBezierSegment(PathSegment, metaclass=PolyQuadraticBezierSegment_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> PolyQuadraticBezierSegment: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...
    @_property
    def points(self) -> PointCollection: ...
    @points.setter
    def points(self, value: PointCollection) -> None: ...

class Projection_Static(microsoft_ui_xaml.DependencyObject_Static):
    pass

class Projection(microsoft_ui_xaml.DependencyObject, metaclass=Projection_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Projection: ...

@typing.final
class QuadraticBezierSegment_Static(PathSegment_Static):
    @_property
    def point1_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def point2_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...

@typing.final
class QuadraticBezierSegment(PathSegment, metaclass=QuadraticBezierSegment_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> QuadraticBezierSegment: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...
    @_property
    def point2(self) -> windows_foundation.Point: ...
    @point2.setter
    def point2(self, value: windows_foundation.Point) -> None: ...
    @_property
    def point1(self) -> windows_foundation.Point: ...
    @point1.setter
    def point1(self, value: windows_foundation.Point) -> None: ...

class RadialGradientBrush_Static(XamlCompositionBrushBase_Static):
    @_property
    def center_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def gradient_origin_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def interpolation_space_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def mapping_mode_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def radius_x_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def radius_y_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def spread_method_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...

class RadialGradientBrush(XamlCompositionBrushBase, metaclass=RadialGradientBrush_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RadialGradientBrush: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...
    @_property
    def spread_method(self) -> GradientSpreadMethod: ...
    @spread_method.setter
    def spread_method(self, value: GradientSpreadMethod) -> None: ...
    @_property
    def radius_y(self) -> winrt.system.Double: ...
    @radius_y.setter
    def radius_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def radius_x(self) -> winrt.system.Double: ...
    @radius_x.setter
    def radius_x(self, value: winrt.system.Double) -> None: ...
    @_property
    def mapping_mode(self) -> BrushMappingMode: ...
    @mapping_mode.setter
    def mapping_mode(self, value: BrushMappingMode) -> None: ...
    @_property
    def interpolation_space(self) -> microsoft_ui_composition.CompositionColorSpace: ...
    @interpolation_space.setter
    def interpolation_space(self, value: microsoft_ui_composition.CompositionColorSpace) -> None: ...
    @_property
    def gradient_origin(self) -> windows_foundation.Point: ...
    @gradient_origin.setter
    def gradient_origin(self, value: windows_foundation.Point) -> None: ...
    @_property
    def center(self) -> windows_foundation.Point: ...
    @center.setter
    def center(self, value: windows_foundation.Point) -> None: ...
    @_property
    def gradient_stops(self) -> windows_foundation_collections.IObservableVector[GradientStop]: ...

@typing.final
class RectangleGeometry_Static(Geometry_Static):
    @_property
    def rect_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...

@typing.final
class RectangleGeometry(Geometry, metaclass=RectangleGeometry_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RectangleGeometry: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...
    @_property
    def rect(self) -> windows_foundation.Rect: ...
    @rect.setter
    def rect(self, value: windows_foundation.Rect) -> None: ...

@typing.final
class RenderedEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RenderedEventArgs: ...
    @_property
    def frame_duration(self) -> datetime.timedelta: ...

@typing.final
class RenderingEventArgs(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RenderingEventArgs: ...
    @_property
    def rendering_time(self) -> datetime.timedelta: ...

@typing.final
class RotateTransform_Static(Transform_Static):
    @_property
    def angle_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def center_x_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def center_y_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...

@typing.final
class RotateTransform(Transform, metaclass=RotateTransform_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> RotateTransform: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...
    @_property
    def center_y(self) -> winrt.system.Double: ...
    @center_y.setter
    def center_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def center_x(self) -> winrt.system.Double: ...
    @center_x.setter
    def center_x(self, value: winrt.system.Double) -> None: ...
    @_property
    def angle(self) -> winrt.system.Double: ...
    @angle.setter
    def angle(self, value: winrt.system.Double) -> None: ...

@typing.final
class ScaleTransform_Static(Transform_Static):
    @_property
    def center_x_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def center_y_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def scale_x_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def scale_y_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...

@typing.final
class ScaleTransform(Transform, metaclass=ScaleTransform_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ScaleTransform: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...
    @_property
    def scale_y(self) -> winrt.system.Double: ...
    @scale_y.setter
    def scale_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def scale_x(self) -> winrt.system.Double: ...
    @scale_x.setter
    def scale_x(self, value: winrt.system.Double) -> None: ...
    @_property
    def center_y(self) -> winrt.system.Double: ...
    @center_y.setter
    def center_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def center_x(self) -> winrt.system.Double: ...
    @center_x.setter
    def center_x(self, value: winrt.system.Double) -> None: ...

class Shadow_Static(microsoft_ui_xaml.DependencyObject_Static):
    pass

class Shadow(microsoft_ui_xaml.DependencyObject, metaclass=Shadow_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Shadow: ...

@typing.final
class SkewTransform_Static(Transform_Static):
    @_property
    def angle_x_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def angle_y_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def center_x_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def center_y_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...

@typing.final
class SkewTransform(Transform, metaclass=SkewTransform_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SkewTransform: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...
    @_property
    def center_y(self) -> winrt.system.Double: ...
    @center_y.setter
    def center_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def center_x(self) -> winrt.system.Double: ...
    @center_x.setter
    def center_x(self, value: winrt.system.Double) -> None: ...
    @_property
    def angle_y(self) -> winrt.system.Double: ...
    @angle_y.setter
    def angle_y(self, value: winrt.system.Double) -> None: ...
    @_property
    def angle_x(self) -> winrt.system.Double: ...
    @angle_x.setter
    def angle_x(self, value: winrt.system.Double) -> None: ...

@typing.final
class SolidColorBrush_Static(Brush_Static):
    @_property
    def color_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...

@typing.final
class SolidColorBrush(Brush, metaclass=SolidColorBrush_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SolidColorBrush: ...
    @typing.overload
    def __new__(cls: typing.Type[Self], color: windows_ui.Color) -> Self: ...
    @typing.overload
    def __new__(cls: typing.Type[Self]) -> Self: ...
    @_property
    def color(self) -> windows_ui.Color: ...
    @color.setter
    def color(self, value: windows_ui.Color) -> None: ...

class SystemBackdrop_Static(microsoft_ui_xaml.DependencyObject_Static):
    pass

class SystemBackdrop(microsoft_ui_xaml.DependencyObject, metaclass=SystemBackdrop_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> SystemBackdrop: ...
    def get_default_system_backdrop_configuration(self, target: microsoft_ui_composition.ImplementsICompositionSupportsSystemBackdrop, xaml_root: microsoft_ui_xaml.XamlRoot, /) -> microsoft_ui_composition_systembackdrops.SystemBackdropConfiguration: ...

class ThemeShadow_Static(Shadow_Static):
    pass

class ThemeShadow(Shadow, metaclass=ThemeShadow_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> ThemeShadow: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...
    @_property
    def receivers(self) -> microsoft_ui_xaml.UIElementWeakCollection: ...

class TileBrush_Static(Brush_Static):
    @_property
    def alignment_x_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def alignment_y_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def stretch_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...

class TileBrush(Brush, metaclass=TileBrush_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TileBrush: ...
    @_property
    def stretch(self) -> Stretch: ...
    @stretch.setter
    def stretch(self, value: Stretch) -> None: ...
    @_property
    def alignment_y(self) -> AlignmentY: ...
    @alignment_y.setter
    def alignment_y(self, value: AlignmentY) -> None: ...
    @_property
    def alignment_x(self) -> AlignmentX: ...
    @alignment_x.setter
    def alignment_x(self, value: AlignmentX) -> None: ...

class Transform_Static(GeneralTransform_Static):
    pass

class Transform(GeneralTransform, metaclass=Transform_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> Transform: ...

@typing.final
class TransformCollection(winrt.system.Object, winrt._winrt.MutableSequence[Transform]):
    def __len__(self) -> int: ...
    def __iter__(self) -> windows_foundation_collections.IIterator[Transform]: ...
    @typing.overload
    def __getitem__(self, index: typing.SupportsIndex) -> Transform: ...
    @typing.overload
    def __getitem__(self, index: slice) -> winrt.system.Array[Transform]: ...
    @typing.overload
    def __delitem__(self, index: typing.SupportsIndex) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: typing.SupportsIndex, value: Transform) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[Transform]) -> None: ...
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TransformCollection: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...
    def append(self, value: Transform, /) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> windows_foundation_collections.IIterator[Transform]: ...
    def get_at(self, index: winrt.system.UInt32, /) -> Transform: ...
    def get_many(self, start_index: winrt.system.UInt32, items: typing.Union[winrt.system.Array[Transform], winrt.system.WriteableBuffer], /) -> winrt.system.UInt32: ...
    def get_view(self) -> typing.Sequence[Transform]: ...
    def index_of(self, value: Transform, /) -> typing.Tuple[bool, winrt.system.UInt32]: ...
    def insert_at(self, index: winrt.system.UInt32, value: Transform, /) -> None: ...
    def remove_at(self, index: winrt.system.UInt32, /) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: typing.Union[winrt.system.Array[Transform], winrt.system.ReadableBuffer], /) -> None: ...
    def set_at(self, index: winrt.system.UInt32, value: Transform, /) -> None: ...
    @_property
    def size(self) -> winrt.system.UInt32: ...

@typing.final
class TransformGroup_Static(Transform_Static):
    @_property
    def children_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...

@typing.final
class TransformGroup(Transform, metaclass=TransformGroup_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TransformGroup: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...
    @_property
    def children(self) -> TransformCollection: ...
    @children.setter
    def children(self, value: TransformCollection) -> None: ...
    @_property
    def value(self) -> Matrix: ...

@typing.final
class TranslateTransform_Static(Transform_Static):
    @_property
    def x_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...
    @_property
    def y_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...

@typing.final
class TranslateTransform(Transform, metaclass=TranslateTransform_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> TranslateTransform: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...
    @_property
    def y(self) -> winrt.system.Double: ...
    @y.setter
    def y(self, value: winrt.system.Double) -> None: ...
    @_property
    def x(self) -> winrt.system.Double: ...
    @x.setter
    def x(self, value: winrt.system.Double) -> None: ...

@typing.final
class VisualTreeHelper_Static(type):
    def disconnect_children_recursive(cls, element: microsoft_ui_xaml.UIElement, /) -> None: ...
    def find_all_elements_in_host_coordinates_point(cls, intersecting_point: windows_foundation.Point, subtree: microsoft_ui_xaml.UIElement, include_all_elements: bool, /) -> typing.Iterable[microsoft_ui_xaml.UIElement]: ...
    def find_all_elements_in_host_coordinates_rect(cls, intersecting_rect: windows_foundation.Rect, subtree: microsoft_ui_xaml.UIElement, include_all_elements: bool, /) -> typing.Iterable[microsoft_ui_xaml.UIElement]: ...
    def find_elements_in_host_coordinates_point(cls, intersecting_point: windows_foundation.Point, subtree: microsoft_ui_xaml.UIElement, /) -> typing.Iterable[microsoft_ui_xaml.UIElement]: ...
    def find_elements_in_host_coordinates_rect(cls, intersecting_rect: windows_foundation.Rect, subtree: microsoft_ui_xaml.UIElement, /) -> typing.Iterable[microsoft_ui_xaml.UIElement]: ...
    def get_child(cls, reference: microsoft_ui_xaml.DependencyObject, child_index: winrt.system.Int32, /) -> microsoft_ui_xaml.DependencyObject: ...
    def get_children_count(cls, reference: microsoft_ui_xaml.DependencyObject, /) -> winrt.system.Int32: ...
    def get_open_popups(cls, window: microsoft_ui_xaml.Window, /) -> typing.Sequence[microsoft_ui_xaml_controls_primitives.Popup]: ...
    def get_open_popups_for_xaml_root(cls, xaml_root: microsoft_ui_xaml.XamlRoot, /) -> typing.Sequence[microsoft_ui_xaml_controls_primitives.Popup]: ...
    def get_parent(cls, reference: microsoft_ui_xaml.DependencyObject, /) -> microsoft_ui_xaml.DependencyObject: ...

@typing.final
class VisualTreeHelper(winrt.system.Object, metaclass=VisualTreeHelper_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> VisualTreeHelper: ...

class XamlCompositionBrushBase_Static(Brush_Static):
    @_property
    def fallback_color_property(cls) -> microsoft_ui_xaml.DependencyProperty: ...

class XamlCompositionBrushBase(Brush, metaclass=XamlCompositionBrushBase_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> XamlCompositionBrushBase: ...
    @_property
    def fallback_color(self) -> windows_ui.Color: ...
    @fallback_color.setter
    def fallback_color(self, value: windows_ui.Color) -> None: ...

class XamlLight_Static(microsoft_ui_xaml.DependencyObject_Static):
    def add_target_brush(cls, light_id: str, brush: Brush, /) -> None: ...
    def add_target_element(cls, light_id: str, element: microsoft_ui_xaml.UIElement, /) -> None: ...
    def remove_target_brush(cls, light_id: str, brush: Brush, /) -> None: ...
    def remove_target_element(cls, light_id: str, element: microsoft_ui_xaml.UIElement, /) -> None: ...

class XamlLight(microsoft_ui_xaml.DependencyObject, metaclass=XamlLight_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> XamlLight: ...
    def __new__(cls: typing.Type[Self]) -> Self: ...

