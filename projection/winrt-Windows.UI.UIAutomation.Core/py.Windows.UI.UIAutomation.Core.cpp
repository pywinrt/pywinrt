// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.2.0

#include "py.Windows.UI.UIAutomation.Core.h"

namespace py::cpp::Windows::UI::UIAutomation::Core
{
    // ----- AutomationRemoteOperationResult class --------------------

    static PyObject* _new_AutomationRemoteOperationResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationResult>::type_name);
        return nullptr;
    }

    static void _dealloc_AutomationRemoteOperationResult(py::wrapper::Windows::UI::UIAutomation::Core::AutomationRemoteOperationResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AutomationRemoteOperationResult_GetOperand(py::wrapper::Windows::UI::UIAutomation::Core::AutomationRemoteOperationResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.AutomationRemoteOperationResult", L"GetOperand", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>(args, 0);

                return py::convert(self->obj.GetOperand(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationRemoteOperationResult_HasOperand(py::wrapper::Windows::UI::UIAutomation::Core::AutomationRemoteOperationResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.AutomationRemoteOperationResult", L"HasOperand", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>(args, 0);

                return py::convert(self->obj.HasOperand(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationRemoteOperationResult_get_ErrorLocation(py::wrapper::Windows::UI::UIAutomation::Core::AutomationRemoteOperationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.UIAutomation.Core.AutomationRemoteOperationResult", L"ErrorLocation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ErrorLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationRemoteOperationResult_get_ExtendedError(py::wrapper::Windows::UI::UIAutomation::Core::AutomationRemoteOperationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.UIAutomation.Core.AutomationRemoteOperationResult", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationRemoteOperationResult_get_Status(py::wrapper::Windows::UI::UIAutomation::Core::AutomationRemoteOperationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.UIAutomation.Core.AutomationRemoteOperationResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AutomationRemoteOperationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AutomationRemoteOperationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AutomationRemoteOperationResult[] = {
        { "get_operand", reinterpret_cast<PyCFunction>(AutomationRemoteOperationResult_GetOperand), METH_VARARGS, nullptr },
        { "has_operand", reinterpret_cast<PyCFunction>(AutomationRemoteOperationResult_HasOperand), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AutomationRemoteOperationResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AutomationRemoteOperationResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AutomationRemoteOperationResult[] = {
        { "error_location", reinterpret_cast<getter>(AutomationRemoteOperationResult_get_ErrorLocation), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(AutomationRemoteOperationResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(AutomationRemoteOperationResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AutomationRemoteOperationResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AutomationRemoteOperationResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AutomationRemoteOperationResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AutomationRemoteOperationResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AutomationRemoteOperationResult) },
        { }
    };

    static PyType_Spec type_spec_AutomationRemoteOperationResult = {
        "winrt._winrt_windows_ui_uiautomation_core.AutomationRemoteOperationResult",
        sizeof(py::wrapper::Windows::UI::UIAutomation::Core::AutomationRemoteOperationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AutomationRemoteOperationResult};

    // ----- CoreAutomationRegistrar class --------------------

    static PyObject* _new_CoreAutomationRegistrar(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::UIAutomation::Core::CoreAutomationRegistrar>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::UIAutomation::Core::CoreAutomationRegistrar>::type_name);
        return nullptr;
    }

    static PyObject* CoreAutomationRegistrar_RegisterAnnotationType(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.CoreAutomationRegistrar", L"RegisterAnnotationType", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(winrt::Windows::UI::UIAutomation::Core::CoreAutomationRegistrar::RegisterAnnotationType(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreAutomationRegistrar_UnregisterAnnotationType(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.CoreAutomationRegistrar", L"UnregisterAnnotationType", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration>(args, 0);

                winrt::Windows::UI::UIAutomation::Core::CoreAutomationRegistrar::UnregisterAnnotationType(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreAutomationRegistrar[] = {
        { }
    };

    static PyGetSetDef _getset_CoreAutomationRegistrar[] = {
        { }
    };

    static PyType_Slot _type_slots_CoreAutomationRegistrar[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreAutomationRegistrar) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreAutomationRegistrar) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreAutomationRegistrar) },
        { }
    };

    static PyType_Spec type_spec_CoreAutomationRegistrar = {
        "winrt._winrt_windows_ui_uiautomation_core.CoreAutomationRegistrar",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreAutomationRegistrar};

    static PyGetSetDef getset_CoreAutomationRegistrar_Static[] = {
        { }
    };

    static PyMethodDef methods_CoreAutomationRegistrar_Static[] = {
        { "register_annotation_type", reinterpret_cast<PyCFunction>(CoreAutomationRegistrar_RegisterAnnotationType), METH_VARARGS, nullptr },
        { "unregister_annotation_type", reinterpret_cast<PyCFunction>(CoreAutomationRegistrar_UnregisterAnnotationType), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_CoreAutomationRegistrar_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CoreAutomationRegistrar_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CoreAutomationRegistrar_Static) },
        { }
    };

    static PyType_Spec type_spec_CoreAutomationRegistrar_Static =
    {
        "winrt._winrt_windows_ui_uiautomation_core.CoreAutomationRegistrar_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CoreAutomationRegistrar_Static
    };

    // ----- CoreAutomationRemoteOperation class --------------------

    static PyObject* _new_CoreAutomationRemoteOperation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperation instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CoreAutomationRemoteOperation(py::wrapper::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreAutomationRemoteOperation_AddToResults(py::wrapper::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.CoreAutomationRemoteOperation", L"AddToResults", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>(args, 0);

                self->obj.AddToResults(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreAutomationRemoteOperation_Execute(py::wrapper::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.CoreAutomationRemoteOperation", L"Execute", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                return py::convert(self->obj.Execute(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreAutomationRemoteOperation_ImportConnectionBoundObject(py::wrapper::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.CoreAutomationRemoteOperation", L"ImportConnectionBoundObject", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::UIAutomation::AutomationConnectionBoundObject>(args, 1);

                self->obj.ImportConnectionBoundObject(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreAutomationRemoteOperation_ImportElement(py::wrapper::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.CoreAutomationRemoteOperation", L"ImportElement", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::UIAutomation::AutomationElement>(args, 1);

                self->obj.ImportElement(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreAutomationRemoteOperation_ImportTextRange(py::wrapper::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.CoreAutomationRemoteOperation", L"ImportTextRange", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::UIAutomation::AutomationTextRange>(args, 1);

                self->obj.ImportTextRange(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreAutomationRemoteOperation_IsOpcodeSupported(py::wrapper::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.CoreAutomationRemoteOperation", L"IsOpcodeSupported", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.IsOpcodeSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreAutomationRemoteOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreAutomationRemoteOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreAutomationRemoteOperation[] = {
        { "add_to_results", reinterpret_cast<PyCFunction>(CoreAutomationRemoteOperation_AddToResults), METH_VARARGS, nullptr },
        { "execute", reinterpret_cast<PyCFunction>(CoreAutomationRemoteOperation_Execute), METH_VARARGS, nullptr },
        { "import_connection_bound_object", reinterpret_cast<PyCFunction>(CoreAutomationRemoteOperation_ImportConnectionBoundObject), METH_VARARGS, nullptr },
        { "import_element", reinterpret_cast<PyCFunction>(CoreAutomationRemoteOperation_ImportElement), METH_VARARGS, nullptr },
        { "import_text_range", reinterpret_cast<PyCFunction>(CoreAutomationRemoteOperation_ImportTextRange), METH_VARARGS, nullptr },
        { "is_opcode_supported", reinterpret_cast<PyCFunction>(CoreAutomationRemoteOperation_IsOpcodeSupported), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreAutomationRemoteOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreAutomationRemoteOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreAutomationRemoteOperation[] = {
        { }
    };

    static PyType_Slot _type_slots_CoreAutomationRemoteOperation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreAutomationRemoteOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreAutomationRemoteOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreAutomationRemoteOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreAutomationRemoteOperation) },
        { }
    };

    static PyType_Spec type_spec_CoreAutomationRemoteOperation = {
        "winrt._winrt_windows_ui_uiautomation_core.CoreAutomationRemoteOperation",
        sizeof(py::wrapper::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreAutomationRemoteOperation};

    // ----- CoreAutomationRemoteOperationContext class --------------------

    static PyObject* _new_CoreAutomationRemoteOperationContext(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperationContext>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperationContext>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreAutomationRemoteOperationContext(py::wrapper::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperationContext* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreAutomationRemoteOperationContext_GetOperand(py::wrapper::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperationContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.CoreAutomationRemoteOperationContext", L"GetOperand", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>(args, 0);

                return py::convert(self->obj.GetOperand(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreAutomationRemoteOperationContext_SetOperand(py::wrapper::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperationContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.CoreAutomationRemoteOperationContext", L"SetOperand", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.SetOperand(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.CoreAutomationRemoteOperationContext", L"SetOperand", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);

                self->obj.SetOperand(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreAutomationRemoteOperationContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperationContext>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreAutomationRemoteOperationContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperationContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreAutomationRemoteOperationContext[] = {
        { "get_operand", reinterpret_cast<PyCFunction>(CoreAutomationRemoteOperationContext_GetOperand), METH_VARARGS, nullptr },
        { "set_operand", reinterpret_cast<PyCFunction>(CoreAutomationRemoteOperationContext_SetOperand), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreAutomationRemoteOperationContext, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreAutomationRemoteOperationContext), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreAutomationRemoteOperationContext[] = {
        { }
    };

    static PyType_Slot _type_slots_CoreAutomationRemoteOperationContext[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreAutomationRemoteOperationContext) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreAutomationRemoteOperationContext) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreAutomationRemoteOperationContext) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreAutomationRemoteOperationContext) },
        { }
    };

    static PyType_Spec type_spec_CoreAutomationRemoteOperationContext = {
        "winrt._winrt_windows_ui_uiautomation_core.CoreAutomationRemoteOperationContext",
        sizeof(py::wrapper::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperationContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreAutomationRemoteOperationContext};

    // ----- RemoteAutomationClientSession class --------------------

    static PyObject* _new_RemoteAutomationClientSession(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);

                winrt::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RemoteAutomationClientSession(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteAutomationClientSession_CreateWindowAsync(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.RemoteAutomationClientSession", L"CreateWindowAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);

                return py::convert(self->obj.CreateWindowAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteAutomationClientSession_Start(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.RemoteAutomationClientSession", L"Start", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteAutomationClientSession_Stop(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.RemoteAutomationClientSession", L"Stop", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteAutomationClientSession_get_SessionId(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.UIAutomation.Core.RemoteAutomationClientSession", L"SessionId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SessionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteAutomationClientSession_add_ConnectionRequested(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.UIAutomation.Core.RemoteAutomationClientSession", L"ConnectionRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession, winrt::Windows::UI::UIAutomation::Core::RemoteAutomationConnectionRequestedEventArgs>>(arg);

            return py::convert(self->obj.ConnectionRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteAutomationClientSession_remove_ConnectionRequested(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.UIAutomation.Core.RemoteAutomationClientSession", L"ConnectionRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ConnectionRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteAutomationClientSession_add_Disconnected(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.UIAutomation.Core.RemoteAutomationClientSession", L"Disconnected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession, winrt::Windows::UI::UIAutomation::Core::RemoteAutomationDisconnectedEventArgs>>(arg);

            return py::convert(self->obj.Disconnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteAutomationClientSession_remove_Disconnected(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.UIAutomation.Core.RemoteAutomationClientSession", L"Disconnected");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Disconnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteAutomationClientSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteAutomationClientSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteAutomationClientSession[] = {
        { "create_window_async", reinterpret_cast<PyCFunction>(RemoteAutomationClientSession_CreateWindowAsync), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(RemoteAutomationClientSession_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(RemoteAutomationClientSession_Stop), METH_VARARGS, nullptr },
        { "add_connection_requested", reinterpret_cast<PyCFunction>(RemoteAutomationClientSession_add_ConnectionRequested), METH_O, nullptr },
        { "remove_connection_requested", reinterpret_cast<PyCFunction>(RemoteAutomationClientSession_remove_ConnectionRequested), METH_O, nullptr },
        { "add_disconnected", reinterpret_cast<PyCFunction>(RemoteAutomationClientSession_add_Disconnected), METH_O, nullptr },
        { "remove_disconnected", reinterpret_cast<PyCFunction>(RemoteAutomationClientSession_remove_Disconnected), METH_O, nullptr },
        { "_assign_array_", _assign_array_RemoteAutomationClientSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteAutomationClientSession), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteAutomationClientSession[] = {
        { "session_id", reinterpret_cast<getter>(RemoteAutomationClientSession_get_SessionId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteAutomationClientSession[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteAutomationClientSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteAutomationClientSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteAutomationClientSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteAutomationClientSession) },
        { }
    };

    static PyType_Spec type_spec_RemoteAutomationClientSession = {
        "winrt._winrt_windows_ui_uiautomation_core.RemoteAutomationClientSession",
        sizeof(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteAutomationClientSession};

    // ----- RemoteAutomationConnectionRequestedEventArgs class --------------------

    static PyObject* _new_RemoteAutomationConnectionRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationConnectionRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationConnectionRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RemoteAutomationConnectionRequestedEventArgs(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationConnectionRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteAutomationConnectionRequestedEventArgs_get_LocalPipeName(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationConnectionRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.UIAutomation.Core.RemoteAutomationConnectionRequestedEventArgs", L"LocalPipeName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LocalPipeName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteAutomationConnectionRequestedEventArgs_get_RemoteProcessId(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationConnectionRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.UIAutomation.Core.RemoteAutomationConnectionRequestedEventArgs", L"RemoteProcessId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RemoteProcessId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteAutomationConnectionRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationConnectionRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteAutomationConnectionRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationConnectionRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteAutomationConnectionRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_RemoteAutomationConnectionRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteAutomationConnectionRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteAutomationConnectionRequestedEventArgs[] = {
        { "local_pipe_name", reinterpret_cast<getter>(RemoteAutomationConnectionRequestedEventArgs_get_LocalPipeName), nullptr, nullptr, nullptr },
        { "remote_process_id", reinterpret_cast<getter>(RemoteAutomationConnectionRequestedEventArgs_get_RemoteProcessId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteAutomationConnectionRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteAutomationConnectionRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteAutomationConnectionRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteAutomationConnectionRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteAutomationConnectionRequestedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_RemoteAutomationConnectionRequestedEventArgs = {
        "winrt._winrt_windows_ui_uiautomation_core.RemoteAutomationConnectionRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationConnectionRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteAutomationConnectionRequestedEventArgs};

    // ----- RemoteAutomationDisconnectedEventArgs class --------------------

    static PyObject* _new_RemoteAutomationDisconnectedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationDisconnectedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationDisconnectedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_RemoteAutomationDisconnectedEventArgs(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationDisconnectedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteAutomationDisconnectedEventArgs_get_LocalPipeName(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationDisconnectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.UIAutomation.Core.RemoteAutomationDisconnectedEventArgs", L"LocalPipeName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LocalPipeName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteAutomationDisconnectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationDisconnectedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteAutomationDisconnectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationDisconnectedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteAutomationDisconnectedEventArgs[] = {
        { "_assign_array_", _assign_array_RemoteAutomationDisconnectedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteAutomationDisconnectedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteAutomationDisconnectedEventArgs[] = {
        { "local_pipe_name", reinterpret_cast<getter>(RemoteAutomationDisconnectedEventArgs_get_LocalPipeName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteAutomationDisconnectedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteAutomationDisconnectedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteAutomationDisconnectedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteAutomationDisconnectedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteAutomationDisconnectedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_RemoteAutomationDisconnectedEventArgs = {
        "winrt._winrt_windows_ui_uiautomation_core.RemoteAutomationDisconnectedEventArgs",
        sizeof(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationDisconnectedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteAutomationDisconnectedEventArgs};

    // ----- RemoteAutomationServer class --------------------

    static PyObject* _new_RemoteAutomationServer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationServer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationServer>::type_name);
        return nullptr;
    }

    static PyObject* RemoteAutomationServer_ReportSession(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.RemoteAutomationServer", L"ReportSession", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);

                winrt::Windows::UI::UIAutomation::Core::RemoteAutomationServer::ReportSession(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteAutomationServer[] = {
        { }
    };

    static PyGetSetDef _getset_RemoteAutomationServer[] = {
        { }
    };

    static PyType_Slot _type_slots_RemoteAutomationServer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteAutomationServer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteAutomationServer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteAutomationServer) },
        { }
    };

    static PyType_Spec type_spec_RemoteAutomationServer = {
        "winrt._winrt_windows_ui_uiautomation_core.RemoteAutomationServer",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteAutomationServer};

    static PyGetSetDef getset_RemoteAutomationServer_Static[] = {
        { }
    };

    static PyMethodDef methods_RemoteAutomationServer_Static[] = {
        { "report_session", reinterpret_cast<PyCFunction>(RemoteAutomationServer_ReportSession), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_RemoteAutomationServer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RemoteAutomationServer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RemoteAutomationServer_Static) },
        { }
    };

    static PyType_Spec type_spec_RemoteAutomationServer_Static =
    {
        "winrt._winrt_windows_ui_uiautomation_core.RemoteAutomationServer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RemoteAutomationServer_Static
    };

    // ----- RemoteAutomationWindow class --------------------

    static PyObject* _new_RemoteAutomationWindow(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationWindow>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationWindow>::type_name);
        return nullptr;
    }

    static void _dealloc_RemoteAutomationWindow(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationWindow* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteAutomationWindow_UnregisterAsync(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.RemoteAutomationWindow", L"UnregisterAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.UnregisterAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteAutomationWindow_get_AutomationProvider(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationWindow* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.UIAutomation.Core.RemoteAutomationWindow", L"AutomationProvider");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AutomationProvider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RemoteAutomationWindow(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationWindow>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RemoteAutomationWindow(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationWindow>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteAutomationWindow[] = {
        { "unregister_async", reinterpret_cast<PyCFunction>(RemoteAutomationWindow_UnregisterAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RemoteAutomationWindow, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteAutomationWindow), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteAutomationWindow[] = {
        { "automation_provider", reinterpret_cast<getter>(RemoteAutomationWindow_get_AutomationProvider), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteAutomationWindow[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RemoteAutomationWindow) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RemoteAutomationWindow) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RemoteAutomationWindow) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RemoteAutomationWindow) },
        { }
    };

    static PyType_Spec type_spec_RemoteAutomationWindow = {
        "winrt._winrt_windows_ui_uiautomation_core.RemoteAutomationWindow",
        sizeof(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationWindow),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteAutomationWindow};

    // ----- ICoreAutomationConnectionBoundObjectProvider interface --------------------

    static PyObject* _new_ICoreAutomationConnectionBoundObjectProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::UIAutomation::Core::ICoreAutomationConnectionBoundObjectProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::UIAutomation::Core::ICoreAutomationConnectionBoundObjectProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_ICoreAutomationConnectionBoundObjectProvider(py::wrapper::Windows::UI::UIAutomation::Core::ICoreAutomationConnectionBoundObjectProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICoreAutomationConnectionBoundObjectProvider_get_IsComThreadingRequired(py::wrapper::Windows::UI::UIAutomation::Core::ICoreAutomationConnectionBoundObjectProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.UIAutomation.Core.ICoreAutomationConnectionBoundObjectProvider", L"IsComThreadingRequired");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsComThreadingRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ICoreAutomationConnectionBoundObjectProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::UIAutomation::Core::ICoreAutomationConnectionBoundObjectProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICoreAutomationConnectionBoundObjectProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::UIAutomation::Core::ICoreAutomationConnectionBoundObjectProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICoreAutomationConnectionBoundObjectProvider[] = {
        { "_assign_array_", _assign_array_ICoreAutomationConnectionBoundObjectProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICoreAutomationConnectionBoundObjectProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICoreAutomationConnectionBoundObjectProvider[] = {
        { "is_com_threading_required", reinterpret_cast<getter>(ICoreAutomationConnectionBoundObjectProvider_get_IsComThreadingRequired), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ICoreAutomationConnectionBoundObjectProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICoreAutomationConnectionBoundObjectProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICoreAutomationConnectionBoundObjectProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICoreAutomationConnectionBoundObjectProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICoreAutomationConnectionBoundObjectProvider) },
        { }
    };

    static PyType_Spec type_spec_ICoreAutomationConnectionBoundObjectProvider = {
        "winrt._winrt_windows_ui_uiautomation_core.ICoreAutomationConnectionBoundObjectProvider",
        sizeof(py::wrapper::Windows::UI::UIAutomation::Core::ICoreAutomationConnectionBoundObjectProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICoreAutomationConnectionBoundObjectProvider};

    // ----- ICoreAutomationRemoteOperationExtensionProvider interface --------------------

    static PyObject* _new_ICoreAutomationRemoteOperationExtensionProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::UIAutomation::Core::ICoreAutomationRemoteOperationExtensionProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::UIAutomation::Core::ICoreAutomationRemoteOperationExtensionProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_ICoreAutomationRemoteOperationExtensionProvider(py::wrapper::Windows::UI::UIAutomation::Core::ICoreAutomationRemoteOperationExtensionProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICoreAutomationRemoteOperationExtensionProvider_CallExtension(py::wrapper::Windows::UI::UIAutomation::Core::ICoreAutomationRemoteOperationExtensionProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.ICoreAutomationRemoteOperationExtensionProvider", L"CallExtension", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperationContext>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId, false>>(args, 2);

                self->obj.CallExtension(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICoreAutomationRemoteOperationExtensionProvider_IsExtensionSupported(py::wrapper::Windows::UI::UIAutomation::Core::ICoreAutomationRemoteOperationExtensionProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.UIAutomation.Core.ICoreAutomationRemoteOperationExtensionProvider", L"IsExtensionSupported", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.IsExtensionSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ICoreAutomationRemoteOperationExtensionProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::UIAutomation::Core::ICoreAutomationRemoteOperationExtensionProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICoreAutomationRemoteOperationExtensionProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::UIAutomation::Core::ICoreAutomationRemoteOperationExtensionProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICoreAutomationRemoteOperationExtensionProvider[] = {
        { "call_extension", reinterpret_cast<PyCFunction>(ICoreAutomationRemoteOperationExtensionProvider_CallExtension), METH_VARARGS, nullptr },
        { "is_extension_supported", reinterpret_cast<PyCFunction>(ICoreAutomationRemoteOperationExtensionProvider_IsExtensionSupported), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ICoreAutomationRemoteOperationExtensionProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICoreAutomationRemoteOperationExtensionProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICoreAutomationRemoteOperationExtensionProvider[] = {
        { }
    };

    static PyType_Slot _type_slots_ICoreAutomationRemoteOperationExtensionProvider[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICoreAutomationRemoteOperationExtensionProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICoreAutomationRemoteOperationExtensionProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICoreAutomationRemoteOperationExtensionProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICoreAutomationRemoteOperationExtensionProvider) },
        { }
    };

    static PyType_Spec type_spec_ICoreAutomationRemoteOperationExtensionProvider = {
        "winrt._winrt_windows_ui_uiautomation_core.ICoreAutomationRemoteOperationExtensionProvider",
        sizeof(py::wrapper::Windows::UI::UIAutomation::Core::ICoreAutomationRemoteOperationExtensionProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICoreAutomationRemoteOperationExtensionProvider};

    // ----- AutomationAnnotationTypeRegistration struct --------------------

    winrt_struct_wrapper<winrt::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration>* _new_AutomationAnnotationTypeRegistration(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_AutomationAnnotationTypeRegistration(winrt_struct_wrapper<winrt::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        int32_t _LocalId{};

        static const char* kwlist[] = {"local_id", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "i", const_cast<char**>(kwlist), &_LocalId))
        {
            return -1;
        }

        try
        {
            self->obj.LocalId = _LocalId;

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_AutomationAnnotationTypeRegistration(py::wrapper::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_AutomationAnnotationTypeRegistration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_AutomationAnnotationTypeRegistration[] = {
        { "_assign_array_", _assign_array_AutomationAnnotationTypeRegistration, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* AutomationAnnotationTypeRegistration_get_LocalId(py::wrapper::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalId);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutomationAnnotationTypeRegistration_set_LocalId(py::wrapper::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.LocalId = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_AutomationAnnotationTypeRegistration[] = {
        { "local_id", reinterpret_cast<getter>(AutomationAnnotationTypeRegistration_get_LocalId), reinterpret_cast<setter>(AutomationAnnotationTypeRegistration_set_LocalId), nullptr, nullptr },
        { }
    };

    static PyObject* _richcompare_AutomationAnnotationTypeRegistration(py::wrapper::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::converter<winrt::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration>::convert_to(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_AutomationAnnotationTypeRegistration(PyObject* self) noexcept
    {
        py::pyobj_handle LocalId{PyObject_GetAttrString(self, "local_id")};
        if (!LocalId)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("AutomationAnnotationTypeRegistration(local_id=%R)", LocalId.get());
    }

    static PyType_Slot _type_slots_AutomationAnnotationTypeRegistration[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AutomationAnnotationTypeRegistration) },
        { Py_tp_init, reinterpret_cast<void*>(_init_AutomationAnnotationTypeRegistration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AutomationAnnotationTypeRegistration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AutomationAnnotationTypeRegistration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AutomationAnnotationTypeRegistration) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_AutomationAnnotationTypeRegistration) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_AutomationAnnotationTypeRegistration) },
        { }
    };

    static PyType_Spec type_spec_AutomationAnnotationTypeRegistration = {
        "winrt._winrt_windows_ui_uiautomation_core.AutomationAnnotationTypeRegistration",
        sizeof(py::wrapper::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AutomationAnnotationTypeRegistration};

    // ----- AutomationRemoteOperationOperandId struct --------------------

    winrt_struct_wrapper<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>* _new_AutomationRemoteOperationOperandId(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_AutomationRemoteOperationOperandId(winrt_struct_wrapper<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        int32_t _Value{};

        static const char* kwlist[] = {"value", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "i", const_cast<char**>(kwlist), &_Value))
        {
            return -1;
        }

        try
        {
            self->obj.Value = _Value;

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_AutomationRemoteOperationOperandId(py::wrapper::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_AutomationRemoteOperationOperandId(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_AutomationRemoteOperationOperandId[] = {
        { "_assign_array_", _assign_array_AutomationRemoteOperationOperandId, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* AutomationRemoteOperationOperandId_get_Value(py::wrapper::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutomationRemoteOperationOperandId_set_Value(py::wrapper::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Value = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_AutomationRemoteOperationOperandId[] = {
        { "value", reinterpret_cast<getter>(AutomationRemoteOperationOperandId_get_Value), reinterpret_cast<setter>(AutomationRemoteOperationOperandId_set_Value), nullptr, nullptr },
        { }
    };

    static PyObject* _richcompare_AutomationRemoteOperationOperandId(py::wrapper::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::converter<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>::convert_to(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_AutomationRemoteOperationOperandId(PyObject* self) noexcept
    {
        py::pyobj_handle Value{PyObject_GetAttrString(self, "value")};
        if (!Value)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("AutomationRemoteOperationOperandId(value=%R)", Value.get());
    }

    static PyType_Slot _type_slots_AutomationRemoteOperationOperandId[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AutomationRemoteOperationOperandId) },
        { Py_tp_init, reinterpret_cast<void*>(_init_AutomationRemoteOperationOperandId) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AutomationRemoteOperationOperandId) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AutomationRemoteOperationOperandId) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AutomationRemoteOperationOperandId) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_AutomationRemoteOperationOperandId) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_AutomationRemoteOperationOperandId) },
        { }
    };

    static PyType_Spec type_spec_AutomationRemoteOperationOperandId = {
        "winrt._winrt_windows_ui_uiautomation_core.AutomationRemoteOperationOperandId",
        sizeof(py::wrapper::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AutomationRemoteOperationOperandId};

    // ----- Windows.UI.UIAutomation.Core Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.UI.UIAutomation.Core");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_ui_uiautomation_core",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::UI::UIAutomation::Core

PyMODINIT_FUNC PyInit__winrt_windows_ui_uiautomation_core(void) noexcept
{
    using namespace py::cpp::Windows::UI::UIAutomation::Core;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle AutomationRemoteOperationResult_type{py::register_python_type(module.get(), &type_spec_AutomationRemoteOperationResult, object_bases.get(), nullptr)};
    if (!AutomationRemoteOperationResult_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_CoreAutomationRegistrar_Static{PyType_FromSpec(&type_spec_CoreAutomationRegistrar_Static)};
    if (!type_CoreAutomationRegistrar_Static)
    {
        return nullptr;
    }

    py::pytype_handle CoreAutomationRegistrar_type{py::register_python_type(module.get(), &type_spec_CoreAutomationRegistrar, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CoreAutomationRegistrar_Static.get()))};
    if (!CoreAutomationRegistrar_type)
    {
        return nullptr;
    }

    py::pytype_handle CoreAutomationRemoteOperation_type{py::register_python_type(module.get(), &type_spec_CoreAutomationRemoteOperation, object_bases.get(), nullptr)};
    if (!CoreAutomationRemoteOperation_type)
    {
        return nullptr;
    }

    py::pytype_handle CoreAutomationRemoteOperationContext_type{py::register_python_type(module.get(), &type_spec_CoreAutomationRemoteOperationContext, object_bases.get(), nullptr)};
    if (!CoreAutomationRemoteOperationContext_type)
    {
        return nullptr;
    }

    py::pytype_handle RemoteAutomationClientSession_type{py::register_python_type(module.get(), &type_spec_RemoteAutomationClientSession, object_bases.get(), nullptr)};
    if (!RemoteAutomationClientSession_type)
    {
        return nullptr;
    }

    py::pytype_handle RemoteAutomationConnectionRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_RemoteAutomationConnectionRequestedEventArgs, object_bases.get(), nullptr)};
    if (!RemoteAutomationConnectionRequestedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle RemoteAutomationDisconnectedEventArgs_type{py::register_python_type(module.get(), &type_spec_RemoteAutomationDisconnectedEventArgs, object_bases.get(), nullptr)};
    if (!RemoteAutomationDisconnectedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_RemoteAutomationServer_Static{PyType_FromSpec(&type_spec_RemoteAutomationServer_Static)};
    if (!type_RemoteAutomationServer_Static)
    {
        return nullptr;
    }

    py::pytype_handle RemoteAutomationServer_type{py::register_python_type(module.get(), &type_spec_RemoteAutomationServer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RemoteAutomationServer_Static.get()))};
    if (!RemoteAutomationServer_type)
    {
        return nullptr;
    }

    py::pytype_handle RemoteAutomationWindow_type{py::register_python_type(module.get(), &type_spec_RemoteAutomationWindow, object_bases.get(), nullptr)};
    if (!RemoteAutomationWindow_type)
    {
        return nullptr;
    }

    py::pytype_handle ICoreAutomationConnectionBoundObjectProvider_type{py::register_python_type(module.get(), &type_spec_ICoreAutomationConnectionBoundObjectProvider, object_bases.get(), nullptr)};
    if (!ICoreAutomationConnectionBoundObjectProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ICoreAutomationRemoteOperationExtensionProvider_type{py::register_python_type(module.get(), &type_spec_ICoreAutomationRemoteOperationExtensionProvider, object_bases.get(), nullptr)};
    if (!ICoreAutomationRemoteOperationExtensionProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle AutomationAnnotationTypeRegistration_type{py::register_python_type(module.get(), &type_spec_AutomationAnnotationTypeRegistration, nullptr, nullptr)};
    if (!AutomationAnnotationTypeRegistration_type)
    {
        return nullptr;
    }

    py::pytype_handle AutomationRemoteOperationOperandId_type{py::register_python_type(module.get(), &type_spec_AutomationRemoteOperationOperandId, nullptr, nullptr)};
    if (!AutomationRemoteOperationOperandId_type)
    {
        return nullptr;
    }


    return module.detach();
}
