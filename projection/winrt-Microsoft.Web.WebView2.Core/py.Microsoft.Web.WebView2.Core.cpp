// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Microsoft.Web.WebView2.Core.h"


namespace py::cpp::Microsoft::Web::WebView2::Core
{
    // ----- CoreWebView2 class --------------------

    static PyObject* _new_CoreWebView2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2_AddHostObjectToScript(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"AddHostObjectToScript", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.AddHostObjectToScript(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_AddScriptToExecuteOnDocumentCreatedAsync(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"AddScriptToExecuteOnDocumentCreatedAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.AddScriptToExecuteOnDocumentCreatedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_AddWebResourceRequestedFilter(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"AddWebResourceRequestedFilter", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceContext>(args, 1);

                self->obj.AddWebResourceRequestedFilter(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_CallDevToolsProtocolMethodAsync(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"CallDevToolsProtocolMethodAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.CallDevToolsProtocolMethodAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_CallDevToolsProtocolMethodForSessionAsync(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"CallDevToolsProtocolMethodForSessionAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.CallDevToolsProtocolMethodForSessionAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_CapturePreviewAsync(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"CapturePreviewAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2CapturePreviewImageFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                return py::convert(self->obj.CapturePreviewAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_ClearServerCertificateErrorActionsAsync(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"ClearServerCertificateErrorActionsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ClearServerCertificateErrorActionsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_ClearVirtualHostNameToFolderMapping(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"ClearVirtualHostNameToFolderMapping", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.ClearVirtualHostNameToFolderMapping(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_CloseDefaultDownloadDialog(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"CloseDefaultDownloadDialog", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.CloseDefaultDownloadDialog();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_ExecuteScriptAsync(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"ExecuteScriptAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ExecuteScriptAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_GetDevToolsProtocolEventReceiver(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"GetDevToolsProtocolEventReceiver", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetDevToolsProtocolEventReceiver(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_GetFaviconAsync(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"GetFaviconAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2FaviconImageFormat>(args, 0);

                return py::convert(self->obj.GetFaviconAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_GoBack(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"GoBack", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.GoBack();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_GoForward(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"GoForward", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.GoForward();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_Navigate(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"Navigate", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Navigate(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_NavigateToString(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"NavigateToString", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.NavigateToString(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_NavigateWithWebResourceRequest(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"NavigateWithWebResourceRequest", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceRequest>(args, 0);

                self->obj.NavigateWithWebResourceRequest(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_OpenDefaultDownloadDialog(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"OpenDefaultDownloadDialog", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.OpenDefaultDownloadDialog();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_OpenDevToolsWindow(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"OpenDevToolsWindow", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.OpenDevToolsWindow();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_OpenTaskManagerWindow(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"OpenTaskManagerWindow", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.OpenTaskManagerWindow();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_PostSharedBufferToScript(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"PostSharedBufferToScript", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2SharedBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2SharedBufferAccess>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                self->obj.PostSharedBufferToScript(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_PostWebMessageAsJson(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"PostWebMessageAsJson", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.PostWebMessageAsJson(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_PostWebMessageAsString(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"PostWebMessageAsString", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.PostWebMessageAsString(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_PrintAsync(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"PrintAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings>(args, 0);

                return py::convert(self->obj.PrintAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_PrintToPdfAsync(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"PrintToPdfAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings>(args, 1);

                return py::convert(self->obj.PrintToPdfAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_PrintToPdfStreamAsync(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"PrintToPdfStreamAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings>(args, 0);

                return py::convert(self->obj.PrintToPdfStreamAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_Reload(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"Reload", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Reload();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_RemoveHostObjectFromScript(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"RemoveHostObjectFromScript", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.RemoveHostObjectFromScript(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_RemoveScriptToExecuteOnDocumentCreated(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"RemoveScriptToExecuteOnDocumentCreated", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.RemoveScriptToExecuteOnDocumentCreated(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_RemoveWebResourceRequestedFilter(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"RemoveWebResourceRequestedFilter", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceContext>(args, 1);

                self->obj.RemoveWebResourceRequestedFilter(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_Resume(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"Resume", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Resume();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_SetVirtualHostNameToFolderMapping(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"SetVirtualHostNameToFolderMapping", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2HostResourceAccessKind>(args, 2);

                self->obj.SetVirtualHostNameToFolderMapping(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_ShowPrintUI(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"ShowPrintUI", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2PrintDialogKind>(args, 0);

                self->obj.ShowPrintUI(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_Stop(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_TrySuspendAsync(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"TrySuspendAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TrySuspendAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_get_BrowserProcessId(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"BrowserProcessId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BrowserProcessId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_get_CanGoBack(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"CanGoBack"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanGoBack());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_get_CanGoForward(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"CanGoForward"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanGoForward());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_get_ContainsFullScreenElement(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"ContainsFullScreenElement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContainsFullScreenElement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_get_DocumentTitle(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"DocumentTitle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DocumentTitle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_get_Settings(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"Settings"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Settings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_get_Source(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"Source"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_get_StatusBarText(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"StatusBarText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StatusBarText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_get_Profile(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"Profile"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Profile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_get_FaviconUri(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"FaviconUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FaviconUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_get_MemoryUsageTargetLevel(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"MemoryUsageTargetLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MemoryUsageTargetLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2_put_MemoryUsageTargetLevel(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"MemoryUsageTargetLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2MemoryUsageTargetLevel>(arg);

            self->obj.MemoryUsageTargetLevel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2_get_CookieManager(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"CookieManager"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CookieManager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_get_Environment(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"Environment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Environment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_get_IsSuspended(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"IsSuspended"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSuspended());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_get_IsMuted(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"IsMuted"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsMuted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2_put_IsMuted(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"IsMuted"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsMuted(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2_get_IsDocumentPlayingAudio(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"IsDocumentPlayingAudio"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDocumentPlayingAudio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_get_DefaultDownloadDialogMargin(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"DefaultDownloadDialogMargin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultDownloadDialogMargin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2_put_DefaultDownloadDialogMargin(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"DefaultDownloadDialogMargin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.DefaultDownloadDialogMargin(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2_get_DefaultDownloadDialogCornerAlignment(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"DefaultDownloadDialogCornerAlignment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultDownloadDialogCornerAlignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2_put_DefaultDownloadDialogCornerAlignment(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"DefaultDownloadDialogCornerAlignment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2DefaultDownloadDialogCornerAlignment>(arg);

            self->obj.DefaultDownloadDialogCornerAlignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2_get_IsDefaultDownloadDialogOpen(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"IsDefaultDownloadDialogOpen"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDefaultDownloadDialogOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_add_BasicAuthenticationRequested(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"BasicAuthenticationRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2, winrt::Microsoft::Web::WebView2::Core::CoreWebView2BasicAuthenticationRequestedEventArgs>>(arg);

            return py::convert(self->obj.BasicAuthenticationRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_remove_BasicAuthenticationRequested(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"BasicAuthenticationRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BasicAuthenticationRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_add_ContextMenuRequested(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"ContextMenuRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2, winrt::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuRequestedEventArgs>>(arg);

            return py::convert(self->obj.ContextMenuRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_remove_ContextMenuRequested(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"ContextMenuRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ContextMenuRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_add_StatusBarTextChanged(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"StatusBarTextChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.StatusBarTextChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_remove_StatusBarTextChanged(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"StatusBarTextChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StatusBarTextChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_add_ServerCertificateErrorDetected(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"ServerCertificateErrorDetected"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2, winrt::Microsoft::Web::WebView2::Core::CoreWebView2ServerCertificateErrorDetectedEventArgs>>(arg);

            return py::convert(self->obj.ServerCertificateErrorDetected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_remove_ServerCertificateErrorDetected(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"ServerCertificateErrorDetected"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ServerCertificateErrorDetected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_add_FaviconChanged(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"FaviconChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.FaviconChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_remove_FaviconChanged(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"FaviconChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FaviconChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_add_LaunchingExternalUriScheme(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"LaunchingExternalUriScheme"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2, winrt::Microsoft::Web::WebView2::Core::CoreWebView2LaunchingExternalUriSchemeEventArgs>>(arg);

            return py::convert(self->obj.LaunchingExternalUriScheme(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_remove_LaunchingExternalUriScheme(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"LaunchingExternalUriScheme"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LaunchingExternalUriScheme(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_add_DOMContentLoaded(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"DOMContentLoaded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2, winrt::Microsoft::Web::WebView2::Core::CoreWebView2DOMContentLoadedEventArgs>>(arg);

            return py::convert(self->obj.DOMContentLoaded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_remove_DOMContentLoaded(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"DOMContentLoaded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DOMContentLoaded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_add_WebResourceResponseReceived(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"WebResourceResponseReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2, winrt::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceResponseReceivedEventArgs>>(arg);

            return py::convert(self->obj.WebResourceResponseReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_remove_WebResourceResponseReceived(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"WebResourceResponseReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.WebResourceResponseReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_add_DownloadStarting(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"DownloadStarting"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2, winrt::Microsoft::Web::WebView2::Core::CoreWebView2DownloadStartingEventArgs>>(arg);

            return py::convert(self->obj.DownloadStarting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_remove_DownloadStarting(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"DownloadStarting"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DownloadStarting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_add_FrameCreated(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"FrameCreated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2, winrt::Microsoft::Web::WebView2::Core::CoreWebView2FrameCreatedEventArgs>>(arg);

            return py::convert(self->obj.FrameCreated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_remove_FrameCreated(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"FrameCreated"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FrameCreated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_add_ClientCertificateRequested(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"ClientCertificateRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2, winrt::Microsoft::Web::WebView2::Core::CoreWebView2ClientCertificateRequestedEventArgs>>(arg);

            return py::convert(self->obj.ClientCertificateRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_remove_ClientCertificateRequested(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"ClientCertificateRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ClientCertificateRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_add_IsDocumentPlayingAudioChanged(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"IsDocumentPlayingAudioChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.IsDocumentPlayingAudioChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_remove_IsDocumentPlayingAudioChanged(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"IsDocumentPlayingAudioChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.IsDocumentPlayingAudioChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_add_IsMutedChanged(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"IsMutedChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.IsMutedChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_remove_IsMutedChanged(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"IsMutedChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.IsMutedChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_add_IsDefaultDownloadDialogOpenChanged(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"IsDefaultDownloadDialogOpenChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.IsDefaultDownloadDialogOpenChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_remove_IsDefaultDownloadDialogOpenChanged(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"IsDefaultDownloadDialogOpenChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.IsDefaultDownloadDialogOpenChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_add_ContainsFullScreenElementChanged(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"ContainsFullScreenElementChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ContainsFullScreenElementChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_remove_ContainsFullScreenElementChanged(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"ContainsFullScreenElementChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ContainsFullScreenElementChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_add_ContentLoading(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"ContentLoading"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2, winrt::Microsoft::Web::WebView2::Core::CoreWebView2ContentLoadingEventArgs>>(arg);

            return py::convert(self->obj.ContentLoading(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_remove_ContentLoading(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"ContentLoading"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ContentLoading(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_add_DocumentTitleChanged(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"DocumentTitleChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.DocumentTitleChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_remove_DocumentTitleChanged(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"DocumentTitleChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DocumentTitleChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_add_FrameNavigationCompleted(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"FrameNavigationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2, winrt::Microsoft::Web::WebView2::Core::CoreWebView2NavigationCompletedEventArgs>>(arg);

            return py::convert(self->obj.FrameNavigationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_remove_FrameNavigationCompleted(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"FrameNavigationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FrameNavigationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_add_FrameNavigationStarting(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"FrameNavigationStarting"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2, winrt::Microsoft::Web::WebView2::Core::CoreWebView2NavigationStartingEventArgs>>(arg);

            return py::convert(self->obj.FrameNavigationStarting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_remove_FrameNavigationStarting(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"FrameNavigationStarting"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FrameNavigationStarting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_add_HistoryChanged(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"HistoryChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.HistoryChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_remove_HistoryChanged(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"HistoryChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HistoryChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_add_NavigationCompleted(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"NavigationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2, winrt::Microsoft::Web::WebView2::Core::CoreWebView2NavigationCompletedEventArgs>>(arg);

            return py::convert(self->obj.NavigationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_remove_NavigationCompleted(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"NavigationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.NavigationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_add_NavigationStarting(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"NavigationStarting"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2, winrt::Microsoft::Web::WebView2::Core::CoreWebView2NavigationStartingEventArgs>>(arg);

            return py::convert(self->obj.NavigationStarting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_remove_NavigationStarting(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"NavigationStarting"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.NavigationStarting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_add_NewWindowRequested(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"NewWindowRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2, winrt::Microsoft::Web::WebView2::Core::CoreWebView2NewWindowRequestedEventArgs>>(arg);

            return py::convert(self->obj.NewWindowRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_remove_NewWindowRequested(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"NewWindowRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.NewWindowRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_add_PermissionRequested(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"PermissionRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2, winrt::Microsoft::Web::WebView2::Core::CoreWebView2PermissionRequestedEventArgs>>(arg);

            return py::convert(self->obj.PermissionRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_remove_PermissionRequested(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"PermissionRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PermissionRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_add_ProcessFailed(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"ProcessFailed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2, winrt::Microsoft::Web::WebView2::Core::CoreWebView2ProcessFailedEventArgs>>(arg);

            return py::convert(self->obj.ProcessFailed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_remove_ProcessFailed(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"ProcessFailed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ProcessFailed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_add_ScriptDialogOpening(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"ScriptDialogOpening"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2, winrt::Microsoft::Web::WebView2::Core::CoreWebView2ScriptDialogOpeningEventArgs>>(arg);

            return py::convert(self->obj.ScriptDialogOpening(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_remove_ScriptDialogOpening(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"ScriptDialogOpening"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ScriptDialogOpening(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_add_SourceChanged(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"SourceChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2, winrt::Microsoft::Web::WebView2::Core::CoreWebView2SourceChangedEventArgs>>(arg);

            return py::convert(self->obj.SourceChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_remove_SourceChanged(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"SourceChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_add_WebMessageReceived(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"WebMessageReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2, winrt::Microsoft::Web::WebView2::Core::CoreWebView2WebMessageReceivedEventArgs>>(arg);

            return py::convert(self->obj.WebMessageReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_remove_WebMessageReceived(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"WebMessageReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.WebMessageReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_add_WebResourceRequested(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"WebResourceRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2, winrt::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceRequestedEventArgs>>(arg);

            return py::convert(self->obj.WebResourceRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_remove_WebResourceRequested(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"WebResourceRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.WebResourceRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_add_WindowCloseRequested(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"WindowCloseRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.WindowCloseRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2_remove_WindowCloseRequested(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2", L"WindowCloseRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.WindowCloseRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2[] = {
        { "add_host_object_to_script", reinterpret_cast<PyCFunction>(CoreWebView2_AddHostObjectToScript), METH_VARARGS, nullptr },
        { "add_script_to_execute_on_document_created_async", reinterpret_cast<PyCFunction>(CoreWebView2_AddScriptToExecuteOnDocumentCreatedAsync), METH_VARARGS, nullptr },
        { "add_web_resource_requested_filter", reinterpret_cast<PyCFunction>(CoreWebView2_AddWebResourceRequestedFilter), METH_VARARGS, nullptr },
        { "call_dev_tools_protocol_method_async", reinterpret_cast<PyCFunction>(CoreWebView2_CallDevToolsProtocolMethodAsync), METH_VARARGS, nullptr },
        { "call_dev_tools_protocol_method_for_session_async", reinterpret_cast<PyCFunction>(CoreWebView2_CallDevToolsProtocolMethodForSessionAsync), METH_VARARGS, nullptr },
        { "capture_preview_async", reinterpret_cast<PyCFunction>(CoreWebView2_CapturePreviewAsync), METH_VARARGS, nullptr },
        { "clear_server_certificate_error_actions_async", reinterpret_cast<PyCFunction>(CoreWebView2_ClearServerCertificateErrorActionsAsync), METH_VARARGS, nullptr },
        { "clear_virtual_host_name_to_folder_mapping", reinterpret_cast<PyCFunction>(CoreWebView2_ClearVirtualHostNameToFolderMapping), METH_VARARGS, nullptr },
        { "close_default_download_dialog", reinterpret_cast<PyCFunction>(CoreWebView2_CloseDefaultDownloadDialog), METH_VARARGS, nullptr },
        { "execute_script_async", reinterpret_cast<PyCFunction>(CoreWebView2_ExecuteScriptAsync), METH_VARARGS, nullptr },
        { "get_dev_tools_protocol_event_receiver", reinterpret_cast<PyCFunction>(CoreWebView2_GetDevToolsProtocolEventReceiver), METH_VARARGS, nullptr },
        { "get_favicon_async", reinterpret_cast<PyCFunction>(CoreWebView2_GetFaviconAsync), METH_VARARGS, nullptr },
        { "go_back", reinterpret_cast<PyCFunction>(CoreWebView2_GoBack), METH_VARARGS, nullptr },
        { "go_forward", reinterpret_cast<PyCFunction>(CoreWebView2_GoForward), METH_VARARGS, nullptr },
        { "navigate", reinterpret_cast<PyCFunction>(CoreWebView2_Navigate), METH_VARARGS, nullptr },
        { "navigate_to_string", reinterpret_cast<PyCFunction>(CoreWebView2_NavigateToString), METH_VARARGS, nullptr },
        { "navigate_with_web_resource_request", reinterpret_cast<PyCFunction>(CoreWebView2_NavigateWithWebResourceRequest), METH_VARARGS, nullptr },
        { "open_default_download_dialog", reinterpret_cast<PyCFunction>(CoreWebView2_OpenDefaultDownloadDialog), METH_VARARGS, nullptr },
        { "open_dev_tools_window", reinterpret_cast<PyCFunction>(CoreWebView2_OpenDevToolsWindow), METH_VARARGS, nullptr },
        { "open_task_manager_window", reinterpret_cast<PyCFunction>(CoreWebView2_OpenTaskManagerWindow), METH_VARARGS, nullptr },
        { "post_shared_buffer_to_script", reinterpret_cast<PyCFunction>(CoreWebView2_PostSharedBufferToScript), METH_VARARGS, nullptr },
        { "post_web_message_as_json", reinterpret_cast<PyCFunction>(CoreWebView2_PostWebMessageAsJson), METH_VARARGS, nullptr },
        { "post_web_message_as_string", reinterpret_cast<PyCFunction>(CoreWebView2_PostWebMessageAsString), METH_VARARGS, nullptr },
        { "print_async", reinterpret_cast<PyCFunction>(CoreWebView2_PrintAsync), METH_VARARGS, nullptr },
        { "print_to_pdf_async", reinterpret_cast<PyCFunction>(CoreWebView2_PrintToPdfAsync), METH_VARARGS, nullptr },
        { "print_to_pdf_stream_async", reinterpret_cast<PyCFunction>(CoreWebView2_PrintToPdfStreamAsync), METH_VARARGS, nullptr },
        { "reload", reinterpret_cast<PyCFunction>(CoreWebView2_Reload), METH_VARARGS, nullptr },
        { "remove_host_object_from_script", reinterpret_cast<PyCFunction>(CoreWebView2_RemoveHostObjectFromScript), METH_VARARGS, nullptr },
        { "remove_script_to_execute_on_document_created", reinterpret_cast<PyCFunction>(CoreWebView2_RemoveScriptToExecuteOnDocumentCreated), METH_VARARGS, nullptr },
        { "remove_web_resource_requested_filter", reinterpret_cast<PyCFunction>(CoreWebView2_RemoveWebResourceRequestedFilter), METH_VARARGS, nullptr },
        { "resume", reinterpret_cast<PyCFunction>(CoreWebView2_Resume), METH_VARARGS, nullptr },
        { "set_virtual_host_name_to_folder_mapping", reinterpret_cast<PyCFunction>(CoreWebView2_SetVirtualHostNameToFolderMapping), METH_VARARGS, nullptr },
        { "show_print_u_i", reinterpret_cast<PyCFunction>(CoreWebView2_ShowPrintUI), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(CoreWebView2_Stop), METH_VARARGS, nullptr },
        { "try_suspend_async", reinterpret_cast<PyCFunction>(CoreWebView2_TrySuspendAsync), METH_VARARGS, nullptr },
        { "add_basic_authentication_requested", reinterpret_cast<PyCFunction>(CoreWebView2_add_BasicAuthenticationRequested), METH_O, nullptr },
        { "remove_basic_authentication_requested", reinterpret_cast<PyCFunction>(CoreWebView2_remove_BasicAuthenticationRequested), METH_O, nullptr },
        { "add_context_menu_requested", reinterpret_cast<PyCFunction>(CoreWebView2_add_ContextMenuRequested), METH_O, nullptr },
        { "remove_context_menu_requested", reinterpret_cast<PyCFunction>(CoreWebView2_remove_ContextMenuRequested), METH_O, nullptr },
        { "add_status_bar_text_changed", reinterpret_cast<PyCFunction>(CoreWebView2_add_StatusBarTextChanged), METH_O, nullptr },
        { "remove_status_bar_text_changed", reinterpret_cast<PyCFunction>(CoreWebView2_remove_StatusBarTextChanged), METH_O, nullptr },
        { "add_server_certificate_error_detected", reinterpret_cast<PyCFunction>(CoreWebView2_add_ServerCertificateErrorDetected), METH_O, nullptr },
        { "remove_server_certificate_error_detected", reinterpret_cast<PyCFunction>(CoreWebView2_remove_ServerCertificateErrorDetected), METH_O, nullptr },
        { "add_favicon_changed", reinterpret_cast<PyCFunction>(CoreWebView2_add_FaviconChanged), METH_O, nullptr },
        { "remove_favicon_changed", reinterpret_cast<PyCFunction>(CoreWebView2_remove_FaviconChanged), METH_O, nullptr },
        { "add_launching_external_uri_scheme", reinterpret_cast<PyCFunction>(CoreWebView2_add_LaunchingExternalUriScheme), METH_O, nullptr },
        { "remove_launching_external_uri_scheme", reinterpret_cast<PyCFunction>(CoreWebView2_remove_LaunchingExternalUriScheme), METH_O, nullptr },
        { "add_d_o_m_content_loaded", reinterpret_cast<PyCFunction>(CoreWebView2_add_DOMContentLoaded), METH_O, nullptr },
        { "remove_d_o_m_content_loaded", reinterpret_cast<PyCFunction>(CoreWebView2_remove_DOMContentLoaded), METH_O, nullptr },
        { "add_web_resource_response_received", reinterpret_cast<PyCFunction>(CoreWebView2_add_WebResourceResponseReceived), METH_O, nullptr },
        { "remove_web_resource_response_received", reinterpret_cast<PyCFunction>(CoreWebView2_remove_WebResourceResponseReceived), METH_O, nullptr },
        { "add_download_starting", reinterpret_cast<PyCFunction>(CoreWebView2_add_DownloadStarting), METH_O, nullptr },
        { "remove_download_starting", reinterpret_cast<PyCFunction>(CoreWebView2_remove_DownloadStarting), METH_O, nullptr },
        { "add_frame_created", reinterpret_cast<PyCFunction>(CoreWebView2_add_FrameCreated), METH_O, nullptr },
        { "remove_frame_created", reinterpret_cast<PyCFunction>(CoreWebView2_remove_FrameCreated), METH_O, nullptr },
        { "add_client_certificate_requested", reinterpret_cast<PyCFunction>(CoreWebView2_add_ClientCertificateRequested), METH_O, nullptr },
        { "remove_client_certificate_requested", reinterpret_cast<PyCFunction>(CoreWebView2_remove_ClientCertificateRequested), METH_O, nullptr },
        { "add_is_document_playing_audio_changed", reinterpret_cast<PyCFunction>(CoreWebView2_add_IsDocumentPlayingAudioChanged), METH_O, nullptr },
        { "remove_is_document_playing_audio_changed", reinterpret_cast<PyCFunction>(CoreWebView2_remove_IsDocumentPlayingAudioChanged), METH_O, nullptr },
        { "add_is_muted_changed", reinterpret_cast<PyCFunction>(CoreWebView2_add_IsMutedChanged), METH_O, nullptr },
        { "remove_is_muted_changed", reinterpret_cast<PyCFunction>(CoreWebView2_remove_IsMutedChanged), METH_O, nullptr },
        { "add_is_default_download_dialog_open_changed", reinterpret_cast<PyCFunction>(CoreWebView2_add_IsDefaultDownloadDialogOpenChanged), METH_O, nullptr },
        { "remove_is_default_download_dialog_open_changed", reinterpret_cast<PyCFunction>(CoreWebView2_remove_IsDefaultDownloadDialogOpenChanged), METH_O, nullptr },
        { "add_contains_full_screen_element_changed", reinterpret_cast<PyCFunction>(CoreWebView2_add_ContainsFullScreenElementChanged), METH_O, nullptr },
        { "remove_contains_full_screen_element_changed", reinterpret_cast<PyCFunction>(CoreWebView2_remove_ContainsFullScreenElementChanged), METH_O, nullptr },
        { "add_content_loading", reinterpret_cast<PyCFunction>(CoreWebView2_add_ContentLoading), METH_O, nullptr },
        { "remove_content_loading", reinterpret_cast<PyCFunction>(CoreWebView2_remove_ContentLoading), METH_O, nullptr },
        { "add_document_title_changed", reinterpret_cast<PyCFunction>(CoreWebView2_add_DocumentTitleChanged), METH_O, nullptr },
        { "remove_document_title_changed", reinterpret_cast<PyCFunction>(CoreWebView2_remove_DocumentTitleChanged), METH_O, nullptr },
        { "add_frame_navigation_completed", reinterpret_cast<PyCFunction>(CoreWebView2_add_FrameNavigationCompleted), METH_O, nullptr },
        { "remove_frame_navigation_completed", reinterpret_cast<PyCFunction>(CoreWebView2_remove_FrameNavigationCompleted), METH_O, nullptr },
        { "add_frame_navigation_starting", reinterpret_cast<PyCFunction>(CoreWebView2_add_FrameNavigationStarting), METH_O, nullptr },
        { "remove_frame_navigation_starting", reinterpret_cast<PyCFunction>(CoreWebView2_remove_FrameNavigationStarting), METH_O, nullptr },
        { "add_history_changed", reinterpret_cast<PyCFunction>(CoreWebView2_add_HistoryChanged), METH_O, nullptr },
        { "remove_history_changed", reinterpret_cast<PyCFunction>(CoreWebView2_remove_HistoryChanged), METH_O, nullptr },
        { "add_navigation_completed", reinterpret_cast<PyCFunction>(CoreWebView2_add_NavigationCompleted), METH_O, nullptr },
        { "remove_navigation_completed", reinterpret_cast<PyCFunction>(CoreWebView2_remove_NavigationCompleted), METH_O, nullptr },
        { "add_navigation_starting", reinterpret_cast<PyCFunction>(CoreWebView2_add_NavigationStarting), METH_O, nullptr },
        { "remove_navigation_starting", reinterpret_cast<PyCFunction>(CoreWebView2_remove_NavigationStarting), METH_O, nullptr },
        { "add_new_window_requested", reinterpret_cast<PyCFunction>(CoreWebView2_add_NewWindowRequested), METH_O, nullptr },
        { "remove_new_window_requested", reinterpret_cast<PyCFunction>(CoreWebView2_remove_NewWindowRequested), METH_O, nullptr },
        { "add_permission_requested", reinterpret_cast<PyCFunction>(CoreWebView2_add_PermissionRequested), METH_O, nullptr },
        { "remove_permission_requested", reinterpret_cast<PyCFunction>(CoreWebView2_remove_PermissionRequested), METH_O, nullptr },
        { "add_process_failed", reinterpret_cast<PyCFunction>(CoreWebView2_add_ProcessFailed), METH_O, nullptr },
        { "remove_process_failed", reinterpret_cast<PyCFunction>(CoreWebView2_remove_ProcessFailed), METH_O, nullptr },
        { "add_script_dialog_opening", reinterpret_cast<PyCFunction>(CoreWebView2_add_ScriptDialogOpening), METH_O, nullptr },
        { "remove_script_dialog_opening", reinterpret_cast<PyCFunction>(CoreWebView2_remove_ScriptDialogOpening), METH_O, nullptr },
        { "add_source_changed", reinterpret_cast<PyCFunction>(CoreWebView2_add_SourceChanged), METH_O, nullptr },
        { "remove_source_changed", reinterpret_cast<PyCFunction>(CoreWebView2_remove_SourceChanged), METH_O, nullptr },
        { "add_web_message_received", reinterpret_cast<PyCFunction>(CoreWebView2_add_WebMessageReceived), METH_O, nullptr },
        { "remove_web_message_received", reinterpret_cast<PyCFunction>(CoreWebView2_remove_WebMessageReceived), METH_O, nullptr },
        { "add_web_resource_requested", reinterpret_cast<PyCFunction>(CoreWebView2_add_WebResourceRequested), METH_O, nullptr },
        { "remove_web_resource_requested", reinterpret_cast<PyCFunction>(CoreWebView2_remove_WebResourceRequested), METH_O, nullptr },
        { "add_window_close_requested", reinterpret_cast<PyCFunction>(CoreWebView2_add_WindowCloseRequested), METH_O, nullptr },
        { "remove_window_close_requested", reinterpret_cast<PyCFunction>(CoreWebView2_remove_WindowCloseRequested), METH_O, nullptr },
        { "_assign_array_", _assign_array_CoreWebView2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2[] = {
        { "browser_process_id", reinterpret_cast<getter>(CoreWebView2_get_BrowserProcessId), nullptr, nullptr, nullptr },
        { "can_go_back", reinterpret_cast<getter>(CoreWebView2_get_CanGoBack), nullptr, nullptr, nullptr },
        { "can_go_forward", reinterpret_cast<getter>(CoreWebView2_get_CanGoForward), nullptr, nullptr, nullptr },
        { "contains_full_screen_element", reinterpret_cast<getter>(CoreWebView2_get_ContainsFullScreenElement), nullptr, nullptr, nullptr },
        { "document_title", reinterpret_cast<getter>(CoreWebView2_get_DocumentTitle), nullptr, nullptr, nullptr },
        { "settings", reinterpret_cast<getter>(CoreWebView2_get_Settings), nullptr, nullptr, nullptr },
        { "source", reinterpret_cast<getter>(CoreWebView2_get_Source), nullptr, nullptr, nullptr },
        { "status_bar_text", reinterpret_cast<getter>(CoreWebView2_get_StatusBarText), nullptr, nullptr, nullptr },
        { "profile", reinterpret_cast<getter>(CoreWebView2_get_Profile), nullptr, nullptr, nullptr },
        { "favicon_uri", reinterpret_cast<getter>(CoreWebView2_get_FaviconUri), nullptr, nullptr, nullptr },
        { "memory_usage_target_level", reinterpret_cast<getter>(CoreWebView2_get_MemoryUsageTargetLevel), reinterpret_cast<setter>(CoreWebView2_put_MemoryUsageTargetLevel), nullptr, nullptr },
        { "cookie_manager", reinterpret_cast<getter>(CoreWebView2_get_CookieManager), nullptr, nullptr, nullptr },
        { "environment", reinterpret_cast<getter>(CoreWebView2_get_Environment), nullptr, nullptr, nullptr },
        { "is_suspended", reinterpret_cast<getter>(CoreWebView2_get_IsSuspended), nullptr, nullptr, nullptr },
        { "is_muted", reinterpret_cast<getter>(CoreWebView2_get_IsMuted), reinterpret_cast<setter>(CoreWebView2_put_IsMuted), nullptr, nullptr },
        { "is_document_playing_audio", reinterpret_cast<getter>(CoreWebView2_get_IsDocumentPlayingAudio), nullptr, nullptr, nullptr },
        { "default_download_dialog_margin", reinterpret_cast<getter>(CoreWebView2_get_DefaultDownloadDialogMargin), reinterpret_cast<setter>(CoreWebView2_put_DefaultDownloadDialogMargin), nullptr, nullptr },
        { "default_download_dialog_corner_alignment", reinterpret_cast<getter>(CoreWebView2_get_DefaultDownloadDialogCornerAlignment), reinterpret_cast<setter>(CoreWebView2_put_DefaultDownloadDialogCornerAlignment), nullptr, nullptr },
        { "is_default_download_dialog_open", reinterpret_cast<getter>(CoreWebView2_get_IsDefaultDownloadDialogOpen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2 =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2
    };

    // ----- CoreWebView2AcceleratorKeyPressedEventArgs class --------------------

    static PyObject* _new_CoreWebView2AcceleratorKeyPressedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2AcceleratorKeyPressedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2AcceleratorKeyPressedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2AcceleratorKeyPressedEventArgs(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2AcceleratorKeyPressedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2AcceleratorKeyPressedEventArgs_get_Handled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2AcceleratorKeyPressedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2AcceleratorKeyPressedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2AcceleratorKeyPressedEventArgs_put_Handled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2AcceleratorKeyPressedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2AcceleratorKeyPressedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2AcceleratorKeyPressedEventArgs_get_KeyEventKind(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2AcceleratorKeyPressedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2AcceleratorKeyPressedEventArgs", L"KeyEventKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyEventKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2AcceleratorKeyPressedEventArgs_get_KeyEventLParam(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2AcceleratorKeyPressedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2AcceleratorKeyPressedEventArgs", L"KeyEventLParam"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyEventLParam());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2AcceleratorKeyPressedEventArgs_get_PhysicalKeyStatus(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2AcceleratorKeyPressedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2AcceleratorKeyPressedEventArgs", L"PhysicalKeyStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhysicalKeyStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2AcceleratorKeyPressedEventArgs_get_VirtualKey(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2AcceleratorKeyPressedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2AcceleratorKeyPressedEventArgs", L"VirtualKey"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VirtualKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2AcceleratorKeyPressedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2AcceleratorKeyPressedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2AcceleratorKeyPressedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2AcceleratorKeyPressedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2AcceleratorKeyPressedEventArgs[] = {
        { "_assign_array_", _assign_array_CoreWebView2AcceleratorKeyPressedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2AcceleratorKeyPressedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2AcceleratorKeyPressedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(CoreWebView2AcceleratorKeyPressedEventArgs_get_Handled), reinterpret_cast<setter>(CoreWebView2AcceleratorKeyPressedEventArgs_put_Handled), nullptr, nullptr },
        { "key_event_kind", reinterpret_cast<getter>(CoreWebView2AcceleratorKeyPressedEventArgs_get_KeyEventKind), nullptr, nullptr, nullptr },
        { "key_event_l_param", reinterpret_cast<getter>(CoreWebView2AcceleratorKeyPressedEventArgs_get_KeyEventLParam), nullptr, nullptr, nullptr },
        { "physical_key_status", reinterpret_cast<getter>(CoreWebView2AcceleratorKeyPressedEventArgs_get_PhysicalKeyStatus), nullptr, nullptr, nullptr },
        { "virtual_key", reinterpret_cast<getter>(CoreWebView2AcceleratorKeyPressedEventArgs_get_VirtualKey), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2AcceleratorKeyPressedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2AcceleratorKeyPressedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2AcceleratorKeyPressedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2AcceleratorKeyPressedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2AcceleratorKeyPressedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2AcceleratorKeyPressedEventArgs =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2AcceleratorKeyPressedEventArgs",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2AcceleratorKeyPressedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2AcceleratorKeyPressedEventArgs
    };

    // ----- CoreWebView2BasicAuthenticationRequestedEventArgs class --------------------

    static PyObject* _new_CoreWebView2BasicAuthenticationRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2BasicAuthenticationRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2BasicAuthenticationRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2BasicAuthenticationRequestedEventArgs(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2BasicAuthenticationRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2BasicAuthenticationRequestedEventArgs_GetDeferral(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2BasicAuthenticationRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2BasicAuthenticationRequestedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2BasicAuthenticationRequestedEventArgs_get_Cancel(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2BasicAuthenticationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2BasicAuthenticationRequestedEventArgs", L"Cancel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Cancel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2BasicAuthenticationRequestedEventArgs_put_Cancel(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2BasicAuthenticationRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2BasicAuthenticationRequestedEventArgs", L"Cancel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Cancel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2BasicAuthenticationRequestedEventArgs_get_Challenge(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2BasicAuthenticationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2BasicAuthenticationRequestedEventArgs", L"Challenge"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Challenge());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2BasicAuthenticationRequestedEventArgs_get_Response(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2BasicAuthenticationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2BasicAuthenticationRequestedEventArgs", L"Response"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Response());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2BasicAuthenticationRequestedEventArgs_get_Uri(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2BasicAuthenticationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2BasicAuthenticationRequestedEventArgs", L"Uri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2BasicAuthenticationRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2BasicAuthenticationRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2BasicAuthenticationRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2BasicAuthenticationRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2BasicAuthenticationRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CoreWebView2BasicAuthenticationRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreWebView2BasicAuthenticationRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2BasicAuthenticationRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2BasicAuthenticationRequestedEventArgs[] = {
        { "cancel", reinterpret_cast<getter>(CoreWebView2BasicAuthenticationRequestedEventArgs_get_Cancel), reinterpret_cast<setter>(CoreWebView2BasicAuthenticationRequestedEventArgs_put_Cancel), nullptr, nullptr },
        { "challenge", reinterpret_cast<getter>(CoreWebView2BasicAuthenticationRequestedEventArgs_get_Challenge), nullptr, nullptr, nullptr },
        { "response", reinterpret_cast<getter>(CoreWebView2BasicAuthenticationRequestedEventArgs_get_Response), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(CoreWebView2BasicAuthenticationRequestedEventArgs_get_Uri), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2BasicAuthenticationRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2BasicAuthenticationRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2BasicAuthenticationRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2BasicAuthenticationRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2BasicAuthenticationRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2BasicAuthenticationRequestedEventArgs =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2BasicAuthenticationRequestedEventArgs",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2BasicAuthenticationRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2BasicAuthenticationRequestedEventArgs
    };

    // ----- CoreWebView2BasicAuthenticationResponse class --------------------

    static PyObject* _new_CoreWebView2BasicAuthenticationResponse(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2BasicAuthenticationResponse>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2BasicAuthenticationResponse>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2BasicAuthenticationResponse(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2BasicAuthenticationResponse* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2BasicAuthenticationResponse_get_UserName(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2BasicAuthenticationResponse* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2BasicAuthenticationResponse", L"UserName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UserName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2BasicAuthenticationResponse_put_UserName(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2BasicAuthenticationResponse* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2BasicAuthenticationResponse", L"UserName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.UserName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2BasicAuthenticationResponse_get_Password(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2BasicAuthenticationResponse* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2BasicAuthenticationResponse", L"Password"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Password());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2BasicAuthenticationResponse_put_Password(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2BasicAuthenticationResponse* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2BasicAuthenticationResponse", L"Password"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Password(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CoreWebView2BasicAuthenticationResponse(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2BasicAuthenticationResponse>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2BasicAuthenticationResponse(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2BasicAuthenticationResponse>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2BasicAuthenticationResponse[] = {
        { "_assign_array_", _assign_array_CoreWebView2BasicAuthenticationResponse, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2BasicAuthenticationResponse), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2BasicAuthenticationResponse[] = {
        { "user_name", reinterpret_cast<getter>(CoreWebView2BasicAuthenticationResponse_get_UserName), reinterpret_cast<setter>(CoreWebView2BasicAuthenticationResponse_put_UserName), nullptr, nullptr },
        { "password", reinterpret_cast<getter>(CoreWebView2BasicAuthenticationResponse_get_Password), reinterpret_cast<setter>(CoreWebView2BasicAuthenticationResponse_put_Password), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2BasicAuthenticationResponse[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2BasicAuthenticationResponse) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2BasicAuthenticationResponse) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2BasicAuthenticationResponse) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2BasicAuthenticationResponse) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2BasicAuthenticationResponse =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2BasicAuthenticationResponse",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2BasicAuthenticationResponse),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2BasicAuthenticationResponse
    };

    // ----- CoreWebView2BrowserProcessExitedEventArgs class --------------------

    static PyObject* _new_CoreWebView2BrowserProcessExitedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2BrowserProcessExitedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2BrowserProcessExitedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2BrowserProcessExitedEventArgs(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2BrowserProcessExitedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2BrowserProcessExitedEventArgs_get_BrowserProcessExitKind(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2BrowserProcessExitedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2BrowserProcessExitedEventArgs", L"BrowserProcessExitKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BrowserProcessExitKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2BrowserProcessExitedEventArgs_get_BrowserProcessId(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2BrowserProcessExitedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2BrowserProcessExitedEventArgs", L"BrowserProcessId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BrowserProcessId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2BrowserProcessExitedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2BrowserProcessExitedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2BrowserProcessExitedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2BrowserProcessExitedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2BrowserProcessExitedEventArgs[] = {
        { "_assign_array_", _assign_array_CoreWebView2BrowserProcessExitedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2BrowserProcessExitedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2BrowserProcessExitedEventArgs[] = {
        { "browser_process_exit_kind", reinterpret_cast<getter>(CoreWebView2BrowserProcessExitedEventArgs_get_BrowserProcessExitKind), nullptr, nullptr, nullptr },
        { "browser_process_id", reinterpret_cast<getter>(CoreWebView2BrowserProcessExitedEventArgs_get_BrowserProcessId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2BrowserProcessExitedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2BrowserProcessExitedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2BrowserProcessExitedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2BrowserProcessExitedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2BrowserProcessExitedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2BrowserProcessExitedEventArgs =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2BrowserProcessExitedEventArgs",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2BrowserProcessExitedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2BrowserProcessExitedEventArgs
    };

    // ----- CoreWebView2Certificate class --------------------

    static PyObject* _new_CoreWebView2Certificate(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Certificate>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Certificate>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2Certificate(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Certificate* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2Certificate_ToCertificate(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Certificate* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Certificate", L"ToCertificate", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ToCertificate());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Certificate_ToPemEncoding(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Certificate* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Certificate", L"ToPemEncoding", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ToPemEncoding());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Certificate_get_DerEncodedSerialNumber(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Certificate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Certificate", L"DerEncodedSerialNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DerEncodedSerialNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Certificate_get_DisplayName(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Certificate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Certificate", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Certificate_get_Issuer(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Certificate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Certificate", L"Issuer"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Issuer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Certificate_get_PemEncodedIssuerCertificateChain(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Certificate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Certificate", L"PemEncodedIssuerCertificateChain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PemEncodedIssuerCertificateChain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Certificate_get_Subject(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Certificate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Certificate", L"Subject"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Subject());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Certificate_get_ValidFrom(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Certificate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Certificate", L"ValidFrom"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ValidFrom());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Certificate_get_ValidTo(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Certificate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Certificate", L"ValidTo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ValidTo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2Certificate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Certificate>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2Certificate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Certificate>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2Certificate[] = {
        { "to_certificate", reinterpret_cast<PyCFunction>(CoreWebView2Certificate_ToCertificate), METH_VARARGS, nullptr },
        { "to_pem_encoding", reinterpret_cast<PyCFunction>(CoreWebView2Certificate_ToPemEncoding), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreWebView2Certificate, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2Certificate), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2Certificate[] = {
        { "der_encoded_serial_number", reinterpret_cast<getter>(CoreWebView2Certificate_get_DerEncodedSerialNumber), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(CoreWebView2Certificate_get_DisplayName), nullptr, nullptr, nullptr },
        { "issuer", reinterpret_cast<getter>(CoreWebView2Certificate_get_Issuer), nullptr, nullptr, nullptr },
        { "pem_encoded_issuer_certificate_chain", reinterpret_cast<getter>(CoreWebView2Certificate_get_PemEncodedIssuerCertificateChain), nullptr, nullptr, nullptr },
        { "subject", reinterpret_cast<getter>(CoreWebView2Certificate_get_Subject), nullptr, nullptr, nullptr },
        { "valid_from", reinterpret_cast<getter>(CoreWebView2Certificate_get_ValidFrom), nullptr, nullptr, nullptr },
        { "valid_to", reinterpret_cast<getter>(CoreWebView2Certificate_get_ValidTo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2Certificate[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2Certificate) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2Certificate) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2Certificate) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2Certificate) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2Certificate =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2Certificate",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Certificate),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2Certificate
    };

    // ----- CoreWebView2ClientCertificate class --------------------

    static PyObject* _new_CoreWebView2ClientCertificate(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ClientCertificate>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ClientCertificate>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2ClientCertificate(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ClientCertificate* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2ClientCertificate_ToCertificate(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ClientCertificate* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ClientCertificate", L"ToCertificate", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ToCertificate());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ClientCertificate_ToPemEncoding(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ClientCertificate* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ClientCertificate", L"ToPemEncoding", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ToPemEncoding());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ClientCertificate_get_DerEncodedSerialNumber(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ClientCertificate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ClientCertificate", L"DerEncodedSerialNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DerEncodedSerialNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ClientCertificate_get_DisplayName(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ClientCertificate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ClientCertificate", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ClientCertificate_get_Issuer(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ClientCertificate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ClientCertificate", L"Issuer"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Issuer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ClientCertificate_get_Kind(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ClientCertificate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ClientCertificate", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ClientCertificate_get_PemEncodedIssuerCertificateChain(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ClientCertificate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ClientCertificate", L"PemEncodedIssuerCertificateChain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PemEncodedIssuerCertificateChain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ClientCertificate_get_Subject(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ClientCertificate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ClientCertificate", L"Subject"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Subject());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ClientCertificate_get_ValidFrom(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ClientCertificate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ClientCertificate", L"ValidFrom"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ValidFrom());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ClientCertificate_get_ValidTo(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ClientCertificate* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ClientCertificate", L"ValidTo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ValidTo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2ClientCertificate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ClientCertificate>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2ClientCertificate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ClientCertificate>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2ClientCertificate[] = {
        { "to_certificate", reinterpret_cast<PyCFunction>(CoreWebView2ClientCertificate_ToCertificate), METH_VARARGS, nullptr },
        { "to_pem_encoding", reinterpret_cast<PyCFunction>(CoreWebView2ClientCertificate_ToPemEncoding), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreWebView2ClientCertificate, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2ClientCertificate), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2ClientCertificate[] = {
        { "der_encoded_serial_number", reinterpret_cast<getter>(CoreWebView2ClientCertificate_get_DerEncodedSerialNumber), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(CoreWebView2ClientCertificate_get_DisplayName), nullptr, nullptr, nullptr },
        { "issuer", reinterpret_cast<getter>(CoreWebView2ClientCertificate_get_Issuer), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(CoreWebView2ClientCertificate_get_Kind), nullptr, nullptr, nullptr },
        { "pem_encoded_issuer_certificate_chain", reinterpret_cast<getter>(CoreWebView2ClientCertificate_get_PemEncodedIssuerCertificateChain), nullptr, nullptr, nullptr },
        { "subject", reinterpret_cast<getter>(CoreWebView2ClientCertificate_get_Subject), nullptr, nullptr, nullptr },
        { "valid_from", reinterpret_cast<getter>(CoreWebView2ClientCertificate_get_ValidFrom), nullptr, nullptr, nullptr },
        { "valid_to", reinterpret_cast<getter>(CoreWebView2ClientCertificate_get_ValidTo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2ClientCertificate[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2ClientCertificate) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2ClientCertificate) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2ClientCertificate) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2ClientCertificate) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2ClientCertificate =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2ClientCertificate",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ClientCertificate),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2ClientCertificate
    };

    // ----- CoreWebView2ClientCertificateRequestedEventArgs class --------------------

    static PyObject* _new_CoreWebView2ClientCertificateRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ClientCertificateRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ClientCertificateRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2ClientCertificateRequestedEventArgs(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ClientCertificateRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2ClientCertificateRequestedEventArgs_GetDeferral(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ClientCertificateRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ClientCertificateRequestedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ClientCertificateRequestedEventArgs_get_SelectedCertificate(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ClientCertificateRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ClientCertificateRequestedEventArgs", L"SelectedCertificate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2ClientCertificateRequestedEventArgs_put_SelectedCertificate(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ClientCertificateRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ClientCertificateRequestedEventArgs", L"SelectedCertificate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ClientCertificate>(arg);

            self->obj.SelectedCertificate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2ClientCertificateRequestedEventArgs_get_Handled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ClientCertificateRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ClientCertificateRequestedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2ClientCertificateRequestedEventArgs_put_Handled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ClientCertificateRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ClientCertificateRequestedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2ClientCertificateRequestedEventArgs_get_Cancel(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ClientCertificateRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ClientCertificateRequestedEventArgs", L"Cancel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Cancel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2ClientCertificateRequestedEventArgs_put_Cancel(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ClientCertificateRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ClientCertificateRequestedEventArgs", L"Cancel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Cancel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2ClientCertificateRequestedEventArgs_get_AllowedCertificateAuthorities(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ClientCertificateRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ClientCertificateRequestedEventArgs", L"AllowedCertificateAuthorities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllowedCertificateAuthorities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ClientCertificateRequestedEventArgs_get_Host(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ClientCertificateRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ClientCertificateRequestedEventArgs", L"Host"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Host());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ClientCertificateRequestedEventArgs_get_IsProxy(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ClientCertificateRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ClientCertificateRequestedEventArgs", L"IsProxy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsProxy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ClientCertificateRequestedEventArgs_get_MutuallyTrustedCertificates(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ClientCertificateRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ClientCertificateRequestedEventArgs", L"MutuallyTrustedCertificates"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MutuallyTrustedCertificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ClientCertificateRequestedEventArgs_get_Port(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ClientCertificateRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ClientCertificateRequestedEventArgs", L"Port"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Port());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2ClientCertificateRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ClientCertificateRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2ClientCertificateRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ClientCertificateRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2ClientCertificateRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CoreWebView2ClientCertificateRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreWebView2ClientCertificateRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2ClientCertificateRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2ClientCertificateRequestedEventArgs[] = {
        { "selected_certificate", reinterpret_cast<getter>(CoreWebView2ClientCertificateRequestedEventArgs_get_SelectedCertificate), reinterpret_cast<setter>(CoreWebView2ClientCertificateRequestedEventArgs_put_SelectedCertificate), nullptr, nullptr },
        { "handled", reinterpret_cast<getter>(CoreWebView2ClientCertificateRequestedEventArgs_get_Handled), reinterpret_cast<setter>(CoreWebView2ClientCertificateRequestedEventArgs_put_Handled), nullptr, nullptr },
        { "cancel", reinterpret_cast<getter>(CoreWebView2ClientCertificateRequestedEventArgs_get_Cancel), reinterpret_cast<setter>(CoreWebView2ClientCertificateRequestedEventArgs_put_Cancel), nullptr, nullptr },
        { "allowed_certificate_authorities", reinterpret_cast<getter>(CoreWebView2ClientCertificateRequestedEventArgs_get_AllowedCertificateAuthorities), nullptr, nullptr, nullptr },
        { "host", reinterpret_cast<getter>(CoreWebView2ClientCertificateRequestedEventArgs_get_Host), nullptr, nullptr, nullptr },
        { "is_proxy", reinterpret_cast<getter>(CoreWebView2ClientCertificateRequestedEventArgs_get_IsProxy), nullptr, nullptr, nullptr },
        { "mutually_trusted_certificates", reinterpret_cast<getter>(CoreWebView2ClientCertificateRequestedEventArgs_get_MutuallyTrustedCertificates), nullptr, nullptr, nullptr },
        { "port", reinterpret_cast<getter>(CoreWebView2ClientCertificateRequestedEventArgs_get_Port), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2ClientCertificateRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2ClientCertificateRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2ClientCertificateRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2ClientCertificateRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2ClientCertificateRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2ClientCertificateRequestedEventArgs =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2ClientCertificateRequestedEventArgs",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ClientCertificateRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2ClientCertificateRequestedEventArgs
    };

    // ----- CoreWebView2CompositionController class --------------------

    static PyObject* _new_CoreWebView2CompositionController(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2CompositionController>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2CompositionController>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2CompositionController(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2CompositionController* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2CompositionController_DragEnter(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2CompositionController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2CompositionController", L"DragEnter", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::DataTransfer::DragDrop::Core::CoreDragInfo>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::DataTransfer::DragDrop::Core::CoreDragUIOverride>(args, 1);

                return py::convert(self->obj.DragEnter(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2CompositionController_DragLeave(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2CompositionController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2CompositionController", L"DragLeave", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.DragLeave();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2CompositionController_DragOver(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2CompositionController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2CompositionController", L"DragOver", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::DataTransfer::DragDrop::Core::CoreDragInfo>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::DataTransfer::DragDrop::Core::CoreDragUIOverride>(args, 1);

                return py::convert(self->obj.DragOver(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2CompositionController_Drop(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2CompositionController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2CompositionController", L"Drop", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::DataTransfer::DragDrop::Core::CoreDragInfo>(args, 0);

                return py::convert(self->obj.Drop(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2CompositionController_SendMouseInput(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2CompositionController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2CompositionController", L"SendMouseInput", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2MouseEventKind>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2MouseEventVirtualKeys>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Point>(args, 3);

                self->obj.SendMouseInput(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2CompositionController_SendPointerInput(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2CompositionController* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2CompositionController", L"SendPointerInput", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2PointerEventKind>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo>(args, 1);

                self->obj.SendPointerInput(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2CompositionController_get_RootVisualTarget(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2CompositionController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2CompositionController", L"RootVisualTarget"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RootVisualTarget());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2CompositionController_put_RootVisualTarget(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2CompositionController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2CompositionController", L"RootVisualTarget"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.RootVisualTarget(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2CompositionController_get_Cursor(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2CompositionController* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2CompositionController", L"Cursor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Cursor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2CompositionController_add_CursorChanged(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2CompositionController* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2CompositionController", L"CursorChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2CompositionController, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.CursorChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2CompositionController_remove_CursorChanged(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2CompositionController* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2CompositionController", L"CursorChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CursorChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2CompositionController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2CompositionController>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2CompositionController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2CompositionController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2CompositionController[] = {
        { "drag_enter", reinterpret_cast<PyCFunction>(CoreWebView2CompositionController_DragEnter), METH_VARARGS, nullptr },
        { "drag_leave", reinterpret_cast<PyCFunction>(CoreWebView2CompositionController_DragLeave), METH_VARARGS, nullptr },
        { "drag_over", reinterpret_cast<PyCFunction>(CoreWebView2CompositionController_DragOver), METH_VARARGS, nullptr },
        { "drop", reinterpret_cast<PyCFunction>(CoreWebView2CompositionController_Drop), METH_VARARGS, nullptr },
        { "send_mouse_input", reinterpret_cast<PyCFunction>(CoreWebView2CompositionController_SendMouseInput), METH_VARARGS, nullptr },
        { "send_pointer_input", reinterpret_cast<PyCFunction>(CoreWebView2CompositionController_SendPointerInput), METH_VARARGS, nullptr },
        { "add_cursor_changed", reinterpret_cast<PyCFunction>(CoreWebView2CompositionController_add_CursorChanged), METH_O, nullptr },
        { "remove_cursor_changed", reinterpret_cast<PyCFunction>(CoreWebView2CompositionController_remove_CursorChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_CoreWebView2CompositionController, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2CompositionController), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2CompositionController[] = {
        { "root_visual_target", reinterpret_cast<getter>(CoreWebView2CompositionController_get_RootVisualTarget), reinterpret_cast<setter>(CoreWebView2CompositionController_put_RootVisualTarget), nullptr, nullptr },
        { "cursor", reinterpret_cast<getter>(CoreWebView2CompositionController_get_Cursor), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2CompositionController[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2CompositionController) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2CompositionController) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2CompositionController) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2CompositionController) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2CompositionController =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2CompositionController",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2CompositionController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2CompositionController
    };

    // ----- CoreWebView2ContentLoadingEventArgs class --------------------

    static PyObject* _new_CoreWebView2ContentLoadingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ContentLoadingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ContentLoadingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2ContentLoadingEventArgs(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContentLoadingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2ContentLoadingEventArgs_get_IsErrorPage(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContentLoadingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ContentLoadingEventArgs", L"IsErrorPage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsErrorPage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ContentLoadingEventArgs_get_NavigationId(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContentLoadingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ContentLoadingEventArgs", L"NavigationId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NavigationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2ContentLoadingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ContentLoadingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2ContentLoadingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ContentLoadingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2ContentLoadingEventArgs[] = {
        { "_assign_array_", _assign_array_CoreWebView2ContentLoadingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2ContentLoadingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2ContentLoadingEventArgs[] = {
        { "is_error_page", reinterpret_cast<getter>(CoreWebView2ContentLoadingEventArgs_get_IsErrorPage), nullptr, nullptr, nullptr },
        { "navigation_id", reinterpret_cast<getter>(CoreWebView2ContentLoadingEventArgs_get_NavigationId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2ContentLoadingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2ContentLoadingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2ContentLoadingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2ContentLoadingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2ContentLoadingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2ContentLoadingEventArgs =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2ContentLoadingEventArgs",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContentLoadingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2ContentLoadingEventArgs
    };

    // ----- CoreWebView2ContextMenuItem class --------------------

    static PyObject* _new_CoreWebView2ContextMenuItem(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuItem>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuItem>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2ContextMenuItem(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2ContextMenuItem_get_IsEnabled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ContextMenuItem", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2ContextMenuItem_put_IsEnabled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ContextMenuItem", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2ContextMenuItem_get_IsChecked(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ContextMenuItem", L"IsChecked"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsChecked());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2ContextMenuItem_put_IsChecked(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ContextMenuItem", L"IsChecked"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsChecked(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2ContextMenuItem_get_Children(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ContextMenuItem", L"Children"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Children());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ContextMenuItem_get_CommandId(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ContextMenuItem", L"CommandId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CommandId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ContextMenuItem_get_Icon(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ContextMenuItem", L"Icon"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Icon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ContextMenuItem_get_Kind(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ContextMenuItem", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ContextMenuItem_get_Label(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ContextMenuItem", L"Label"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ContextMenuItem_get_Name(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ContextMenuItem", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ContextMenuItem_get_ShortcutKeyDescription(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuItem* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ContextMenuItem", L"ShortcutKeyDescription"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShortcutKeyDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ContextMenuItem_add_CustomItemSelected(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuItem* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ContextMenuItem", L"CustomItemSelected"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuItem, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.CustomItemSelected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ContextMenuItem_remove_CustomItemSelected(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuItem* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ContextMenuItem", L"CustomItemSelected"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CustomItemSelected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2ContextMenuItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2ContextMenuItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2ContextMenuItem[] = {
        { "add_custom_item_selected", reinterpret_cast<PyCFunction>(CoreWebView2ContextMenuItem_add_CustomItemSelected), METH_O, nullptr },
        { "remove_custom_item_selected", reinterpret_cast<PyCFunction>(CoreWebView2ContextMenuItem_remove_CustomItemSelected), METH_O, nullptr },
        { "_assign_array_", _assign_array_CoreWebView2ContextMenuItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2ContextMenuItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2ContextMenuItem[] = {
        { "is_enabled", reinterpret_cast<getter>(CoreWebView2ContextMenuItem_get_IsEnabled), reinterpret_cast<setter>(CoreWebView2ContextMenuItem_put_IsEnabled), nullptr, nullptr },
        { "is_checked", reinterpret_cast<getter>(CoreWebView2ContextMenuItem_get_IsChecked), reinterpret_cast<setter>(CoreWebView2ContextMenuItem_put_IsChecked), nullptr, nullptr },
        { "children", reinterpret_cast<getter>(CoreWebView2ContextMenuItem_get_Children), nullptr, nullptr, nullptr },
        { "command_id", reinterpret_cast<getter>(CoreWebView2ContextMenuItem_get_CommandId), nullptr, nullptr, nullptr },
        { "icon", reinterpret_cast<getter>(CoreWebView2ContextMenuItem_get_Icon), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(CoreWebView2ContextMenuItem_get_Kind), nullptr, nullptr, nullptr },
        { "label", reinterpret_cast<getter>(CoreWebView2ContextMenuItem_get_Label), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(CoreWebView2ContextMenuItem_get_Name), nullptr, nullptr, nullptr },
        { "shortcut_key_description", reinterpret_cast<getter>(CoreWebView2ContextMenuItem_get_ShortcutKeyDescription), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2ContextMenuItem[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2ContextMenuItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2ContextMenuItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2ContextMenuItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2ContextMenuItem) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2ContextMenuItem =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2ContextMenuItem",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2ContextMenuItem
    };

    // ----- CoreWebView2ContextMenuRequestedEventArgs class --------------------

    static PyObject* _new_CoreWebView2ContextMenuRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2ContextMenuRequestedEventArgs(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2ContextMenuRequestedEventArgs_GetDeferral(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ContextMenuRequestedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ContextMenuRequestedEventArgs_get_SelectedCommandId(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ContextMenuRequestedEventArgs", L"SelectedCommandId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectedCommandId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2ContextMenuRequestedEventArgs_put_SelectedCommandId(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ContextMenuRequestedEventArgs", L"SelectedCommandId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.SelectedCommandId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2ContextMenuRequestedEventArgs_get_Handled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ContextMenuRequestedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2ContextMenuRequestedEventArgs_put_Handled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ContextMenuRequestedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2ContextMenuRequestedEventArgs_get_ContextMenuTarget(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ContextMenuRequestedEventArgs", L"ContextMenuTarget"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContextMenuTarget());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ContextMenuRequestedEventArgs_get_Location(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ContextMenuRequestedEventArgs", L"Location"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ContextMenuRequestedEventArgs_get_MenuItems(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ContextMenuRequestedEventArgs", L"MenuItems"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MenuItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2ContextMenuRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2ContextMenuRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2ContextMenuRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CoreWebView2ContextMenuRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreWebView2ContextMenuRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2ContextMenuRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2ContextMenuRequestedEventArgs[] = {
        { "selected_command_id", reinterpret_cast<getter>(CoreWebView2ContextMenuRequestedEventArgs_get_SelectedCommandId), reinterpret_cast<setter>(CoreWebView2ContextMenuRequestedEventArgs_put_SelectedCommandId), nullptr, nullptr },
        { "handled", reinterpret_cast<getter>(CoreWebView2ContextMenuRequestedEventArgs_get_Handled), reinterpret_cast<setter>(CoreWebView2ContextMenuRequestedEventArgs_put_Handled), nullptr, nullptr },
        { "context_menu_target", reinterpret_cast<getter>(CoreWebView2ContextMenuRequestedEventArgs_get_ContextMenuTarget), nullptr, nullptr, nullptr },
        { "location", reinterpret_cast<getter>(CoreWebView2ContextMenuRequestedEventArgs_get_Location), nullptr, nullptr, nullptr },
        { "menu_items", reinterpret_cast<getter>(CoreWebView2ContextMenuRequestedEventArgs_get_MenuItems), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2ContextMenuRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2ContextMenuRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2ContextMenuRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2ContextMenuRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2ContextMenuRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2ContextMenuRequestedEventArgs =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2ContextMenuRequestedEventArgs",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2ContextMenuRequestedEventArgs
    };

    // ----- CoreWebView2ContextMenuTarget class --------------------

    static PyObject* _new_CoreWebView2ContextMenuTarget(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuTarget>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuTarget>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2ContextMenuTarget(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuTarget* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2ContextMenuTarget_get_FrameUri(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuTarget* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ContextMenuTarget", L"FrameUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FrameUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ContextMenuTarget_get_HasLinkText(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuTarget* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ContextMenuTarget", L"HasLinkText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasLinkText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ContextMenuTarget_get_HasLinkUri(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuTarget* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ContextMenuTarget", L"HasLinkUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasLinkUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ContextMenuTarget_get_HasSelection(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuTarget* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ContextMenuTarget", L"HasSelection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasSelection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ContextMenuTarget_get_HasSourceUri(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuTarget* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ContextMenuTarget", L"HasSourceUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasSourceUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ContextMenuTarget_get_IsEditable(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuTarget* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ContextMenuTarget", L"IsEditable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEditable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ContextMenuTarget_get_IsRequestedForMainFrame(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuTarget* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ContextMenuTarget", L"IsRequestedForMainFrame"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsRequestedForMainFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ContextMenuTarget_get_Kind(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuTarget* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ContextMenuTarget", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ContextMenuTarget_get_LinkText(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuTarget* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ContextMenuTarget", L"LinkText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LinkText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ContextMenuTarget_get_LinkUri(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuTarget* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ContextMenuTarget", L"LinkUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LinkUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ContextMenuTarget_get_PageUri(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuTarget* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ContextMenuTarget", L"PageUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PageUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ContextMenuTarget_get_SelectionText(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuTarget* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ContextMenuTarget", L"SelectionText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectionText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ContextMenuTarget_get_SourceUri(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuTarget* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ContextMenuTarget", L"SourceUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourceUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2ContextMenuTarget(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuTarget>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2ContextMenuTarget(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuTarget>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2ContextMenuTarget[] = {
        { "_assign_array_", _assign_array_CoreWebView2ContextMenuTarget, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2ContextMenuTarget), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2ContextMenuTarget[] = {
        { "frame_uri", reinterpret_cast<getter>(CoreWebView2ContextMenuTarget_get_FrameUri), nullptr, nullptr, nullptr },
        { "has_link_text", reinterpret_cast<getter>(CoreWebView2ContextMenuTarget_get_HasLinkText), nullptr, nullptr, nullptr },
        { "has_link_uri", reinterpret_cast<getter>(CoreWebView2ContextMenuTarget_get_HasLinkUri), nullptr, nullptr, nullptr },
        { "has_selection", reinterpret_cast<getter>(CoreWebView2ContextMenuTarget_get_HasSelection), nullptr, nullptr, nullptr },
        { "has_source_uri", reinterpret_cast<getter>(CoreWebView2ContextMenuTarget_get_HasSourceUri), nullptr, nullptr, nullptr },
        { "is_editable", reinterpret_cast<getter>(CoreWebView2ContextMenuTarget_get_IsEditable), nullptr, nullptr, nullptr },
        { "is_requested_for_main_frame", reinterpret_cast<getter>(CoreWebView2ContextMenuTarget_get_IsRequestedForMainFrame), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(CoreWebView2ContextMenuTarget_get_Kind), nullptr, nullptr, nullptr },
        { "link_text", reinterpret_cast<getter>(CoreWebView2ContextMenuTarget_get_LinkText), nullptr, nullptr, nullptr },
        { "link_uri", reinterpret_cast<getter>(CoreWebView2ContextMenuTarget_get_LinkUri), nullptr, nullptr, nullptr },
        { "page_uri", reinterpret_cast<getter>(CoreWebView2ContextMenuTarget_get_PageUri), nullptr, nullptr, nullptr },
        { "selection_text", reinterpret_cast<getter>(CoreWebView2ContextMenuTarget_get_SelectionText), nullptr, nullptr, nullptr },
        { "source_uri", reinterpret_cast<getter>(CoreWebView2ContextMenuTarget_get_SourceUri), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2ContextMenuTarget[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2ContextMenuTarget) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2ContextMenuTarget) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2ContextMenuTarget) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2ContextMenuTarget) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2ContextMenuTarget =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2ContextMenuTarget",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuTarget),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2ContextMenuTarget
    };

    // ----- CoreWebView2Controller class --------------------

    static PyObject* _new_CoreWebView2Controller(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Controller>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Controller>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2Controller(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Controller* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2Controller_Close(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Controller* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Controller", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Controller_MoveFocus(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Controller* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Controller", L"MoveFocus", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2MoveFocusReason>(args, 0);

                self->obj.MoveFocus(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Controller_NotifyParentWindowPositionChanged(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Controller* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Controller", L"NotifyParentWindowPositionChanged", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.NotifyParentWindowPositionChanged();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Controller_SetBoundsAndZoomFactor(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Controller* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Controller", L"SetBoundsAndZoomFactor", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.SetBoundsAndZoomFactor(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Controller_get_ZoomFactor(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Controller* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Controller", L"ZoomFactor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ZoomFactor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2Controller_put_ZoomFactor(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Controller* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Controller", L"ZoomFactor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.ZoomFactor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2Controller_get_ParentWindow(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Controller* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Controller", L"ParentWindow"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ParentWindow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2Controller_put_ParentWindow(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Controller* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Controller", L"ParentWindow"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ControllerWindowReference>(arg);

            self->obj.ParentWindow(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2Controller_get_IsVisible(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Controller* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Controller", L"IsVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2Controller_put_IsVisible(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Controller* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Controller", L"IsVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2Controller_get_Bounds(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Controller* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Controller", L"Bounds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Bounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2Controller_put_Bounds(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Controller* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Controller", L"Bounds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(arg);

            self->obj.Bounds(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2Controller_get_CoreWebView2(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Controller* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Controller", L"CoreWebView2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CoreWebView2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Controller_get_DefaultBackgroundColor(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Controller* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Controller", L"DefaultBackgroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultBackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2Controller_put_DefaultBackgroundColor(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Controller* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Controller", L"DefaultBackgroundColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.DefaultBackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2Controller_get_ShouldDetectMonitorScaleChanges(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Controller* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Controller", L"ShouldDetectMonitorScaleChanges"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShouldDetectMonitorScaleChanges());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2Controller_put_ShouldDetectMonitorScaleChanges(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Controller* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Controller", L"ShouldDetectMonitorScaleChanges"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShouldDetectMonitorScaleChanges(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2Controller_get_RasterizationScale(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Controller* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Controller", L"RasterizationScale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RasterizationScale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2Controller_put_RasterizationScale(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Controller* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Controller", L"RasterizationScale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.RasterizationScale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2Controller_get_BoundsMode(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Controller* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Controller", L"BoundsMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BoundsMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2Controller_put_BoundsMode(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Controller* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Controller", L"BoundsMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2BoundsMode>(arg);

            self->obj.BoundsMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2Controller_get_AllowExternalDrop(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Controller* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Controller", L"AllowExternalDrop"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllowExternalDrop());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2Controller_put_AllowExternalDrop(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Controller* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Controller", L"AllowExternalDrop"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowExternalDrop(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2Controller_get_IsBrowserHitTransparent(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Controller* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Controller", L"IsBrowserHitTransparent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsBrowserHitTransparent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Controller_add_RasterizationScaleChanged(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Controller* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Controller", L"RasterizationScaleChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Controller, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.RasterizationScaleChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Controller_remove_RasterizationScaleChanged(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Controller* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Controller", L"RasterizationScaleChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RasterizationScaleChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Controller_add_AcceleratorKeyPressed(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Controller* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Controller", L"AcceleratorKeyPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Controller, winrt::Microsoft::Web::WebView2::Core::CoreWebView2AcceleratorKeyPressedEventArgs>>(arg);

            return py::convert(self->obj.AcceleratorKeyPressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Controller_remove_AcceleratorKeyPressed(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Controller* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Controller", L"AcceleratorKeyPressed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AcceleratorKeyPressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Controller_add_GotFocus(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Controller* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Controller", L"GotFocus"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Controller, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.GotFocus(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Controller_remove_GotFocus(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Controller* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Controller", L"GotFocus"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.GotFocus(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Controller_add_LostFocus(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Controller* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Controller", L"LostFocus"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Controller, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.LostFocus(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Controller_remove_LostFocus(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Controller* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Controller", L"LostFocus"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LostFocus(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Controller_add_MoveFocusRequested(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Controller* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Controller", L"MoveFocusRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Controller, winrt::Microsoft::Web::WebView2::Core::CoreWebView2MoveFocusRequestedEventArgs>>(arg);

            return py::convert(self->obj.MoveFocusRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Controller_remove_MoveFocusRequested(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Controller* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Controller", L"MoveFocusRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MoveFocusRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Controller_add_ZoomFactorChanged(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Controller* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Controller", L"ZoomFactorChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Controller, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ZoomFactorChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Controller_remove_ZoomFactorChanged(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Controller* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Controller", L"ZoomFactorChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ZoomFactorChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2Controller(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Controller>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2Controller(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Controller>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2Controller[] = {
        { "close", reinterpret_cast<PyCFunction>(CoreWebView2Controller_Close), METH_VARARGS, nullptr },
        { "move_focus", reinterpret_cast<PyCFunction>(CoreWebView2Controller_MoveFocus), METH_VARARGS, nullptr },
        { "notify_parent_window_position_changed", reinterpret_cast<PyCFunction>(CoreWebView2Controller_NotifyParentWindowPositionChanged), METH_VARARGS, nullptr },
        { "set_bounds_and_zoom_factor", reinterpret_cast<PyCFunction>(CoreWebView2Controller_SetBoundsAndZoomFactor), METH_VARARGS, nullptr },
        { "add_rasterization_scale_changed", reinterpret_cast<PyCFunction>(CoreWebView2Controller_add_RasterizationScaleChanged), METH_O, nullptr },
        { "remove_rasterization_scale_changed", reinterpret_cast<PyCFunction>(CoreWebView2Controller_remove_RasterizationScaleChanged), METH_O, nullptr },
        { "add_accelerator_key_pressed", reinterpret_cast<PyCFunction>(CoreWebView2Controller_add_AcceleratorKeyPressed), METH_O, nullptr },
        { "remove_accelerator_key_pressed", reinterpret_cast<PyCFunction>(CoreWebView2Controller_remove_AcceleratorKeyPressed), METH_O, nullptr },
        { "add_got_focus", reinterpret_cast<PyCFunction>(CoreWebView2Controller_add_GotFocus), METH_O, nullptr },
        { "remove_got_focus", reinterpret_cast<PyCFunction>(CoreWebView2Controller_remove_GotFocus), METH_O, nullptr },
        { "add_lost_focus", reinterpret_cast<PyCFunction>(CoreWebView2Controller_add_LostFocus), METH_O, nullptr },
        { "remove_lost_focus", reinterpret_cast<PyCFunction>(CoreWebView2Controller_remove_LostFocus), METH_O, nullptr },
        { "add_move_focus_requested", reinterpret_cast<PyCFunction>(CoreWebView2Controller_add_MoveFocusRequested), METH_O, nullptr },
        { "remove_move_focus_requested", reinterpret_cast<PyCFunction>(CoreWebView2Controller_remove_MoveFocusRequested), METH_O, nullptr },
        { "add_zoom_factor_changed", reinterpret_cast<PyCFunction>(CoreWebView2Controller_add_ZoomFactorChanged), METH_O, nullptr },
        { "remove_zoom_factor_changed", reinterpret_cast<PyCFunction>(CoreWebView2Controller_remove_ZoomFactorChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_CoreWebView2Controller, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2Controller), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2Controller[] = {
        { "zoom_factor", reinterpret_cast<getter>(CoreWebView2Controller_get_ZoomFactor), reinterpret_cast<setter>(CoreWebView2Controller_put_ZoomFactor), nullptr, nullptr },
        { "parent_window", reinterpret_cast<getter>(CoreWebView2Controller_get_ParentWindow), reinterpret_cast<setter>(CoreWebView2Controller_put_ParentWindow), nullptr, nullptr },
        { "is_visible", reinterpret_cast<getter>(CoreWebView2Controller_get_IsVisible), reinterpret_cast<setter>(CoreWebView2Controller_put_IsVisible), nullptr, nullptr },
        { "bounds", reinterpret_cast<getter>(CoreWebView2Controller_get_Bounds), reinterpret_cast<setter>(CoreWebView2Controller_put_Bounds), nullptr, nullptr },
        { "core_web_view2", reinterpret_cast<getter>(CoreWebView2Controller_get_CoreWebView2), nullptr, nullptr, nullptr },
        { "default_background_color", reinterpret_cast<getter>(CoreWebView2Controller_get_DefaultBackgroundColor), reinterpret_cast<setter>(CoreWebView2Controller_put_DefaultBackgroundColor), nullptr, nullptr },
        { "should_detect_monitor_scale_changes", reinterpret_cast<getter>(CoreWebView2Controller_get_ShouldDetectMonitorScaleChanges), reinterpret_cast<setter>(CoreWebView2Controller_put_ShouldDetectMonitorScaleChanges), nullptr, nullptr },
        { "rasterization_scale", reinterpret_cast<getter>(CoreWebView2Controller_get_RasterizationScale), reinterpret_cast<setter>(CoreWebView2Controller_put_RasterizationScale), nullptr, nullptr },
        { "bounds_mode", reinterpret_cast<getter>(CoreWebView2Controller_get_BoundsMode), reinterpret_cast<setter>(CoreWebView2Controller_put_BoundsMode), nullptr, nullptr },
        { "allow_external_drop", reinterpret_cast<getter>(CoreWebView2Controller_get_AllowExternalDrop), reinterpret_cast<setter>(CoreWebView2Controller_put_AllowExternalDrop), nullptr, nullptr },
        { "is_browser_hit_transparent", reinterpret_cast<getter>(CoreWebView2Controller_get_IsBrowserHitTransparent), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2Controller[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2Controller) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2Controller) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2Controller) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2Controller) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2Controller =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2Controller",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Controller),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2Controller
    };

    // ----- CoreWebView2ControllerOptions class --------------------

    static PyObject* _new_CoreWebView2ControllerOptions(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ControllerOptions>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ControllerOptions>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2ControllerOptions(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ControllerOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2ControllerOptions_get_ProfileName(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ControllerOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ControllerOptions", L"ProfileName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProfileName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2ControllerOptions_put_ProfileName(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ControllerOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ControllerOptions", L"ProfileName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ProfileName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2ControllerOptions_get_IsInPrivateModeEnabled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ControllerOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ControllerOptions", L"IsInPrivateModeEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsInPrivateModeEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2ControllerOptions_put_IsInPrivateModeEnabled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ControllerOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ControllerOptions", L"IsInPrivateModeEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsInPrivateModeEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2ControllerOptions_get_ScriptLocale(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ControllerOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ControllerOptions", L"ScriptLocale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ScriptLocale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2ControllerOptions_put_ScriptLocale(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ControllerOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ControllerOptions", L"ScriptLocale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ScriptLocale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CoreWebView2ControllerOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ControllerOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2ControllerOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ControllerOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2ControllerOptions[] = {
        { "_assign_array_", _assign_array_CoreWebView2ControllerOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2ControllerOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2ControllerOptions[] = {
        { "profile_name", reinterpret_cast<getter>(CoreWebView2ControllerOptions_get_ProfileName), reinterpret_cast<setter>(CoreWebView2ControllerOptions_put_ProfileName), nullptr, nullptr },
        { "is_in_private_mode_enabled", reinterpret_cast<getter>(CoreWebView2ControllerOptions_get_IsInPrivateModeEnabled), reinterpret_cast<setter>(CoreWebView2ControllerOptions_put_IsInPrivateModeEnabled), nullptr, nullptr },
        { "script_locale", reinterpret_cast<getter>(CoreWebView2ControllerOptions_get_ScriptLocale), reinterpret_cast<setter>(CoreWebView2ControllerOptions_put_ScriptLocale), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2ControllerOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2ControllerOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2ControllerOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2ControllerOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2ControllerOptions) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2ControllerOptions =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2ControllerOptions",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ControllerOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2ControllerOptions
    };

    // ----- CoreWebView2ControllerWindowReference class --------------------

    static PyObject* _new_CoreWebView2ControllerWindowReference(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ControllerWindowReference>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ControllerWindowReference>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2ControllerWindowReference(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ControllerWindowReference* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2ControllerWindowReference_CreateFromCoreWindow(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ControllerWindowReference", L"CreateFromCoreWindow", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Core::CoreWindow>(args, 0);

                return py::convert(winrt::Microsoft::Web::WebView2::Core::CoreWebView2ControllerWindowReference::CreateFromCoreWindow(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ControllerWindowReference_CreateFromWindowHandle(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ControllerWindowReference", L"CreateFromWindowHandle", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(winrt::Microsoft::Web::WebView2::Core::CoreWebView2ControllerWindowReference::CreateFromWindowHandle(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ControllerWindowReference_get_CoreWindow(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ControllerWindowReference* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ControllerWindowReference", L"CoreWindow"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CoreWindow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ControllerWindowReference_get_WindowHandle(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ControllerWindowReference* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ControllerWindowReference", L"WindowHandle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WindowHandle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2ControllerWindowReference(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ControllerWindowReference>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2ControllerWindowReference(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ControllerWindowReference>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2ControllerWindowReference[] = {
        { "_assign_array_", _assign_array_CoreWebView2ControllerWindowReference, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2ControllerWindowReference), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2ControllerWindowReference[] = {
        { "core_window", reinterpret_cast<getter>(CoreWebView2ControllerWindowReference_get_CoreWindow), nullptr, nullptr, nullptr },
        { "window_handle", reinterpret_cast<getter>(CoreWebView2ControllerWindowReference_get_WindowHandle), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2ControllerWindowReference[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2ControllerWindowReference) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2ControllerWindowReference) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2ControllerWindowReference) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2ControllerWindowReference) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2ControllerWindowReference =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2ControllerWindowReference",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ControllerWindowReference),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2ControllerWindowReference
    };

    static PyGetSetDef getset_CoreWebView2ControllerWindowReference_Static[] = {
        { }
    };

    static PyMethodDef methods_CoreWebView2ControllerWindowReference_Static[] = {
        { "create_from_core_window", reinterpret_cast<PyCFunction>(CoreWebView2ControllerWindowReference_CreateFromCoreWindow), METH_VARARGS, nullptr },
        { "create_from_window_handle", reinterpret_cast<PyCFunction>(CoreWebView2ControllerWindowReference_CreateFromWindowHandle), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_CoreWebView2ControllerWindowReference_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CoreWebView2ControllerWindowReference_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CoreWebView2ControllerWindowReference_Static) },
        { }
    };

    static PyType_Spec type_spec_CoreWebView2ControllerWindowReference_Static =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2ControllerWindowReference_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CoreWebView2ControllerWindowReference_Static
    };

    // ----- CoreWebView2Cookie class --------------------

    static PyObject* _new_CoreWebView2Cookie(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Cookie>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Cookie>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2Cookie(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Cookie* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2Cookie_get_Value(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Cookie* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Cookie", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2Cookie_put_Value(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Cookie* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Cookie", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2Cookie_get_SameSite(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Cookie* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Cookie", L"SameSite"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SameSite());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2Cookie_put_SameSite(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Cookie* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Cookie", L"SameSite"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2CookieSameSiteKind>(arg);

            self->obj.SameSite(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2Cookie_get_IsSecure(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Cookie* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Cookie", L"IsSecure"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSecure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2Cookie_put_IsSecure(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Cookie* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Cookie", L"IsSecure"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsSecure(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2Cookie_get_IsHttpOnly(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Cookie* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Cookie", L"IsHttpOnly"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsHttpOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2Cookie_put_IsHttpOnly(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Cookie* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Cookie", L"IsHttpOnly"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsHttpOnly(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2Cookie_get_Expires(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Cookie* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Cookie", L"Expires"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Expires());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2Cookie_put_Expires(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Cookie* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Cookie", L"Expires"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Expires(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2Cookie_get_Domain(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Cookie* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Cookie", L"Domain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Domain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Cookie_get_IsSession(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Cookie* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Cookie", L"IsSession"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSession());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Cookie_get_Name(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Cookie* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Cookie", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Cookie_get_Path(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Cookie* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Cookie", L"Path"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2Cookie(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Cookie>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2Cookie(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Cookie>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2Cookie[] = {
        { "_assign_array_", _assign_array_CoreWebView2Cookie, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2Cookie), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2Cookie[] = {
        { "value", reinterpret_cast<getter>(CoreWebView2Cookie_get_Value), reinterpret_cast<setter>(CoreWebView2Cookie_put_Value), nullptr, nullptr },
        { "same_site", reinterpret_cast<getter>(CoreWebView2Cookie_get_SameSite), reinterpret_cast<setter>(CoreWebView2Cookie_put_SameSite), nullptr, nullptr },
        { "is_secure", reinterpret_cast<getter>(CoreWebView2Cookie_get_IsSecure), reinterpret_cast<setter>(CoreWebView2Cookie_put_IsSecure), nullptr, nullptr },
        { "is_http_only", reinterpret_cast<getter>(CoreWebView2Cookie_get_IsHttpOnly), reinterpret_cast<setter>(CoreWebView2Cookie_put_IsHttpOnly), nullptr, nullptr },
        { "expires", reinterpret_cast<getter>(CoreWebView2Cookie_get_Expires), reinterpret_cast<setter>(CoreWebView2Cookie_put_Expires), nullptr, nullptr },
        { "domain", reinterpret_cast<getter>(CoreWebView2Cookie_get_Domain), nullptr, nullptr, nullptr },
        { "is_session", reinterpret_cast<getter>(CoreWebView2Cookie_get_IsSession), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(CoreWebView2Cookie_get_Name), nullptr, nullptr, nullptr },
        { "path", reinterpret_cast<getter>(CoreWebView2Cookie_get_Path), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2Cookie[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2Cookie) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2Cookie) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2Cookie) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2Cookie) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2Cookie =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2Cookie",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Cookie),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2Cookie
    };

    // ----- CoreWebView2CookieManager class --------------------

    static PyObject* _new_CoreWebView2CookieManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2CookieManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2CookieManager>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2CookieManager(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2CookieManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2CookieManager_AddOrUpdateCookie(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2CookieManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2CookieManager", L"AddOrUpdateCookie", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Cookie>(args, 0);

                self->obj.AddOrUpdateCookie(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2CookieManager_CopyCookie(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2CookieManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2CookieManager", L"CopyCookie", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Cookie>(args, 0);

                return py::convert(self->obj.CopyCookie(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2CookieManager_CreateCookie(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2CookieManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2CookieManager", L"CreateCookie", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert(self->obj.CreateCookie(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2CookieManager_DeleteAllCookies(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2CookieManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2CookieManager", L"DeleteAllCookies", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.DeleteAllCookies();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2CookieManager_DeleteCookie(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2CookieManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2CookieManager", L"DeleteCookie", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Cookie>(args, 0);

                self->obj.DeleteCookie(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2CookieManager_DeleteCookies(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2CookieManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2CookieManager", L"DeleteCookies", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.DeleteCookies(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2CookieManager_DeleteCookiesWithDomainAndPath(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2CookieManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2CookieManager", L"DeleteCookiesWithDomainAndPath", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                self->obj.DeleteCookiesWithDomainAndPath(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2CookieManager_GetCookiesAsync(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2CookieManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2CookieManager", L"GetCookiesAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetCookiesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2CookieManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2CookieManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2CookieManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2CookieManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2CookieManager[] = {
        { "add_or_update_cookie", reinterpret_cast<PyCFunction>(CoreWebView2CookieManager_AddOrUpdateCookie), METH_VARARGS, nullptr },
        { "copy_cookie", reinterpret_cast<PyCFunction>(CoreWebView2CookieManager_CopyCookie), METH_VARARGS, nullptr },
        { "create_cookie", reinterpret_cast<PyCFunction>(CoreWebView2CookieManager_CreateCookie), METH_VARARGS, nullptr },
        { "delete_all_cookies", reinterpret_cast<PyCFunction>(CoreWebView2CookieManager_DeleteAllCookies), METH_VARARGS, nullptr },
        { "delete_cookie", reinterpret_cast<PyCFunction>(CoreWebView2CookieManager_DeleteCookie), METH_VARARGS, nullptr },
        { "delete_cookies", reinterpret_cast<PyCFunction>(CoreWebView2CookieManager_DeleteCookies), METH_VARARGS, nullptr },
        { "delete_cookies_with_domain_and_path", reinterpret_cast<PyCFunction>(CoreWebView2CookieManager_DeleteCookiesWithDomainAndPath), METH_VARARGS, nullptr },
        { "get_cookies_async", reinterpret_cast<PyCFunction>(CoreWebView2CookieManager_GetCookiesAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreWebView2CookieManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2CookieManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2CookieManager[] = {
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2CookieManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2CookieManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2CookieManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2CookieManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2CookieManager) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2CookieManager =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2CookieManager",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2CookieManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2CookieManager
    };

    // ----- CoreWebView2CustomSchemeRegistration class --------------------

    static PyObject* _new_CoreWebView2CustomSchemeRegistration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2CustomSchemeRegistration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2CustomSchemeRegistration>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2CustomSchemeRegistration(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2CustomSchemeRegistration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2CustomSchemeRegistration_get_TreatAsSecure(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2CustomSchemeRegistration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2CustomSchemeRegistration", L"TreatAsSecure"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TreatAsSecure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2CustomSchemeRegistration_put_TreatAsSecure(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2CustomSchemeRegistration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2CustomSchemeRegistration", L"TreatAsSecure"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.TreatAsSecure(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2CustomSchemeRegistration_get_HasAuthorityComponent(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2CustomSchemeRegistration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2CustomSchemeRegistration", L"HasAuthorityComponent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasAuthorityComponent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2CustomSchemeRegistration_put_HasAuthorityComponent(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2CustomSchemeRegistration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2CustomSchemeRegistration", L"HasAuthorityComponent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.HasAuthorityComponent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CoreWebView2CustomSchemeRegistration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2CustomSchemeRegistration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2CustomSchemeRegistration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2CustomSchemeRegistration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2CustomSchemeRegistration[] = {
        { "_assign_array_", _assign_array_CoreWebView2CustomSchemeRegistration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2CustomSchemeRegistration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2CustomSchemeRegistration[] = {
        { "treat_as_secure", reinterpret_cast<getter>(CoreWebView2CustomSchemeRegistration_get_TreatAsSecure), reinterpret_cast<setter>(CoreWebView2CustomSchemeRegistration_put_TreatAsSecure), nullptr, nullptr },
        { "has_authority_component", reinterpret_cast<getter>(CoreWebView2CustomSchemeRegistration_get_HasAuthorityComponent), reinterpret_cast<setter>(CoreWebView2CustomSchemeRegistration_put_HasAuthorityComponent), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2CustomSchemeRegistration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2CustomSchemeRegistration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2CustomSchemeRegistration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2CustomSchemeRegistration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2CustomSchemeRegistration) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2CustomSchemeRegistration =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2CustomSchemeRegistration",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2CustomSchemeRegistration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2CustomSchemeRegistration
    };

    // ----- CoreWebView2DOMContentLoadedEventArgs class --------------------

    static PyObject* _new_CoreWebView2DOMContentLoadedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2DOMContentLoadedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2DOMContentLoadedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2DOMContentLoadedEventArgs(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DOMContentLoadedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2DOMContentLoadedEventArgs_get_NavigationId(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DOMContentLoadedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2DOMContentLoadedEventArgs", L"NavigationId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NavigationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2DOMContentLoadedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2DOMContentLoadedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2DOMContentLoadedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2DOMContentLoadedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2DOMContentLoadedEventArgs[] = {
        { "_assign_array_", _assign_array_CoreWebView2DOMContentLoadedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2DOMContentLoadedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2DOMContentLoadedEventArgs[] = {
        { "navigation_id", reinterpret_cast<getter>(CoreWebView2DOMContentLoadedEventArgs_get_NavigationId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2DOMContentLoadedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2DOMContentLoadedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2DOMContentLoadedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2DOMContentLoadedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2DOMContentLoadedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2DOMContentLoadedEventArgs =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2DOMContentLoadedEventArgs",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DOMContentLoadedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2DOMContentLoadedEventArgs
    };

    // ----- CoreWebView2DevToolsProtocolEventReceivedEventArgs class --------------------

    static PyObject* _new_CoreWebView2DevToolsProtocolEventReceivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2DevToolsProtocolEventReceivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2DevToolsProtocolEventReceivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2DevToolsProtocolEventReceivedEventArgs(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DevToolsProtocolEventReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2DevToolsProtocolEventReceivedEventArgs_get_ParameterObjectAsJson(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DevToolsProtocolEventReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2DevToolsProtocolEventReceivedEventArgs", L"ParameterObjectAsJson"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ParameterObjectAsJson());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2DevToolsProtocolEventReceivedEventArgs_get_SessionId(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DevToolsProtocolEventReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2DevToolsProtocolEventReceivedEventArgs", L"SessionId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SessionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2DevToolsProtocolEventReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2DevToolsProtocolEventReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2DevToolsProtocolEventReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2DevToolsProtocolEventReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2DevToolsProtocolEventReceivedEventArgs[] = {
        { "_assign_array_", _assign_array_CoreWebView2DevToolsProtocolEventReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2DevToolsProtocolEventReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2DevToolsProtocolEventReceivedEventArgs[] = {
        { "parameter_object_as_json", reinterpret_cast<getter>(CoreWebView2DevToolsProtocolEventReceivedEventArgs_get_ParameterObjectAsJson), nullptr, nullptr, nullptr },
        { "session_id", reinterpret_cast<getter>(CoreWebView2DevToolsProtocolEventReceivedEventArgs_get_SessionId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2DevToolsProtocolEventReceivedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2DevToolsProtocolEventReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2DevToolsProtocolEventReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2DevToolsProtocolEventReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2DevToolsProtocolEventReceivedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2DevToolsProtocolEventReceivedEventArgs =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2DevToolsProtocolEventReceivedEventArgs",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DevToolsProtocolEventReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2DevToolsProtocolEventReceivedEventArgs
    };

    // ----- CoreWebView2DevToolsProtocolEventReceiver class --------------------

    static PyObject* _new_CoreWebView2DevToolsProtocolEventReceiver(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2DevToolsProtocolEventReceiver>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2DevToolsProtocolEventReceiver>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2DevToolsProtocolEventReceiver(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DevToolsProtocolEventReceiver* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2DevToolsProtocolEventReceiver_add_DevToolsProtocolEventReceived(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DevToolsProtocolEventReceiver* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2DevToolsProtocolEventReceiver", L"DevToolsProtocolEventReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2, winrt::Microsoft::Web::WebView2::Core::CoreWebView2DevToolsProtocolEventReceivedEventArgs>>(arg);

            return py::convert(self->obj.DevToolsProtocolEventReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2DevToolsProtocolEventReceiver_remove_DevToolsProtocolEventReceived(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DevToolsProtocolEventReceiver* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2DevToolsProtocolEventReceiver", L"DevToolsProtocolEventReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DevToolsProtocolEventReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2DevToolsProtocolEventReceiver(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2DevToolsProtocolEventReceiver>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2DevToolsProtocolEventReceiver(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2DevToolsProtocolEventReceiver>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2DevToolsProtocolEventReceiver[] = {
        { "add_dev_tools_protocol_event_received", reinterpret_cast<PyCFunction>(CoreWebView2DevToolsProtocolEventReceiver_add_DevToolsProtocolEventReceived), METH_O, nullptr },
        { "remove_dev_tools_protocol_event_received", reinterpret_cast<PyCFunction>(CoreWebView2DevToolsProtocolEventReceiver_remove_DevToolsProtocolEventReceived), METH_O, nullptr },
        { "_assign_array_", _assign_array_CoreWebView2DevToolsProtocolEventReceiver, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2DevToolsProtocolEventReceiver), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2DevToolsProtocolEventReceiver[] = {
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2DevToolsProtocolEventReceiver[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2DevToolsProtocolEventReceiver) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2DevToolsProtocolEventReceiver) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2DevToolsProtocolEventReceiver) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2DevToolsProtocolEventReceiver) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2DevToolsProtocolEventReceiver =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2DevToolsProtocolEventReceiver",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DevToolsProtocolEventReceiver),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2DevToolsProtocolEventReceiver
    };

    // ----- CoreWebView2DownloadOperation class --------------------

    static PyObject* _new_CoreWebView2DownloadOperation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2DownloadOperation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2DownloadOperation>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2DownloadOperation(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DownloadOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2DownloadOperation_Cancel(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DownloadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2DownloadOperation", L"Cancel", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Cancel();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2DownloadOperation_Pause(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DownloadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2DownloadOperation", L"Pause", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Pause();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2DownloadOperation_Resume(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DownloadOperation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2DownloadOperation", L"Resume", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Resume();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2DownloadOperation_get_BytesReceived(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DownloadOperation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2DownloadOperation", L"BytesReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BytesReceived());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2DownloadOperation_get_CanResume(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DownloadOperation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2DownloadOperation", L"CanResume"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanResume());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2DownloadOperation_get_ContentDisposition(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DownloadOperation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2DownloadOperation", L"ContentDisposition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContentDisposition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2DownloadOperation_get_EstimatedEndTime(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DownloadOperation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2DownloadOperation", L"EstimatedEndTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EstimatedEndTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2DownloadOperation_get_InterruptReason(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DownloadOperation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2DownloadOperation", L"InterruptReason"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InterruptReason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2DownloadOperation_get_MimeType(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DownloadOperation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2DownloadOperation", L"MimeType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MimeType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2DownloadOperation_get_ResultFilePath(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DownloadOperation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2DownloadOperation", L"ResultFilePath"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ResultFilePath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2DownloadOperation_get_State(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DownloadOperation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2DownloadOperation", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2DownloadOperation_get_TotalBytesToReceive(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DownloadOperation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2DownloadOperation", L"TotalBytesToReceive"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TotalBytesToReceive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2DownloadOperation_get_Uri(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DownloadOperation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2DownloadOperation", L"Uri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2DownloadOperation_add_BytesReceivedChanged(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DownloadOperation* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2DownloadOperation", L"BytesReceivedChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2DownloadOperation, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.BytesReceivedChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2DownloadOperation_remove_BytesReceivedChanged(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DownloadOperation* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2DownloadOperation", L"BytesReceivedChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BytesReceivedChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2DownloadOperation_add_EstimatedEndTimeChanged(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DownloadOperation* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2DownloadOperation", L"EstimatedEndTimeChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2DownloadOperation, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.EstimatedEndTimeChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2DownloadOperation_remove_EstimatedEndTimeChanged(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DownloadOperation* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2DownloadOperation", L"EstimatedEndTimeChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EstimatedEndTimeChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2DownloadOperation_add_StateChanged(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DownloadOperation* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2DownloadOperation", L"StateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2DownloadOperation, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.StateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2DownloadOperation_remove_StateChanged(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DownloadOperation* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2DownloadOperation", L"StateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2DownloadOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2DownloadOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2DownloadOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2DownloadOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2DownloadOperation[] = {
        { "cancel", reinterpret_cast<PyCFunction>(CoreWebView2DownloadOperation_Cancel), METH_VARARGS, nullptr },
        { "pause", reinterpret_cast<PyCFunction>(CoreWebView2DownloadOperation_Pause), METH_VARARGS, nullptr },
        { "resume", reinterpret_cast<PyCFunction>(CoreWebView2DownloadOperation_Resume), METH_VARARGS, nullptr },
        { "add_bytes_received_changed", reinterpret_cast<PyCFunction>(CoreWebView2DownloadOperation_add_BytesReceivedChanged), METH_O, nullptr },
        { "remove_bytes_received_changed", reinterpret_cast<PyCFunction>(CoreWebView2DownloadOperation_remove_BytesReceivedChanged), METH_O, nullptr },
        { "add_estimated_end_time_changed", reinterpret_cast<PyCFunction>(CoreWebView2DownloadOperation_add_EstimatedEndTimeChanged), METH_O, nullptr },
        { "remove_estimated_end_time_changed", reinterpret_cast<PyCFunction>(CoreWebView2DownloadOperation_remove_EstimatedEndTimeChanged), METH_O, nullptr },
        { "add_state_changed", reinterpret_cast<PyCFunction>(CoreWebView2DownloadOperation_add_StateChanged), METH_O, nullptr },
        { "remove_state_changed", reinterpret_cast<PyCFunction>(CoreWebView2DownloadOperation_remove_StateChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_CoreWebView2DownloadOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2DownloadOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2DownloadOperation[] = {
        { "bytes_received", reinterpret_cast<getter>(CoreWebView2DownloadOperation_get_BytesReceived), nullptr, nullptr, nullptr },
        { "can_resume", reinterpret_cast<getter>(CoreWebView2DownloadOperation_get_CanResume), nullptr, nullptr, nullptr },
        { "content_disposition", reinterpret_cast<getter>(CoreWebView2DownloadOperation_get_ContentDisposition), nullptr, nullptr, nullptr },
        { "estimated_end_time", reinterpret_cast<getter>(CoreWebView2DownloadOperation_get_EstimatedEndTime), nullptr, nullptr, nullptr },
        { "interrupt_reason", reinterpret_cast<getter>(CoreWebView2DownloadOperation_get_InterruptReason), nullptr, nullptr, nullptr },
        { "mime_type", reinterpret_cast<getter>(CoreWebView2DownloadOperation_get_MimeType), nullptr, nullptr, nullptr },
        { "result_file_path", reinterpret_cast<getter>(CoreWebView2DownloadOperation_get_ResultFilePath), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(CoreWebView2DownloadOperation_get_State), nullptr, nullptr, nullptr },
        { "total_bytes_to_receive", reinterpret_cast<getter>(CoreWebView2DownloadOperation_get_TotalBytesToReceive), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(CoreWebView2DownloadOperation_get_Uri), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2DownloadOperation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2DownloadOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2DownloadOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2DownloadOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2DownloadOperation) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2DownloadOperation =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2DownloadOperation",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DownloadOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2DownloadOperation
    };

    // ----- CoreWebView2DownloadStartingEventArgs class --------------------

    static PyObject* _new_CoreWebView2DownloadStartingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2DownloadStartingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2DownloadStartingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2DownloadStartingEventArgs(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DownloadStartingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2DownloadStartingEventArgs_GetDeferral(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DownloadStartingEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2DownloadStartingEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2DownloadStartingEventArgs_get_ResultFilePath(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DownloadStartingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2DownloadStartingEventArgs", L"ResultFilePath"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ResultFilePath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2DownloadStartingEventArgs_put_ResultFilePath(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DownloadStartingEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2DownloadStartingEventArgs", L"ResultFilePath"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ResultFilePath(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2DownloadStartingEventArgs_get_Handled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DownloadStartingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2DownloadStartingEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2DownloadStartingEventArgs_put_Handled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DownloadStartingEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2DownloadStartingEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2DownloadStartingEventArgs_get_Cancel(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DownloadStartingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2DownloadStartingEventArgs", L"Cancel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Cancel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2DownloadStartingEventArgs_put_Cancel(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DownloadStartingEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2DownloadStartingEventArgs", L"Cancel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Cancel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2DownloadStartingEventArgs_get_DownloadOperation(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DownloadStartingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2DownloadStartingEventArgs", L"DownloadOperation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DownloadOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2DownloadStartingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2DownloadStartingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2DownloadStartingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2DownloadStartingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2DownloadStartingEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CoreWebView2DownloadStartingEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreWebView2DownloadStartingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2DownloadStartingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2DownloadStartingEventArgs[] = {
        { "result_file_path", reinterpret_cast<getter>(CoreWebView2DownloadStartingEventArgs_get_ResultFilePath), reinterpret_cast<setter>(CoreWebView2DownloadStartingEventArgs_put_ResultFilePath), nullptr, nullptr },
        { "handled", reinterpret_cast<getter>(CoreWebView2DownloadStartingEventArgs_get_Handled), reinterpret_cast<setter>(CoreWebView2DownloadStartingEventArgs_put_Handled), nullptr, nullptr },
        { "cancel", reinterpret_cast<getter>(CoreWebView2DownloadStartingEventArgs_get_Cancel), reinterpret_cast<setter>(CoreWebView2DownloadStartingEventArgs_put_Cancel), nullptr, nullptr },
        { "download_operation", reinterpret_cast<getter>(CoreWebView2DownloadStartingEventArgs_get_DownloadOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2DownloadStartingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2DownloadStartingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2DownloadStartingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2DownloadStartingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2DownloadStartingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2DownloadStartingEventArgs =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2DownloadStartingEventArgs",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2DownloadStartingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2DownloadStartingEventArgs
    };

    // ----- CoreWebView2Environment class --------------------

    static PyObject* _new_CoreWebView2Environment(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Environment>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Environment>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2Environment(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Environment* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2Environment_CompareBrowserVersionString(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Environment", L"CompareBrowserVersionString", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Microsoft::Web::WebView2::Core::CoreWebView2Environment::CompareBrowserVersionString(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Environment_CreateAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Environment", L"CreateAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Microsoft::Web::WebView2::Core::CoreWebView2Environment::CreateAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Environment_CreateContextMenuItem(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Environment* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Environment", L"CreateContextMenuItem", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ContextMenuItemKind>(args, 2);

                return py::convert(self->obj.CreateContextMenuItem(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Environment_CreateCoreWebView2CompositionControllerAsync(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Environment* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Environment", L"CreateCoreWebView2CompositionControllerAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ControllerWindowReference>(args, 0);

                return py::convert(self->obj.CreateCoreWebView2CompositionControllerAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Environment", L"CreateCoreWebView2CompositionControllerAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ControllerWindowReference>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ControllerOptions>(args, 1);

                return py::convert(self->obj.CreateCoreWebView2CompositionControllerAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Environment_CreateCoreWebView2ControllerAsync(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Environment* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Environment", L"CreateCoreWebView2ControllerAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ControllerWindowReference>(args, 0);

                return py::convert(self->obj.CreateCoreWebView2ControllerAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Environment", L"CreateCoreWebView2ControllerAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ControllerWindowReference>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ControllerOptions>(args, 1);

                return py::convert(self->obj.CreateCoreWebView2ControllerAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Environment_CreateCoreWebView2ControllerOptions(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Environment* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Environment", L"CreateCoreWebView2ControllerOptions", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateCoreWebView2ControllerOptions());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Environment_CreateCoreWebView2PointerInfo(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Environment* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Environment", L"CreateCoreWebView2PointerInfo", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateCoreWebView2PointerInfo());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Environment_CreatePrintSettings(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Environment* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Environment", L"CreatePrintSettings", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreatePrintSettings());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Environment_CreateSharedBuffer(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Environment* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Environment", L"CreateSharedBuffer", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.CreateSharedBuffer(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Environment_CreateWebResourceRequest(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Environment* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Environment", L"CreateWebResourceRequest", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert(self->obj.CreateWebResourceRequest(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Environment_CreateWebResourceResponse(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Environment* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Environment", L"CreateWebResourceResponse", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert(self->obj.CreateWebResourceResponse(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Environment_CreateWithOptionsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Environment", L"CreateWithOptionsAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2EnvironmentOptions>(args, 2);

                return py::convert(winrt::Microsoft::Web::WebView2::Core::CoreWebView2Environment::CreateWithOptionsAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Environment_GetAvailableBrowserVersionString(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Environment", L"GetAvailableBrowserVersionString", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Microsoft::Web::WebView2::Core::CoreWebView2Environment::GetAvailableBrowserVersionString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Environment", L"GetAvailableBrowserVersionString", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Microsoft::Web::WebView2::Core::CoreWebView2Environment::GetAvailableBrowserVersionString(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Environment_GetProcessInfos(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Environment* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Environment", L"GetProcessInfos", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetProcessInfos());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Environment_get_BrowserVersionString(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Environment* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Environment", L"BrowserVersionString"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BrowserVersionString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Environment_get_FailureReportFolderPath(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Environment* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Environment", L"FailureReportFolderPath"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FailureReportFolderPath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Environment_get_UserDataFolder(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Environment* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Environment", L"UserDataFolder"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UserDataFolder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Environment_add_BrowserProcessExited(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Environment* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Environment", L"BrowserProcessExited"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Environment, winrt::Microsoft::Web::WebView2::Core::CoreWebView2BrowserProcessExitedEventArgs>>(arg);

            return py::convert(self->obj.BrowserProcessExited(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Environment_remove_BrowserProcessExited(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Environment* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Environment", L"BrowserProcessExited"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BrowserProcessExited(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Environment_add_ProcessInfosChanged(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Environment* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Environment", L"ProcessInfosChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Environment, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ProcessInfosChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Environment_remove_ProcessInfosChanged(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Environment* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Environment", L"ProcessInfosChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ProcessInfosChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Environment_add_NewBrowserVersionAvailable(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Environment* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Environment", L"NewBrowserVersionAvailable"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Environment, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.NewBrowserVersionAvailable(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Environment_remove_NewBrowserVersionAvailable(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Environment* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Environment", L"NewBrowserVersionAvailable"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.NewBrowserVersionAvailable(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2Environment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Environment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2Environment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Environment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2Environment[] = {
        { "create_context_menu_item", reinterpret_cast<PyCFunction>(CoreWebView2Environment_CreateContextMenuItem), METH_VARARGS, nullptr },
        { "create_core_web_view2_composition_controller_async", reinterpret_cast<PyCFunction>(CoreWebView2Environment_CreateCoreWebView2CompositionControllerAsync), METH_VARARGS, nullptr },
        { "create_core_web_view2_controller_async", reinterpret_cast<PyCFunction>(CoreWebView2Environment_CreateCoreWebView2ControllerAsync), METH_VARARGS, nullptr },
        { "create_core_web_view2_controller_options", reinterpret_cast<PyCFunction>(CoreWebView2Environment_CreateCoreWebView2ControllerOptions), METH_VARARGS, nullptr },
        { "create_core_web_view2_pointer_info", reinterpret_cast<PyCFunction>(CoreWebView2Environment_CreateCoreWebView2PointerInfo), METH_VARARGS, nullptr },
        { "create_print_settings", reinterpret_cast<PyCFunction>(CoreWebView2Environment_CreatePrintSettings), METH_VARARGS, nullptr },
        { "create_shared_buffer", reinterpret_cast<PyCFunction>(CoreWebView2Environment_CreateSharedBuffer), METH_VARARGS, nullptr },
        { "create_web_resource_request", reinterpret_cast<PyCFunction>(CoreWebView2Environment_CreateWebResourceRequest), METH_VARARGS, nullptr },
        { "create_web_resource_response", reinterpret_cast<PyCFunction>(CoreWebView2Environment_CreateWebResourceResponse), METH_VARARGS, nullptr },
        { "get_process_infos", reinterpret_cast<PyCFunction>(CoreWebView2Environment_GetProcessInfos), METH_VARARGS, nullptr },
        { "add_browser_process_exited", reinterpret_cast<PyCFunction>(CoreWebView2Environment_add_BrowserProcessExited), METH_O, nullptr },
        { "remove_browser_process_exited", reinterpret_cast<PyCFunction>(CoreWebView2Environment_remove_BrowserProcessExited), METH_O, nullptr },
        { "add_process_infos_changed", reinterpret_cast<PyCFunction>(CoreWebView2Environment_add_ProcessInfosChanged), METH_O, nullptr },
        { "remove_process_infos_changed", reinterpret_cast<PyCFunction>(CoreWebView2Environment_remove_ProcessInfosChanged), METH_O, nullptr },
        { "add_new_browser_version_available", reinterpret_cast<PyCFunction>(CoreWebView2Environment_add_NewBrowserVersionAvailable), METH_O, nullptr },
        { "remove_new_browser_version_available", reinterpret_cast<PyCFunction>(CoreWebView2Environment_remove_NewBrowserVersionAvailable), METH_O, nullptr },
        { "_assign_array_", _assign_array_CoreWebView2Environment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2Environment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2Environment[] = {
        { "browser_version_string", reinterpret_cast<getter>(CoreWebView2Environment_get_BrowserVersionString), nullptr, nullptr, nullptr },
        { "failure_report_folder_path", reinterpret_cast<getter>(CoreWebView2Environment_get_FailureReportFolderPath), nullptr, nullptr, nullptr },
        { "user_data_folder", reinterpret_cast<getter>(CoreWebView2Environment_get_UserDataFolder), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2Environment[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2Environment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2Environment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2Environment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2Environment) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2Environment =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2Environment",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Environment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2Environment
    };

    static PyGetSetDef getset_CoreWebView2Environment_Static[] = {
        { }
    };

    static PyMethodDef methods_CoreWebView2Environment_Static[] = {
        { "compare_browser_version_string", reinterpret_cast<PyCFunction>(CoreWebView2Environment_CompareBrowserVersionString), METH_VARARGS, nullptr },
        { "create_async", reinterpret_cast<PyCFunction>(CoreWebView2Environment_CreateAsync), METH_VARARGS, nullptr },
        { "create_with_options_async", reinterpret_cast<PyCFunction>(CoreWebView2Environment_CreateWithOptionsAsync), METH_VARARGS, nullptr },
        { "get_available_browser_version_string", reinterpret_cast<PyCFunction>(CoreWebView2Environment_GetAvailableBrowserVersionString), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_CoreWebView2Environment_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CoreWebView2Environment_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CoreWebView2Environment_Static) },
        { }
    };

    static PyType_Spec type_spec_CoreWebView2Environment_Static =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2Environment_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CoreWebView2Environment_Static
    };

    // ----- CoreWebView2EnvironmentOptions class --------------------

    static PyObject* _new_CoreWebView2EnvironmentOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::Web::WebView2::Core::CoreWebView2EnvironmentOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CoreWebView2EnvironmentOptions(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2EnvironmentOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2EnvironmentOptions_get_TargetCompatibleBrowserVersion(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2EnvironmentOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2EnvironmentOptions", L"TargetCompatibleBrowserVersion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TargetCompatibleBrowserVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2EnvironmentOptions_put_TargetCompatibleBrowserVersion(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2EnvironmentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2EnvironmentOptions", L"TargetCompatibleBrowserVersion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.TargetCompatibleBrowserVersion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2EnvironmentOptions_get_Language(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2EnvironmentOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2EnvironmentOptions", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2EnvironmentOptions_put_Language(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2EnvironmentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2EnvironmentOptions", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Language(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2EnvironmentOptions_get_AllowSingleSignOnUsingOSPrimaryAccount(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2EnvironmentOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2EnvironmentOptions", L"AllowSingleSignOnUsingOSPrimaryAccount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllowSingleSignOnUsingOSPrimaryAccount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2EnvironmentOptions_put_AllowSingleSignOnUsingOSPrimaryAccount(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2EnvironmentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2EnvironmentOptions", L"AllowSingleSignOnUsingOSPrimaryAccount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowSingleSignOnUsingOSPrimaryAccount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2EnvironmentOptions_get_AdditionalBrowserArguments(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2EnvironmentOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2EnvironmentOptions", L"AdditionalBrowserArguments"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AdditionalBrowserArguments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2EnvironmentOptions_put_AdditionalBrowserArguments(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2EnvironmentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2EnvironmentOptions", L"AdditionalBrowserArguments"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.AdditionalBrowserArguments(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2EnvironmentOptions_get_ExclusiveUserDataFolderAccess(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2EnvironmentOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2EnvironmentOptions", L"ExclusiveUserDataFolderAccess"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExclusiveUserDataFolderAccess());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2EnvironmentOptions_put_ExclusiveUserDataFolderAccess(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2EnvironmentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2EnvironmentOptions", L"ExclusiveUserDataFolderAccess"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ExclusiveUserDataFolderAccess(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2EnvironmentOptions_get_IsCustomCrashReportingEnabled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2EnvironmentOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2EnvironmentOptions", L"IsCustomCrashReportingEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsCustomCrashReportingEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2EnvironmentOptions_put_IsCustomCrashReportingEnabled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2EnvironmentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2EnvironmentOptions", L"IsCustomCrashReportingEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCustomCrashReportingEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2EnvironmentOptions_get_EnableTrackingPrevention(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2EnvironmentOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2EnvironmentOptions", L"EnableTrackingPrevention"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EnableTrackingPrevention());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2EnvironmentOptions_put_EnableTrackingPrevention(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2EnvironmentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2EnvironmentOptions", L"EnableTrackingPrevention"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.EnableTrackingPrevention(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CoreWebView2EnvironmentOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2EnvironmentOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2EnvironmentOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2EnvironmentOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2EnvironmentOptions[] = {
        { "_assign_array_", _assign_array_CoreWebView2EnvironmentOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2EnvironmentOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2EnvironmentOptions[] = {
        { "target_compatible_browser_version", reinterpret_cast<getter>(CoreWebView2EnvironmentOptions_get_TargetCompatibleBrowserVersion), reinterpret_cast<setter>(CoreWebView2EnvironmentOptions_put_TargetCompatibleBrowserVersion), nullptr, nullptr },
        { "language", reinterpret_cast<getter>(CoreWebView2EnvironmentOptions_get_Language), reinterpret_cast<setter>(CoreWebView2EnvironmentOptions_put_Language), nullptr, nullptr },
        { "allow_single_sign_on_using_o_s_primary_account", reinterpret_cast<getter>(CoreWebView2EnvironmentOptions_get_AllowSingleSignOnUsingOSPrimaryAccount), reinterpret_cast<setter>(CoreWebView2EnvironmentOptions_put_AllowSingleSignOnUsingOSPrimaryAccount), nullptr, nullptr },
        { "additional_browser_arguments", reinterpret_cast<getter>(CoreWebView2EnvironmentOptions_get_AdditionalBrowserArguments), reinterpret_cast<setter>(CoreWebView2EnvironmentOptions_put_AdditionalBrowserArguments), nullptr, nullptr },
        { "exclusive_user_data_folder_access", reinterpret_cast<getter>(CoreWebView2EnvironmentOptions_get_ExclusiveUserDataFolderAccess), reinterpret_cast<setter>(CoreWebView2EnvironmentOptions_put_ExclusiveUserDataFolderAccess), nullptr, nullptr },
        { "is_custom_crash_reporting_enabled", reinterpret_cast<getter>(CoreWebView2EnvironmentOptions_get_IsCustomCrashReportingEnabled), reinterpret_cast<setter>(CoreWebView2EnvironmentOptions_put_IsCustomCrashReportingEnabled), nullptr, nullptr },
        { "enable_tracking_prevention", reinterpret_cast<getter>(CoreWebView2EnvironmentOptions_get_EnableTrackingPrevention), reinterpret_cast<setter>(CoreWebView2EnvironmentOptions_put_EnableTrackingPrevention), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2EnvironmentOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2EnvironmentOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2EnvironmentOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2EnvironmentOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2EnvironmentOptions) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2EnvironmentOptions =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2EnvironmentOptions",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2EnvironmentOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2EnvironmentOptions
    };

    // ----- CoreWebView2File class --------------------

    static PyObject* _new_CoreWebView2File(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2File>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2File>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2File(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2File* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2File_get_Path(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2File* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2File", L"Path"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2File(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2File>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2File(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2File>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2File[] = {
        { "_assign_array_", _assign_array_CoreWebView2File, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2File), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2File[] = {
        { "path", reinterpret_cast<getter>(CoreWebView2File_get_Path), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2File[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2File) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2File) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2File) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2File) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2File =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2File",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2File),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2File
    };

    // ----- CoreWebView2Frame class --------------------

    static PyObject* _new_CoreWebView2Frame(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Frame>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Frame>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2Frame(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Frame* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2Frame_ExecuteScriptAsync(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Frame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Frame", L"ExecuteScriptAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ExecuteScriptAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Frame_IsDestroyed(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Frame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Frame", L"IsDestroyed", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.IsDestroyed());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Frame_PostSharedBufferToScript(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Frame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Frame", L"PostSharedBufferToScript", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2SharedBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2SharedBufferAccess>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                self->obj.PostSharedBufferToScript(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Frame_PostWebMessageAsJson(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Frame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Frame", L"PostWebMessageAsJson", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.PostWebMessageAsJson(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Frame_PostWebMessageAsString(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Frame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Frame", L"PostWebMessageAsString", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.PostWebMessageAsString(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Frame_RemoveHostObjectFromScript(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Frame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Frame", L"RemoveHostObjectFromScript", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.RemoveHostObjectFromScript(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Frame_get_Name(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Frame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Frame", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Frame_add_ContentLoading(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Frame* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Frame", L"ContentLoading"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Frame, winrt::Microsoft::Web::WebView2::Core::CoreWebView2ContentLoadingEventArgs>>(arg);

            return py::convert(self->obj.ContentLoading(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Frame_remove_ContentLoading(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Frame* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Frame", L"ContentLoading"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ContentLoading(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Frame_add_DOMContentLoaded(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Frame* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Frame", L"DOMContentLoaded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Frame, winrt::Microsoft::Web::WebView2::Core::CoreWebView2DOMContentLoadedEventArgs>>(arg);

            return py::convert(self->obj.DOMContentLoaded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Frame_remove_DOMContentLoaded(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Frame* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Frame", L"DOMContentLoaded"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DOMContentLoaded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Frame_add_NavigationCompleted(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Frame* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Frame", L"NavigationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Frame, winrt::Microsoft::Web::WebView2::Core::CoreWebView2NavigationCompletedEventArgs>>(arg);

            return py::convert(self->obj.NavigationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Frame_remove_NavigationCompleted(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Frame* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Frame", L"NavigationCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.NavigationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Frame_add_NavigationStarting(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Frame* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Frame", L"NavigationStarting"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Frame, winrt::Microsoft::Web::WebView2::Core::CoreWebView2NavigationStartingEventArgs>>(arg);

            return py::convert(self->obj.NavigationStarting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Frame_remove_NavigationStarting(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Frame* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Frame", L"NavigationStarting"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.NavigationStarting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Frame_add_WebMessageReceived(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Frame* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Frame", L"WebMessageReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Frame, winrt::Microsoft::Web::WebView2::Core::CoreWebView2WebMessageReceivedEventArgs>>(arg);

            return py::convert(self->obj.WebMessageReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Frame_remove_WebMessageReceived(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Frame* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Frame", L"WebMessageReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.WebMessageReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Frame_add_PermissionRequested(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Frame* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Frame", L"PermissionRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Frame, winrt::Microsoft::Web::WebView2::Core::CoreWebView2PermissionRequestedEventArgs>>(arg);

            return py::convert(self->obj.PermissionRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Frame_remove_PermissionRequested(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Frame* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Frame", L"PermissionRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PermissionRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Frame_add_Destroyed(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Frame* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Frame", L"Destroyed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Frame, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Destroyed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Frame_remove_Destroyed(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Frame* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Frame", L"Destroyed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Destroyed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Frame_add_NameChanged(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Frame* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Frame", L"NameChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Frame, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.NameChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Frame_remove_NameChanged(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Frame* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Frame", L"NameChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.NameChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2Frame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Frame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2Frame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Frame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2Frame[] = {
        { "execute_script_async", reinterpret_cast<PyCFunction>(CoreWebView2Frame_ExecuteScriptAsync), METH_VARARGS, nullptr },
        { "is_destroyed", reinterpret_cast<PyCFunction>(CoreWebView2Frame_IsDestroyed), METH_VARARGS, nullptr },
        { "post_shared_buffer_to_script", reinterpret_cast<PyCFunction>(CoreWebView2Frame_PostSharedBufferToScript), METH_VARARGS, nullptr },
        { "post_web_message_as_json", reinterpret_cast<PyCFunction>(CoreWebView2Frame_PostWebMessageAsJson), METH_VARARGS, nullptr },
        { "post_web_message_as_string", reinterpret_cast<PyCFunction>(CoreWebView2Frame_PostWebMessageAsString), METH_VARARGS, nullptr },
        { "remove_host_object_from_script", reinterpret_cast<PyCFunction>(CoreWebView2Frame_RemoveHostObjectFromScript), METH_VARARGS, nullptr },
        { "add_content_loading", reinterpret_cast<PyCFunction>(CoreWebView2Frame_add_ContentLoading), METH_O, nullptr },
        { "remove_content_loading", reinterpret_cast<PyCFunction>(CoreWebView2Frame_remove_ContentLoading), METH_O, nullptr },
        { "add_d_o_m_content_loaded", reinterpret_cast<PyCFunction>(CoreWebView2Frame_add_DOMContentLoaded), METH_O, nullptr },
        { "remove_d_o_m_content_loaded", reinterpret_cast<PyCFunction>(CoreWebView2Frame_remove_DOMContentLoaded), METH_O, nullptr },
        { "add_navigation_completed", reinterpret_cast<PyCFunction>(CoreWebView2Frame_add_NavigationCompleted), METH_O, nullptr },
        { "remove_navigation_completed", reinterpret_cast<PyCFunction>(CoreWebView2Frame_remove_NavigationCompleted), METH_O, nullptr },
        { "add_navigation_starting", reinterpret_cast<PyCFunction>(CoreWebView2Frame_add_NavigationStarting), METH_O, nullptr },
        { "remove_navigation_starting", reinterpret_cast<PyCFunction>(CoreWebView2Frame_remove_NavigationStarting), METH_O, nullptr },
        { "add_web_message_received", reinterpret_cast<PyCFunction>(CoreWebView2Frame_add_WebMessageReceived), METH_O, nullptr },
        { "remove_web_message_received", reinterpret_cast<PyCFunction>(CoreWebView2Frame_remove_WebMessageReceived), METH_O, nullptr },
        { "add_permission_requested", reinterpret_cast<PyCFunction>(CoreWebView2Frame_add_PermissionRequested), METH_O, nullptr },
        { "remove_permission_requested", reinterpret_cast<PyCFunction>(CoreWebView2Frame_remove_PermissionRequested), METH_O, nullptr },
        { "add_destroyed", reinterpret_cast<PyCFunction>(CoreWebView2Frame_add_Destroyed), METH_O, nullptr },
        { "remove_destroyed", reinterpret_cast<PyCFunction>(CoreWebView2Frame_remove_Destroyed), METH_O, nullptr },
        { "add_name_changed", reinterpret_cast<PyCFunction>(CoreWebView2Frame_add_NameChanged), METH_O, nullptr },
        { "remove_name_changed", reinterpret_cast<PyCFunction>(CoreWebView2Frame_remove_NameChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_CoreWebView2Frame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2Frame), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2Frame[] = {
        { "name", reinterpret_cast<getter>(CoreWebView2Frame_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2Frame[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2Frame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2Frame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2Frame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2Frame) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2Frame =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2Frame",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Frame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2Frame
    };

    // ----- CoreWebView2FrameCreatedEventArgs class --------------------

    static PyObject* _new_CoreWebView2FrameCreatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2FrameCreatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2FrameCreatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2FrameCreatedEventArgs(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2FrameCreatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2FrameCreatedEventArgs_get_Frame(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2FrameCreatedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2FrameCreatedEventArgs", L"Frame"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Frame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2FrameCreatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2FrameCreatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2FrameCreatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2FrameCreatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2FrameCreatedEventArgs[] = {
        { "_assign_array_", _assign_array_CoreWebView2FrameCreatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2FrameCreatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2FrameCreatedEventArgs[] = {
        { "frame", reinterpret_cast<getter>(CoreWebView2FrameCreatedEventArgs_get_Frame), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2FrameCreatedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2FrameCreatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2FrameCreatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2FrameCreatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2FrameCreatedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2FrameCreatedEventArgs =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2FrameCreatedEventArgs",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2FrameCreatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2FrameCreatedEventArgs
    };

    // ----- CoreWebView2FrameInfo class --------------------

    static PyObject* _new_CoreWebView2FrameInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2FrameInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2FrameInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2FrameInfo(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2FrameInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2FrameInfo_get_Name(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2FrameInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2FrameInfo", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2FrameInfo_get_Source(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2FrameInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2FrameInfo", L"Source"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2FrameInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2FrameInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2FrameInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2FrameInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2FrameInfo[] = {
        { "_assign_array_", _assign_array_CoreWebView2FrameInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2FrameInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2FrameInfo[] = {
        { "name", reinterpret_cast<getter>(CoreWebView2FrameInfo_get_Name), nullptr, nullptr, nullptr },
        { "source", reinterpret_cast<getter>(CoreWebView2FrameInfo_get_Source), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2FrameInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2FrameInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2FrameInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2FrameInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2FrameInfo) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2FrameInfo =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2FrameInfo",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2FrameInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2FrameInfo
    };

    // ----- CoreWebView2HttpHeadersCollectionIterator class --------------------

    static PyObject* _new_CoreWebView2HttpHeadersCollectionIterator(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2HttpHeadersCollectionIterator>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2HttpHeadersCollectionIterator>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2HttpHeadersCollectionIterator(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2HttpHeadersCollectionIterator* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2HttpHeadersCollectionIterator_GetMany(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2HttpHeadersCollectionIterator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2HttpHeadersCollectionIterator", L"GetMany", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::hstring>, true>>(args, 0);

                return py::convert(self->obj.GetMany(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2HttpHeadersCollectionIterator_MoveNext(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2HttpHeadersCollectionIterator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2HttpHeadersCollectionIterator", L"MoveNext", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.MoveNext());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2HttpHeadersCollectionIterator_get_Current(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2HttpHeadersCollectionIterator* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2HttpHeadersCollectionIterator", L"Current"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Current());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2HttpHeadersCollectionIterator_get_HasCurrent(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2HttpHeadersCollectionIterator* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2HttpHeadersCollectionIterator", L"HasCurrent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasCurrent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2HttpHeadersCollectionIterator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2HttpHeadersCollectionIterator>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2HttpHeadersCollectionIterator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2HttpHeadersCollectionIterator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_CoreWebView2HttpHeadersCollectionIterator(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2HttpHeadersCollectionIterator* self) noexcept
    {
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _iterator_next_CoreWebView2HttpHeadersCollectionIterator(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2HttpHeadersCollectionIterator* self) noexcept
    {
        try
        {
            if (self->obj.HasCurrent())
            {
                auto cur = self->obj.Current();
                self->obj.MoveNext();
                return py::convert(cur);
            }
            else
            {
                return nullptr;
            }}
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2HttpHeadersCollectionIterator[] = {
        { "get_many", reinterpret_cast<PyCFunction>(CoreWebView2HttpHeadersCollectionIterator_GetMany), METH_VARARGS, nullptr },
        { "move_next", reinterpret_cast<PyCFunction>(CoreWebView2HttpHeadersCollectionIterator_MoveNext), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreWebView2HttpHeadersCollectionIterator, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2HttpHeadersCollectionIterator), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2HttpHeadersCollectionIterator[] = {
        { "current", reinterpret_cast<getter>(CoreWebView2HttpHeadersCollectionIterator_get_Current), nullptr, nullptr, nullptr },
        { "has_current", reinterpret_cast<getter>(CoreWebView2HttpHeadersCollectionIterator_get_HasCurrent), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2HttpHeadersCollectionIterator[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2HttpHeadersCollectionIterator) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2HttpHeadersCollectionIterator) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2HttpHeadersCollectionIterator) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2HttpHeadersCollectionIterator) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_CoreWebView2HttpHeadersCollectionIterator) },
        { Py_tp_iternext, reinterpret_cast<void*>(_iterator_next_CoreWebView2HttpHeadersCollectionIterator) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2HttpHeadersCollectionIterator =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2HttpHeadersCollectionIterator",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2HttpHeadersCollectionIterator),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2HttpHeadersCollectionIterator
    };

    // ----- CoreWebView2HttpRequestHeaders class --------------------

    static PyObject* _new_CoreWebView2HttpRequestHeaders(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2HttpRequestHeaders>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2HttpRequestHeaders>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2HttpRequestHeaders(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2HttpRequestHeaders* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2HttpRequestHeaders_Contains(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2HttpRequestHeaders* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2HttpRequestHeaders", L"Contains", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.Contains(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2HttpRequestHeaders_First(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2HttpRequestHeaders* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2HttpRequestHeaders", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2HttpRequestHeaders_GetHeader(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2HttpRequestHeaders* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2HttpRequestHeaders", L"GetHeader", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetHeader(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2HttpRequestHeaders_GetHeaders(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2HttpRequestHeaders* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2HttpRequestHeaders", L"GetHeaders", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetHeaders(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2HttpRequestHeaders_RemoveHeader(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2HttpRequestHeaders* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2HttpRequestHeaders", L"RemoveHeader", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.RemoveHeader(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2HttpRequestHeaders_SetHeader(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2HttpRequestHeaders* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2HttpRequestHeaders", L"SetHeader", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetHeader(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2HttpRequestHeaders(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2HttpRequestHeaders>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2HttpRequestHeaders(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2HttpRequestHeaders>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_CoreWebView2HttpRequestHeaders(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2HttpRequestHeaders* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2HttpRequestHeaders[] = {
        { "contains", reinterpret_cast<PyCFunction>(CoreWebView2HttpRequestHeaders_Contains), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(CoreWebView2HttpRequestHeaders_First), METH_VARARGS, nullptr },
        { "get_header", reinterpret_cast<PyCFunction>(CoreWebView2HttpRequestHeaders_GetHeader), METH_VARARGS, nullptr },
        { "get_headers", reinterpret_cast<PyCFunction>(CoreWebView2HttpRequestHeaders_GetHeaders), METH_VARARGS, nullptr },
        { "remove_header", reinterpret_cast<PyCFunction>(CoreWebView2HttpRequestHeaders_RemoveHeader), METH_VARARGS, nullptr },
        { "set_header", reinterpret_cast<PyCFunction>(CoreWebView2HttpRequestHeaders_SetHeader), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreWebView2HttpRequestHeaders, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2HttpRequestHeaders), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2HttpRequestHeaders[] = {
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2HttpRequestHeaders[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2HttpRequestHeaders) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2HttpRequestHeaders) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2HttpRequestHeaders) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2HttpRequestHeaders) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_CoreWebView2HttpRequestHeaders) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2HttpRequestHeaders =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2HttpRequestHeaders",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2HttpRequestHeaders),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2HttpRequestHeaders
    };

    // ----- CoreWebView2HttpResponseHeaders class --------------------

    static PyObject* _new_CoreWebView2HttpResponseHeaders(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2HttpResponseHeaders>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2HttpResponseHeaders>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2HttpResponseHeaders(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2HttpResponseHeaders* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2HttpResponseHeaders_AppendHeader(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2HttpResponseHeaders* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2HttpResponseHeaders", L"AppendHeader", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.AppendHeader(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2HttpResponseHeaders_Contains(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2HttpResponseHeaders* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2HttpResponseHeaders", L"Contains", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.Contains(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2HttpResponseHeaders_First(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2HttpResponseHeaders* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2HttpResponseHeaders", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2HttpResponseHeaders_GetHeader(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2HttpResponseHeaders* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2HttpResponseHeaders", L"GetHeader", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetHeader(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2HttpResponseHeaders_GetHeaders(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2HttpResponseHeaders* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2HttpResponseHeaders", L"GetHeaders", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetHeaders(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2HttpResponseHeaders(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2HttpResponseHeaders>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2HttpResponseHeaders(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2HttpResponseHeaders>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_CoreWebView2HttpResponseHeaders(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2HttpResponseHeaders* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2HttpResponseHeaders[] = {
        { "append_header", reinterpret_cast<PyCFunction>(CoreWebView2HttpResponseHeaders_AppendHeader), METH_VARARGS, nullptr },
        { "contains", reinterpret_cast<PyCFunction>(CoreWebView2HttpResponseHeaders_Contains), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(CoreWebView2HttpResponseHeaders_First), METH_VARARGS, nullptr },
        { "get_header", reinterpret_cast<PyCFunction>(CoreWebView2HttpResponseHeaders_GetHeader), METH_VARARGS, nullptr },
        { "get_headers", reinterpret_cast<PyCFunction>(CoreWebView2HttpResponseHeaders_GetHeaders), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreWebView2HttpResponseHeaders, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2HttpResponseHeaders), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2HttpResponseHeaders[] = {
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2HttpResponseHeaders[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2HttpResponseHeaders) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2HttpResponseHeaders) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2HttpResponseHeaders) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2HttpResponseHeaders) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_CoreWebView2HttpResponseHeaders) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2HttpResponseHeaders =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2HttpResponseHeaders",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2HttpResponseHeaders),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2HttpResponseHeaders
    };

    // ----- CoreWebView2LaunchingExternalUriSchemeEventArgs class --------------------

    static PyObject* _new_CoreWebView2LaunchingExternalUriSchemeEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2LaunchingExternalUriSchemeEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2LaunchingExternalUriSchemeEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2LaunchingExternalUriSchemeEventArgs(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2LaunchingExternalUriSchemeEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2LaunchingExternalUriSchemeEventArgs_GetDeferral(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2LaunchingExternalUriSchemeEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2LaunchingExternalUriSchemeEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2LaunchingExternalUriSchemeEventArgs_get_Cancel(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2LaunchingExternalUriSchemeEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2LaunchingExternalUriSchemeEventArgs", L"Cancel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Cancel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2LaunchingExternalUriSchemeEventArgs_put_Cancel(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2LaunchingExternalUriSchemeEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2LaunchingExternalUriSchemeEventArgs", L"Cancel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Cancel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2LaunchingExternalUriSchemeEventArgs_get_InitiatingOrigin(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2LaunchingExternalUriSchemeEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2LaunchingExternalUriSchemeEventArgs", L"InitiatingOrigin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InitiatingOrigin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2LaunchingExternalUriSchemeEventArgs_get_IsUserInitiated(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2LaunchingExternalUriSchemeEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2LaunchingExternalUriSchemeEventArgs", L"IsUserInitiated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsUserInitiated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2LaunchingExternalUriSchemeEventArgs_get_Uri(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2LaunchingExternalUriSchemeEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2LaunchingExternalUriSchemeEventArgs", L"Uri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2LaunchingExternalUriSchemeEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2LaunchingExternalUriSchemeEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2LaunchingExternalUriSchemeEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2LaunchingExternalUriSchemeEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2LaunchingExternalUriSchemeEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CoreWebView2LaunchingExternalUriSchemeEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreWebView2LaunchingExternalUriSchemeEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2LaunchingExternalUriSchemeEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2LaunchingExternalUriSchemeEventArgs[] = {
        { "cancel", reinterpret_cast<getter>(CoreWebView2LaunchingExternalUriSchemeEventArgs_get_Cancel), reinterpret_cast<setter>(CoreWebView2LaunchingExternalUriSchemeEventArgs_put_Cancel), nullptr, nullptr },
        { "initiating_origin", reinterpret_cast<getter>(CoreWebView2LaunchingExternalUriSchemeEventArgs_get_InitiatingOrigin), nullptr, nullptr, nullptr },
        { "is_user_initiated", reinterpret_cast<getter>(CoreWebView2LaunchingExternalUriSchemeEventArgs_get_IsUserInitiated), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(CoreWebView2LaunchingExternalUriSchemeEventArgs_get_Uri), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2LaunchingExternalUriSchemeEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2LaunchingExternalUriSchemeEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2LaunchingExternalUriSchemeEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2LaunchingExternalUriSchemeEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2LaunchingExternalUriSchemeEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2LaunchingExternalUriSchemeEventArgs =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2LaunchingExternalUriSchemeEventArgs",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2LaunchingExternalUriSchemeEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2LaunchingExternalUriSchemeEventArgs
    };

    // ----- CoreWebView2MoveFocusRequestedEventArgs class --------------------

    static PyObject* _new_CoreWebView2MoveFocusRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2MoveFocusRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2MoveFocusRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2MoveFocusRequestedEventArgs(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2MoveFocusRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2MoveFocusRequestedEventArgs_get_Handled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2MoveFocusRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2MoveFocusRequestedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2MoveFocusRequestedEventArgs_put_Handled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2MoveFocusRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2MoveFocusRequestedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2MoveFocusRequestedEventArgs_get_Reason(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2MoveFocusRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2MoveFocusRequestedEventArgs", L"Reason"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2MoveFocusRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2MoveFocusRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2MoveFocusRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2MoveFocusRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2MoveFocusRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_CoreWebView2MoveFocusRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2MoveFocusRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2MoveFocusRequestedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(CoreWebView2MoveFocusRequestedEventArgs_get_Handled), reinterpret_cast<setter>(CoreWebView2MoveFocusRequestedEventArgs_put_Handled), nullptr, nullptr },
        { "reason", reinterpret_cast<getter>(CoreWebView2MoveFocusRequestedEventArgs_get_Reason), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2MoveFocusRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2MoveFocusRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2MoveFocusRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2MoveFocusRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2MoveFocusRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2MoveFocusRequestedEventArgs =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2MoveFocusRequestedEventArgs",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2MoveFocusRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2MoveFocusRequestedEventArgs
    };

    // ----- CoreWebView2NavigationCompletedEventArgs class --------------------

    static PyObject* _new_CoreWebView2NavigationCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2NavigationCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2NavigationCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2NavigationCompletedEventArgs(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2NavigationCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2NavigationCompletedEventArgs_get_IsSuccess(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2NavigationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2NavigationCompletedEventArgs", L"IsSuccess"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSuccess());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2NavigationCompletedEventArgs_get_NavigationId(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2NavigationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2NavigationCompletedEventArgs", L"NavigationId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NavigationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2NavigationCompletedEventArgs_get_WebErrorStatus(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2NavigationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2NavigationCompletedEventArgs", L"WebErrorStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WebErrorStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2NavigationCompletedEventArgs_get_HttpStatusCode(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2NavigationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2NavigationCompletedEventArgs", L"HttpStatusCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HttpStatusCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2NavigationCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2NavigationCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2NavigationCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2NavigationCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2NavigationCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_CoreWebView2NavigationCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2NavigationCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2NavigationCompletedEventArgs[] = {
        { "is_success", reinterpret_cast<getter>(CoreWebView2NavigationCompletedEventArgs_get_IsSuccess), nullptr, nullptr, nullptr },
        { "navigation_id", reinterpret_cast<getter>(CoreWebView2NavigationCompletedEventArgs_get_NavigationId), nullptr, nullptr, nullptr },
        { "web_error_status", reinterpret_cast<getter>(CoreWebView2NavigationCompletedEventArgs_get_WebErrorStatus), nullptr, nullptr, nullptr },
        { "http_status_code", reinterpret_cast<getter>(CoreWebView2NavigationCompletedEventArgs_get_HttpStatusCode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2NavigationCompletedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2NavigationCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2NavigationCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2NavigationCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2NavigationCompletedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2NavigationCompletedEventArgs =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2NavigationCompletedEventArgs",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2NavigationCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2NavigationCompletedEventArgs
    };

    // ----- CoreWebView2NavigationStartingEventArgs class --------------------

    static PyObject* _new_CoreWebView2NavigationStartingEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2NavigationStartingEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2NavigationStartingEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2NavigationStartingEventArgs(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2NavigationStartingEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2NavigationStartingEventArgs_get_Cancel(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2NavigationStartingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2NavigationStartingEventArgs", L"Cancel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Cancel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2NavigationStartingEventArgs_put_Cancel(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2NavigationStartingEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2NavigationStartingEventArgs", L"Cancel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Cancel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2NavigationStartingEventArgs_get_IsRedirected(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2NavigationStartingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2NavigationStartingEventArgs", L"IsRedirected"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsRedirected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2NavigationStartingEventArgs_get_IsUserInitiated(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2NavigationStartingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2NavigationStartingEventArgs", L"IsUserInitiated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsUserInitiated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2NavigationStartingEventArgs_get_NavigationId(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2NavigationStartingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2NavigationStartingEventArgs", L"NavigationId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NavigationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2NavigationStartingEventArgs_get_RequestHeaders(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2NavigationStartingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2NavigationStartingEventArgs", L"RequestHeaders"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RequestHeaders());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2NavigationStartingEventArgs_get_Uri(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2NavigationStartingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2NavigationStartingEventArgs", L"Uri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2NavigationStartingEventArgs_get_AdditionalAllowedFrameAncestors(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2NavigationStartingEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2NavigationStartingEventArgs", L"AdditionalAllowedFrameAncestors"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AdditionalAllowedFrameAncestors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2NavigationStartingEventArgs_put_AdditionalAllowedFrameAncestors(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2NavigationStartingEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2NavigationStartingEventArgs", L"AdditionalAllowedFrameAncestors"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.AdditionalAllowedFrameAncestors(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CoreWebView2NavigationStartingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2NavigationStartingEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2NavigationStartingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2NavigationStartingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2NavigationStartingEventArgs[] = {
        { "_assign_array_", _assign_array_CoreWebView2NavigationStartingEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2NavigationStartingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2NavigationStartingEventArgs[] = {
        { "cancel", reinterpret_cast<getter>(CoreWebView2NavigationStartingEventArgs_get_Cancel), reinterpret_cast<setter>(CoreWebView2NavigationStartingEventArgs_put_Cancel), nullptr, nullptr },
        { "is_redirected", reinterpret_cast<getter>(CoreWebView2NavigationStartingEventArgs_get_IsRedirected), nullptr, nullptr, nullptr },
        { "is_user_initiated", reinterpret_cast<getter>(CoreWebView2NavigationStartingEventArgs_get_IsUserInitiated), nullptr, nullptr, nullptr },
        { "navigation_id", reinterpret_cast<getter>(CoreWebView2NavigationStartingEventArgs_get_NavigationId), nullptr, nullptr, nullptr },
        { "request_headers", reinterpret_cast<getter>(CoreWebView2NavigationStartingEventArgs_get_RequestHeaders), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(CoreWebView2NavigationStartingEventArgs_get_Uri), nullptr, nullptr, nullptr },
        { "additional_allowed_frame_ancestors", reinterpret_cast<getter>(CoreWebView2NavigationStartingEventArgs_get_AdditionalAllowedFrameAncestors), reinterpret_cast<setter>(CoreWebView2NavigationStartingEventArgs_put_AdditionalAllowedFrameAncestors), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2NavigationStartingEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2NavigationStartingEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2NavigationStartingEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2NavigationStartingEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2NavigationStartingEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2NavigationStartingEventArgs =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2NavigationStartingEventArgs",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2NavigationStartingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2NavigationStartingEventArgs
    };

    // ----- CoreWebView2NewWindowRequestedEventArgs class --------------------

    static PyObject* _new_CoreWebView2NewWindowRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2NewWindowRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2NewWindowRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2NewWindowRequestedEventArgs(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2NewWindowRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2NewWindowRequestedEventArgs_GetDeferral(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2NewWindowRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2NewWindowRequestedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2NewWindowRequestedEventArgs_get_NewWindow(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2NewWindowRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2NewWindowRequestedEventArgs", L"NewWindow"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NewWindow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2NewWindowRequestedEventArgs_put_NewWindow(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2NewWindowRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2NewWindowRequestedEventArgs", L"NewWindow"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2>(arg);

            self->obj.NewWindow(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2NewWindowRequestedEventArgs_get_Handled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2NewWindowRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2NewWindowRequestedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2NewWindowRequestedEventArgs_put_Handled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2NewWindowRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2NewWindowRequestedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2NewWindowRequestedEventArgs_get_IsUserInitiated(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2NewWindowRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2NewWindowRequestedEventArgs", L"IsUserInitiated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsUserInitiated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2NewWindowRequestedEventArgs_get_Uri(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2NewWindowRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2NewWindowRequestedEventArgs", L"Uri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2NewWindowRequestedEventArgs_get_WindowFeatures(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2NewWindowRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2NewWindowRequestedEventArgs", L"WindowFeatures"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WindowFeatures());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2NewWindowRequestedEventArgs_get_Name(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2NewWindowRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2NewWindowRequestedEventArgs", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2NewWindowRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2NewWindowRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2NewWindowRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2NewWindowRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2NewWindowRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CoreWebView2NewWindowRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreWebView2NewWindowRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2NewWindowRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2NewWindowRequestedEventArgs[] = {
        { "new_window", reinterpret_cast<getter>(CoreWebView2NewWindowRequestedEventArgs_get_NewWindow), reinterpret_cast<setter>(CoreWebView2NewWindowRequestedEventArgs_put_NewWindow), nullptr, nullptr },
        { "handled", reinterpret_cast<getter>(CoreWebView2NewWindowRequestedEventArgs_get_Handled), reinterpret_cast<setter>(CoreWebView2NewWindowRequestedEventArgs_put_Handled), nullptr, nullptr },
        { "is_user_initiated", reinterpret_cast<getter>(CoreWebView2NewWindowRequestedEventArgs_get_IsUserInitiated), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(CoreWebView2NewWindowRequestedEventArgs_get_Uri), nullptr, nullptr, nullptr },
        { "window_features", reinterpret_cast<getter>(CoreWebView2NewWindowRequestedEventArgs_get_WindowFeatures), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(CoreWebView2NewWindowRequestedEventArgs_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2NewWindowRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2NewWindowRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2NewWindowRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2NewWindowRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2NewWindowRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2NewWindowRequestedEventArgs =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2NewWindowRequestedEventArgs",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2NewWindowRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2NewWindowRequestedEventArgs
    };

    // ----- CoreWebView2PermissionRequestedEventArgs class --------------------

    static PyObject* _new_CoreWebView2PermissionRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2PermissionRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2PermissionRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2PermissionRequestedEventArgs(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PermissionRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2PermissionRequestedEventArgs_GetDeferral(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PermissionRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PermissionRequestedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2PermissionRequestedEventArgs_get_State(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PermissionRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PermissionRequestedEventArgs", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PermissionRequestedEventArgs_put_State(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PermissionRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PermissionRequestedEventArgs", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2PermissionState>(arg);

            self->obj.State(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PermissionRequestedEventArgs_get_IsUserInitiated(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PermissionRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PermissionRequestedEventArgs", L"IsUserInitiated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsUserInitiated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2PermissionRequestedEventArgs_get_PermissionKind(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PermissionRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PermissionRequestedEventArgs", L"PermissionKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PermissionKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2PermissionRequestedEventArgs_get_Uri(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PermissionRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PermissionRequestedEventArgs", L"Uri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2PermissionRequestedEventArgs_get_Handled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PermissionRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PermissionRequestedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PermissionRequestedEventArgs_put_Handled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PermissionRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PermissionRequestedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PermissionRequestedEventArgs_get_SavesInProfile(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PermissionRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PermissionRequestedEventArgs", L"SavesInProfile"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SavesInProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PermissionRequestedEventArgs_put_SavesInProfile(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PermissionRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PermissionRequestedEventArgs", L"SavesInProfile"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.SavesInProfile(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CoreWebView2PermissionRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2PermissionRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2PermissionRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2PermissionRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2PermissionRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CoreWebView2PermissionRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreWebView2PermissionRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2PermissionRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2PermissionRequestedEventArgs[] = {
        { "state", reinterpret_cast<getter>(CoreWebView2PermissionRequestedEventArgs_get_State), reinterpret_cast<setter>(CoreWebView2PermissionRequestedEventArgs_put_State), nullptr, nullptr },
        { "is_user_initiated", reinterpret_cast<getter>(CoreWebView2PermissionRequestedEventArgs_get_IsUserInitiated), nullptr, nullptr, nullptr },
        { "permission_kind", reinterpret_cast<getter>(CoreWebView2PermissionRequestedEventArgs_get_PermissionKind), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(CoreWebView2PermissionRequestedEventArgs_get_Uri), nullptr, nullptr, nullptr },
        { "handled", reinterpret_cast<getter>(CoreWebView2PermissionRequestedEventArgs_get_Handled), reinterpret_cast<setter>(CoreWebView2PermissionRequestedEventArgs_put_Handled), nullptr, nullptr },
        { "saves_in_profile", reinterpret_cast<getter>(CoreWebView2PermissionRequestedEventArgs_get_SavesInProfile), reinterpret_cast<setter>(CoreWebView2PermissionRequestedEventArgs_put_SavesInProfile), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2PermissionRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2PermissionRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2PermissionRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2PermissionRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2PermissionRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2PermissionRequestedEventArgs =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2PermissionRequestedEventArgs",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PermissionRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2PermissionRequestedEventArgs
    };

    // ----- CoreWebView2PermissionSetting class --------------------

    static PyObject* _new_CoreWebView2PermissionSetting(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2PermissionSetting>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2PermissionSetting>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2PermissionSetting(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PermissionSetting* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2PermissionSetting_get_PermissionKind(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PermissionSetting* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PermissionSetting", L"PermissionKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PermissionKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2PermissionSetting_get_PermissionOrigin(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PermissionSetting* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PermissionSetting", L"PermissionOrigin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PermissionOrigin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2PermissionSetting_get_PermissionState(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PermissionSetting* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PermissionSetting", L"PermissionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PermissionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2PermissionSetting(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2PermissionSetting>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2PermissionSetting(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2PermissionSetting>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2PermissionSetting[] = {
        { "_assign_array_", _assign_array_CoreWebView2PermissionSetting, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2PermissionSetting), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2PermissionSetting[] = {
        { "permission_kind", reinterpret_cast<getter>(CoreWebView2PermissionSetting_get_PermissionKind), nullptr, nullptr, nullptr },
        { "permission_origin", reinterpret_cast<getter>(CoreWebView2PermissionSetting_get_PermissionOrigin), nullptr, nullptr, nullptr },
        { "permission_state", reinterpret_cast<getter>(CoreWebView2PermissionSetting_get_PermissionState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2PermissionSetting[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2PermissionSetting) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2PermissionSetting) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2PermissionSetting) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2PermissionSetting) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2PermissionSetting =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2PermissionSetting",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PermissionSetting),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2PermissionSetting
    };

    // ----- CoreWebView2PointerInfo class --------------------

    static PyObject* _new_CoreWebView2PointerInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2PointerInfo(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2PointerInfo_get_TouchPressure(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"TouchPressure"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TouchPressure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PointerInfo_put_TouchPressure(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"TouchPressure"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.TouchPressure(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PointerInfo_get_TouchOrientation(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"TouchOrientation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TouchOrientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PointerInfo_put_TouchOrientation(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"TouchOrientation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.TouchOrientation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PointerInfo_get_TouchMask(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"TouchMask"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TouchMask());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PointerInfo_put_TouchMask(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"TouchMask"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.TouchMask(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PointerInfo_get_TouchFlags(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"TouchFlags"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TouchFlags());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PointerInfo_put_TouchFlags(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"TouchFlags"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.TouchFlags(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PointerInfo_get_TouchContactRaw(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"TouchContactRaw"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TouchContactRaw());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PointerInfo_put_TouchContactRaw(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"TouchContactRaw"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(arg);

            self->obj.TouchContactRaw(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PointerInfo_get_TouchContact(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"TouchContact"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TouchContact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PointerInfo_put_TouchContact(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"TouchContact"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(arg);

            self->obj.TouchContact(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PointerInfo_get_Time(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"Time"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Time());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PointerInfo_put_Time(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"Time"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Time(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PointerInfo_get_PointerKind(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"PointerKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PointerInfo_put_PointerKind(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"PointerKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.PointerKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PointerInfo_get_PointerId(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"PointerId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PointerInfo_put_PointerId(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"PointerId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.PointerId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PointerInfo_get_PointerFlags(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"PointerFlags"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerFlags());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PointerInfo_put_PointerFlags(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"PointerFlags"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.PointerFlags(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PointerInfo_get_PointerDeviceRect(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"PointerDeviceRect"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerDeviceRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PointerInfo_put_PointerDeviceRect(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"PointerDeviceRect"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(arg);

            self->obj.PointerDeviceRect(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PointerInfo_get_PixelLocationRaw(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"PixelLocationRaw"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PixelLocationRaw());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PointerInfo_put_PixelLocationRaw(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"PixelLocationRaw"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.PixelLocationRaw(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PointerInfo_get_PixelLocation(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"PixelLocation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PixelLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PointerInfo_put_PixelLocation(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"PixelLocation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.PixelLocation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PointerInfo_get_PerformanceCount(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"PerformanceCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PerformanceCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PointerInfo_put_PerformanceCount(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"PerformanceCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint64_t>(arg);

            self->obj.PerformanceCount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PointerInfo_get_PenTiltY(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"PenTiltY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PenTiltY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PointerInfo_put_PenTiltY(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"PenTiltY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.PenTiltY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PointerInfo_get_PenTiltX(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"PenTiltX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PenTiltX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PointerInfo_put_PenTiltX(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"PenTiltX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.PenTiltX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PointerInfo_get_PenRotation(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"PenRotation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PenRotation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PointerInfo_put_PenRotation(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"PenRotation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.PenRotation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PointerInfo_get_PenPressure(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"PenPressure"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PenPressure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PointerInfo_put_PenPressure(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"PenPressure"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.PenPressure(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PointerInfo_get_PenMask(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"PenMask"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PenMask());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PointerInfo_put_PenMask(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"PenMask"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.PenMask(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PointerInfo_get_PenFlags(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"PenFlags"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PenFlags());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PointerInfo_put_PenFlags(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"PenFlags"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.PenFlags(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PointerInfo_get_KeyStates(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"KeyStates"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyStates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PointerInfo_put_KeyStates(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"KeyStates"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.KeyStates(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PointerInfo_get_InputData(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"InputData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InputData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PointerInfo_put_InputData(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"InputData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.InputData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PointerInfo_get_HistoryCount(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"HistoryCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HistoryCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PointerInfo_put_HistoryCount(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"HistoryCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.HistoryCount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PointerInfo_get_HimetricLocationRaw(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"HimetricLocationRaw"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HimetricLocationRaw());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PointerInfo_put_HimetricLocationRaw(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"HimetricLocationRaw"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.HimetricLocationRaw(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PointerInfo_get_HimetricLocation(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"HimetricLocation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HimetricLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PointerInfo_put_HimetricLocation(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"HimetricLocation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.HimetricLocation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PointerInfo_get_FrameId(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"FrameId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FrameId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PointerInfo_put_FrameId(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"FrameId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.FrameId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PointerInfo_get_DisplayRect(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"DisplayRect"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PointerInfo_put_DisplayRect(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"DisplayRect"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(arg);

            self->obj.DisplayRect(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PointerInfo_get_ButtonChangeKind(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"ButtonChangeKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ButtonChangeKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PointerInfo_put_ButtonChangeKind(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PointerInfo", L"ButtonChangeKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ButtonChangeKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CoreWebView2PointerInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2PointerInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2PointerInfo[] = {
        { "_assign_array_", _assign_array_CoreWebView2PointerInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2PointerInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2PointerInfo[] = {
        { "touch_pressure", reinterpret_cast<getter>(CoreWebView2PointerInfo_get_TouchPressure), reinterpret_cast<setter>(CoreWebView2PointerInfo_put_TouchPressure), nullptr, nullptr },
        { "touch_orientation", reinterpret_cast<getter>(CoreWebView2PointerInfo_get_TouchOrientation), reinterpret_cast<setter>(CoreWebView2PointerInfo_put_TouchOrientation), nullptr, nullptr },
        { "touch_mask", reinterpret_cast<getter>(CoreWebView2PointerInfo_get_TouchMask), reinterpret_cast<setter>(CoreWebView2PointerInfo_put_TouchMask), nullptr, nullptr },
        { "touch_flags", reinterpret_cast<getter>(CoreWebView2PointerInfo_get_TouchFlags), reinterpret_cast<setter>(CoreWebView2PointerInfo_put_TouchFlags), nullptr, nullptr },
        { "touch_contact_raw", reinterpret_cast<getter>(CoreWebView2PointerInfo_get_TouchContactRaw), reinterpret_cast<setter>(CoreWebView2PointerInfo_put_TouchContactRaw), nullptr, nullptr },
        { "touch_contact", reinterpret_cast<getter>(CoreWebView2PointerInfo_get_TouchContact), reinterpret_cast<setter>(CoreWebView2PointerInfo_put_TouchContact), nullptr, nullptr },
        { "time", reinterpret_cast<getter>(CoreWebView2PointerInfo_get_Time), reinterpret_cast<setter>(CoreWebView2PointerInfo_put_Time), nullptr, nullptr },
        { "pointer_kind", reinterpret_cast<getter>(CoreWebView2PointerInfo_get_PointerKind), reinterpret_cast<setter>(CoreWebView2PointerInfo_put_PointerKind), nullptr, nullptr },
        { "pointer_id", reinterpret_cast<getter>(CoreWebView2PointerInfo_get_PointerId), reinterpret_cast<setter>(CoreWebView2PointerInfo_put_PointerId), nullptr, nullptr },
        { "pointer_flags", reinterpret_cast<getter>(CoreWebView2PointerInfo_get_PointerFlags), reinterpret_cast<setter>(CoreWebView2PointerInfo_put_PointerFlags), nullptr, nullptr },
        { "pointer_device_rect", reinterpret_cast<getter>(CoreWebView2PointerInfo_get_PointerDeviceRect), reinterpret_cast<setter>(CoreWebView2PointerInfo_put_PointerDeviceRect), nullptr, nullptr },
        { "pixel_location_raw", reinterpret_cast<getter>(CoreWebView2PointerInfo_get_PixelLocationRaw), reinterpret_cast<setter>(CoreWebView2PointerInfo_put_PixelLocationRaw), nullptr, nullptr },
        { "pixel_location", reinterpret_cast<getter>(CoreWebView2PointerInfo_get_PixelLocation), reinterpret_cast<setter>(CoreWebView2PointerInfo_put_PixelLocation), nullptr, nullptr },
        { "performance_count", reinterpret_cast<getter>(CoreWebView2PointerInfo_get_PerformanceCount), reinterpret_cast<setter>(CoreWebView2PointerInfo_put_PerformanceCount), nullptr, nullptr },
        { "pen_tilt_y", reinterpret_cast<getter>(CoreWebView2PointerInfo_get_PenTiltY), reinterpret_cast<setter>(CoreWebView2PointerInfo_put_PenTiltY), nullptr, nullptr },
        { "pen_tilt_x", reinterpret_cast<getter>(CoreWebView2PointerInfo_get_PenTiltX), reinterpret_cast<setter>(CoreWebView2PointerInfo_put_PenTiltX), nullptr, nullptr },
        { "pen_rotation", reinterpret_cast<getter>(CoreWebView2PointerInfo_get_PenRotation), reinterpret_cast<setter>(CoreWebView2PointerInfo_put_PenRotation), nullptr, nullptr },
        { "pen_pressure", reinterpret_cast<getter>(CoreWebView2PointerInfo_get_PenPressure), reinterpret_cast<setter>(CoreWebView2PointerInfo_put_PenPressure), nullptr, nullptr },
        { "pen_mask", reinterpret_cast<getter>(CoreWebView2PointerInfo_get_PenMask), reinterpret_cast<setter>(CoreWebView2PointerInfo_put_PenMask), nullptr, nullptr },
        { "pen_flags", reinterpret_cast<getter>(CoreWebView2PointerInfo_get_PenFlags), reinterpret_cast<setter>(CoreWebView2PointerInfo_put_PenFlags), nullptr, nullptr },
        { "key_states", reinterpret_cast<getter>(CoreWebView2PointerInfo_get_KeyStates), reinterpret_cast<setter>(CoreWebView2PointerInfo_put_KeyStates), nullptr, nullptr },
        { "input_data", reinterpret_cast<getter>(CoreWebView2PointerInfo_get_InputData), reinterpret_cast<setter>(CoreWebView2PointerInfo_put_InputData), nullptr, nullptr },
        { "history_count", reinterpret_cast<getter>(CoreWebView2PointerInfo_get_HistoryCount), reinterpret_cast<setter>(CoreWebView2PointerInfo_put_HistoryCount), nullptr, nullptr },
        { "himetric_location_raw", reinterpret_cast<getter>(CoreWebView2PointerInfo_get_HimetricLocationRaw), reinterpret_cast<setter>(CoreWebView2PointerInfo_put_HimetricLocationRaw), nullptr, nullptr },
        { "himetric_location", reinterpret_cast<getter>(CoreWebView2PointerInfo_get_HimetricLocation), reinterpret_cast<setter>(CoreWebView2PointerInfo_put_HimetricLocation), nullptr, nullptr },
        { "frame_id", reinterpret_cast<getter>(CoreWebView2PointerInfo_get_FrameId), reinterpret_cast<setter>(CoreWebView2PointerInfo_put_FrameId), nullptr, nullptr },
        { "display_rect", reinterpret_cast<getter>(CoreWebView2PointerInfo_get_DisplayRect), reinterpret_cast<setter>(CoreWebView2PointerInfo_put_DisplayRect), nullptr, nullptr },
        { "button_change_kind", reinterpret_cast<getter>(CoreWebView2PointerInfo_get_ButtonChangeKind), reinterpret_cast<setter>(CoreWebView2PointerInfo_put_ButtonChangeKind), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2PointerInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2PointerInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2PointerInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2PointerInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2PointerInfo) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2PointerInfo =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2PointerInfo",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PointerInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2PointerInfo
    };

    // ----- CoreWebView2PrintSettings class --------------------

    static PyObject* _new_CoreWebView2PrintSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2PrintSettings(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2PrintSettings_get_ShouldPrintSelectionOnly(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"ShouldPrintSelectionOnly"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShouldPrintSelectionOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PrintSettings_put_ShouldPrintSelectionOnly(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"ShouldPrintSelectionOnly"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShouldPrintSelectionOnly(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PrintSettings_get_ShouldPrintHeaderAndFooter(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"ShouldPrintHeaderAndFooter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShouldPrintHeaderAndFooter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PrintSettings_put_ShouldPrintHeaderAndFooter(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"ShouldPrintHeaderAndFooter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShouldPrintHeaderAndFooter(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PrintSettings_get_ShouldPrintBackgrounds(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"ShouldPrintBackgrounds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShouldPrintBackgrounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PrintSettings_put_ShouldPrintBackgrounds(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"ShouldPrintBackgrounds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShouldPrintBackgrounds(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PrintSettings_get_ScaleFactor(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"ScaleFactor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ScaleFactor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PrintSettings_put_ScaleFactor(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"ScaleFactor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.ScaleFactor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PrintSettings_get_PageWidth(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"PageWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PageWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PrintSettings_put_PageWidth(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"PageWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.PageWidth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PrintSettings_get_PageHeight(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"PageHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PageHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PrintSettings_put_PageHeight(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"PageHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.PageHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PrintSettings_get_Orientation(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"Orientation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PrintSettings_put_Orientation(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"Orientation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2PrintOrientation>(arg);

            self->obj.Orientation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PrintSettings_get_MarginTop(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"MarginTop"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MarginTop());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PrintSettings_put_MarginTop(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"MarginTop"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.MarginTop(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PrintSettings_get_MarginRight(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"MarginRight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MarginRight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PrintSettings_put_MarginRight(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"MarginRight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.MarginRight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PrintSettings_get_MarginLeft(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"MarginLeft"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MarginLeft());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PrintSettings_put_MarginLeft(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"MarginLeft"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.MarginLeft(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PrintSettings_get_MarginBottom(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"MarginBottom"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MarginBottom());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PrintSettings_put_MarginBottom(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"MarginBottom"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.MarginBottom(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PrintSettings_get_HeaderTitle(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"HeaderTitle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HeaderTitle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PrintSettings_put_HeaderTitle(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"HeaderTitle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.HeaderTitle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PrintSettings_get_FooterUri(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"FooterUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FooterUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PrintSettings_put_FooterUri(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"FooterUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FooterUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PrintSettings_get_PrinterName(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"PrinterName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PrinterName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PrintSettings_put_PrinterName(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"PrinterName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.PrinterName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PrintSettings_get_PagesPerSide(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"PagesPerSide"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PagesPerSide());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PrintSettings_put_PagesPerSide(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"PagesPerSide"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.PagesPerSide(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PrintSettings_get_PageRanges(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"PageRanges"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PageRanges());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PrintSettings_put_PageRanges(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"PageRanges"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.PageRanges(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PrintSettings_get_MediaSize(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"MediaSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MediaSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PrintSettings_put_MediaSize(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"MediaSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2PrintMediaSize>(arg);

            self->obj.MediaSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PrintSettings_get_Duplex(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"Duplex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duplex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PrintSettings_put_Duplex(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"Duplex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2PrintDuplex>(arg);

            self->obj.Duplex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PrintSettings_get_Copies(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"Copies"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Copies());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PrintSettings_put_Copies(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"Copies"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Copies(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PrintSettings_get_ColorMode(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"ColorMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ColorMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PrintSettings_put_ColorMode(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"ColorMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2PrintColorMode>(arg);

            self->obj.ColorMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PrintSettings_get_Collation(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"Collation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Collation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PrintSettings_put_Collation(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2PrintSettings", L"Collation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2PrintCollation>(arg);

            self->obj.Collation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CoreWebView2PrintSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2PrintSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2PrintSettings[] = {
        { "_assign_array_", _assign_array_CoreWebView2PrintSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2PrintSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2PrintSettings[] = {
        { "should_print_selection_only", reinterpret_cast<getter>(CoreWebView2PrintSettings_get_ShouldPrintSelectionOnly), reinterpret_cast<setter>(CoreWebView2PrintSettings_put_ShouldPrintSelectionOnly), nullptr, nullptr },
        { "should_print_header_and_footer", reinterpret_cast<getter>(CoreWebView2PrintSettings_get_ShouldPrintHeaderAndFooter), reinterpret_cast<setter>(CoreWebView2PrintSettings_put_ShouldPrintHeaderAndFooter), nullptr, nullptr },
        { "should_print_backgrounds", reinterpret_cast<getter>(CoreWebView2PrintSettings_get_ShouldPrintBackgrounds), reinterpret_cast<setter>(CoreWebView2PrintSettings_put_ShouldPrintBackgrounds), nullptr, nullptr },
        { "scale_factor", reinterpret_cast<getter>(CoreWebView2PrintSettings_get_ScaleFactor), reinterpret_cast<setter>(CoreWebView2PrintSettings_put_ScaleFactor), nullptr, nullptr },
        { "page_width", reinterpret_cast<getter>(CoreWebView2PrintSettings_get_PageWidth), reinterpret_cast<setter>(CoreWebView2PrintSettings_put_PageWidth), nullptr, nullptr },
        { "page_height", reinterpret_cast<getter>(CoreWebView2PrintSettings_get_PageHeight), reinterpret_cast<setter>(CoreWebView2PrintSettings_put_PageHeight), nullptr, nullptr },
        { "orientation", reinterpret_cast<getter>(CoreWebView2PrintSettings_get_Orientation), reinterpret_cast<setter>(CoreWebView2PrintSettings_put_Orientation), nullptr, nullptr },
        { "margin_top", reinterpret_cast<getter>(CoreWebView2PrintSettings_get_MarginTop), reinterpret_cast<setter>(CoreWebView2PrintSettings_put_MarginTop), nullptr, nullptr },
        { "margin_right", reinterpret_cast<getter>(CoreWebView2PrintSettings_get_MarginRight), reinterpret_cast<setter>(CoreWebView2PrintSettings_put_MarginRight), nullptr, nullptr },
        { "margin_left", reinterpret_cast<getter>(CoreWebView2PrintSettings_get_MarginLeft), reinterpret_cast<setter>(CoreWebView2PrintSettings_put_MarginLeft), nullptr, nullptr },
        { "margin_bottom", reinterpret_cast<getter>(CoreWebView2PrintSettings_get_MarginBottom), reinterpret_cast<setter>(CoreWebView2PrintSettings_put_MarginBottom), nullptr, nullptr },
        { "header_title", reinterpret_cast<getter>(CoreWebView2PrintSettings_get_HeaderTitle), reinterpret_cast<setter>(CoreWebView2PrintSettings_put_HeaderTitle), nullptr, nullptr },
        { "footer_uri", reinterpret_cast<getter>(CoreWebView2PrintSettings_get_FooterUri), reinterpret_cast<setter>(CoreWebView2PrintSettings_put_FooterUri), nullptr, nullptr },
        { "printer_name", reinterpret_cast<getter>(CoreWebView2PrintSettings_get_PrinterName), reinterpret_cast<setter>(CoreWebView2PrintSettings_put_PrinterName), nullptr, nullptr },
        { "pages_per_side", reinterpret_cast<getter>(CoreWebView2PrintSettings_get_PagesPerSide), reinterpret_cast<setter>(CoreWebView2PrintSettings_put_PagesPerSide), nullptr, nullptr },
        { "page_ranges", reinterpret_cast<getter>(CoreWebView2PrintSettings_get_PageRanges), reinterpret_cast<setter>(CoreWebView2PrintSettings_put_PageRanges), nullptr, nullptr },
        { "media_size", reinterpret_cast<getter>(CoreWebView2PrintSettings_get_MediaSize), reinterpret_cast<setter>(CoreWebView2PrintSettings_put_MediaSize), nullptr, nullptr },
        { "duplex", reinterpret_cast<getter>(CoreWebView2PrintSettings_get_Duplex), reinterpret_cast<setter>(CoreWebView2PrintSettings_put_Duplex), nullptr, nullptr },
        { "copies", reinterpret_cast<getter>(CoreWebView2PrintSettings_get_Copies), reinterpret_cast<setter>(CoreWebView2PrintSettings_put_Copies), nullptr, nullptr },
        { "color_mode", reinterpret_cast<getter>(CoreWebView2PrintSettings_get_ColorMode), reinterpret_cast<setter>(CoreWebView2PrintSettings_put_ColorMode), nullptr, nullptr },
        { "collation", reinterpret_cast<getter>(CoreWebView2PrintSettings_get_Collation), reinterpret_cast<setter>(CoreWebView2PrintSettings_put_Collation), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2PrintSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2PrintSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2PrintSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2PrintSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2PrintSettings) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2PrintSettings =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2PrintSettings",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PrintSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2PrintSettings
    };

    // ----- CoreWebView2ProcessFailedEventArgs class --------------------

    static PyObject* _new_CoreWebView2ProcessFailedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ProcessFailedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ProcessFailedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2ProcessFailedEventArgs(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ProcessFailedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2ProcessFailedEventArgs_get_ProcessFailedKind(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ProcessFailedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ProcessFailedEventArgs", L"ProcessFailedKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProcessFailedKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ProcessFailedEventArgs_get_ExitCode(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ProcessFailedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ProcessFailedEventArgs", L"ExitCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExitCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ProcessFailedEventArgs_get_FrameInfosForFailedProcess(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ProcessFailedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ProcessFailedEventArgs", L"FrameInfosForFailedProcess"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FrameInfosForFailedProcess());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ProcessFailedEventArgs_get_ProcessDescription(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ProcessFailedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ProcessFailedEventArgs", L"ProcessDescription"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProcessDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ProcessFailedEventArgs_get_Reason(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ProcessFailedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ProcessFailedEventArgs", L"Reason"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2ProcessFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ProcessFailedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2ProcessFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ProcessFailedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2ProcessFailedEventArgs[] = {
        { "_assign_array_", _assign_array_CoreWebView2ProcessFailedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2ProcessFailedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2ProcessFailedEventArgs[] = {
        { "process_failed_kind", reinterpret_cast<getter>(CoreWebView2ProcessFailedEventArgs_get_ProcessFailedKind), nullptr, nullptr, nullptr },
        { "exit_code", reinterpret_cast<getter>(CoreWebView2ProcessFailedEventArgs_get_ExitCode), nullptr, nullptr, nullptr },
        { "frame_infos_for_failed_process", reinterpret_cast<getter>(CoreWebView2ProcessFailedEventArgs_get_FrameInfosForFailedProcess), nullptr, nullptr, nullptr },
        { "process_description", reinterpret_cast<getter>(CoreWebView2ProcessFailedEventArgs_get_ProcessDescription), nullptr, nullptr, nullptr },
        { "reason", reinterpret_cast<getter>(CoreWebView2ProcessFailedEventArgs_get_Reason), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2ProcessFailedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2ProcessFailedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2ProcessFailedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2ProcessFailedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2ProcessFailedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2ProcessFailedEventArgs =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2ProcessFailedEventArgs",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ProcessFailedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2ProcessFailedEventArgs
    };

    // ----- CoreWebView2ProcessInfo class --------------------

    static PyObject* _new_CoreWebView2ProcessInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ProcessInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ProcessInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2ProcessInfo(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ProcessInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2ProcessInfo_get_Kind(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ProcessInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ProcessInfo", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ProcessInfo_get_ProcessId(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ProcessInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ProcessInfo", L"ProcessId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProcessId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2ProcessInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ProcessInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2ProcessInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ProcessInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2ProcessInfo[] = {
        { "_assign_array_", _assign_array_CoreWebView2ProcessInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2ProcessInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2ProcessInfo[] = {
        { "kind", reinterpret_cast<getter>(CoreWebView2ProcessInfo_get_Kind), nullptr, nullptr, nullptr },
        { "process_id", reinterpret_cast<getter>(CoreWebView2ProcessInfo_get_ProcessId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2ProcessInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2ProcessInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2ProcessInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2ProcessInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2ProcessInfo) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2ProcessInfo =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2ProcessInfo",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ProcessInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2ProcessInfo
    };

    // ----- CoreWebView2Profile class --------------------

    static PyObject* _new_CoreWebView2Profile(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Profile>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Profile>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2Profile(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Profile* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2Profile_ClearBrowsingDataAsync(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Profile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Profile", L"ClearBrowsingDataAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ClearBrowsingDataAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Profile", L"ClearBrowsingDataAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2BrowsingDataKinds>(args, 0);

                return py::convert(self->obj.ClearBrowsingDataAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Profile", L"ClearBrowsingDataAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2BrowsingDataKinds>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 2);

                return py::convert(self->obj.ClearBrowsingDataAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Profile_GetNonDefaultPermissionSettingsAsync(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Profile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Profile", L"GetNonDefaultPermissionSettingsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetNonDefaultPermissionSettingsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Profile_SetPermissionStateAsync(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Profile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Profile", L"SetPermissionStateAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2PermissionKind>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2PermissionState>(args, 2);

                return py::convert(self->obj.SetPermissionStateAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Profile_get_PreferredColorScheme(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Profile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Profile", L"PreferredColorScheme"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreferredColorScheme());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2Profile_put_PreferredColorScheme(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Profile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Profile", L"PreferredColorScheme"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2PreferredColorScheme>(arg);

            self->obj.PreferredColorScheme(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2Profile_get_DefaultDownloadFolderPath(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Profile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Profile", L"DefaultDownloadFolderPath"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultDownloadFolderPath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2Profile_put_DefaultDownloadFolderPath(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Profile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Profile", L"DefaultDownloadFolderPath"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DefaultDownloadFolderPath(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2Profile_get_IsInPrivateModeEnabled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Profile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Profile", L"IsInPrivateModeEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsInPrivateModeEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Profile_get_ProfileName(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Profile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Profile", L"ProfileName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProfileName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Profile_get_ProfilePath(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Profile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Profile", L"ProfilePath"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProfilePath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Profile_get_PreferredTrackingPreventionLevel(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Profile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Profile", L"PreferredTrackingPreventionLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PreferredTrackingPreventionLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2Profile_put_PreferredTrackingPreventionLevel(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Profile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Profile", L"PreferredTrackingPreventionLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2TrackingPreventionLevel>(arg);

            self->obj.PreferredTrackingPreventionLevel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2Profile_get_CookieManager(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Profile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Profile", L"CookieManager"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CookieManager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2Profile_get_IsPasswordAutosaveEnabled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Profile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Profile", L"IsPasswordAutosaveEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPasswordAutosaveEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2Profile_put_IsPasswordAutosaveEnabled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Profile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Profile", L"IsPasswordAutosaveEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsPasswordAutosaveEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2Profile_get_IsGeneralAutofillEnabled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Profile* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Profile", L"IsGeneralAutofillEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsGeneralAutofillEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2Profile_put_IsGeneralAutofillEnabled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Profile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Profile", L"IsGeneralAutofillEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsGeneralAutofillEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CoreWebView2Profile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Profile>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2Profile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Profile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2Profile[] = {
        { "clear_browsing_data_async", reinterpret_cast<PyCFunction>(CoreWebView2Profile_ClearBrowsingDataAsync), METH_VARARGS, nullptr },
        { "get_non_default_permission_settings_async", reinterpret_cast<PyCFunction>(CoreWebView2Profile_GetNonDefaultPermissionSettingsAsync), METH_VARARGS, nullptr },
        { "set_permission_state_async", reinterpret_cast<PyCFunction>(CoreWebView2Profile_SetPermissionStateAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreWebView2Profile, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2Profile), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2Profile[] = {
        { "preferred_color_scheme", reinterpret_cast<getter>(CoreWebView2Profile_get_PreferredColorScheme), reinterpret_cast<setter>(CoreWebView2Profile_put_PreferredColorScheme), nullptr, nullptr },
        { "default_download_folder_path", reinterpret_cast<getter>(CoreWebView2Profile_get_DefaultDownloadFolderPath), reinterpret_cast<setter>(CoreWebView2Profile_put_DefaultDownloadFolderPath), nullptr, nullptr },
        { "is_in_private_mode_enabled", reinterpret_cast<getter>(CoreWebView2Profile_get_IsInPrivateModeEnabled), nullptr, nullptr, nullptr },
        { "profile_name", reinterpret_cast<getter>(CoreWebView2Profile_get_ProfileName), nullptr, nullptr, nullptr },
        { "profile_path", reinterpret_cast<getter>(CoreWebView2Profile_get_ProfilePath), nullptr, nullptr, nullptr },
        { "preferred_tracking_prevention_level", reinterpret_cast<getter>(CoreWebView2Profile_get_PreferredTrackingPreventionLevel), reinterpret_cast<setter>(CoreWebView2Profile_put_PreferredTrackingPreventionLevel), nullptr, nullptr },
        { "cookie_manager", reinterpret_cast<getter>(CoreWebView2Profile_get_CookieManager), nullptr, nullptr, nullptr },
        { "is_password_autosave_enabled", reinterpret_cast<getter>(CoreWebView2Profile_get_IsPasswordAutosaveEnabled), reinterpret_cast<setter>(CoreWebView2Profile_put_IsPasswordAutosaveEnabled), nullptr, nullptr },
        { "is_general_autofill_enabled", reinterpret_cast<getter>(CoreWebView2Profile_get_IsGeneralAutofillEnabled), reinterpret_cast<setter>(CoreWebView2Profile_put_IsGeneralAutofillEnabled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2Profile[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2Profile) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2Profile) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2Profile) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2Profile) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2Profile =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2Profile",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Profile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2Profile
    };

    // ----- CoreWebView2ScriptDialogOpeningEventArgs class --------------------

    static PyObject* _new_CoreWebView2ScriptDialogOpeningEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ScriptDialogOpeningEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ScriptDialogOpeningEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2ScriptDialogOpeningEventArgs(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ScriptDialogOpeningEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2ScriptDialogOpeningEventArgs_Accept(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ScriptDialogOpeningEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ScriptDialogOpeningEventArgs", L"Accept", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Accept();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ScriptDialogOpeningEventArgs_GetDeferral(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ScriptDialogOpeningEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ScriptDialogOpeningEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ScriptDialogOpeningEventArgs_get_ResultText(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ScriptDialogOpeningEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ScriptDialogOpeningEventArgs", L"ResultText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ResultText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2ScriptDialogOpeningEventArgs_put_ResultText(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ScriptDialogOpeningEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ScriptDialogOpeningEventArgs", L"ResultText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ResultText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2ScriptDialogOpeningEventArgs_get_DefaultText(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ScriptDialogOpeningEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ScriptDialogOpeningEventArgs", L"DefaultText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ScriptDialogOpeningEventArgs_get_Kind(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ScriptDialogOpeningEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ScriptDialogOpeningEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ScriptDialogOpeningEventArgs_get_Message(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ScriptDialogOpeningEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ScriptDialogOpeningEventArgs", L"Message"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ScriptDialogOpeningEventArgs_get_Uri(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ScriptDialogOpeningEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ScriptDialogOpeningEventArgs", L"Uri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2ScriptDialogOpeningEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ScriptDialogOpeningEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2ScriptDialogOpeningEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ScriptDialogOpeningEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2ScriptDialogOpeningEventArgs[] = {
        { "accept", reinterpret_cast<PyCFunction>(CoreWebView2ScriptDialogOpeningEventArgs_Accept), METH_VARARGS, nullptr },
        { "get_deferral", reinterpret_cast<PyCFunction>(CoreWebView2ScriptDialogOpeningEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreWebView2ScriptDialogOpeningEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2ScriptDialogOpeningEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2ScriptDialogOpeningEventArgs[] = {
        { "result_text", reinterpret_cast<getter>(CoreWebView2ScriptDialogOpeningEventArgs_get_ResultText), reinterpret_cast<setter>(CoreWebView2ScriptDialogOpeningEventArgs_put_ResultText), nullptr, nullptr },
        { "default_text", reinterpret_cast<getter>(CoreWebView2ScriptDialogOpeningEventArgs_get_DefaultText), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(CoreWebView2ScriptDialogOpeningEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "message", reinterpret_cast<getter>(CoreWebView2ScriptDialogOpeningEventArgs_get_Message), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(CoreWebView2ScriptDialogOpeningEventArgs_get_Uri), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2ScriptDialogOpeningEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2ScriptDialogOpeningEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2ScriptDialogOpeningEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2ScriptDialogOpeningEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2ScriptDialogOpeningEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2ScriptDialogOpeningEventArgs =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2ScriptDialogOpeningEventArgs",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ScriptDialogOpeningEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2ScriptDialogOpeningEventArgs
    };

    // ----- CoreWebView2ServerCertificateErrorDetectedEventArgs class --------------------

    static PyObject* _new_CoreWebView2ServerCertificateErrorDetectedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ServerCertificateErrorDetectedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ServerCertificateErrorDetectedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2ServerCertificateErrorDetectedEventArgs(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ServerCertificateErrorDetectedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2ServerCertificateErrorDetectedEventArgs_GetDeferral(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ServerCertificateErrorDetectedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ServerCertificateErrorDetectedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ServerCertificateErrorDetectedEventArgs_get_Action(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ServerCertificateErrorDetectedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ServerCertificateErrorDetectedEventArgs", L"Action"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Action());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2ServerCertificateErrorDetectedEventArgs_put_Action(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ServerCertificateErrorDetectedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ServerCertificateErrorDetectedEventArgs", L"Action"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ServerCertificateErrorAction>(arg);

            self->obj.Action(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2ServerCertificateErrorDetectedEventArgs_get_ErrorStatus(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ServerCertificateErrorDetectedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ServerCertificateErrorDetectedEventArgs", L"ErrorStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ErrorStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ServerCertificateErrorDetectedEventArgs_get_RequestUri(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ServerCertificateErrorDetectedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ServerCertificateErrorDetectedEventArgs", L"RequestUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RequestUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2ServerCertificateErrorDetectedEventArgs_get_ServerCertificate(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ServerCertificateErrorDetectedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2ServerCertificateErrorDetectedEventArgs", L"ServerCertificate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ServerCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2ServerCertificateErrorDetectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ServerCertificateErrorDetectedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2ServerCertificateErrorDetectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2ServerCertificateErrorDetectedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2ServerCertificateErrorDetectedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CoreWebView2ServerCertificateErrorDetectedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreWebView2ServerCertificateErrorDetectedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2ServerCertificateErrorDetectedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2ServerCertificateErrorDetectedEventArgs[] = {
        { "action", reinterpret_cast<getter>(CoreWebView2ServerCertificateErrorDetectedEventArgs_get_Action), reinterpret_cast<setter>(CoreWebView2ServerCertificateErrorDetectedEventArgs_put_Action), nullptr, nullptr },
        { "error_status", reinterpret_cast<getter>(CoreWebView2ServerCertificateErrorDetectedEventArgs_get_ErrorStatus), nullptr, nullptr, nullptr },
        { "request_uri", reinterpret_cast<getter>(CoreWebView2ServerCertificateErrorDetectedEventArgs_get_RequestUri), nullptr, nullptr, nullptr },
        { "server_certificate", reinterpret_cast<getter>(CoreWebView2ServerCertificateErrorDetectedEventArgs_get_ServerCertificate), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2ServerCertificateErrorDetectedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2ServerCertificateErrorDetectedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2ServerCertificateErrorDetectedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2ServerCertificateErrorDetectedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2ServerCertificateErrorDetectedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2ServerCertificateErrorDetectedEventArgs =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2ServerCertificateErrorDetectedEventArgs",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2ServerCertificateErrorDetectedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2ServerCertificateErrorDetectedEventArgs
    };

    // ----- CoreWebView2Settings class --------------------

    static PyObject* _new_CoreWebView2Settings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Settings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Settings>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2Settings(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Settings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2Settings_get_IsZoomControlEnabled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Settings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Settings", L"IsZoomControlEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsZoomControlEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2Settings_put_IsZoomControlEnabled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Settings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Settings", L"IsZoomControlEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsZoomControlEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2Settings_get_IsWebMessageEnabled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Settings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Settings", L"IsWebMessageEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsWebMessageEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2Settings_put_IsWebMessageEnabled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Settings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Settings", L"IsWebMessageEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsWebMessageEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2Settings_get_IsStatusBarEnabled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Settings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Settings", L"IsStatusBarEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsStatusBarEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2Settings_put_IsStatusBarEnabled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Settings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Settings", L"IsStatusBarEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsStatusBarEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2Settings_get_IsScriptEnabled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Settings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Settings", L"IsScriptEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsScriptEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2Settings_put_IsScriptEnabled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Settings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Settings", L"IsScriptEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsScriptEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2Settings_get_IsBuiltInErrorPageEnabled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Settings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Settings", L"IsBuiltInErrorPageEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsBuiltInErrorPageEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2Settings_put_IsBuiltInErrorPageEnabled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Settings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Settings", L"IsBuiltInErrorPageEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsBuiltInErrorPageEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2Settings_get_AreHostObjectsAllowed(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Settings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Settings", L"AreHostObjectsAllowed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AreHostObjectsAllowed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2Settings_put_AreHostObjectsAllowed(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Settings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Settings", L"AreHostObjectsAllowed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AreHostObjectsAllowed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2Settings_get_AreDevToolsEnabled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Settings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Settings", L"AreDevToolsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AreDevToolsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2Settings_put_AreDevToolsEnabled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Settings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Settings", L"AreDevToolsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AreDevToolsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2Settings_get_AreDefaultScriptDialogsEnabled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Settings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Settings", L"AreDefaultScriptDialogsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AreDefaultScriptDialogsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2Settings_put_AreDefaultScriptDialogsEnabled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Settings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Settings", L"AreDefaultScriptDialogsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AreDefaultScriptDialogsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2Settings_get_AreDefaultContextMenusEnabled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Settings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Settings", L"AreDefaultContextMenusEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AreDefaultContextMenusEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2Settings_put_AreDefaultContextMenusEnabled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Settings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Settings", L"AreDefaultContextMenusEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AreDefaultContextMenusEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2Settings_get_HostObjectDispatchAdapter(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Settings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Settings", L"HostObjectDispatchAdapter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HostObjectDispatchAdapter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2Settings_put_HostObjectDispatchAdapter(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Settings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Settings", L"HostObjectDispatchAdapter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter>(arg);

            self->obj.HostObjectDispatchAdapter(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2Settings_get_UserAgent(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Settings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Settings", L"UserAgent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UserAgent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2Settings_put_UserAgent(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Settings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Settings", L"UserAgent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.UserAgent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2Settings_get_AreBrowserAcceleratorKeysEnabled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Settings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Settings", L"AreBrowserAcceleratorKeysEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AreBrowserAcceleratorKeysEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2Settings_put_AreBrowserAcceleratorKeysEnabled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Settings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Settings", L"AreBrowserAcceleratorKeysEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AreBrowserAcceleratorKeysEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2Settings_get_IsPasswordAutosaveEnabled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Settings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Settings", L"IsPasswordAutosaveEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPasswordAutosaveEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2Settings_put_IsPasswordAutosaveEnabled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Settings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Settings", L"IsPasswordAutosaveEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsPasswordAutosaveEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2Settings_get_IsGeneralAutofillEnabled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Settings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Settings", L"IsGeneralAutofillEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsGeneralAutofillEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2Settings_put_IsGeneralAutofillEnabled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Settings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Settings", L"IsGeneralAutofillEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsGeneralAutofillEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2Settings_get_IsPinchZoomEnabled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Settings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Settings", L"IsPinchZoomEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsPinchZoomEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2Settings_put_IsPinchZoomEnabled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Settings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Settings", L"IsPinchZoomEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsPinchZoomEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2Settings_get_IsSwipeNavigationEnabled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Settings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Settings", L"IsSwipeNavigationEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSwipeNavigationEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2Settings_put_IsSwipeNavigationEnabled(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Settings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Settings", L"IsSwipeNavigationEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsSwipeNavigationEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2Settings_get_HiddenPdfToolbarItems(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Settings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Settings", L"HiddenPdfToolbarItems"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HiddenPdfToolbarItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2Settings_put_HiddenPdfToolbarItems(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Settings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Settings", L"HiddenPdfToolbarItems"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2PdfToolbarItems>(arg);

            self->obj.HiddenPdfToolbarItems(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2Settings_get_IsReputationCheckingRequired(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Settings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Settings", L"IsReputationCheckingRequired"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsReputationCheckingRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2Settings_put_IsReputationCheckingRequired(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Settings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2Settings", L"IsReputationCheckingRequired"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsReputationCheckingRequired(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CoreWebView2Settings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Settings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2Settings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2Settings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2Settings[] = {
        { "_assign_array_", _assign_array_CoreWebView2Settings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2Settings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2Settings[] = {
        { "is_zoom_control_enabled", reinterpret_cast<getter>(CoreWebView2Settings_get_IsZoomControlEnabled), reinterpret_cast<setter>(CoreWebView2Settings_put_IsZoomControlEnabled), nullptr, nullptr },
        { "is_web_message_enabled", reinterpret_cast<getter>(CoreWebView2Settings_get_IsWebMessageEnabled), reinterpret_cast<setter>(CoreWebView2Settings_put_IsWebMessageEnabled), nullptr, nullptr },
        { "is_status_bar_enabled", reinterpret_cast<getter>(CoreWebView2Settings_get_IsStatusBarEnabled), reinterpret_cast<setter>(CoreWebView2Settings_put_IsStatusBarEnabled), nullptr, nullptr },
        { "is_script_enabled", reinterpret_cast<getter>(CoreWebView2Settings_get_IsScriptEnabled), reinterpret_cast<setter>(CoreWebView2Settings_put_IsScriptEnabled), nullptr, nullptr },
        { "is_built_in_error_page_enabled", reinterpret_cast<getter>(CoreWebView2Settings_get_IsBuiltInErrorPageEnabled), reinterpret_cast<setter>(CoreWebView2Settings_put_IsBuiltInErrorPageEnabled), nullptr, nullptr },
        { "are_host_objects_allowed", reinterpret_cast<getter>(CoreWebView2Settings_get_AreHostObjectsAllowed), reinterpret_cast<setter>(CoreWebView2Settings_put_AreHostObjectsAllowed), nullptr, nullptr },
        { "are_dev_tools_enabled", reinterpret_cast<getter>(CoreWebView2Settings_get_AreDevToolsEnabled), reinterpret_cast<setter>(CoreWebView2Settings_put_AreDevToolsEnabled), nullptr, nullptr },
        { "are_default_script_dialogs_enabled", reinterpret_cast<getter>(CoreWebView2Settings_get_AreDefaultScriptDialogsEnabled), reinterpret_cast<setter>(CoreWebView2Settings_put_AreDefaultScriptDialogsEnabled), nullptr, nullptr },
        { "are_default_context_menus_enabled", reinterpret_cast<getter>(CoreWebView2Settings_get_AreDefaultContextMenusEnabled), reinterpret_cast<setter>(CoreWebView2Settings_put_AreDefaultContextMenusEnabled), nullptr, nullptr },
        { "host_object_dispatch_adapter", reinterpret_cast<getter>(CoreWebView2Settings_get_HostObjectDispatchAdapter), reinterpret_cast<setter>(CoreWebView2Settings_put_HostObjectDispatchAdapter), nullptr, nullptr },
        { "user_agent", reinterpret_cast<getter>(CoreWebView2Settings_get_UserAgent), reinterpret_cast<setter>(CoreWebView2Settings_put_UserAgent), nullptr, nullptr },
        { "are_browser_accelerator_keys_enabled", reinterpret_cast<getter>(CoreWebView2Settings_get_AreBrowserAcceleratorKeysEnabled), reinterpret_cast<setter>(CoreWebView2Settings_put_AreBrowserAcceleratorKeysEnabled), nullptr, nullptr },
        { "is_password_autosave_enabled", reinterpret_cast<getter>(CoreWebView2Settings_get_IsPasswordAutosaveEnabled), reinterpret_cast<setter>(CoreWebView2Settings_put_IsPasswordAutosaveEnabled), nullptr, nullptr },
        { "is_general_autofill_enabled", reinterpret_cast<getter>(CoreWebView2Settings_get_IsGeneralAutofillEnabled), reinterpret_cast<setter>(CoreWebView2Settings_put_IsGeneralAutofillEnabled), nullptr, nullptr },
        { "is_pinch_zoom_enabled", reinterpret_cast<getter>(CoreWebView2Settings_get_IsPinchZoomEnabled), reinterpret_cast<setter>(CoreWebView2Settings_put_IsPinchZoomEnabled), nullptr, nullptr },
        { "is_swipe_navigation_enabled", reinterpret_cast<getter>(CoreWebView2Settings_get_IsSwipeNavigationEnabled), reinterpret_cast<setter>(CoreWebView2Settings_put_IsSwipeNavigationEnabled), nullptr, nullptr },
        { "hidden_pdf_toolbar_items", reinterpret_cast<getter>(CoreWebView2Settings_get_HiddenPdfToolbarItems), reinterpret_cast<setter>(CoreWebView2Settings_put_HiddenPdfToolbarItems), nullptr, nullptr },
        { "is_reputation_checking_required", reinterpret_cast<getter>(CoreWebView2Settings_get_IsReputationCheckingRequired), reinterpret_cast<setter>(CoreWebView2Settings_put_IsReputationCheckingRequired), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2Settings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2Settings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2Settings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2Settings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2Settings) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2Settings =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2Settings",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2Settings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2Settings
    };

    // ----- CoreWebView2SharedBuffer class --------------------

    static PyObject* _new_CoreWebView2SharedBuffer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2SharedBuffer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2SharedBuffer>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2SharedBuffer(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2SharedBuffer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2SharedBuffer_Close(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2SharedBuffer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2SharedBuffer", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2SharedBuffer_OpenStream(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2SharedBuffer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2SharedBuffer", L"OpenStream", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.OpenStream());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2SharedBuffer_get_Size(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2SharedBuffer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2SharedBuffer", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2SharedBuffer_get_Buffer(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2SharedBuffer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2SharedBuffer", L"Buffer"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Buffer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2SharedBuffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2SharedBuffer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2SharedBuffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2SharedBuffer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_CoreWebView2SharedBuffer(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2SharedBuffer* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_CoreWebView2SharedBuffer(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2SharedBuffer* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2SharedBuffer[] = {
        { "close", reinterpret_cast<PyCFunction>(CoreWebView2SharedBuffer_Close), METH_VARARGS, nullptr },
        { "open_stream", reinterpret_cast<PyCFunction>(CoreWebView2SharedBuffer_OpenStream), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreWebView2SharedBuffer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2SharedBuffer), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_CoreWebView2SharedBuffer), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_CoreWebView2SharedBuffer), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2SharedBuffer[] = {
        { "size", reinterpret_cast<getter>(CoreWebView2SharedBuffer_get_Size), nullptr, nullptr, nullptr },
        { "buffer", reinterpret_cast<getter>(CoreWebView2SharedBuffer_get_Buffer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2SharedBuffer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2SharedBuffer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2SharedBuffer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2SharedBuffer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2SharedBuffer) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2SharedBuffer =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2SharedBuffer",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2SharedBuffer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2SharedBuffer
    };

    // ----- CoreWebView2SourceChangedEventArgs class --------------------

    static PyObject* _new_CoreWebView2SourceChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2SourceChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2SourceChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2SourceChangedEventArgs(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2SourceChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2SourceChangedEventArgs_get_IsNewDocument(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2SourceChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2SourceChangedEventArgs", L"IsNewDocument"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsNewDocument());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2SourceChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2SourceChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2SourceChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2SourceChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2SourceChangedEventArgs[] = {
        { "_assign_array_", _assign_array_CoreWebView2SourceChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2SourceChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2SourceChangedEventArgs[] = {
        { "is_new_document", reinterpret_cast<getter>(CoreWebView2SourceChangedEventArgs_get_IsNewDocument), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2SourceChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2SourceChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2SourceChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2SourceChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2SourceChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2SourceChangedEventArgs =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2SourceChangedEventArgs",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2SourceChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2SourceChangedEventArgs
    };

    // ----- CoreWebView2WebMessageReceivedEventArgs class --------------------

    static PyObject* _new_CoreWebView2WebMessageReceivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2WebMessageReceivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2WebMessageReceivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2WebMessageReceivedEventArgs(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebMessageReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2WebMessageReceivedEventArgs_TryGetWebMessageAsString(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebMessageReceivedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2WebMessageReceivedEventArgs", L"TryGetWebMessageAsString", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.TryGetWebMessageAsString());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2WebMessageReceivedEventArgs_get_Source(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebMessageReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2WebMessageReceivedEventArgs", L"Source"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2WebMessageReceivedEventArgs_get_WebMessageAsJson(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebMessageReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2WebMessageReceivedEventArgs", L"WebMessageAsJson"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WebMessageAsJson());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2WebMessageReceivedEventArgs_get_AdditionalObjects(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebMessageReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2WebMessageReceivedEventArgs", L"AdditionalObjects"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AdditionalObjects());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2WebMessageReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2WebMessageReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2WebMessageReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2WebMessageReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2WebMessageReceivedEventArgs[] = {
        { "try_get_web_message_as_string", reinterpret_cast<PyCFunction>(CoreWebView2WebMessageReceivedEventArgs_TryGetWebMessageAsString), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreWebView2WebMessageReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2WebMessageReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2WebMessageReceivedEventArgs[] = {
        { "source", reinterpret_cast<getter>(CoreWebView2WebMessageReceivedEventArgs_get_Source), nullptr, nullptr, nullptr },
        { "web_message_as_json", reinterpret_cast<getter>(CoreWebView2WebMessageReceivedEventArgs_get_WebMessageAsJson), nullptr, nullptr, nullptr },
        { "additional_objects", reinterpret_cast<getter>(CoreWebView2WebMessageReceivedEventArgs_get_AdditionalObjects), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2WebMessageReceivedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2WebMessageReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2WebMessageReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2WebMessageReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2WebMessageReceivedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2WebMessageReceivedEventArgs =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2WebMessageReceivedEventArgs",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebMessageReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2WebMessageReceivedEventArgs
    };

    // ----- CoreWebView2WebResourceRequest class --------------------

    static PyObject* _new_CoreWebView2WebResourceRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2WebResourceRequest(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2WebResourceRequest_get_Uri(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2WebResourceRequest", L"Uri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2WebResourceRequest_put_Uri(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2WebResourceRequest", L"Uri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Uri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2WebResourceRequest_get_Method(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2WebResourceRequest", L"Method"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Method());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2WebResourceRequest_put_Method(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2WebResourceRequest", L"Method"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Method(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2WebResourceRequest_get_Content(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2WebResourceRequest", L"Content"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Content());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2WebResourceRequest_put_Content(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2WebResourceRequest", L"Content"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(arg);

            self->obj.Content(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2WebResourceRequest_get_Headers(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceRequest* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2WebResourceRequest", L"Headers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Headers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2WebResourceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2WebResourceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2WebResourceRequest[] = {
        { "_assign_array_", _assign_array_CoreWebView2WebResourceRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2WebResourceRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2WebResourceRequest[] = {
        { "uri", reinterpret_cast<getter>(CoreWebView2WebResourceRequest_get_Uri), reinterpret_cast<setter>(CoreWebView2WebResourceRequest_put_Uri), nullptr, nullptr },
        { "method", reinterpret_cast<getter>(CoreWebView2WebResourceRequest_get_Method), reinterpret_cast<setter>(CoreWebView2WebResourceRequest_put_Method), nullptr, nullptr },
        { "content", reinterpret_cast<getter>(CoreWebView2WebResourceRequest_get_Content), reinterpret_cast<setter>(CoreWebView2WebResourceRequest_put_Content), nullptr, nullptr },
        { "headers", reinterpret_cast<getter>(CoreWebView2WebResourceRequest_get_Headers), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2WebResourceRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2WebResourceRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2WebResourceRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2WebResourceRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2WebResourceRequest) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2WebResourceRequest =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2WebResourceRequest",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2WebResourceRequest
    };

    // ----- CoreWebView2WebResourceRequestedEventArgs class --------------------

    static PyObject* _new_CoreWebView2WebResourceRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2WebResourceRequestedEventArgs(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2WebResourceRequestedEventArgs_GetDeferral(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2WebResourceRequestedEventArgs", L"GetDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2WebResourceRequestedEventArgs_get_Response(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2WebResourceRequestedEventArgs", L"Response"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Response());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2WebResourceRequestedEventArgs_put_Response(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2WebResourceRequestedEventArgs", L"Response"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceResponse>(arg);

            self->obj.Response(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2WebResourceRequestedEventArgs_get_Request(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2WebResourceRequestedEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2WebResourceRequestedEventArgs_get_ResourceContext(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2WebResourceRequestedEventArgs", L"ResourceContext"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ResourceContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2WebResourceRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2WebResourceRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2WebResourceRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CoreWebView2WebResourceRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreWebView2WebResourceRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2WebResourceRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2WebResourceRequestedEventArgs[] = {
        { "response", reinterpret_cast<getter>(CoreWebView2WebResourceRequestedEventArgs_get_Response), reinterpret_cast<setter>(CoreWebView2WebResourceRequestedEventArgs_put_Response), nullptr, nullptr },
        { "request", reinterpret_cast<getter>(CoreWebView2WebResourceRequestedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { "resource_context", reinterpret_cast<getter>(CoreWebView2WebResourceRequestedEventArgs_get_ResourceContext), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2WebResourceRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2WebResourceRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2WebResourceRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2WebResourceRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2WebResourceRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2WebResourceRequestedEventArgs =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2WebResourceRequestedEventArgs",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2WebResourceRequestedEventArgs
    };

    // ----- CoreWebView2WebResourceResponse class --------------------

    static PyObject* _new_CoreWebView2WebResourceResponse(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceResponse>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceResponse>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2WebResourceResponse(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceResponse* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2WebResourceResponse_get_StatusCode(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceResponse* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2WebResourceResponse", L"StatusCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StatusCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2WebResourceResponse_put_StatusCode(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceResponse* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2WebResourceResponse", L"StatusCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.StatusCode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2WebResourceResponse_get_ReasonPhrase(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceResponse* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2WebResourceResponse", L"ReasonPhrase"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReasonPhrase());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2WebResourceResponse_put_ReasonPhrase(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceResponse* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2WebResourceResponse", L"ReasonPhrase"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ReasonPhrase(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2WebResourceResponse_get_Content(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceResponse* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2WebResourceResponse", L"Content"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Content());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2WebResourceResponse_put_Content(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceResponse* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2WebResourceResponse", L"Content"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(arg);

            self->obj.Content(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2WebResourceResponse_get_Headers(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceResponse* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2WebResourceResponse", L"Headers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Headers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2WebResourceResponse(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceResponse>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2WebResourceResponse(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceResponse>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2WebResourceResponse[] = {
        { "_assign_array_", _assign_array_CoreWebView2WebResourceResponse, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2WebResourceResponse), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2WebResourceResponse[] = {
        { "status_code", reinterpret_cast<getter>(CoreWebView2WebResourceResponse_get_StatusCode), reinterpret_cast<setter>(CoreWebView2WebResourceResponse_put_StatusCode), nullptr, nullptr },
        { "reason_phrase", reinterpret_cast<getter>(CoreWebView2WebResourceResponse_get_ReasonPhrase), reinterpret_cast<setter>(CoreWebView2WebResourceResponse_put_ReasonPhrase), nullptr, nullptr },
        { "content", reinterpret_cast<getter>(CoreWebView2WebResourceResponse_get_Content), reinterpret_cast<setter>(CoreWebView2WebResourceResponse_put_Content), nullptr, nullptr },
        { "headers", reinterpret_cast<getter>(CoreWebView2WebResourceResponse_get_Headers), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2WebResourceResponse[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2WebResourceResponse) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2WebResourceResponse) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2WebResourceResponse) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2WebResourceResponse) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2WebResourceResponse =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2WebResourceResponse",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceResponse),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2WebResourceResponse
    };

    // ----- CoreWebView2WebResourceResponseReceivedEventArgs class --------------------

    static PyObject* _new_CoreWebView2WebResourceResponseReceivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceResponseReceivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceResponseReceivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2WebResourceResponseReceivedEventArgs(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceResponseReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2WebResourceResponseReceivedEventArgs_get_Request(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceResponseReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2WebResourceResponseReceivedEventArgs", L"Request"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2WebResourceResponseReceivedEventArgs_get_Response(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceResponseReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2WebResourceResponseReceivedEventArgs", L"Response"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Response());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2WebResourceResponseReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceResponseReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2WebResourceResponseReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceResponseReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2WebResourceResponseReceivedEventArgs[] = {
        { "_assign_array_", _assign_array_CoreWebView2WebResourceResponseReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2WebResourceResponseReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2WebResourceResponseReceivedEventArgs[] = {
        { "request", reinterpret_cast<getter>(CoreWebView2WebResourceResponseReceivedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { "response", reinterpret_cast<getter>(CoreWebView2WebResourceResponseReceivedEventArgs_get_Response), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2WebResourceResponseReceivedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2WebResourceResponseReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2WebResourceResponseReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2WebResourceResponseReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2WebResourceResponseReceivedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2WebResourceResponseReceivedEventArgs =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2WebResourceResponseReceivedEventArgs",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceResponseReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2WebResourceResponseReceivedEventArgs
    };

    // ----- CoreWebView2WebResourceResponseView class --------------------

    static PyObject* _new_CoreWebView2WebResourceResponseView(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceResponseView>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceResponseView>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2WebResourceResponseView(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceResponseView* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2WebResourceResponseView_GetContentAsync(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceResponseView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2WebResourceResponseView", L"GetContentAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetContentAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreWebView2WebResourceResponseView_get_Headers(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceResponseView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2WebResourceResponseView", L"Headers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Headers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2WebResourceResponseView_get_ReasonPhrase(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceResponseView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2WebResourceResponseView", L"ReasonPhrase"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReasonPhrase());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2WebResourceResponseView_get_StatusCode(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceResponseView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2WebResourceResponseView", L"StatusCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StatusCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2WebResourceResponseView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceResponseView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2WebResourceResponseView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceResponseView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2WebResourceResponseView[] = {
        { "get_content_async", reinterpret_cast<PyCFunction>(CoreWebView2WebResourceResponseView_GetContentAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CoreWebView2WebResourceResponseView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2WebResourceResponseView), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2WebResourceResponseView[] = {
        { "headers", reinterpret_cast<getter>(CoreWebView2WebResourceResponseView_get_Headers), nullptr, nullptr, nullptr },
        { "reason_phrase", reinterpret_cast<getter>(CoreWebView2WebResourceResponseView_get_ReasonPhrase), nullptr, nullptr, nullptr },
        { "status_code", reinterpret_cast<getter>(CoreWebView2WebResourceResponseView_get_StatusCode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2WebResourceResponseView[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2WebResourceResponseView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2WebResourceResponseView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2WebResourceResponseView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2WebResourceResponseView) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2WebResourceResponseView =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2WebResourceResponseView",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WebResourceResponseView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2WebResourceResponseView
    };

    // ----- CoreWebView2WindowFeatures class --------------------

    static PyObject* _new_CoreWebView2WindowFeatures(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2WindowFeatures>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::CoreWebView2WindowFeatures>::type_name);
        return nullptr;
    }

    static void _dealloc_CoreWebView2WindowFeatures(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WindowFeatures* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreWebView2WindowFeatures_get_HasPosition(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WindowFeatures* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2WindowFeatures", L"HasPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2WindowFeatures_get_HasSize(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WindowFeatures* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2WindowFeatures", L"HasSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2WindowFeatures_get_Height(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WindowFeatures* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2WindowFeatures", L"Height"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2WindowFeatures_get_Left(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WindowFeatures* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2WindowFeatures", L"Left"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Left());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2WindowFeatures_get_ShouldDisplayMenuBar(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WindowFeatures* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2WindowFeatures", L"ShouldDisplayMenuBar"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShouldDisplayMenuBar());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2WindowFeatures_get_ShouldDisplayScrollBars(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WindowFeatures* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2WindowFeatures", L"ShouldDisplayScrollBars"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShouldDisplayScrollBars());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2WindowFeatures_get_ShouldDisplayStatus(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WindowFeatures* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2WindowFeatures", L"ShouldDisplayStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShouldDisplayStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2WindowFeatures_get_ShouldDisplayToolbar(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WindowFeatures* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2WindowFeatures", L"ShouldDisplayToolbar"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShouldDisplayToolbar());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2WindowFeatures_get_Top(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WindowFeatures* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2WindowFeatures", L"Top"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Top());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CoreWebView2WindowFeatures_get_Width(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WindowFeatures* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Web.WebView2.Core.CoreWebView2WindowFeatures", L"Width"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CoreWebView2WindowFeatures(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2WindowFeatures>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CoreWebView2WindowFeatures(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::CoreWebView2WindowFeatures>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreWebView2WindowFeatures[] = {
        { "_assign_array_", _assign_array_CoreWebView2WindowFeatures, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreWebView2WindowFeatures), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreWebView2WindowFeatures[] = {
        { "has_position", reinterpret_cast<getter>(CoreWebView2WindowFeatures_get_HasPosition), nullptr, nullptr, nullptr },
        { "has_size", reinterpret_cast<getter>(CoreWebView2WindowFeatures_get_HasSize), nullptr, nullptr, nullptr },
        { "height", reinterpret_cast<getter>(CoreWebView2WindowFeatures_get_Height), nullptr, nullptr, nullptr },
        { "left", reinterpret_cast<getter>(CoreWebView2WindowFeatures_get_Left), nullptr, nullptr, nullptr },
        { "should_display_menu_bar", reinterpret_cast<getter>(CoreWebView2WindowFeatures_get_ShouldDisplayMenuBar), nullptr, nullptr, nullptr },
        { "should_display_scroll_bars", reinterpret_cast<getter>(CoreWebView2WindowFeatures_get_ShouldDisplayScrollBars), nullptr, nullptr, nullptr },
        { "should_display_status", reinterpret_cast<getter>(CoreWebView2WindowFeatures_get_ShouldDisplayStatus), nullptr, nullptr, nullptr },
        { "should_display_toolbar", reinterpret_cast<getter>(CoreWebView2WindowFeatures_get_ShouldDisplayToolbar), nullptr, nullptr, nullptr },
        { "top", reinterpret_cast<getter>(CoreWebView2WindowFeatures_get_Top), nullptr, nullptr, nullptr },
        { "width", reinterpret_cast<getter>(CoreWebView2WindowFeatures_get_Width), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2WindowFeatures[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2WindowFeatures) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2WindowFeatures) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2WindowFeatures) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2WindowFeatures) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2WindowFeatures =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2WindowFeatures",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2WindowFeatures),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2WindowFeatures
    };

    // ----- ICoreWebView2DispatchAdapter interface --------------------

    static PyObject* _new_ICoreWebView2DispatchAdapter(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter>::type_name);
        return nullptr;
    }

    static void _dealloc_ICoreWebView2DispatchAdapter(py::wrapper::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICoreWebView2DispatchAdapter_Clean(py::wrapper::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.ICoreWebView2DispatchAdapter", L"Clean", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clean();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICoreWebView2DispatchAdapter_UnwrapObject(py::wrapper::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.ICoreWebView2DispatchAdapter", L"UnwrapObject", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.UnwrapObject(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICoreWebView2DispatchAdapter_WrapNamedObject(py::wrapper::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.ICoreWebView2DispatchAdapter", L"WrapNamedObject", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter>(args, 1);

                return py::convert(self->obj.WrapNamedObject(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICoreWebView2DispatchAdapter_WrapObject(py::wrapper::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Web.WebView2.Core.ICoreWebView2DispatchAdapter", L"WrapObject", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter>(args, 1);

                return py::convert(self->obj.WrapObject(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ICoreWebView2DispatchAdapter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICoreWebView2DispatchAdapter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICoreWebView2DispatchAdapter[] = {
        { "clean", reinterpret_cast<PyCFunction>(ICoreWebView2DispatchAdapter_Clean), METH_VARARGS, nullptr },
        { "unwrap_object", reinterpret_cast<PyCFunction>(ICoreWebView2DispatchAdapter_UnwrapObject), METH_VARARGS, nullptr },
        { "wrap_named_object", reinterpret_cast<PyCFunction>(ICoreWebView2DispatchAdapter_WrapNamedObject), METH_VARARGS, nullptr },
        { "wrap_object", reinterpret_cast<PyCFunction>(ICoreWebView2DispatchAdapter_WrapObject), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ICoreWebView2DispatchAdapter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICoreWebView2DispatchAdapter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICoreWebView2DispatchAdapter[] = {
        { }
    };

    static PyType_Slot _type_slots_ICoreWebView2DispatchAdapter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICoreWebView2DispatchAdapter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICoreWebView2DispatchAdapter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICoreWebView2DispatchAdapter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICoreWebView2DispatchAdapter) },
        { },
    };

    static PyType_Spec type_spec_ICoreWebView2DispatchAdapter =
    {
        "winrt._winrt_microsoft_web_webview2_core.ICoreWebView2DispatchAdapter",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::ICoreWebView2DispatchAdapter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICoreWebView2DispatchAdapter
    };

    // ----- CoreWebView2PhysicalKeyStatus struct --------------------

    winrt_struct_wrapper<winrt::Microsoft::Web::WebView2::Core::CoreWebView2PhysicalKeyStatus>* _new_CoreWebView2PhysicalKeyStatus(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Microsoft::Web::WebView2::Core::CoreWebView2PhysicalKeyStatus>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_CoreWebView2PhysicalKeyStatus(winrt_struct_wrapper<winrt::Microsoft::Web::WebView2::Core::CoreWebView2PhysicalKeyStatus>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        uint32_t _RepeatCount{};
        uint32_t _ScanCode{};
        int32_t _IsExtendedKey{};
        int32_t _IsMenuKeyDown{};
        int32_t _WasKeyDown{};
        int32_t _IsKeyReleased{};

        static const char* kwlist[] = {"repeat_count", "scan_code", "is_extended_key", "is_menu_key_down", "was_key_down", "is_key_released", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "IIiiii", const_cast<char**>(kwlist), &_RepeatCount, &_ScanCode, &_IsExtendedKey, &_IsMenuKeyDown, &_WasKeyDown, &_IsKeyReleased))
        {
            return -1;
        }

        try
        {
            self->obj = {_RepeatCount, _ScanCode, _IsExtendedKey, _IsMenuKeyDown, _WasKeyDown, _IsKeyReleased};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_CoreWebView2PhysicalKeyStatus(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PhysicalKeyStatus* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_CoreWebView2PhysicalKeyStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Web::WebView2::Core::CoreWebView2PhysicalKeyStatus>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_CoreWebView2PhysicalKeyStatus[] = {
        { "_assign_array_", _assign_array_CoreWebView2PhysicalKeyStatus, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* CoreWebView2PhysicalKeyStatus_get_RepeatCount(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PhysicalKeyStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RepeatCount);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PhysicalKeyStatus_set_RepeatCount(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PhysicalKeyStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.RepeatCount = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PhysicalKeyStatus_get_ScanCode(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PhysicalKeyStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ScanCode);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PhysicalKeyStatus_set_ScanCode(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PhysicalKeyStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.ScanCode = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PhysicalKeyStatus_get_IsExtendedKey(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PhysicalKeyStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsExtendedKey);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PhysicalKeyStatus_set_IsExtendedKey(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PhysicalKeyStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.IsExtendedKey = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PhysicalKeyStatus_get_IsMenuKeyDown(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PhysicalKeyStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsMenuKeyDown);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PhysicalKeyStatus_set_IsMenuKeyDown(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PhysicalKeyStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.IsMenuKeyDown = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PhysicalKeyStatus_get_WasKeyDown(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PhysicalKeyStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WasKeyDown);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PhysicalKeyStatus_set_WasKeyDown(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PhysicalKeyStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.WasKeyDown = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CoreWebView2PhysicalKeyStatus_get_IsKeyReleased(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PhysicalKeyStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsKeyReleased);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CoreWebView2PhysicalKeyStatus_set_IsKeyReleased(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PhysicalKeyStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.IsKeyReleased = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_CoreWebView2PhysicalKeyStatus[] = {
        { "repeat_count", reinterpret_cast<getter>(CoreWebView2PhysicalKeyStatus_get_RepeatCount), reinterpret_cast<setter>(CoreWebView2PhysicalKeyStatus_set_RepeatCount), nullptr, nullptr },
        { "scan_code", reinterpret_cast<getter>(CoreWebView2PhysicalKeyStatus_get_ScanCode), reinterpret_cast<setter>(CoreWebView2PhysicalKeyStatus_set_ScanCode), nullptr, nullptr },
        { "is_extended_key", reinterpret_cast<getter>(CoreWebView2PhysicalKeyStatus_get_IsExtendedKey), reinterpret_cast<setter>(CoreWebView2PhysicalKeyStatus_set_IsExtendedKey), nullptr, nullptr },
        { "is_menu_key_down", reinterpret_cast<getter>(CoreWebView2PhysicalKeyStatus_get_IsMenuKeyDown), reinterpret_cast<setter>(CoreWebView2PhysicalKeyStatus_set_IsMenuKeyDown), nullptr, nullptr },
        { "was_key_down", reinterpret_cast<getter>(CoreWebView2PhysicalKeyStatus_get_WasKeyDown), reinterpret_cast<setter>(CoreWebView2PhysicalKeyStatus_set_WasKeyDown), nullptr, nullptr },
        { "is_key_released", reinterpret_cast<getter>(CoreWebView2PhysicalKeyStatus_get_IsKeyReleased), reinterpret_cast<setter>(CoreWebView2PhysicalKeyStatus_set_IsKeyReleased), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CoreWebView2PhysicalKeyStatus[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CoreWebView2PhysicalKeyStatus) },
        { Py_tp_init, reinterpret_cast<void*>(_init_CoreWebView2PhysicalKeyStatus) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CoreWebView2PhysicalKeyStatus) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CoreWebView2PhysicalKeyStatus) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CoreWebView2PhysicalKeyStatus) },
        { },
    };

    static PyType_Spec type_spec_CoreWebView2PhysicalKeyStatus =
    {
        "winrt._winrt_microsoft_web_webview2_core.CoreWebView2PhysicalKeyStatus",
        sizeof(py::wrapper::Microsoft::Web::WebView2::Core::CoreWebView2PhysicalKeyStatus),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreWebView2PhysicalKeyStatus
    };

    // ----- Microsoft.Web.WebView2.Core Initialization --------------------
    PyDoc_STRVAR(module_doc, "Microsoft::Web::WebView2::Core");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_microsoft_web_webview2_core",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Microsoft::Web::WebView2::Core

PyMODINIT_FUNC PyInit__winrt_microsoft_web_webview2_core(void) noexcept
{
    using namespace py::cpp::Microsoft::Web::WebView2::Core;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2AcceleratorKeyPressedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2BasicAuthenticationRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2BasicAuthenticationResponse, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2BrowserProcessExitedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2Certificate, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2ClientCertificate, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2ClientCertificateRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2CompositionController, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2ContentLoadingEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2ContextMenuItem, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2ContextMenuRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2ContextMenuTarget, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2Controller, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2ControllerOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_CoreWebView2ControllerWindowReference_Static{PyType_FromSpec(&type_spec_CoreWebView2ControllerWindowReference_Static)};
    if (!type_CoreWebView2ControllerWindowReference_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2ControllerWindowReference, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CoreWebView2ControllerWindowReference_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2Cookie, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2CookieManager, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2CustomSchemeRegistration, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2DOMContentLoadedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2DevToolsProtocolEventReceivedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2DevToolsProtocolEventReceiver, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2DownloadOperation, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2DownloadStartingEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_CoreWebView2Environment_Static{PyType_FromSpec(&type_spec_CoreWebView2Environment_Static)};
    if (!type_CoreWebView2Environment_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2Environment, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CoreWebView2Environment_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2EnvironmentOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2File, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2Frame, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2FrameCreatedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2FrameInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2HttpHeadersCollectionIterator, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2HttpRequestHeaders, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2HttpResponseHeaders, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2LaunchingExternalUriSchemeEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2MoveFocusRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2NavigationCompletedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2NavigationStartingEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2NewWindowRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2PermissionRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2PermissionSetting, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2PointerInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2PrintSettings, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2ProcessFailedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2ProcessInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2Profile, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2ScriptDialogOpeningEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2ServerCertificateErrorDetectedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2Settings, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2SharedBuffer, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2SourceChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2WebMessageReceivedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2WebResourceRequest, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2WebResourceRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2WebResourceResponse, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2WebResourceResponseReceivedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2WebResourceResponseView, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2WindowFeatures, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ICoreWebView2DispatchAdapter, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CoreWebView2PhysicalKeyStatus, nullptr, nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
