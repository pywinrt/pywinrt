// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Microsoft.UI.Xaml.Documents.h"


namespace py::cpp::Microsoft::UI::Xaml::Documents
{
    // ----- Block class --------------------

    static PyObject* _new_Block(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Documents::Block>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Documents::Block>::type_name);
        return nullptr;
    }

    static void _dealloc_Block(py::wrapper::Microsoft::UI::Xaml::Documents::Block* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Block_get_TextAlignment(py::wrapper::Microsoft::UI::Xaml::Documents::Block* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Block", L"TextAlignment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TextAlignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Block_put_TextAlignment(py::wrapper::Microsoft::UI::Xaml::Documents::Block* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Block", L"TextAlignment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::TextAlignment>(arg);

            self->obj.TextAlignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Block_get_Margin(py::wrapper::Microsoft::UI::Xaml::Documents::Block* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Block", L"Margin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Margin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Block_put_Margin(py::wrapper::Microsoft::UI::Xaml::Documents::Block* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Block", L"Margin"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Thickness>(arg);

            self->obj.Margin(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Block_get_LineStackingStrategy(py::wrapper::Microsoft::UI::Xaml::Documents::Block* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Block", L"LineStackingStrategy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LineStackingStrategy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Block_put_LineStackingStrategy(py::wrapper::Microsoft::UI::Xaml::Documents::Block* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Block", L"LineStackingStrategy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::LineStackingStrategy>(arg);

            self->obj.LineStackingStrategy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Block_get_LineHeight(py::wrapper::Microsoft::UI::Xaml::Documents::Block* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Block", L"LineHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LineHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Block_put_LineHeight(py::wrapper::Microsoft::UI::Xaml::Documents::Block* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Block", L"LineHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.LineHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Block_get_HorizontalTextAlignment(py::wrapper::Microsoft::UI::Xaml::Documents::Block* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Block", L"HorizontalTextAlignment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontalTextAlignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Block_put_HorizontalTextAlignment(py::wrapper::Microsoft::UI::Xaml::Documents::Block* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Block", L"HorizontalTextAlignment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::TextAlignment>(arg);

            self->obj.HorizontalTextAlignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Block_get_HorizontalTextAlignmentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Block", L"HorizontalTextAlignmentProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Block::HorizontalTextAlignmentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Block_get_LineHeightProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Block", L"LineHeightProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Block::LineHeightProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Block_get_LineStackingStrategyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Block", L"LineStackingStrategyProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Block::LineStackingStrategyProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Block_get_MarginProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Block", L"MarginProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Block::MarginProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Block_get_TextAlignmentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Block", L"TextAlignmentProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Block::TextAlignmentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Block(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::Block>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Block(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::Block>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Block[] = {
        { "_assign_array_", _assign_array_Block, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Block), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Block[] = {
        { "text_alignment", reinterpret_cast<getter>(Block_get_TextAlignment), reinterpret_cast<setter>(Block_put_TextAlignment), nullptr, nullptr },
        { "margin", reinterpret_cast<getter>(Block_get_Margin), reinterpret_cast<setter>(Block_put_Margin), nullptr, nullptr },
        { "line_stacking_strategy", reinterpret_cast<getter>(Block_get_LineStackingStrategy), reinterpret_cast<setter>(Block_put_LineStackingStrategy), nullptr, nullptr },
        { "line_height", reinterpret_cast<getter>(Block_get_LineHeight), reinterpret_cast<setter>(Block_put_LineHeight), nullptr, nullptr },
        { "horizontal_text_alignment", reinterpret_cast<getter>(Block_get_HorizontalTextAlignment), reinterpret_cast<setter>(Block_put_HorizontalTextAlignment), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Block[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Block) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Block) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Block) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Block) },
        { },
    };

    static PyType_Spec type_spec_Block =
    {
        "winrt._winrt_microsoft_ui_xaml_documents.Block",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Documents::Block),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Block
    };

    static PyGetSetDef getset_Block_Static[] = {
        { "horizontal_text_alignment_property", reinterpret_cast<getter>(Block_get_HorizontalTextAlignmentProperty), nullptr, nullptr, nullptr },
        { "line_height_property", reinterpret_cast<getter>(Block_get_LineHeightProperty), nullptr, nullptr, nullptr },
        { "line_stacking_strategy_property", reinterpret_cast<getter>(Block_get_LineStackingStrategyProperty), nullptr, nullptr, nullptr },
        { "margin_property", reinterpret_cast<getter>(Block_get_MarginProperty), nullptr, nullptr, nullptr },
        { "text_alignment_property", reinterpret_cast<getter>(Block_get_TextAlignmentProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Block_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Block_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Block_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Block_Static) },
        { }
    };

    static PyType_Spec type_spec_Block_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_documents.Block_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Block_Static
    };

    // ----- BlockCollection class --------------------

    static PyObject* _new_BlockCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Documents::BlockCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Documents::BlockCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_BlockCollection(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BlockCollection_Append(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.BlockCollection", L"Append", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Documents::Block>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BlockCollection_Clear(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.BlockCollection", L"Clear", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BlockCollection_First(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.BlockCollection", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BlockCollection_GetAt(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.BlockCollection", L"GetAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BlockCollection_GetMany(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.BlockCollection", L"GetMany", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Microsoft::UI::Xaml::Documents::Block, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BlockCollection_GetView(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.BlockCollection", L"GetView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BlockCollection_IndexOf(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.BlockCollection", L"IndexOf", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Documents::Block>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BlockCollection_InsertAt(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.BlockCollection", L"InsertAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Documents::Block>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BlockCollection_RemoveAt(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.BlockCollection", L"RemoveAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BlockCollection_RemoveAtEnd(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.BlockCollection", L"RemoveAtEnd", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BlockCollection_ReplaceAll(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.BlockCollection", L"ReplaceAll", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Microsoft::UI::Xaml::Documents::Block, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BlockCollection_SetAt(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.BlockCollection", L"SetAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Documents::Block>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BlockCollection_get_Size(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.BlockCollection", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BlockCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::BlockCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BlockCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::BlockCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_BlockCollection(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_BlockCollection(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_BlockCollection(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_BlockCollection(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_BlockCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(
                    PyExc_NotImplementedError,
                    "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Microsoft::UI::Xaml::Documents::Block> items(static_cast<uint32_t>(length), empty_instance<winrt::Microsoft::UI::Xaml::Documents::Block>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(
                    PyExc_RuntimeError,
                    "returned count %d did not match requested length %zd",
                    count,
                    length);
                return nullptr;
            }

            return convert(items);}
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_BlockCollection(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Microsoft::UI::Xaml::Documents::Block>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_BlockCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(BlockCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(BlockCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(BlockCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(BlockCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(BlockCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(BlockCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(BlockCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(BlockCollection_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(BlockCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(BlockCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(BlockCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(BlockCollection_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BlockCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BlockCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BlockCollection[] = {
        { "size", reinterpret_cast<getter>(BlockCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BlockCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BlockCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BlockCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BlockCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BlockCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_BlockCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_BlockCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_BlockCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_BlockCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_BlockCollection) },
        { },
    };

    static PyType_Spec type_spec_BlockCollection =
    {
        "winrt._winrt_microsoft_ui_xaml_documents.BlockCollection",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BlockCollection
    };

    // ----- Bold class --------------------

    static PyObject* _new_Bold(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Documents::Bold instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Bold(py::wrapper::Microsoft::UI::Xaml::Documents::Bold* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Bold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::Bold>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Bold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::Bold>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Bold[] = {
        { "_assign_array_", _assign_array_Bold, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Bold), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Bold[] = {
        { }
    };

    static PyType_Slot _type_slots_Bold[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Bold) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Bold) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Bold) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Bold) },
        { },
    };

    static PyType_Spec type_spec_Bold =
    {
        "winrt._winrt_microsoft_ui_xaml_documents.Bold",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Documents::Bold),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Bold
    };

    // ----- Glyphs class --------------------

    static PyObject* _new_Glyphs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Documents::Glyphs instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Glyphs(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Glyphs_get_UnicodeString(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"UnicodeString"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UnicodeString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Glyphs_put_UnicodeString(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"UnicodeString"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.UnicodeString(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Glyphs_get_StyleSimulations(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"StyleSimulations"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StyleSimulations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Glyphs_put_StyleSimulations(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"StyleSimulations"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::StyleSimulations>(arg);

            self->obj.StyleSimulations(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Glyphs_get_OriginY(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"OriginY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OriginY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Glyphs_put_OriginY(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"OriginY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OriginY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Glyphs_get_OriginX(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"OriginX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OriginX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Glyphs_put_OriginX(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"OriginX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OriginX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Glyphs_get_IsColorFontEnabled(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"IsColorFontEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsColorFontEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Glyphs_put_IsColorFontEnabled(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"IsColorFontEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsColorFontEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Glyphs_get_Indices(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"Indices"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Indices());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Glyphs_put_Indices(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"Indices"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Indices(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Glyphs_get_FontUri(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"FontUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FontUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Glyphs_put_FontUri(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"FontUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.FontUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Glyphs_get_FontRenderingEmSize(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"FontRenderingEmSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FontRenderingEmSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Glyphs_put_FontRenderingEmSize(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"FontRenderingEmSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.FontRenderingEmSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Glyphs_get_Fill(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"Fill"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Fill());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Glyphs_put_Fill(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"Fill"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.Fill(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Glyphs_get_ColorFontPaletteIndex(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"ColorFontPaletteIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ColorFontPaletteIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Glyphs_put_ColorFontPaletteIndex(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"ColorFontPaletteIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ColorFontPaletteIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Glyphs_get_ColorFontPaletteIndexProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"ColorFontPaletteIndexProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Glyphs::ColorFontPaletteIndexProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Glyphs_get_FillProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"FillProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Glyphs::FillProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Glyphs_get_FontRenderingEmSizeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"FontRenderingEmSizeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Glyphs::FontRenderingEmSizeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Glyphs_get_FontUriProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"FontUriProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Glyphs::FontUriProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Glyphs_get_IndicesProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"IndicesProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Glyphs::IndicesProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Glyphs_get_IsColorFontEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"IsColorFontEnabledProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Glyphs::IsColorFontEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Glyphs_get_OriginXProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"OriginXProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Glyphs::OriginXProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Glyphs_get_OriginYProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"OriginYProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Glyphs::OriginYProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Glyphs_get_StyleSimulationsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"StyleSimulationsProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Glyphs::StyleSimulationsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Glyphs_get_UnicodeStringProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"UnicodeStringProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Glyphs::UnicodeStringProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Glyphs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::Glyphs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Glyphs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::Glyphs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Glyphs[] = {
        { "_assign_array_", _assign_array_Glyphs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Glyphs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Glyphs[] = {
        { "unicode_string", reinterpret_cast<getter>(Glyphs_get_UnicodeString), reinterpret_cast<setter>(Glyphs_put_UnicodeString), nullptr, nullptr },
        { "style_simulations", reinterpret_cast<getter>(Glyphs_get_StyleSimulations), reinterpret_cast<setter>(Glyphs_put_StyleSimulations), nullptr, nullptr },
        { "origin_y", reinterpret_cast<getter>(Glyphs_get_OriginY), reinterpret_cast<setter>(Glyphs_put_OriginY), nullptr, nullptr },
        { "origin_x", reinterpret_cast<getter>(Glyphs_get_OriginX), reinterpret_cast<setter>(Glyphs_put_OriginX), nullptr, nullptr },
        { "is_color_font_enabled", reinterpret_cast<getter>(Glyphs_get_IsColorFontEnabled), reinterpret_cast<setter>(Glyphs_put_IsColorFontEnabled), nullptr, nullptr },
        { "indices", reinterpret_cast<getter>(Glyphs_get_Indices), reinterpret_cast<setter>(Glyphs_put_Indices), nullptr, nullptr },
        { "font_uri", reinterpret_cast<getter>(Glyphs_get_FontUri), reinterpret_cast<setter>(Glyphs_put_FontUri), nullptr, nullptr },
        { "font_rendering_em_size", reinterpret_cast<getter>(Glyphs_get_FontRenderingEmSize), reinterpret_cast<setter>(Glyphs_put_FontRenderingEmSize), nullptr, nullptr },
        { "fill", reinterpret_cast<getter>(Glyphs_get_Fill), reinterpret_cast<setter>(Glyphs_put_Fill), nullptr, nullptr },
        { "color_font_palette_index", reinterpret_cast<getter>(Glyphs_get_ColorFontPaletteIndex), reinterpret_cast<setter>(Glyphs_put_ColorFontPaletteIndex), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Glyphs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Glyphs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Glyphs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Glyphs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Glyphs) },
        { },
    };

    static PyType_Spec type_spec_Glyphs =
    {
        "winrt._winrt_microsoft_ui_xaml_documents.Glyphs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Glyphs
    };

    static PyGetSetDef getset_Glyphs_Static[] = {
        { "color_font_palette_index_property", reinterpret_cast<getter>(Glyphs_get_ColorFontPaletteIndexProperty), nullptr, nullptr, nullptr },
        { "fill_property", reinterpret_cast<getter>(Glyphs_get_FillProperty), nullptr, nullptr, nullptr },
        { "font_rendering_em_size_property", reinterpret_cast<getter>(Glyphs_get_FontRenderingEmSizeProperty), nullptr, nullptr, nullptr },
        { "font_uri_property", reinterpret_cast<getter>(Glyphs_get_FontUriProperty), nullptr, nullptr, nullptr },
        { "indices_property", reinterpret_cast<getter>(Glyphs_get_IndicesProperty), nullptr, nullptr, nullptr },
        { "is_color_font_enabled_property", reinterpret_cast<getter>(Glyphs_get_IsColorFontEnabledProperty), nullptr, nullptr, nullptr },
        { "origin_x_property", reinterpret_cast<getter>(Glyphs_get_OriginXProperty), nullptr, nullptr, nullptr },
        { "origin_y_property", reinterpret_cast<getter>(Glyphs_get_OriginYProperty), nullptr, nullptr, nullptr },
        { "style_simulations_property", reinterpret_cast<getter>(Glyphs_get_StyleSimulationsProperty), nullptr, nullptr, nullptr },
        { "unicode_string_property", reinterpret_cast<getter>(Glyphs_get_UnicodeStringProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Glyphs_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Glyphs_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Glyphs_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Glyphs_Static) },
        { }
    };

    static PyType_Spec type_spec_Glyphs_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_documents.Glyphs_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Glyphs_Static
    };

    // ----- Hyperlink class --------------------

    static PyObject* _new_Hyperlink(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Documents::Hyperlink instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Hyperlink(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Hyperlink_Focus(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"Focus", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::FocusState>(args, 0);

                return py::convert(self->obj.Focus(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Hyperlink_get_XYFocusUpNavigationStrategy(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusUpNavigationStrategy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.XYFocusUpNavigationStrategy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Hyperlink_put_XYFocusUpNavigationStrategy(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusUpNavigationStrategy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Input::XYFocusNavigationStrategy>(arg);

            self->obj.XYFocusUpNavigationStrategy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Hyperlink_get_XYFocusUp(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusUp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.XYFocusUp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Hyperlink_put_XYFocusUp(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusUp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(arg);

            self->obj.XYFocusUp(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Hyperlink_get_XYFocusRightNavigationStrategy(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusRightNavigationStrategy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.XYFocusRightNavigationStrategy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Hyperlink_put_XYFocusRightNavigationStrategy(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusRightNavigationStrategy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Input::XYFocusNavigationStrategy>(arg);

            self->obj.XYFocusRightNavigationStrategy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Hyperlink_get_XYFocusRight(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusRight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.XYFocusRight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Hyperlink_put_XYFocusRight(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusRight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(arg);

            self->obj.XYFocusRight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Hyperlink_get_XYFocusLeftNavigationStrategy(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusLeftNavigationStrategy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.XYFocusLeftNavigationStrategy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Hyperlink_put_XYFocusLeftNavigationStrategy(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusLeftNavigationStrategy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Input::XYFocusNavigationStrategy>(arg);

            self->obj.XYFocusLeftNavigationStrategy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Hyperlink_get_XYFocusLeft(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusLeft"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.XYFocusLeft());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Hyperlink_put_XYFocusLeft(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusLeft"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(arg);

            self->obj.XYFocusLeft(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Hyperlink_get_XYFocusDownNavigationStrategy(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusDownNavigationStrategy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.XYFocusDownNavigationStrategy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Hyperlink_put_XYFocusDownNavigationStrategy(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusDownNavigationStrategy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Input::XYFocusNavigationStrategy>(arg);

            self->obj.XYFocusDownNavigationStrategy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Hyperlink_get_XYFocusDown(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusDown"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.XYFocusDown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Hyperlink_put_XYFocusDown(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusDown"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(arg);

            self->obj.XYFocusDown(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Hyperlink_get_UnderlineStyle(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"UnderlineStyle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UnderlineStyle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Hyperlink_put_UnderlineStyle(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"UnderlineStyle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Documents::UnderlineStyle>(arg);

            self->obj.UnderlineStyle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Hyperlink_get_TabIndex(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"TabIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TabIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Hyperlink_put_TabIndex(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"TabIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.TabIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Hyperlink_get_NavigateUri(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"NavigateUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NavigateUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Hyperlink_put_NavigateUri(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"NavigateUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.NavigateUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Hyperlink_get_IsTabStop(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"IsTabStop"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsTabStop());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Hyperlink_put_IsTabStop(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"IsTabStop"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsTabStop(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Hyperlink_get_ElementSoundMode(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"ElementSoundMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ElementSoundMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Hyperlink_put_ElementSoundMode(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"ElementSoundMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::ElementSoundMode>(arg);

            self->obj.ElementSoundMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Hyperlink_get_FocusState(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"FocusState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FocusState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_get_ElementSoundModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"ElementSoundModeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Hyperlink::ElementSoundModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_get_FocusStateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"FocusStateProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Hyperlink::FocusStateProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_get_IsTabStopProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"IsTabStopProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Hyperlink::IsTabStopProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_get_NavigateUriProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"NavigateUriProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Hyperlink::NavigateUriProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_get_TabIndexProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"TabIndexProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Hyperlink::TabIndexProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_get_UnderlineStyleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"UnderlineStyleProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Hyperlink::UnderlineStyleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_get_XYFocusDownNavigationStrategyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusDownNavigationStrategyProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Hyperlink::XYFocusDownNavigationStrategyProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_get_XYFocusDownProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusDownProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Hyperlink::XYFocusDownProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_get_XYFocusLeftNavigationStrategyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusLeftNavigationStrategyProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Hyperlink::XYFocusLeftNavigationStrategyProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_get_XYFocusLeftProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusLeftProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Hyperlink::XYFocusLeftProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_get_XYFocusRightNavigationStrategyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusRightNavigationStrategyProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Hyperlink::XYFocusRightNavigationStrategyProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_get_XYFocusRightProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusRightProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Hyperlink::XYFocusRightProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_get_XYFocusUpNavigationStrategyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusUpNavigationStrategyProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Hyperlink::XYFocusUpNavigationStrategyProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_get_XYFocusUpProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusUpProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Hyperlink::XYFocusUpProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_add_Click(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"Click"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Documents::Hyperlink, winrt::Microsoft::UI::Xaml::Documents::HyperlinkClickEventArgs>>(arg);

            return py::convert(self->obj.Click(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_remove_Click(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"Click"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Click(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_add_GotFocus(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"GotFocus"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::RoutedEventHandler>(arg);

            return py::convert(self->obj.GotFocus(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_remove_GotFocus(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"GotFocus"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.GotFocus(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_add_LostFocus(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"LostFocus"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::RoutedEventHandler>(arg);

            return py::convert(self->obj.LostFocus(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_remove_LostFocus(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"LostFocus"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LostFocus(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Hyperlink(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::Hyperlink>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Hyperlink(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::Hyperlink>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Hyperlink[] = {
        { "focus", reinterpret_cast<PyCFunction>(Hyperlink_Focus), METH_VARARGS, nullptr },
        { "add_click", reinterpret_cast<PyCFunction>(Hyperlink_add_Click), METH_O, nullptr },
        { "remove_click", reinterpret_cast<PyCFunction>(Hyperlink_remove_Click), METH_O, nullptr },
        { "add_got_focus", reinterpret_cast<PyCFunction>(Hyperlink_add_GotFocus), METH_O, nullptr },
        { "remove_got_focus", reinterpret_cast<PyCFunction>(Hyperlink_remove_GotFocus), METH_O, nullptr },
        { "add_lost_focus", reinterpret_cast<PyCFunction>(Hyperlink_add_LostFocus), METH_O, nullptr },
        { "remove_lost_focus", reinterpret_cast<PyCFunction>(Hyperlink_remove_LostFocus), METH_O, nullptr },
        { "_assign_array_", _assign_array_Hyperlink, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Hyperlink), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Hyperlink[] = {
        { "x_y_focus_up_navigation_strategy", reinterpret_cast<getter>(Hyperlink_get_XYFocusUpNavigationStrategy), reinterpret_cast<setter>(Hyperlink_put_XYFocusUpNavigationStrategy), nullptr, nullptr },
        { "x_y_focus_up", reinterpret_cast<getter>(Hyperlink_get_XYFocusUp), reinterpret_cast<setter>(Hyperlink_put_XYFocusUp), nullptr, nullptr },
        { "x_y_focus_right_navigation_strategy", reinterpret_cast<getter>(Hyperlink_get_XYFocusRightNavigationStrategy), reinterpret_cast<setter>(Hyperlink_put_XYFocusRightNavigationStrategy), nullptr, nullptr },
        { "x_y_focus_right", reinterpret_cast<getter>(Hyperlink_get_XYFocusRight), reinterpret_cast<setter>(Hyperlink_put_XYFocusRight), nullptr, nullptr },
        { "x_y_focus_left_navigation_strategy", reinterpret_cast<getter>(Hyperlink_get_XYFocusLeftNavigationStrategy), reinterpret_cast<setter>(Hyperlink_put_XYFocusLeftNavigationStrategy), nullptr, nullptr },
        { "x_y_focus_left", reinterpret_cast<getter>(Hyperlink_get_XYFocusLeft), reinterpret_cast<setter>(Hyperlink_put_XYFocusLeft), nullptr, nullptr },
        { "x_y_focus_down_navigation_strategy", reinterpret_cast<getter>(Hyperlink_get_XYFocusDownNavigationStrategy), reinterpret_cast<setter>(Hyperlink_put_XYFocusDownNavigationStrategy), nullptr, nullptr },
        { "x_y_focus_down", reinterpret_cast<getter>(Hyperlink_get_XYFocusDown), reinterpret_cast<setter>(Hyperlink_put_XYFocusDown), nullptr, nullptr },
        { "underline_style", reinterpret_cast<getter>(Hyperlink_get_UnderlineStyle), reinterpret_cast<setter>(Hyperlink_put_UnderlineStyle), nullptr, nullptr },
        { "tab_index", reinterpret_cast<getter>(Hyperlink_get_TabIndex), reinterpret_cast<setter>(Hyperlink_put_TabIndex), nullptr, nullptr },
        { "navigate_uri", reinterpret_cast<getter>(Hyperlink_get_NavigateUri), reinterpret_cast<setter>(Hyperlink_put_NavigateUri), nullptr, nullptr },
        { "is_tab_stop", reinterpret_cast<getter>(Hyperlink_get_IsTabStop), reinterpret_cast<setter>(Hyperlink_put_IsTabStop), nullptr, nullptr },
        { "element_sound_mode", reinterpret_cast<getter>(Hyperlink_get_ElementSoundMode), reinterpret_cast<setter>(Hyperlink_put_ElementSoundMode), nullptr, nullptr },
        { "focus_state", reinterpret_cast<getter>(Hyperlink_get_FocusState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Hyperlink[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Hyperlink) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Hyperlink) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Hyperlink) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Hyperlink) },
        { },
    };

    static PyType_Spec type_spec_Hyperlink =
    {
        "winrt._winrt_microsoft_ui_xaml_documents.Hyperlink",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Hyperlink
    };

    static PyGetSetDef getset_Hyperlink_Static[] = {
        { "element_sound_mode_property", reinterpret_cast<getter>(Hyperlink_get_ElementSoundModeProperty), nullptr, nullptr, nullptr },
        { "focus_state_property", reinterpret_cast<getter>(Hyperlink_get_FocusStateProperty), nullptr, nullptr, nullptr },
        { "is_tab_stop_property", reinterpret_cast<getter>(Hyperlink_get_IsTabStopProperty), nullptr, nullptr, nullptr },
        { "navigate_uri_property", reinterpret_cast<getter>(Hyperlink_get_NavigateUriProperty), nullptr, nullptr, nullptr },
        { "tab_index_property", reinterpret_cast<getter>(Hyperlink_get_TabIndexProperty), nullptr, nullptr, nullptr },
        { "underline_style_property", reinterpret_cast<getter>(Hyperlink_get_UnderlineStyleProperty), nullptr, nullptr, nullptr },
        { "x_y_focus_down_navigation_strategy_property", reinterpret_cast<getter>(Hyperlink_get_XYFocusDownNavigationStrategyProperty), nullptr, nullptr, nullptr },
        { "x_y_focus_down_property", reinterpret_cast<getter>(Hyperlink_get_XYFocusDownProperty), nullptr, nullptr, nullptr },
        { "x_y_focus_left_navigation_strategy_property", reinterpret_cast<getter>(Hyperlink_get_XYFocusLeftNavigationStrategyProperty), nullptr, nullptr, nullptr },
        { "x_y_focus_left_property", reinterpret_cast<getter>(Hyperlink_get_XYFocusLeftProperty), nullptr, nullptr, nullptr },
        { "x_y_focus_right_navigation_strategy_property", reinterpret_cast<getter>(Hyperlink_get_XYFocusRightNavigationStrategyProperty), nullptr, nullptr, nullptr },
        { "x_y_focus_right_property", reinterpret_cast<getter>(Hyperlink_get_XYFocusRightProperty), nullptr, nullptr, nullptr },
        { "x_y_focus_up_navigation_strategy_property", reinterpret_cast<getter>(Hyperlink_get_XYFocusUpNavigationStrategyProperty), nullptr, nullptr, nullptr },
        { "x_y_focus_up_property", reinterpret_cast<getter>(Hyperlink_get_XYFocusUpProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Hyperlink_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Hyperlink_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Hyperlink_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Hyperlink_Static) },
        { }
    };

    static PyType_Spec type_spec_Hyperlink_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_documents.Hyperlink_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Hyperlink_Static
    };

    // ----- HyperlinkClickEventArgs class --------------------

    static PyObject* _new_HyperlinkClickEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Documents::HyperlinkClickEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Documents::HyperlinkClickEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_HyperlinkClickEventArgs(py::wrapper::Microsoft::UI::Xaml::Documents::HyperlinkClickEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_HyperlinkClickEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::HyperlinkClickEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HyperlinkClickEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::HyperlinkClickEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HyperlinkClickEventArgs[] = {
        { "_assign_array_", _assign_array_HyperlinkClickEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HyperlinkClickEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HyperlinkClickEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_HyperlinkClickEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HyperlinkClickEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HyperlinkClickEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HyperlinkClickEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HyperlinkClickEventArgs) },
        { },
    };

    static PyType_Spec type_spec_HyperlinkClickEventArgs =
    {
        "winrt._winrt_microsoft_ui_xaml_documents.HyperlinkClickEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Documents::HyperlinkClickEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HyperlinkClickEventArgs
    };

    // ----- Inline class --------------------

    static PyObject* _new_Inline(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Documents::Inline>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Documents::Inline>::type_name);
        return nullptr;
    }

    static void _dealloc_Inline(py::wrapper::Microsoft::UI::Xaml::Documents::Inline* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Inline(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::Inline>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Inline(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::Inline>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Inline[] = {
        { "_assign_array_", _assign_array_Inline, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Inline), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Inline[] = {
        { }
    };

    static PyType_Slot _type_slots_Inline[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Inline) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Inline) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Inline) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Inline) },
        { },
    };

    static PyType_Spec type_spec_Inline =
    {
        "winrt._winrt_microsoft_ui_xaml_documents.Inline",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Documents::Inline),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Inline
    };

    // ----- InlineCollection class --------------------

    static PyObject* _new_InlineCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Documents::InlineCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Documents::InlineCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_InlineCollection(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InlineCollection_Append(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.InlineCollection", L"Append", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Documents::Inline>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InlineCollection_Clear(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.InlineCollection", L"Clear", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InlineCollection_First(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.InlineCollection", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InlineCollection_GetAt(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.InlineCollection", L"GetAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InlineCollection_GetMany(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.InlineCollection", L"GetMany", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Microsoft::UI::Xaml::Documents::Inline, true>>(args, 1);

                return py::convert(self->obj.GetMany(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InlineCollection_GetView(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.InlineCollection", L"GetView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InlineCollection_IndexOf(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.InlineCollection", L"IndexOf", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Documents::Inline>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InlineCollection_InsertAt(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.InlineCollection", L"InsertAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Documents::Inline>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InlineCollection_RemoveAt(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.InlineCollection", L"RemoveAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InlineCollection_RemoveAtEnd(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.InlineCollection", L"RemoveAtEnd", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InlineCollection_ReplaceAll(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.InlineCollection", L"ReplaceAll", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Microsoft::UI::Xaml::Documents::Inline, false>>(args, 0);

                self->obj.ReplaceAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InlineCollection_SetAt(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.InlineCollection", L"SetAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Documents::Inline>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InlineCollection_get_Size(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.InlineCollection", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InlineCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::InlineCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InlineCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::InlineCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_InlineCollection(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_InlineCollection(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_InlineCollection(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_InlineCollection(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_InlineCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(
                    PyExc_TypeError,
                    "indicies must be integers, not '%s'",
                    Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            if (PySlice_GetIndicesEx(
                    slice, self->obj.Size(), &start, &stop, &step, &length)
                < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(
                    PyExc_NotImplementedError,
                    "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Microsoft::UI::Xaml::Documents::Inline> items(static_cast<uint32_t>(length), empty_instance<winrt::Microsoft::UI::Xaml::Documents::Inline>::get());

            auto count = self->obj.GetMany(static_cast<uint32_t>(start), items);

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(
                    PyExc_RuntimeError,
                    "returned count %d did not match requested length %zd",
                    count,
                    length);
                return nullptr;
            }

            return convert(items);}
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_InlineCollection(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (value == nullptr) { self->obj.RemoveAt(static_cast<uint32_t>(i)); }
            else { self->obj.SetAt(static_cast<uint32_t>(i), py::convert_to<winrt::Microsoft::UI::Xaml::Documents::Inline>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_InlineCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(InlineCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(InlineCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(InlineCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(InlineCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(InlineCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(InlineCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(InlineCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(InlineCollection_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(InlineCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(InlineCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(InlineCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(InlineCollection_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_InlineCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InlineCollection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InlineCollection[] = {
        { "size", reinterpret_cast<getter>(InlineCollection_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InlineCollection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InlineCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InlineCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InlineCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InlineCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_InlineCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_InlineCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_InlineCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_InlineCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_InlineCollection) },
        { },
    };

    static PyType_Spec type_spec_InlineCollection =
    {
        "winrt._winrt_microsoft_ui_xaml_documents.InlineCollection",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InlineCollection
    };

    // ----- InlineUIContainer class --------------------

    static PyObject* _new_InlineUIContainer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Documents::InlineUIContainer instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InlineUIContainer(py::wrapper::Microsoft::UI::Xaml::Documents::InlineUIContainer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InlineUIContainer_get_Child(py::wrapper::Microsoft::UI::Xaml::Documents::InlineUIContainer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.InlineUIContainer", L"Child"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Child());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InlineUIContainer_put_Child(py::wrapper::Microsoft::UI::Xaml::Documents::InlineUIContainer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.InlineUIContainer", L"Child"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(arg);

            self->obj.Child(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_InlineUIContainer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::InlineUIContainer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InlineUIContainer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::InlineUIContainer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InlineUIContainer[] = {
        { "_assign_array_", _assign_array_InlineUIContainer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InlineUIContainer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InlineUIContainer[] = {
        { "child", reinterpret_cast<getter>(InlineUIContainer_get_Child), reinterpret_cast<setter>(InlineUIContainer_put_Child), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InlineUIContainer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InlineUIContainer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InlineUIContainer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InlineUIContainer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InlineUIContainer) },
        { },
    };

    static PyType_Spec type_spec_InlineUIContainer =
    {
        "winrt._winrt_microsoft_ui_xaml_documents.InlineUIContainer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Documents::InlineUIContainer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InlineUIContainer
    };

    // ----- Italic class --------------------

    static PyObject* _new_Italic(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Documents::Italic instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Italic(py::wrapper::Microsoft::UI::Xaml::Documents::Italic* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Italic(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::Italic>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Italic(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::Italic>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Italic[] = {
        { "_assign_array_", _assign_array_Italic, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Italic), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Italic[] = {
        { }
    };

    static PyType_Slot _type_slots_Italic[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Italic) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Italic) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Italic) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Italic) },
        { },
    };

    static PyType_Spec type_spec_Italic =
    {
        "winrt._winrt_microsoft_ui_xaml_documents.Italic",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Documents::Italic),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Italic
    };

    // ----- LineBreak class --------------------

    static PyObject* _new_LineBreak(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Documents::LineBreak instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LineBreak(py::wrapper::Microsoft::UI::Xaml::Documents::LineBreak* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_LineBreak(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::LineBreak>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LineBreak(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::LineBreak>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineBreak[] = {
        { "_assign_array_", _assign_array_LineBreak, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LineBreak), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LineBreak[] = {
        { }
    };

    static PyType_Slot _type_slots_LineBreak[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LineBreak) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LineBreak) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LineBreak) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LineBreak) },
        { },
    };

    static PyType_Spec type_spec_LineBreak =
    {
        "winrt._winrt_microsoft_ui_xaml_documents.LineBreak",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Documents::LineBreak),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineBreak
    };

    // ----- Paragraph class --------------------

    static PyObject* _new_Paragraph(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Documents::Paragraph instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Paragraph(py::wrapper::Microsoft::UI::Xaml::Documents::Paragraph* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Paragraph_get_TextIndent(py::wrapper::Microsoft::UI::Xaml::Documents::Paragraph* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Paragraph", L"TextIndent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TextIndent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Paragraph_put_TextIndent(py::wrapper::Microsoft::UI::Xaml::Documents::Paragraph* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Paragraph", L"TextIndent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.TextIndent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Paragraph_get_Inlines(py::wrapper::Microsoft::UI::Xaml::Documents::Paragraph* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Paragraph", L"Inlines"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Inlines());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Paragraph_get_TextIndentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Paragraph", L"TextIndentProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Paragraph::TextIndentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Paragraph(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::Paragraph>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Paragraph(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::Paragraph>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Paragraph[] = {
        { "_assign_array_", _assign_array_Paragraph, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Paragraph), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Paragraph[] = {
        { "text_indent", reinterpret_cast<getter>(Paragraph_get_TextIndent), reinterpret_cast<setter>(Paragraph_put_TextIndent), nullptr, nullptr },
        { "inlines", reinterpret_cast<getter>(Paragraph_get_Inlines), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Paragraph[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Paragraph) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Paragraph) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Paragraph) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Paragraph) },
        { },
    };

    static PyType_Spec type_spec_Paragraph =
    {
        "winrt._winrt_microsoft_ui_xaml_documents.Paragraph",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Documents::Paragraph),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Paragraph
    };

    static PyGetSetDef getset_Paragraph_Static[] = {
        { "text_indent_property", reinterpret_cast<getter>(Paragraph_get_TextIndentProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Paragraph_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Paragraph_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Paragraph_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Paragraph_Static) },
        { }
    };

    static PyType_Spec type_spec_Paragraph_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_documents.Paragraph_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Paragraph_Static
    };

    // ----- Run class --------------------

    static PyObject* _new_Run(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Documents::Run instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Run(py::wrapper::Microsoft::UI::Xaml::Documents::Run* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Run_get_Text(py::wrapper::Microsoft::UI::Xaml::Documents::Run* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Run", L"Text"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Run_put_Text(py::wrapper::Microsoft::UI::Xaml::Documents::Run* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Run", L"Text"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Run_get_FlowDirection(py::wrapper::Microsoft::UI::Xaml::Documents::Run* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Run", L"FlowDirection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FlowDirection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Run_put_FlowDirection(py::wrapper::Microsoft::UI::Xaml::Documents::Run* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Run", L"FlowDirection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::FlowDirection>(arg);

            self->obj.FlowDirection(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Run_get_FlowDirectionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Run", L"FlowDirectionProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Run::FlowDirectionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Run(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::Run>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Run(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::Run>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Run[] = {
        { "_assign_array_", _assign_array_Run, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Run), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Run[] = {
        { "text", reinterpret_cast<getter>(Run_get_Text), reinterpret_cast<setter>(Run_put_Text), nullptr, nullptr },
        { "flow_direction", reinterpret_cast<getter>(Run_get_FlowDirection), reinterpret_cast<setter>(Run_put_FlowDirection), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Run[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Run) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Run) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Run) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Run) },
        { },
    };

    static PyType_Spec type_spec_Run =
    {
        "winrt._winrt_microsoft_ui_xaml_documents.Run",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Documents::Run),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Run
    };

    static PyGetSetDef getset_Run_Static[] = {
        { "flow_direction_property", reinterpret_cast<getter>(Run_get_FlowDirectionProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Run_Static[] = {
        { }
    };

    static PyType_Slot type_slots_Run_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Run_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Run_Static) },
        { }
    };

    static PyType_Spec type_spec_Run_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_documents.Run_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Run_Static
    };

    // ----- Span class --------------------

    static PyObject* _new_Span(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Documents::Span instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Span(py::wrapper::Microsoft::UI::Xaml::Documents::Span* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Span_get_Inlines(py::wrapper::Microsoft::UI::Xaml::Documents::Span* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Span", L"Inlines"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Inlines());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Span_put_Inlines(py::wrapper::Microsoft::UI::Xaml::Documents::Span* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Span", L"Inlines"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Documents::InlineCollection>(arg);

            self->obj.Inlines(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_Span(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::Span>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Span(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::Span>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Span[] = {
        { "_assign_array_", _assign_array_Span, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Span), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Span[] = {
        { "inlines", reinterpret_cast<getter>(Span_get_Inlines), reinterpret_cast<setter>(Span_put_Inlines), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Span[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Span) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Span) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Span) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Span) },
        { },
    };

    static PyType_Spec type_spec_Span =
    {
        "winrt._winrt_microsoft_ui_xaml_documents.Span",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Documents::Span),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Span
    };

    // ----- TextElement class --------------------

    static PyObject* _new_TextElement(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Documents::TextElement>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Documents::TextElement>::type_name);
        return nullptr;
    }

    static void _dealloc_TextElement(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TextElement_FindName(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"FindName", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TextElement_OnDisconnectVisualChildren(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"OnDisconnectVisualChildren", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.OnDisconnectVisualChildren();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TextElement_get_XamlRoot(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"XamlRoot"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.XamlRoot());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextElement_put_XamlRoot(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"XamlRoot"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::XamlRoot>(arg);

            self->obj.XamlRoot(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextElement_get_TextDecorations(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"TextDecorations"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TextDecorations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextElement_put_TextDecorations(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"TextDecorations"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::TextDecorations>(arg);

            self->obj.TextDecorations(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextElement_get_Language(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextElement_put_Language(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"Language"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Language(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextElement_get_KeyTipVerticalOffset(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"KeyTipVerticalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyTipVerticalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextElement_put_KeyTipVerticalOffset(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"KeyTipVerticalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.KeyTipVerticalOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextElement_get_KeyTipPlacementMode(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"KeyTipPlacementMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyTipPlacementMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextElement_put_KeyTipPlacementMode(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"KeyTipPlacementMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Input::KeyTipPlacementMode>(arg);

            self->obj.KeyTipPlacementMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextElement_get_KeyTipHorizontalOffset(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"KeyTipHorizontalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyTipHorizontalOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextElement_put_KeyTipHorizontalOffset(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"KeyTipHorizontalOffset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.KeyTipHorizontalOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextElement_get_IsTextScaleFactorEnabled(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"IsTextScaleFactorEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsTextScaleFactorEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextElement_put_IsTextScaleFactorEnabled(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"IsTextScaleFactorEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsTextScaleFactorEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextElement_get_IsAccessKeyScope(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"IsAccessKeyScope"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsAccessKeyScope());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextElement_put_IsAccessKeyScope(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"IsAccessKeyScope"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsAccessKeyScope(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextElement_get_Foreground(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"Foreground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Foreground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextElement_put_Foreground(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"Foreground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.Foreground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextElement_get_FontWeight(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"FontWeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FontWeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextElement_put_FontWeight(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"FontWeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::FontWeight>(arg);

            self->obj.FontWeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextElement_get_FontStyle(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"FontStyle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FontStyle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextElement_put_FontStyle(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"FontStyle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::FontStyle>(arg);

            self->obj.FontStyle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextElement_get_FontStretch(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"FontStretch"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FontStretch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextElement_put_FontStretch(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"FontStretch"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Text::FontStretch>(arg);

            self->obj.FontStretch(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextElement_get_FontSize(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"FontSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FontSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextElement_put_FontSize(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"FontSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.FontSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextElement_get_FontFamily(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"FontFamily"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FontFamily());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextElement_put_FontFamily(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"FontFamily"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::FontFamily>(arg);

            self->obj.FontFamily(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextElement_get_ExitDisplayModeOnAccessKeyInvoked(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"ExitDisplayModeOnAccessKeyInvoked"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExitDisplayModeOnAccessKeyInvoked());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextElement_put_ExitDisplayModeOnAccessKeyInvoked(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"ExitDisplayModeOnAccessKeyInvoked"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ExitDisplayModeOnAccessKeyInvoked(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextElement_get_CharacterSpacing(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"CharacterSpacing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CharacterSpacing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextElement_put_CharacterSpacing(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"CharacterSpacing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.CharacterSpacing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextElement_get_AllowFocusOnInteraction(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"AllowFocusOnInteraction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AllowFocusOnInteraction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextElement_put_AllowFocusOnInteraction(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"AllowFocusOnInteraction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowFocusOnInteraction(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextElement_get_AccessKeyScopeOwner(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"AccessKeyScopeOwner"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccessKeyScopeOwner());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextElement_put_AccessKeyScopeOwner(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"AccessKeyScopeOwner"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(arg);

            self->obj.AccessKeyScopeOwner(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextElement_get_AccessKey(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"AccessKey"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccessKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextElement_put_AccessKey(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"AccessKey"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.AccessKey(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextElement_get_ContentEnd(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"ContentEnd"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContentEnd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_ContentStart(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"ContentStart"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContentStart());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_ElementEnd(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"ElementEnd"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ElementEnd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_ElementStart(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"ElementStart"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ElementStart());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_Name(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_AccessKeyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"AccessKeyProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::TextElement::AccessKeyProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_AccessKeyScopeOwnerProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"AccessKeyScopeOwnerProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::TextElement::AccessKeyScopeOwnerProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_AllowFocusOnInteractionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"AllowFocusOnInteractionProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::TextElement::AllowFocusOnInteractionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_CharacterSpacingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"CharacterSpacingProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::TextElement::CharacterSpacingProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_ExitDisplayModeOnAccessKeyInvokedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"ExitDisplayModeOnAccessKeyInvokedProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::TextElement::ExitDisplayModeOnAccessKeyInvokedProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_FontFamilyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"FontFamilyProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::TextElement::FontFamilyProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_FontSizeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"FontSizeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::TextElement::FontSizeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_FontStretchProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"FontStretchProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::TextElement::FontStretchProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_FontStyleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"FontStyleProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::TextElement::FontStyleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_FontWeightProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"FontWeightProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::TextElement::FontWeightProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_ForegroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"ForegroundProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::TextElement::ForegroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_IsAccessKeyScopeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"IsAccessKeyScopeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::TextElement::IsAccessKeyScopeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_IsTextScaleFactorEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"IsTextScaleFactorEnabledProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::TextElement::IsTextScaleFactorEnabledProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_KeyTipHorizontalOffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"KeyTipHorizontalOffsetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::TextElement::KeyTipHorizontalOffsetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_KeyTipPlacementModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"KeyTipPlacementModeProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::TextElement::KeyTipPlacementModeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_KeyTipVerticalOffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"KeyTipVerticalOffsetProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::TextElement::KeyTipVerticalOffsetProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_LanguageProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"LanguageProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::TextElement::LanguageProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_TextDecorationsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"TextDecorationsProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::TextElement::TextDecorationsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_add_AccessKeyDisplayDismissed(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"AccessKeyDisplayDismissed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Documents::TextElement, winrt::Microsoft::UI::Xaml::Input::AccessKeyDisplayDismissedEventArgs>>(arg);

            return py::convert(self->obj.AccessKeyDisplayDismissed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_remove_AccessKeyDisplayDismissed(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"AccessKeyDisplayDismissed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AccessKeyDisplayDismissed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_add_AccessKeyDisplayRequested(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"AccessKeyDisplayRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Documents::TextElement, winrt::Microsoft::UI::Xaml::Input::AccessKeyDisplayRequestedEventArgs>>(arg);

            return py::convert(self->obj.AccessKeyDisplayRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_remove_AccessKeyDisplayRequested(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"AccessKeyDisplayRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AccessKeyDisplayRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_add_AccessKeyInvoked(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"AccessKeyInvoked"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Documents::TextElement, winrt::Microsoft::UI::Xaml::Input::AccessKeyInvokedEventArgs>>(arg);

            return py::convert(self->obj.AccessKeyInvoked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_remove_AccessKeyInvoked(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"AccessKeyInvoked"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AccessKeyInvoked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TextElement(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::TextElement>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TextElement(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::TextElement>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TextElement[] = {
        { "find_name", reinterpret_cast<PyCFunction>(TextElement_FindName), METH_VARARGS, nullptr },
        { "on_disconnect_visual_children", reinterpret_cast<PyCFunction>(TextElement_OnDisconnectVisualChildren), METH_VARARGS, nullptr },
        { "add_access_key_display_dismissed", reinterpret_cast<PyCFunction>(TextElement_add_AccessKeyDisplayDismissed), METH_O, nullptr },
        { "remove_access_key_display_dismissed", reinterpret_cast<PyCFunction>(TextElement_remove_AccessKeyDisplayDismissed), METH_O, nullptr },
        { "add_access_key_display_requested", reinterpret_cast<PyCFunction>(TextElement_add_AccessKeyDisplayRequested), METH_O, nullptr },
        { "remove_access_key_display_requested", reinterpret_cast<PyCFunction>(TextElement_remove_AccessKeyDisplayRequested), METH_O, nullptr },
        { "add_access_key_invoked", reinterpret_cast<PyCFunction>(TextElement_add_AccessKeyInvoked), METH_O, nullptr },
        { "remove_access_key_invoked", reinterpret_cast<PyCFunction>(TextElement_remove_AccessKeyInvoked), METH_O, nullptr },
        { "_assign_array_", _assign_array_TextElement, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TextElement), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TextElement[] = {
        { "xaml_root", reinterpret_cast<getter>(TextElement_get_XamlRoot), reinterpret_cast<setter>(TextElement_put_XamlRoot), nullptr, nullptr },
        { "text_decorations", reinterpret_cast<getter>(TextElement_get_TextDecorations), reinterpret_cast<setter>(TextElement_put_TextDecorations), nullptr, nullptr },
        { "language", reinterpret_cast<getter>(TextElement_get_Language), reinterpret_cast<setter>(TextElement_put_Language), nullptr, nullptr },
        { "key_tip_vertical_offset", reinterpret_cast<getter>(TextElement_get_KeyTipVerticalOffset), reinterpret_cast<setter>(TextElement_put_KeyTipVerticalOffset), nullptr, nullptr },
        { "key_tip_placement_mode", reinterpret_cast<getter>(TextElement_get_KeyTipPlacementMode), reinterpret_cast<setter>(TextElement_put_KeyTipPlacementMode), nullptr, nullptr },
        { "key_tip_horizontal_offset", reinterpret_cast<getter>(TextElement_get_KeyTipHorizontalOffset), reinterpret_cast<setter>(TextElement_put_KeyTipHorizontalOffset), nullptr, nullptr },
        { "is_text_scale_factor_enabled", reinterpret_cast<getter>(TextElement_get_IsTextScaleFactorEnabled), reinterpret_cast<setter>(TextElement_put_IsTextScaleFactorEnabled), nullptr, nullptr },
        { "is_access_key_scope", reinterpret_cast<getter>(TextElement_get_IsAccessKeyScope), reinterpret_cast<setter>(TextElement_put_IsAccessKeyScope), nullptr, nullptr },
        { "foreground", reinterpret_cast<getter>(TextElement_get_Foreground), reinterpret_cast<setter>(TextElement_put_Foreground), nullptr, nullptr },
        { "font_weight", reinterpret_cast<getter>(TextElement_get_FontWeight), reinterpret_cast<setter>(TextElement_put_FontWeight), nullptr, nullptr },
        { "font_style", reinterpret_cast<getter>(TextElement_get_FontStyle), reinterpret_cast<setter>(TextElement_put_FontStyle), nullptr, nullptr },
        { "font_stretch", reinterpret_cast<getter>(TextElement_get_FontStretch), reinterpret_cast<setter>(TextElement_put_FontStretch), nullptr, nullptr },
        { "font_size", reinterpret_cast<getter>(TextElement_get_FontSize), reinterpret_cast<setter>(TextElement_put_FontSize), nullptr, nullptr },
        { "font_family", reinterpret_cast<getter>(TextElement_get_FontFamily), reinterpret_cast<setter>(TextElement_put_FontFamily), nullptr, nullptr },
        { "exit_display_mode_on_access_key_invoked", reinterpret_cast<getter>(TextElement_get_ExitDisplayModeOnAccessKeyInvoked), reinterpret_cast<setter>(TextElement_put_ExitDisplayModeOnAccessKeyInvoked), nullptr, nullptr },
        { "character_spacing", reinterpret_cast<getter>(TextElement_get_CharacterSpacing), reinterpret_cast<setter>(TextElement_put_CharacterSpacing), nullptr, nullptr },
        { "allow_focus_on_interaction", reinterpret_cast<getter>(TextElement_get_AllowFocusOnInteraction), reinterpret_cast<setter>(TextElement_put_AllowFocusOnInteraction), nullptr, nullptr },
        { "access_key_scope_owner", reinterpret_cast<getter>(TextElement_get_AccessKeyScopeOwner), reinterpret_cast<setter>(TextElement_put_AccessKeyScopeOwner), nullptr, nullptr },
        { "access_key", reinterpret_cast<getter>(TextElement_get_AccessKey), reinterpret_cast<setter>(TextElement_put_AccessKey), nullptr, nullptr },
        { "content_end", reinterpret_cast<getter>(TextElement_get_ContentEnd), nullptr, nullptr, nullptr },
        { "content_start", reinterpret_cast<getter>(TextElement_get_ContentStart), nullptr, nullptr, nullptr },
        { "element_end", reinterpret_cast<getter>(TextElement_get_ElementEnd), nullptr, nullptr, nullptr },
        { "element_start", reinterpret_cast<getter>(TextElement_get_ElementStart), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(TextElement_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TextElement[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TextElement) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TextElement) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TextElement) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TextElement) },
        { },
    };

    static PyType_Spec type_spec_TextElement =
    {
        "winrt._winrt_microsoft_ui_xaml_documents.TextElement",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Documents::TextElement),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TextElement
    };

    static PyGetSetDef getset_TextElement_Static[] = {
        { "access_key_property", reinterpret_cast<getter>(TextElement_get_AccessKeyProperty), nullptr, nullptr, nullptr },
        { "access_key_scope_owner_property", reinterpret_cast<getter>(TextElement_get_AccessKeyScopeOwnerProperty), nullptr, nullptr, nullptr },
        { "allow_focus_on_interaction_property", reinterpret_cast<getter>(TextElement_get_AllowFocusOnInteractionProperty), nullptr, nullptr, nullptr },
        { "character_spacing_property", reinterpret_cast<getter>(TextElement_get_CharacterSpacingProperty), nullptr, nullptr, nullptr },
        { "exit_display_mode_on_access_key_invoked_property", reinterpret_cast<getter>(TextElement_get_ExitDisplayModeOnAccessKeyInvokedProperty), nullptr, nullptr, nullptr },
        { "font_family_property", reinterpret_cast<getter>(TextElement_get_FontFamilyProperty), nullptr, nullptr, nullptr },
        { "font_size_property", reinterpret_cast<getter>(TextElement_get_FontSizeProperty), nullptr, nullptr, nullptr },
        { "font_stretch_property", reinterpret_cast<getter>(TextElement_get_FontStretchProperty), nullptr, nullptr, nullptr },
        { "font_style_property", reinterpret_cast<getter>(TextElement_get_FontStyleProperty), nullptr, nullptr, nullptr },
        { "font_weight_property", reinterpret_cast<getter>(TextElement_get_FontWeightProperty), nullptr, nullptr, nullptr },
        { "foreground_property", reinterpret_cast<getter>(TextElement_get_ForegroundProperty), nullptr, nullptr, nullptr },
        { "is_access_key_scope_property", reinterpret_cast<getter>(TextElement_get_IsAccessKeyScopeProperty), nullptr, nullptr, nullptr },
        { "is_text_scale_factor_enabled_property", reinterpret_cast<getter>(TextElement_get_IsTextScaleFactorEnabledProperty), nullptr, nullptr, nullptr },
        { "key_tip_horizontal_offset_property", reinterpret_cast<getter>(TextElement_get_KeyTipHorizontalOffsetProperty), nullptr, nullptr, nullptr },
        { "key_tip_placement_mode_property", reinterpret_cast<getter>(TextElement_get_KeyTipPlacementModeProperty), nullptr, nullptr, nullptr },
        { "key_tip_vertical_offset_property", reinterpret_cast<getter>(TextElement_get_KeyTipVerticalOffsetProperty), nullptr, nullptr, nullptr },
        { "language_property", reinterpret_cast<getter>(TextElement_get_LanguageProperty), nullptr, nullptr, nullptr },
        { "text_decorations_property", reinterpret_cast<getter>(TextElement_get_TextDecorationsProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_TextElement_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TextElement_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TextElement_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TextElement_Static) },
        { }
    };

    static PyType_Spec type_spec_TextElement_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_documents.TextElement_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TextElement_Static
    };

    // ----- TextHighlighter class --------------------

    static PyObject* _new_TextHighlighter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Documents::TextHighlighter instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TextHighlighter(py::wrapper::Microsoft::UI::Xaml::Documents::TextHighlighter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TextHighlighter_get_Foreground(py::wrapper::Microsoft::UI::Xaml::Documents::TextHighlighter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextHighlighter", L"Foreground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Foreground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextHighlighter_put_Foreground(py::wrapper::Microsoft::UI::Xaml::Documents::TextHighlighter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextHighlighter", L"Foreground"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.Foreground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextHighlighter_get_Background(py::wrapper::Microsoft::UI::Xaml::Documents::TextHighlighter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextHighlighter", L"Background"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Background());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextHighlighter_put_Background(py::wrapper::Microsoft::UI::Xaml::Documents::TextHighlighter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextHighlighter", L"Background"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            self->obj.Background(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextHighlighter_get_Ranges(py::wrapper::Microsoft::UI::Xaml::Documents::TextHighlighter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextHighlighter", L"Ranges"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Ranges());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextHighlighter_get_BackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextHighlighter", L"BackgroundProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::TextHighlighter::BackgroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextHighlighter_get_ForegroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextHighlighter", L"ForegroundProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::TextHighlighter::ForegroundProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TextHighlighter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::TextHighlighter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TextHighlighter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::TextHighlighter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TextHighlighter[] = {
        { "_assign_array_", _assign_array_TextHighlighter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TextHighlighter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TextHighlighter[] = {
        { "foreground", reinterpret_cast<getter>(TextHighlighter_get_Foreground), reinterpret_cast<setter>(TextHighlighter_put_Foreground), nullptr, nullptr },
        { "background", reinterpret_cast<getter>(TextHighlighter_get_Background), reinterpret_cast<setter>(TextHighlighter_put_Background), nullptr, nullptr },
        { "ranges", reinterpret_cast<getter>(TextHighlighter_get_Ranges), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TextHighlighter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TextHighlighter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TextHighlighter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TextHighlighter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TextHighlighter) },
        { },
    };

    static PyType_Spec type_spec_TextHighlighter =
    {
        "winrt._winrt_microsoft_ui_xaml_documents.TextHighlighter",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Documents::TextHighlighter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TextHighlighter
    };

    static PyGetSetDef getset_TextHighlighter_Static[] = {
        { "background_property", reinterpret_cast<getter>(TextHighlighter_get_BackgroundProperty), nullptr, nullptr, nullptr },
        { "foreground_property", reinterpret_cast<getter>(TextHighlighter_get_ForegroundProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_TextHighlighter_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TextHighlighter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TextHighlighter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TextHighlighter_Static) },
        { }
    };

    static PyType_Spec type_spec_TextHighlighter_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_documents.TextHighlighter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TextHighlighter_Static
    };

    // ----- TextHighlighterBase class --------------------

    static PyObject* _new_TextHighlighterBase(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Documents::TextHighlighterBase>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Documents::TextHighlighterBase>::type_name);
        return nullptr;
    }

    static void _dealloc_TextHighlighterBase(py::wrapper::Microsoft::UI::Xaml::Documents::TextHighlighterBase* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TextHighlighterBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::TextHighlighterBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TextHighlighterBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::TextHighlighterBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TextHighlighterBase[] = {
        { "_assign_array_", _assign_array_TextHighlighterBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TextHighlighterBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TextHighlighterBase[] = {
        { }
    };

    static PyType_Slot _type_slots_TextHighlighterBase[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TextHighlighterBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TextHighlighterBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TextHighlighterBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TextHighlighterBase) },
        { },
    };

    static PyType_Spec type_spec_TextHighlighterBase =
    {
        "winrt._winrt_microsoft_ui_xaml_documents.TextHighlighterBase",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Documents::TextHighlighterBase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TextHighlighterBase
    };

    // ----- TextPointer class --------------------

    static PyObject* _new_TextPointer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Documents::TextPointer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Documents::TextPointer>::type_name);
        return nullptr;
    }

    static void _dealloc_TextPointer(py::wrapper::Microsoft::UI::Xaml::Documents::TextPointer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TextPointer_GetCharacterRect(py::wrapper::Microsoft::UI::Xaml::Documents::TextPointer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.TextPointer", L"GetCharacterRect", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Documents::LogicalDirection>(args, 0);

                return py::convert(self->obj.GetCharacterRect(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TextPointer_GetPositionAtOffset(py::wrapper::Microsoft::UI::Xaml::Documents::TextPointer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.TextPointer", L"GetPositionAtOffset", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Documents::LogicalDirection>(args, 1);

                return py::convert(self->obj.GetPositionAtOffset(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TextPointer_get_LogicalDirection(py::wrapper::Microsoft::UI::Xaml::Documents::TextPointer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextPointer", L"LogicalDirection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LogicalDirection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextPointer_get_Offset(py::wrapper::Microsoft::UI::Xaml::Documents::TextPointer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextPointer", L"Offset"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Offset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextPointer_get_Parent(py::wrapper::Microsoft::UI::Xaml::Documents::TextPointer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextPointer", L"Parent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Parent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextPointer_get_VisualParent(py::wrapper::Microsoft::UI::Xaml::Documents::TextPointer* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextPointer", L"VisualParent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VisualParent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TextPointer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::TextPointer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TextPointer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::TextPointer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TextPointer[] = {
        { "get_character_rect", reinterpret_cast<PyCFunction>(TextPointer_GetCharacterRect), METH_VARARGS, nullptr },
        { "get_position_at_offset", reinterpret_cast<PyCFunction>(TextPointer_GetPositionAtOffset), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TextPointer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TextPointer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TextPointer[] = {
        { "logical_direction", reinterpret_cast<getter>(TextPointer_get_LogicalDirection), nullptr, nullptr, nullptr },
        { "offset", reinterpret_cast<getter>(TextPointer_get_Offset), nullptr, nullptr, nullptr },
        { "parent", reinterpret_cast<getter>(TextPointer_get_Parent), nullptr, nullptr, nullptr },
        { "visual_parent", reinterpret_cast<getter>(TextPointer_get_VisualParent), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TextPointer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TextPointer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TextPointer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TextPointer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TextPointer) },
        { },
    };

    static PyType_Spec type_spec_TextPointer =
    {
        "winrt._winrt_microsoft_ui_xaml_documents.TextPointer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Documents::TextPointer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TextPointer
    };

    // ----- Typography class --------------------

    static PyObject* _new_Typography(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Documents::Typography>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Documents::Typography>::type_name);
        return nullptr;
    }

    static void _dealloc_Typography(py::wrapper::Microsoft::UI::Xaml::Documents::Typography* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Typography_GetAnnotationAlternates(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetAnnotationAlternates", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetAnnotationAlternates(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetCapitalSpacing(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetCapitalSpacing", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetCapitalSpacing(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetCapitals(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetCapitals", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetCapitals(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetCaseSensitiveForms(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetCaseSensitiveForms", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetCaseSensitiveForms(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetContextualAlternates(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetContextualAlternates", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetContextualAlternates(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetContextualLigatures(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetContextualLigatures", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetContextualLigatures(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetContextualSwashes(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetContextualSwashes", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetContextualSwashes(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetDiscretionaryLigatures(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetDiscretionaryLigatures", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetDiscretionaryLigatures(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetEastAsianExpertForms(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetEastAsianExpertForms", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetEastAsianExpertForms(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetEastAsianLanguage(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetEastAsianLanguage", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetEastAsianLanguage(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetEastAsianWidths(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetEastAsianWidths", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetEastAsianWidths(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetFraction(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetFraction", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetFraction(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetHistoricalForms(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetHistoricalForms", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetHistoricalForms(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetHistoricalLigatures(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetHistoricalLigatures", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetHistoricalLigatures(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetKerning(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetKerning", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetKerning(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetMathematicalGreek(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetMathematicalGreek", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetMathematicalGreek(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetNumeralAlignment(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetNumeralAlignment", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetNumeralAlignment(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetNumeralStyle(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetNumeralStyle", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetNumeralStyle(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetSlashedZero(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetSlashedZero", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetSlashedZero(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStandardLigatures(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStandardLigatures", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetStandardLigatures(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStandardSwashes(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStandardSwashes", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetStandardSwashes(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticAlternates(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticAlternates", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticAlternates(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet1(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet1", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet1(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet10(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet10", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet10(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet11(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet11", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet11(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet12(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet12", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet12(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet13(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet13", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet13(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet14(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet14", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet14(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet15(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet15", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet15(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet16(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet16", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet16(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet17(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet17", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet17(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet18(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet18", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet18(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet19(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet19", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet19(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet2(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet2", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet2(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet20(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet20", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet20(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet3(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet3", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet3(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet4(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet4", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet4(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet5(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet5", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet5(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet6(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet6", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet6(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet7(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet7", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet7(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet8(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet8", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet8(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet9(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet9", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet9(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetVariants(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetVariants", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::GetVariants(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetAnnotationAlternates(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetAnnotationAlternates", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetAnnotationAlternates(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetCapitalSpacing(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetCapitalSpacing", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetCapitalSpacing(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetCapitals(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetCapitals", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::FontCapitals>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetCapitals(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetCaseSensitiveForms(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetCaseSensitiveForms", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetCaseSensitiveForms(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetContextualAlternates(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetContextualAlternates", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetContextualAlternates(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetContextualLigatures(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetContextualLigatures", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetContextualLigatures(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetContextualSwashes(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetContextualSwashes", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetContextualSwashes(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetDiscretionaryLigatures(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetDiscretionaryLigatures", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetDiscretionaryLigatures(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetEastAsianExpertForms(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetEastAsianExpertForms", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetEastAsianExpertForms(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetEastAsianLanguage(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetEastAsianLanguage", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::FontEastAsianLanguage>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetEastAsianLanguage(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetEastAsianWidths(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetEastAsianWidths", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::FontEastAsianWidths>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetEastAsianWidths(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetFraction(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetFraction", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::FontFraction>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetFraction(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetHistoricalForms(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetHistoricalForms", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetHistoricalForms(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetHistoricalLigatures(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetHistoricalLigatures", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetHistoricalLigatures(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetKerning(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetKerning", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetKerning(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetMathematicalGreek(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetMathematicalGreek", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetMathematicalGreek(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetNumeralAlignment(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetNumeralAlignment", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::FontNumeralAlignment>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetNumeralAlignment(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetNumeralStyle(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetNumeralStyle", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::FontNumeralStyle>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetNumeralStyle(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetSlashedZero(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetSlashedZero", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetSlashedZero(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStandardLigatures(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStandardLigatures", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetStandardLigatures(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStandardSwashes(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStandardSwashes", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetStandardSwashes(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticAlternates(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticAlternates", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticAlternates(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet1(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet1", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet1(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet10(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet10", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet10(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet11(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet11", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet11(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet12(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet12", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet12(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet13(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet13", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet13(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet14(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet14", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet14(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet15(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet15", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet15(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet16(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet16", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet16(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet17(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet17", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet17(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet18(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet18", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet18(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet19(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet19", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet19(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet2(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet2", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet2(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet20(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet20", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet20(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet3(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet3", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet3(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet4(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet4", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet4(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet5(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet5", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet5(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet6(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet6", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet6(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet7(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet7", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet7(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet8(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet8", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet8(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet9(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet9", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet9(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetVariants(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetVariants", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::FontVariants>(args, 1);

                winrt::Microsoft::UI::Xaml::Documents::Typography::SetVariants(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_get_AnnotationAlternatesProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"AnnotationAlternatesProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::AnnotationAlternatesProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_CapitalSpacingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"CapitalSpacingProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::CapitalSpacingProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_CapitalsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"CapitalsProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::CapitalsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_CaseSensitiveFormsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"CaseSensitiveFormsProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::CaseSensitiveFormsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_ContextualAlternatesProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"ContextualAlternatesProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::ContextualAlternatesProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_ContextualLigaturesProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"ContextualLigaturesProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::ContextualLigaturesProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_ContextualSwashesProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"ContextualSwashesProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::ContextualSwashesProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_DiscretionaryLigaturesProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"DiscretionaryLigaturesProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::DiscretionaryLigaturesProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_EastAsianExpertFormsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"EastAsianExpertFormsProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::EastAsianExpertFormsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_EastAsianLanguageProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"EastAsianLanguageProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::EastAsianLanguageProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_EastAsianWidthsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"EastAsianWidthsProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::EastAsianWidthsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_FractionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"FractionProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::FractionProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_HistoricalFormsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"HistoricalFormsProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::HistoricalFormsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_HistoricalLigaturesProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"HistoricalLigaturesProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::HistoricalLigaturesProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_KerningProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"KerningProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::KerningProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_MathematicalGreekProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"MathematicalGreekProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::MathematicalGreekProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_NumeralAlignmentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"NumeralAlignmentProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::NumeralAlignmentProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_NumeralStyleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"NumeralStyleProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::NumeralStyleProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_SlashedZeroProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SlashedZeroProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::SlashedZeroProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StandardLigaturesProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StandardLigaturesProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::StandardLigaturesProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StandardSwashesProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StandardSwashesProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::StandardSwashesProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticAlternatesProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticAlternatesProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticAlternatesProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet10Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet10Property"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet10Property());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet11Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet11Property"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet11Property());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet12Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet12Property"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet12Property());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet13Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet13Property"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet13Property());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet14Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet14Property"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet14Property());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet15Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet15Property"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet15Property());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet16Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet16Property"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet16Property());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet17Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet17Property"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet17Property());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet18Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet18Property"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet18Property());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet19Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet19Property"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet19Property());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet1Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet1Property"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet1Property());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet20Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet20Property"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet20Property());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet2Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet2Property"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet2Property());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet3Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet3Property"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet3Property());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet4Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet4Property"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet4Property());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet5Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet5Property"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet5Property());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet6Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet6Property"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet6Property());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet7Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet7Property"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet7Property());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet8Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet8Property"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet8Property());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet9Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet9Property"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet9Property());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_VariantsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"VariantsProperty"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::UI::Xaml::Documents::Typography::VariantsProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Typography(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::Typography>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Typography(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::Typography>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Typography[] = {
        { "_assign_array_", _assign_array_Typography, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Typography), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Typography[] = {
        { }
    };

    static PyType_Slot _type_slots_Typography[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Typography) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Typography) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Typography) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Typography) },
        { },
    };

    static PyType_Spec type_spec_Typography =
    {
        "winrt._winrt_microsoft_ui_xaml_documents.Typography",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Documents::Typography),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Typography
    };

    static PyGetSetDef getset_Typography_Static[] = {
        { "annotation_alternates_property", reinterpret_cast<getter>(Typography_get_AnnotationAlternatesProperty), nullptr, nullptr, nullptr },
        { "capital_spacing_property", reinterpret_cast<getter>(Typography_get_CapitalSpacingProperty), nullptr, nullptr, nullptr },
        { "capitals_property", reinterpret_cast<getter>(Typography_get_CapitalsProperty), nullptr, nullptr, nullptr },
        { "case_sensitive_forms_property", reinterpret_cast<getter>(Typography_get_CaseSensitiveFormsProperty), nullptr, nullptr, nullptr },
        { "contextual_alternates_property", reinterpret_cast<getter>(Typography_get_ContextualAlternatesProperty), nullptr, nullptr, nullptr },
        { "contextual_ligatures_property", reinterpret_cast<getter>(Typography_get_ContextualLigaturesProperty), nullptr, nullptr, nullptr },
        { "contextual_swashes_property", reinterpret_cast<getter>(Typography_get_ContextualSwashesProperty), nullptr, nullptr, nullptr },
        { "discretionary_ligatures_property", reinterpret_cast<getter>(Typography_get_DiscretionaryLigaturesProperty), nullptr, nullptr, nullptr },
        { "east_asian_expert_forms_property", reinterpret_cast<getter>(Typography_get_EastAsianExpertFormsProperty), nullptr, nullptr, nullptr },
        { "east_asian_language_property", reinterpret_cast<getter>(Typography_get_EastAsianLanguageProperty), nullptr, nullptr, nullptr },
        { "east_asian_widths_property", reinterpret_cast<getter>(Typography_get_EastAsianWidthsProperty), nullptr, nullptr, nullptr },
        { "fraction_property", reinterpret_cast<getter>(Typography_get_FractionProperty), nullptr, nullptr, nullptr },
        { "historical_forms_property", reinterpret_cast<getter>(Typography_get_HistoricalFormsProperty), nullptr, nullptr, nullptr },
        { "historical_ligatures_property", reinterpret_cast<getter>(Typography_get_HistoricalLigaturesProperty), nullptr, nullptr, nullptr },
        { "kerning_property", reinterpret_cast<getter>(Typography_get_KerningProperty), nullptr, nullptr, nullptr },
        { "mathematical_greek_property", reinterpret_cast<getter>(Typography_get_MathematicalGreekProperty), nullptr, nullptr, nullptr },
        { "numeral_alignment_property", reinterpret_cast<getter>(Typography_get_NumeralAlignmentProperty), nullptr, nullptr, nullptr },
        { "numeral_style_property", reinterpret_cast<getter>(Typography_get_NumeralStyleProperty), nullptr, nullptr, nullptr },
        { "slashed_zero_property", reinterpret_cast<getter>(Typography_get_SlashedZeroProperty), nullptr, nullptr, nullptr },
        { "standard_ligatures_property", reinterpret_cast<getter>(Typography_get_StandardLigaturesProperty), nullptr, nullptr, nullptr },
        { "standard_swashes_property", reinterpret_cast<getter>(Typography_get_StandardSwashesProperty), nullptr, nullptr, nullptr },
        { "stylistic_alternates_property", reinterpret_cast<getter>(Typography_get_StylisticAlternatesProperty), nullptr, nullptr, nullptr },
        { "stylistic_set10_property", reinterpret_cast<getter>(Typography_get_StylisticSet10Property), nullptr, nullptr, nullptr },
        { "stylistic_set11_property", reinterpret_cast<getter>(Typography_get_StylisticSet11Property), nullptr, nullptr, nullptr },
        { "stylistic_set12_property", reinterpret_cast<getter>(Typography_get_StylisticSet12Property), nullptr, nullptr, nullptr },
        { "stylistic_set13_property", reinterpret_cast<getter>(Typography_get_StylisticSet13Property), nullptr, nullptr, nullptr },
        { "stylistic_set14_property", reinterpret_cast<getter>(Typography_get_StylisticSet14Property), nullptr, nullptr, nullptr },
        { "stylistic_set15_property", reinterpret_cast<getter>(Typography_get_StylisticSet15Property), nullptr, nullptr, nullptr },
        { "stylistic_set16_property", reinterpret_cast<getter>(Typography_get_StylisticSet16Property), nullptr, nullptr, nullptr },
        { "stylistic_set17_property", reinterpret_cast<getter>(Typography_get_StylisticSet17Property), nullptr, nullptr, nullptr },
        { "stylistic_set18_property", reinterpret_cast<getter>(Typography_get_StylisticSet18Property), nullptr, nullptr, nullptr },
        { "stylistic_set19_property", reinterpret_cast<getter>(Typography_get_StylisticSet19Property), nullptr, nullptr, nullptr },
        { "stylistic_set1_property", reinterpret_cast<getter>(Typography_get_StylisticSet1Property), nullptr, nullptr, nullptr },
        { "stylistic_set20_property", reinterpret_cast<getter>(Typography_get_StylisticSet20Property), nullptr, nullptr, nullptr },
        { "stylistic_set2_property", reinterpret_cast<getter>(Typography_get_StylisticSet2Property), nullptr, nullptr, nullptr },
        { "stylistic_set3_property", reinterpret_cast<getter>(Typography_get_StylisticSet3Property), nullptr, nullptr, nullptr },
        { "stylistic_set4_property", reinterpret_cast<getter>(Typography_get_StylisticSet4Property), nullptr, nullptr, nullptr },
        { "stylistic_set5_property", reinterpret_cast<getter>(Typography_get_StylisticSet5Property), nullptr, nullptr, nullptr },
        { "stylistic_set6_property", reinterpret_cast<getter>(Typography_get_StylisticSet6Property), nullptr, nullptr, nullptr },
        { "stylistic_set7_property", reinterpret_cast<getter>(Typography_get_StylisticSet7Property), nullptr, nullptr, nullptr },
        { "stylistic_set8_property", reinterpret_cast<getter>(Typography_get_StylisticSet8Property), nullptr, nullptr, nullptr },
        { "stylistic_set9_property", reinterpret_cast<getter>(Typography_get_StylisticSet9Property), nullptr, nullptr, nullptr },
        { "variants_property", reinterpret_cast<getter>(Typography_get_VariantsProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_Typography_Static[] = {
        { "get_annotation_alternates", reinterpret_cast<PyCFunction>(Typography_GetAnnotationAlternates), METH_VARARGS, nullptr },
        { "get_capital_spacing", reinterpret_cast<PyCFunction>(Typography_GetCapitalSpacing), METH_VARARGS, nullptr },
        { "get_capitals", reinterpret_cast<PyCFunction>(Typography_GetCapitals), METH_VARARGS, nullptr },
        { "get_case_sensitive_forms", reinterpret_cast<PyCFunction>(Typography_GetCaseSensitiveForms), METH_VARARGS, nullptr },
        { "get_contextual_alternates", reinterpret_cast<PyCFunction>(Typography_GetContextualAlternates), METH_VARARGS, nullptr },
        { "get_contextual_ligatures", reinterpret_cast<PyCFunction>(Typography_GetContextualLigatures), METH_VARARGS, nullptr },
        { "get_contextual_swashes", reinterpret_cast<PyCFunction>(Typography_GetContextualSwashes), METH_VARARGS, nullptr },
        { "get_discretionary_ligatures", reinterpret_cast<PyCFunction>(Typography_GetDiscretionaryLigatures), METH_VARARGS, nullptr },
        { "get_east_asian_expert_forms", reinterpret_cast<PyCFunction>(Typography_GetEastAsianExpertForms), METH_VARARGS, nullptr },
        { "get_east_asian_language", reinterpret_cast<PyCFunction>(Typography_GetEastAsianLanguage), METH_VARARGS, nullptr },
        { "get_east_asian_widths", reinterpret_cast<PyCFunction>(Typography_GetEastAsianWidths), METH_VARARGS, nullptr },
        { "get_fraction", reinterpret_cast<PyCFunction>(Typography_GetFraction), METH_VARARGS, nullptr },
        { "get_historical_forms", reinterpret_cast<PyCFunction>(Typography_GetHistoricalForms), METH_VARARGS, nullptr },
        { "get_historical_ligatures", reinterpret_cast<PyCFunction>(Typography_GetHistoricalLigatures), METH_VARARGS, nullptr },
        { "get_kerning", reinterpret_cast<PyCFunction>(Typography_GetKerning), METH_VARARGS, nullptr },
        { "get_mathematical_greek", reinterpret_cast<PyCFunction>(Typography_GetMathematicalGreek), METH_VARARGS, nullptr },
        { "get_numeral_alignment", reinterpret_cast<PyCFunction>(Typography_GetNumeralAlignment), METH_VARARGS, nullptr },
        { "get_numeral_style", reinterpret_cast<PyCFunction>(Typography_GetNumeralStyle), METH_VARARGS, nullptr },
        { "get_slashed_zero", reinterpret_cast<PyCFunction>(Typography_GetSlashedZero), METH_VARARGS, nullptr },
        { "get_standard_ligatures", reinterpret_cast<PyCFunction>(Typography_GetStandardLigatures), METH_VARARGS, nullptr },
        { "get_standard_swashes", reinterpret_cast<PyCFunction>(Typography_GetStandardSwashes), METH_VARARGS, nullptr },
        { "get_stylistic_alternates", reinterpret_cast<PyCFunction>(Typography_GetStylisticAlternates), METH_VARARGS, nullptr },
        { "get_stylistic_set1", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet1), METH_VARARGS, nullptr },
        { "get_stylistic_set10", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet10), METH_VARARGS, nullptr },
        { "get_stylistic_set11", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet11), METH_VARARGS, nullptr },
        { "get_stylistic_set12", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet12), METH_VARARGS, nullptr },
        { "get_stylistic_set13", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet13), METH_VARARGS, nullptr },
        { "get_stylistic_set14", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet14), METH_VARARGS, nullptr },
        { "get_stylistic_set15", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet15), METH_VARARGS, nullptr },
        { "get_stylistic_set16", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet16), METH_VARARGS, nullptr },
        { "get_stylistic_set17", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet17), METH_VARARGS, nullptr },
        { "get_stylistic_set18", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet18), METH_VARARGS, nullptr },
        { "get_stylistic_set19", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet19), METH_VARARGS, nullptr },
        { "get_stylistic_set2", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet2), METH_VARARGS, nullptr },
        { "get_stylistic_set20", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet20), METH_VARARGS, nullptr },
        { "get_stylistic_set3", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet3), METH_VARARGS, nullptr },
        { "get_stylistic_set4", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet4), METH_VARARGS, nullptr },
        { "get_stylistic_set5", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet5), METH_VARARGS, nullptr },
        { "get_stylistic_set6", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet6), METH_VARARGS, nullptr },
        { "get_stylistic_set7", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet7), METH_VARARGS, nullptr },
        { "get_stylistic_set8", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet8), METH_VARARGS, nullptr },
        { "get_stylistic_set9", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet9), METH_VARARGS, nullptr },
        { "get_variants", reinterpret_cast<PyCFunction>(Typography_GetVariants), METH_VARARGS, nullptr },
        { "set_annotation_alternates", reinterpret_cast<PyCFunction>(Typography_SetAnnotationAlternates), METH_VARARGS, nullptr },
        { "set_capital_spacing", reinterpret_cast<PyCFunction>(Typography_SetCapitalSpacing), METH_VARARGS, nullptr },
        { "set_capitals", reinterpret_cast<PyCFunction>(Typography_SetCapitals), METH_VARARGS, nullptr },
        { "set_case_sensitive_forms", reinterpret_cast<PyCFunction>(Typography_SetCaseSensitiveForms), METH_VARARGS, nullptr },
        { "set_contextual_alternates", reinterpret_cast<PyCFunction>(Typography_SetContextualAlternates), METH_VARARGS, nullptr },
        { "set_contextual_ligatures", reinterpret_cast<PyCFunction>(Typography_SetContextualLigatures), METH_VARARGS, nullptr },
        { "set_contextual_swashes", reinterpret_cast<PyCFunction>(Typography_SetContextualSwashes), METH_VARARGS, nullptr },
        { "set_discretionary_ligatures", reinterpret_cast<PyCFunction>(Typography_SetDiscretionaryLigatures), METH_VARARGS, nullptr },
        { "set_east_asian_expert_forms", reinterpret_cast<PyCFunction>(Typography_SetEastAsianExpertForms), METH_VARARGS, nullptr },
        { "set_east_asian_language", reinterpret_cast<PyCFunction>(Typography_SetEastAsianLanguage), METH_VARARGS, nullptr },
        { "set_east_asian_widths", reinterpret_cast<PyCFunction>(Typography_SetEastAsianWidths), METH_VARARGS, nullptr },
        { "set_fraction", reinterpret_cast<PyCFunction>(Typography_SetFraction), METH_VARARGS, nullptr },
        { "set_historical_forms", reinterpret_cast<PyCFunction>(Typography_SetHistoricalForms), METH_VARARGS, nullptr },
        { "set_historical_ligatures", reinterpret_cast<PyCFunction>(Typography_SetHistoricalLigatures), METH_VARARGS, nullptr },
        { "set_kerning", reinterpret_cast<PyCFunction>(Typography_SetKerning), METH_VARARGS, nullptr },
        { "set_mathematical_greek", reinterpret_cast<PyCFunction>(Typography_SetMathematicalGreek), METH_VARARGS, nullptr },
        { "set_numeral_alignment", reinterpret_cast<PyCFunction>(Typography_SetNumeralAlignment), METH_VARARGS, nullptr },
        { "set_numeral_style", reinterpret_cast<PyCFunction>(Typography_SetNumeralStyle), METH_VARARGS, nullptr },
        { "set_slashed_zero", reinterpret_cast<PyCFunction>(Typography_SetSlashedZero), METH_VARARGS, nullptr },
        { "set_standard_ligatures", reinterpret_cast<PyCFunction>(Typography_SetStandardLigatures), METH_VARARGS, nullptr },
        { "set_standard_swashes", reinterpret_cast<PyCFunction>(Typography_SetStandardSwashes), METH_VARARGS, nullptr },
        { "set_stylistic_alternates", reinterpret_cast<PyCFunction>(Typography_SetStylisticAlternates), METH_VARARGS, nullptr },
        { "set_stylistic_set1", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet1), METH_VARARGS, nullptr },
        { "set_stylistic_set10", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet10), METH_VARARGS, nullptr },
        { "set_stylistic_set11", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet11), METH_VARARGS, nullptr },
        { "set_stylistic_set12", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet12), METH_VARARGS, nullptr },
        { "set_stylistic_set13", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet13), METH_VARARGS, nullptr },
        { "set_stylistic_set14", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet14), METH_VARARGS, nullptr },
        { "set_stylistic_set15", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet15), METH_VARARGS, nullptr },
        { "set_stylistic_set16", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet16), METH_VARARGS, nullptr },
        { "set_stylistic_set17", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet17), METH_VARARGS, nullptr },
        { "set_stylistic_set18", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet18), METH_VARARGS, nullptr },
        { "set_stylistic_set19", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet19), METH_VARARGS, nullptr },
        { "set_stylistic_set2", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet2), METH_VARARGS, nullptr },
        { "set_stylistic_set20", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet20), METH_VARARGS, nullptr },
        { "set_stylistic_set3", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet3), METH_VARARGS, nullptr },
        { "set_stylistic_set4", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet4), METH_VARARGS, nullptr },
        { "set_stylistic_set5", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet5), METH_VARARGS, nullptr },
        { "set_stylistic_set6", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet6), METH_VARARGS, nullptr },
        { "set_stylistic_set7", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet7), METH_VARARGS, nullptr },
        { "set_stylistic_set8", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet8), METH_VARARGS, nullptr },
        { "set_stylistic_set9", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet9), METH_VARARGS, nullptr },
        { "set_variants", reinterpret_cast<PyCFunction>(Typography_SetVariants), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_Typography_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Typography_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Typography_Static) },
        { }
    };

    static PyType_Spec type_spec_Typography_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_documents.Typography_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Typography_Static
    };

    // ----- Underline class --------------------

    static PyObject* _new_Underline(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Documents::Underline instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Underline(py::wrapper::Microsoft::UI::Xaml::Documents::Underline* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Underline(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::Underline>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Underline(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::Underline>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Underline[] = {
        { "_assign_array_", _assign_array_Underline, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Underline), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Underline[] = {
        { }
    };

    static PyType_Slot _type_slots_Underline[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_Underline) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Underline) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Underline) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Underline) },
        { },
    };

    static PyType_Spec type_spec_Underline =
    {
        "winrt._winrt_microsoft_ui_xaml_documents.Underline",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Documents::Underline),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Underline
    };

    // ----- TextRange struct --------------------

    winrt_struct_wrapper<winrt::Microsoft::UI::Xaml::Documents::TextRange>* _new_TextRange(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Microsoft::UI::Xaml::Documents::TextRange>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_TextRange(winrt_struct_wrapper<winrt::Microsoft::UI::Xaml::Documents::TextRange>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        int32_t _StartIndex{};
        int32_t _Length{};

        static const char* kwlist[] = {"start_index", "length", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ii", const_cast<char**>(kwlist), &_StartIndex, &_Length))
        {
            return -1;
        }

        try
        {
            self->obj = {_StartIndex, _Length};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_TextRange(py::wrapper::Microsoft::UI::Xaml::Documents::TextRange* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TextRange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::TextRange>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_TextRange[] = {
        { "_assign_array_", _assign_array_TextRange, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* TextRange_get_StartIndex(py::wrapper::Microsoft::UI::Xaml::Documents::TextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartIndex);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextRange_set_StartIndex(py::wrapper::Microsoft::UI::Xaml::Documents::TextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.StartIndex = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextRange_get_Length(py::wrapper::Microsoft::UI::Xaml::Documents::TextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Length);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextRange_set_Length(py::wrapper::Microsoft::UI::Xaml::Documents::TextRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Length = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_TextRange[] = {
        { "start_index", reinterpret_cast<getter>(TextRange_get_StartIndex), reinterpret_cast<setter>(TextRange_set_StartIndex), nullptr, nullptr },
        { "length", reinterpret_cast<getter>(TextRange_get_Length), reinterpret_cast<setter>(TextRange_set_Length), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TextRange[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TextRange) },
        { Py_tp_init, reinterpret_cast<void*>(_init_TextRange) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TextRange) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TextRange) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TextRange) },
        { },
    };

    static PyType_Spec type_spec_TextRange =
    {
        "winrt._winrt_microsoft_ui_xaml_documents.TextRange",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Documents::TextRange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TextRange
    };

    // ----- Microsoft.UI.Xaml.Documents Initialization --------------------
    PyDoc_STRVAR(module_doc, "Microsoft::UI::Xaml::Documents");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_microsoft_ui_xaml_documents",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Microsoft::UI::Xaml::Documents

PyMODINIT_FUNC PyInit__winrt_microsoft_ui_xaml_documents(void) noexcept
{
    using namespace py::cpp::Microsoft::UI::Xaml::Documents;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Block_Static{PyType_FromSpec(&type_spec_Block_Static)};
    if (!type_Block_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Block, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Block_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BlockCollection, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Bold, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_Glyphs_Static{PyType_FromSpec(&type_spec_Glyphs_Static)};
    if (!type_Glyphs_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Glyphs, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Glyphs_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_Hyperlink_Static{PyType_FromSpec(&type_spec_Hyperlink_Static)};
    if (!type_Hyperlink_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Hyperlink, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Hyperlink_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HyperlinkClickEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Inline, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InlineCollection, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InlineUIContainer, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Italic, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LineBreak, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_Paragraph_Static{PyType_FromSpec(&type_spec_Paragraph_Static)};
    if (!type_Paragraph_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Paragraph, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Paragraph_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_Run_Static{PyType_FromSpec(&type_spec_Run_Static)};
    if (!type_Run_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Run, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Run_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Span, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_TextElement_Static{PyType_FromSpec(&type_spec_TextElement_Static)};
    if (!type_TextElement_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TextElement, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TextElement_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_TextHighlighter_Static{PyType_FromSpec(&type_spec_TextHighlighter_Static)};
    if (!type_TextHighlighter_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TextHighlighter, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TextHighlighter_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TextHighlighterBase, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TextPointer, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_Typography_Static{PyType_FromSpec(&type_spec_Typography_Static)};
    if (!type_Typography_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Typography, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Typography_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_Underline, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TextRange, nullptr, nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
