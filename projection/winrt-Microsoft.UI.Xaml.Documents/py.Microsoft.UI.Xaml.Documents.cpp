// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Microsoft.UI.Xaml.Documents.h"

namespace py::cpp::Microsoft::UI::Xaml::Documents
{
    // ----- Block class --------------------

    struct PyWinrtBlock;
    using BasePyWinrtBlock = winrt::Microsoft::UI::Xaml::Documents::BlockT<PyWinrtBlock, py::IPywinrtObject>;

    struct PyWinrtBlock : py::py_obj_ref, BasePyWinrtBlock
    {

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtBlock* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_Block(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Documents::Block>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Documents::Block>::type_name);
        return nullptr;
    }

    static void _dealloc_Block(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Block_get_TextAlignment(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Block", L"TextAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::Block>().TextAlignment();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Block_put_TextAlignment(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Block", L"TextAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::TextAlignment>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::Block>().TextAlignment(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Block_get_Margin(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Block", L"Margin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::Block>().Margin();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Block_put_Margin(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Block", L"Margin");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Thickness>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::Block>().Margin(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Block_get_LineStackingStrategy(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Block", L"LineStackingStrategy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::Block>().LineStackingStrategy();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Block_put_LineStackingStrategy(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Block", L"LineStackingStrategy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::LineStackingStrategy>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::Block>().LineStackingStrategy(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Block_get_LineHeight(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Block", L"LineHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::Block>().LineHeight();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Block_put_LineHeight(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Block", L"LineHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::Block>().LineHeight(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Block_get_HorizontalTextAlignment(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Block", L"HorizontalTextAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::Block>().HorizontalTextAlignment();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Block_put_HorizontalTextAlignment(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Block", L"HorizontalTextAlignment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::TextAlignment>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::Block>().HorizontalTextAlignment(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Block_get_HorizontalTextAlignmentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Block", L"HorizontalTextAlignmentProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Block::HorizontalTextAlignmentProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Block_get_LineHeightProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Block", L"LineHeightProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Block::LineHeightProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Block_get_LineStackingStrategyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Block", L"LineStackingStrategyProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Block::LineStackingStrategyProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Block_get_MarginProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Block", L"MarginProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Block::MarginProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Block_get_TextAlignmentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Block", L"TextAlignmentProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Block::TextAlignmentProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Block(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::Block>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Block(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::Block>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Block[] = {
        { "_assign_array_", _assign_array_Block, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Block), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Block[] = {
        { "text_alignment", reinterpret_cast<getter>(Block_get_TextAlignment), reinterpret_cast<setter>(Block_put_TextAlignment), nullptr, nullptr },
        { "margin", reinterpret_cast<getter>(Block_get_Margin), reinterpret_cast<setter>(Block_put_Margin), nullptr, nullptr },
        { "line_stacking_strategy", reinterpret_cast<getter>(Block_get_LineStackingStrategy), reinterpret_cast<setter>(Block_put_LineStackingStrategy), nullptr, nullptr },
        { "line_height", reinterpret_cast<getter>(Block_get_LineHeight), reinterpret_cast<setter>(Block_put_LineHeight), nullptr, nullptr },
        { "horizontal_text_alignment", reinterpret_cast<getter>(Block_get_HorizontalTextAlignment), reinterpret_cast<setter>(Block_put_HorizontalTextAlignment), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Block[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Block) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Block) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Block) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Block) },
        { }};

    static PyType_Spec type_spec_Block = {
        "winrt._winrt_microsoft_ui_xaml_documents.Block",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_Block};

    static PyGetSetDef getset_Block_Static[] = {
        { "horizontal_text_alignment_property", reinterpret_cast<getter>(Block_get_HorizontalTextAlignmentProperty), nullptr, nullptr, nullptr },
        { "line_height_property", reinterpret_cast<getter>(Block_get_LineHeightProperty), nullptr, nullptr, nullptr },
        { "line_stacking_strategy_property", reinterpret_cast<getter>(Block_get_LineStackingStrategyProperty), nullptr, nullptr, nullptr },
        { "margin_property", reinterpret_cast<getter>(Block_get_MarginProperty), nullptr, nullptr, nullptr },
        { "text_alignment_property", reinterpret_cast<getter>(Block_get_TextAlignmentProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_Block_Static[] = {
        { }};

    static PyType_Slot type_slots_Block_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Block_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Block_Static) },
        { }
    };

    static PyType_Spec type_spec_Block_Static = {
        "winrt._winrt_microsoft_ui_xaml_documents.Block_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_Block_Static};

    // ----- BlockCollection class --------------------

    static PyObject* _new_BlockCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Documents::BlockCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Documents::BlockCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_BlockCollection(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BlockCollection_Append(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.BlockCollection", L"Append", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Documents::Block>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.Append(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BlockCollection_Clear(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.BlockCollection", L"Clear", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Clear();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BlockCollection_First(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.BlockCollection", L"First", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.First();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BlockCollection_GetAt(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.BlockCollection", L"GetAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetAt(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BlockCollection_GetMany(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.BlockCollection", L"GetMany", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Microsoft::UI::Xaml::Documents::Block, true>>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetMany(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BlockCollection_GetView(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.BlockCollection", L"GetView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetView();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BlockCollection_IndexOf(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.BlockCollection", L"IndexOf", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Documents::Block>(args, 0);
                uint32_t param1{};

                auto return_value = [&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IndexOf(param0, param1);
                }();

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }

                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BlockCollection_InsertAt(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.BlockCollection", L"InsertAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Documents::Block>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.InsertAt(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BlockCollection_RemoveAt(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.BlockCollection", L"RemoveAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.RemoveAt(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BlockCollection_RemoveAtEnd(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.BlockCollection", L"RemoveAtEnd", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.RemoveAtEnd();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BlockCollection_ReplaceAll(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.BlockCollection", L"ReplaceAll", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Microsoft::UI::Xaml::Documents::Block, false>>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.ReplaceAll(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BlockCollection_SetAt(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.BlockCollection", L"SetAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Documents::Block>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.SetAt(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BlockCollection_get_Size(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.BlockCollection", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Size();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BlockCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::BlockCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BlockCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::BlockCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_BlockCollection(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection* self) noexcept
    {
        try
        {
            return py::convert([&]()
            {
                auto _gil = py::release_gil();
                return self->obj.First();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_BlockCollection(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection* self) noexcept
    {
        try
        {
            auto _gil = py::release_gil();
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_BlockCollection(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert([&]()
            {
                auto _gil = py::release_gil();
                return self->obj.GetAt(static_cast<uint32_t>(i));
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_BlockCollection(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_BlockCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(PyExc_TypeError, "indices must be integers, not '%s'", Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            auto size = [&]()
            {
                auto _gil = py::release_gil();
                return self->obj.Size();
            }();
            if (PySlice_GetIndicesEx(slice, size, &start, &stop, &step, &length) < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(PyExc_NotImplementedError, "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Microsoft::UI::Xaml::Documents::Block> items(static_cast<uint32_t>(length), empty_instance<winrt::Microsoft::UI::Xaml::Documents::Block>::get());

            auto count = [&]()
            {
                auto _gil = py::release_gil();
                return self->obj.GetMany(static_cast<uint32_t>(start), items);
            }();

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(PyExc_RuntimeError, "returned count %d did not match requested length %zd", count, length);
                return nullptr;
            }

            return convert(items);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_BlockCollection(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (!value)
            {
                auto _gil = py::release_gil();
                self->obj.RemoveAt(static_cast<uint32_t>(i));
            }
            else
            {
                auto _value = py::convert_to<winrt::Microsoft::UI::Xaml::Documents::Block>(value);
                {
                    auto _gil = py::release_gil();
                    self->obj.SetAt(static_cast<uint32_t>(i), _value);
                }
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_BlockCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(BlockCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(BlockCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(BlockCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(BlockCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(BlockCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(BlockCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(BlockCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(BlockCollection_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(BlockCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(BlockCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(BlockCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(BlockCollection_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BlockCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BlockCollection), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_BlockCollection[] = {
        { "size", reinterpret_cast<getter>(BlockCollection_get_Size), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_BlockCollection[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BlockCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BlockCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BlockCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BlockCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_BlockCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_BlockCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_BlockCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_BlockCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_BlockCollection) },
        { }};

    static PyType_Spec type_spec_BlockCollection = {
        "winrt._winrt_microsoft_ui_xaml_documents.BlockCollection",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Documents::BlockCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BlockCollection};

    // ----- Bold class --------------------

    static PyObject* _new_Bold(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Documents::Bold instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Bold(py::wrapper::Microsoft::UI::Xaml::Documents::Bold* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Bold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::Bold>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Bold(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::Bold>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Bold[] = {
        { "_assign_array_", _assign_array_Bold, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Bold), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Bold[] = {
        { }};

    static PyType_Slot _type_slots_Bold[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Bold) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Bold) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Bold) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Bold) },
        { }};

    static PyType_Spec type_spec_Bold = {
        "winrt._winrt_microsoft_ui_xaml_documents.Bold",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Documents::Bold),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Bold};

    // ----- Glyphs class --------------------

    static PyObject* _new_Glyphs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Documents::Glyphs instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Glyphs(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Glyphs_get_UnicodeString(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"UnicodeString");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UnicodeString();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Glyphs_put_UnicodeString(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"UnicodeString");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.UnicodeString(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Glyphs_get_StyleSimulations(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"StyleSimulations");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.StyleSimulations();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Glyphs_put_StyleSimulations(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"StyleSimulations");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::StyleSimulations>(arg);

            {
                auto _gil = release_gil();
                self->obj.StyleSimulations(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Glyphs_get_OriginY(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"OriginY");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OriginY();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Glyphs_put_OriginY(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"OriginY");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.OriginY(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Glyphs_get_OriginX(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"OriginX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OriginX();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Glyphs_put_OriginX(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"OriginX");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.OriginX(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Glyphs_get_IsColorFontEnabled(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"IsColorFontEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsColorFontEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Glyphs_put_IsColorFontEnabled(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"IsColorFontEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsColorFontEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Glyphs_get_Indices(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"Indices");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Indices();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Glyphs_put_Indices(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"Indices");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Indices(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Glyphs_get_FontUri(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"FontUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FontUri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Glyphs_put_FontUri(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"FontUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            {
                auto _gil = release_gil();
                self->obj.FontUri(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Glyphs_get_FontRenderingEmSize(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"FontRenderingEmSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FontRenderingEmSize();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Glyphs_put_FontRenderingEmSize(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"FontRenderingEmSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.FontRenderingEmSize(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Glyphs_get_Fill(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"Fill");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Fill();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Glyphs_put_Fill(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"Fill");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.Fill(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Glyphs_get_ColorFontPaletteIndex(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"ColorFontPaletteIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ColorFontPaletteIndex();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Glyphs_put_ColorFontPaletteIndex(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"ColorFontPaletteIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.ColorFontPaletteIndex(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Glyphs_get_ColorFontPaletteIndexProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"ColorFontPaletteIndexProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Glyphs::ColorFontPaletteIndexProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Glyphs_get_FillProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"FillProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Glyphs::FillProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Glyphs_get_FontRenderingEmSizeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"FontRenderingEmSizeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Glyphs::FontRenderingEmSizeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Glyphs_get_FontUriProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"FontUriProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Glyphs::FontUriProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Glyphs_get_IndicesProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"IndicesProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Glyphs::IndicesProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Glyphs_get_IsColorFontEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"IsColorFontEnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Glyphs::IsColorFontEnabledProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Glyphs_get_OriginXProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"OriginXProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Glyphs::OriginXProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Glyphs_get_OriginYProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"OriginYProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Glyphs::OriginYProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Glyphs_get_StyleSimulationsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"StyleSimulationsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Glyphs::StyleSimulationsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Glyphs_get_UnicodeStringProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Glyphs", L"UnicodeStringProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Glyphs::UnicodeStringProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Glyphs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::Glyphs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Glyphs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::Glyphs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Glyphs[] = {
        { "_assign_array_", _assign_array_Glyphs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Glyphs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Glyphs[] = {
        { "unicode_string", reinterpret_cast<getter>(Glyphs_get_UnicodeString), reinterpret_cast<setter>(Glyphs_put_UnicodeString), nullptr, nullptr },
        { "style_simulations", reinterpret_cast<getter>(Glyphs_get_StyleSimulations), reinterpret_cast<setter>(Glyphs_put_StyleSimulations), nullptr, nullptr },
        { "origin_y", reinterpret_cast<getter>(Glyphs_get_OriginY), reinterpret_cast<setter>(Glyphs_put_OriginY), nullptr, nullptr },
        { "origin_x", reinterpret_cast<getter>(Glyphs_get_OriginX), reinterpret_cast<setter>(Glyphs_put_OriginX), nullptr, nullptr },
        { "is_color_font_enabled", reinterpret_cast<getter>(Glyphs_get_IsColorFontEnabled), reinterpret_cast<setter>(Glyphs_put_IsColorFontEnabled), nullptr, nullptr },
        { "indices", reinterpret_cast<getter>(Glyphs_get_Indices), reinterpret_cast<setter>(Glyphs_put_Indices), nullptr, nullptr },
        { "font_uri", reinterpret_cast<getter>(Glyphs_get_FontUri), reinterpret_cast<setter>(Glyphs_put_FontUri), nullptr, nullptr },
        { "font_rendering_em_size", reinterpret_cast<getter>(Glyphs_get_FontRenderingEmSize), reinterpret_cast<setter>(Glyphs_put_FontRenderingEmSize), nullptr, nullptr },
        { "fill", reinterpret_cast<getter>(Glyphs_get_Fill), reinterpret_cast<setter>(Glyphs_put_Fill), nullptr, nullptr },
        { "color_font_palette_index", reinterpret_cast<getter>(Glyphs_get_ColorFontPaletteIndex), reinterpret_cast<setter>(Glyphs_put_ColorFontPaletteIndex), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Glyphs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Glyphs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Glyphs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Glyphs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Glyphs) },
        { }};

    static PyType_Spec type_spec_Glyphs = {
        "winrt._winrt_microsoft_ui_xaml_documents.Glyphs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Documents::Glyphs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Glyphs};

    static PyGetSetDef getset_Glyphs_Static[] = {
        { "color_font_palette_index_property", reinterpret_cast<getter>(Glyphs_get_ColorFontPaletteIndexProperty), nullptr, nullptr, nullptr },
        { "fill_property", reinterpret_cast<getter>(Glyphs_get_FillProperty), nullptr, nullptr, nullptr },
        { "font_rendering_em_size_property", reinterpret_cast<getter>(Glyphs_get_FontRenderingEmSizeProperty), nullptr, nullptr, nullptr },
        { "font_uri_property", reinterpret_cast<getter>(Glyphs_get_FontUriProperty), nullptr, nullptr, nullptr },
        { "indices_property", reinterpret_cast<getter>(Glyphs_get_IndicesProperty), nullptr, nullptr, nullptr },
        { "is_color_font_enabled_property", reinterpret_cast<getter>(Glyphs_get_IsColorFontEnabledProperty), nullptr, nullptr, nullptr },
        { "origin_x_property", reinterpret_cast<getter>(Glyphs_get_OriginXProperty), nullptr, nullptr, nullptr },
        { "origin_y_property", reinterpret_cast<getter>(Glyphs_get_OriginYProperty), nullptr, nullptr, nullptr },
        { "style_simulations_property", reinterpret_cast<getter>(Glyphs_get_StyleSimulationsProperty), nullptr, nullptr, nullptr },
        { "unicode_string_property", reinterpret_cast<getter>(Glyphs_get_UnicodeStringProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_Glyphs_Static[] = {
        { }};

    static PyType_Slot type_slots_Glyphs_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Glyphs_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Glyphs_Static) },
        { }
    };

    static PyType_Spec type_spec_Glyphs_Static = {
        "winrt._winrt_microsoft_ui_xaml_documents.Glyphs_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Glyphs_Static};

    // ----- Hyperlink class --------------------

    static PyObject* _new_Hyperlink(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Documents::Hyperlink instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Hyperlink(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Hyperlink_Focus(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"Focus", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::FocusState>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Focus(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Hyperlink_get_XYFocusUpNavigationStrategy(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusUpNavigationStrategy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.XYFocusUpNavigationStrategy();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Hyperlink_put_XYFocusUpNavigationStrategy(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusUpNavigationStrategy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Input::XYFocusNavigationStrategy>(arg);

            {
                auto _gil = release_gil();
                self->obj.XYFocusUpNavigationStrategy(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Hyperlink_get_XYFocusUp(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusUp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.XYFocusUp();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Hyperlink_put_XYFocusUp(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusUp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(arg);

            {
                auto _gil = release_gil();
                self->obj.XYFocusUp(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Hyperlink_get_XYFocusRightNavigationStrategy(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusRightNavigationStrategy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.XYFocusRightNavigationStrategy();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Hyperlink_put_XYFocusRightNavigationStrategy(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusRightNavigationStrategy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Input::XYFocusNavigationStrategy>(arg);

            {
                auto _gil = release_gil();
                self->obj.XYFocusRightNavigationStrategy(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Hyperlink_get_XYFocusRight(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusRight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.XYFocusRight();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Hyperlink_put_XYFocusRight(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusRight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(arg);

            {
                auto _gil = release_gil();
                self->obj.XYFocusRight(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Hyperlink_get_XYFocusLeftNavigationStrategy(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusLeftNavigationStrategy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.XYFocusLeftNavigationStrategy();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Hyperlink_put_XYFocusLeftNavigationStrategy(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusLeftNavigationStrategy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Input::XYFocusNavigationStrategy>(arg);

            {
                auto _gil = release_gil();
                self->obj.XYFocusLeftNavigationStrategy(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Hyperlink_get_XYFocusLeft(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusLeft");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.XYFocusLeft();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Hyperlink_put_XYFocusLeft(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusLeft");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(arg);

            {
                auto _gil = release_gil();
                self->obj.XYFocusLeft(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Hyperlink_get_XYFocusDownNavigationStrategy(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusDownNavigationStrategy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.XYFocusDownNavigationStrategy();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Hyperlink_put_XYFocusDownNavigationStrategy(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusDownNavigationStrategy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Input::XYFocusNavigationStrategy>(arg);

            {
                auto _gil = release_gil();
                self->obj.XYFocusDownNavigationStrategy(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Hyperlink_get_XYFocusDown(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusDown");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.XYFocusDown();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Hyperlink_put_XYFocusDown(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusDown");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(arg);

            {
                auto _gil = release_gil();
                self->obj.XYFocusDown(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Hyperlink_get_UnderlineStyle(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"UnderlineStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UnderlineStyle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Hyperlink_put_UnderlineStyle(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"UnderlineStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Documents::UnderlineStyle>(arg);

            {
                auto _gil = release_gil();
                self->obj.UnderlineStyle(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Hyperlink_get_TabIndex(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"TabIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TabIndex();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Hyperlink_put_TabIndex(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"TabIndex");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.TabIndex(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Hyperlink_get_NavigateUri(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"NavigateUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.NavigateUri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Hyperlink_put_NavigateUri(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"NavigateUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            {
                auto _gil = release_gil();
                self->obj.NavigateUri(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Hyperlink_get_IsTabStop(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"IsTabStop");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsTabStop();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Hyperlink_put_IsTabStop(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"IsTabStop");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsTabStop(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Hyperlink_get_ElementSoundMode(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"ElementSoundMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ElementSoundMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Hyperlink_put_ElementSoundMode(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"ElementSoundMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::ElementSoundMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.ElementSoundMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Hyperlink_get_FocusState(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"FocusState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FocusState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_get_ElementSoundModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"ElementSoundModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Hyperlink::ElementSoundModeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_get_FocusStateProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"FocusStateProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Hyperlink::FocusStateProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_get_IsTabStopProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"IsTabStopProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Hyperlink::IsTabStopProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_get_NavigateUriProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"NavigateUriProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Hyperlink::NavigateUriProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_get_TabIndexProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"TabIndexProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Hyperlink::TabIndexProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_get_UnderlineStyleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"UnderlineStyleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Hyperlink::UnderlineStyleProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_get_XYFocusDownNavigationStrategyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusDownNavigationStrategyProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Hyperlink::XYFocusDownNavigationStrategyProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_get_XYFocusDownProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusDownProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Hyperlink::XYFocusDownProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_get_XYFocusLeftNavigationStrategyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusLeftNavigationStrategyProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Hyperlink::XYFocusLeftNavigationStrategyProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_get_XYFocusLeftProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusLeftProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Hyperlink::XYFocusLeftProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_get_XYFocusRightNavigationStrategyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusRightNavigationStrategyProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Hyperlink::XYFocusRightNavigationStrategyProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_get_XYFocusRightProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusRightProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Hyperlink::XYFocusRightProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_get_XYFocusUpNavigationStrategyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusUpNavigationStrategyProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Hyperlink::XYFocusUpNavigationStrategyProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_get_XYFocusUpProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"XYFocusUpProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Hyperlink::XYFocusUpProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_add_Click(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"Click");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Documents::Hyperlink, winrt::Microsoft::UI::Xaml::Documents::HyperlinkClickEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Click(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_remove_Click(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"Click");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.Click(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_add_GotFocus(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"GotFocus");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::RoutedEventHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.GotFocus(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_remove_GotFocus(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"GotFocus");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.GotFocus(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_add_LostFocus(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"LostFocus");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::RoutedEventHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LostFocus(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Hyperlink_remove_LostFocus(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Documents.Hyperlink", L"LostFocus");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.LostFocus(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Hyperlink(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::Hyperlink>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Hyperlink(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::Hyperlink>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Hyperlink[] = {
        { "focus", reinterpret_cast<PyCFunction>(Hyperlink_Focus), METH_VARARGS, nullptr },
        { "add_click", reinterpret_cast<PyCFunction>(Hyperlink_add_Click), METH_O, nullptr },
        { "remove_click", reinterpret_cast<PyCFunction>(Hyperlink_remove_Click), METH_O, nullptr },
        { "add_got_focus", reinterpret_cast<PyCFunction>(Hyperlink_add_GotFocus), METH_O, nullptr },
        { "remove_got_focus", reinterpret_cast<PyCFunction>(Hyperlink_remove_GotFocus), METH_O, nullptr },
        { "add_lost_focus", reinterpret_cast<PyCFunction>(Hyperlink_add_LostFocus), METH_O, nullptr },
        { "remove_lost_focus", reinterpret_cast<PyCFunction>(Hyperlink_remove_LostFocus), METH_O, nullptr },
        { "_assign_array_", _assign_array_Hyperlink, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Hyperlink), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Hyperlink[] = {
        { "x_y_focus_up_navigation_strategy", reinterpret_cast<getter>(Hyperlink_get_XYFocusUpNavigationStrategy), reinterpret_cast<setter>(Hyperlink_put_XYFocusUpNavigationStrategy), nullptr, nullptr },
        { "x_y_focus_up", reinterpret_cast<getter>(Hyperlink_get_XYFocusUp), reinterpret_cast<setter>(Hyperlink_put_XYFocusUp), nullptr, nullptr },
        { "x_y_focus_right_navigation_strategy", reinterpret_cast<getter>(Hyperlink_get_XYFocusRightNavigationStrategy), reinterpret_cast<setter>(Hyperlink_put_XYFocusRightNavigationStrategy), nullptr, nullptr },
        { "x_y_focus_right", reinterpret_cast<getter>(Hyperlink_get_XYFocusRight), reinterpret_cast<setter>(Hyperlink_put_XYFocusRight), nullptr, nullptr },
        { "x_y_focus_left_navigation_strategy", reinterpret_cast<getter>(Hyperlink_get_XYFocusLeftNavigationStrategy), reinterpret_cast<setter>(Hyperlink_put_XYFocusLeftNavigationStrategy), nullptr, nullptr },
        { "x_y_focus_left", reinterpret_cast<getter>(Hyperlink_get_XYFocusLeft), reinterpret_cast<setter>(Hyperlink_put_XYFocusLeft), nullptr, nullptr },
        { "x_y_focus_down_navigation_strategy", reinterpret_cast<getter>(Hyperlink_get_XYFocusDownNavigationStrategy), reinterpret_cast<setter>(Hyperlink_put_XYFocusDownNavigationStrategy), nullptr, nullptr },
        { "x_y_focus_down", reinterpret_cast<getter>(Hyperlink_get_XYFocusDown), reinterpret_cast<setter>(Hyperlink_put_XYFocusDown), nullptr, nullptr },
        { "underline_style", reinterpret_cast<getter>(Hyperlink_get_UnderlineStyle), reinterpret_cast<setter>(Hyperlink_put_UnderlineStyle), nullptr, nullptr },
        { "tab_index", reinterpret_cast<getter>(Hyperlink_get_TabIndex), reinterpret_cast<setter>(Hyperlink_put_TabIndex), nullptr, nullptr },
        { "navigate_uri", reinterpret_cast<getter>(Hyperlink_get_NavigateUri), reinterpret_cast<setter>(Hyperlink_put_NavigateUri), nullptr, nullptr },
        { "is_tab_stop", reinterpret_cast<getter>(Hyperlink_get_IsTabStop), reinterpret_cast<setter>(Hyperlink_put_IsTabStop), nullptr, nullptr },
        { "element_sound_mode", reinterpret_cast<getter>(Hyperlink_get_ElementSoundMode), reinterpret_cast<setter>(Hyperlink_put_ElementSoundMode), nullptr, nullptr },
        { "focus_state", reinterpret_cast<getter>(Hyperlink_get_FocusState), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Hyperlink[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Hyperlink) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Hyperlink) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Hyperlink) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Hyperlink) },
        { }};

    static PyType_Spec type_spec_Hyperlink = {
        "winrt._winrt_microsoft_ui_xaml_documents.Hyperlink",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Documents::Hyperlink),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Hyperlink};

    static PyGetSetDef getset_Hyperlink_Static[] = {
        { "element_sound_mode_property", reinterpret_cast<getter>(Hyperlink_get_ElementSoundModeProperty), nullptr, nullptr, nullptr },
        { "focus_state_property", reinterpret_cast<getter>(Hyperlink_get_FocusStateProperty), nullptr, nullptr, nullptr },
        { "is_tab_stop_property", reinterpret_cast<getter>(Hyperlink_get_IsTabStopProperty), nullptr, nullptr, nullptr },
        { "navigate_uri_property", reinterpret_cast<getter>(Hyperlink_get_NavigateUriProperty), nullptr, nullptr, nullptr },
        { "tab_index_property", reinterpret_cast<getter>(Hyperlink_get_TabIndexProperty), nullptr, nullptr, nullptr },
        { "underline_style_property", reinterpret_cast<getter>(Hyperlink_get_UnderlineStyleProperty), nullptr, nullptr, nullptr },
        { "x_y_focus_down_navigation_strategy_property", reinterpret_cast<getter>(Hyperlink_get_XYFocusDownNavigationStrategyProperty), nullptr, nullptr, nullptr },
        { "x_y_focus_down_property", reinterpret_cast<getter>(Hyperlink_get_XYFocusDownProperty), nullptr, nullptr, nullptr },
        { "x_y_focus_left_navigation_strategy_property", reinterpret_cast<getter>(Hyperlink_get_XYFocusLeftNavigationStrategyProperty), nullptr, nullptr, nullptr },
        { "x_y_focus_left_property", reinterpret_cast<getter>(Hyperlink_get_XYFocusLeftProperty), nullptr, nullptr, nullptr },
        { "x_y_focus_right_navigation_strategy_property", reinterpret_cast<getter>(Hyperlink_get_XYFocusRightNavigationStrategyProperty), nullptr, nullptr, nullptr },
        { "x_y_focus_right_property", reinterpret_cast<getter>(Hyperlink_get_XYFocusRightProperty), nullptr, nullptr, nullptr },
        { "x_y_focus_up_navigation_strategy_property", reinterpret_cast<getter>(Hyperlink_get_XYFocusUpNavigationStrategyProperty), nullptr, nullptr, nullptr },
        { "x_y_focus_up_property", reinterpret_cast<getter>(Hyperlink_get_XYFocusUpProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_Hyperlink_Static[] = {
        { }};

    static PyType_Slot type_slots_Hyperlink_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Hyperlink_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Hyperlink_Static) },
        { }
    };

    static PyType_Spec type_spec_Hyperlink_Static = {
        "winrt._winrt_microsoft_ui_xaml_documents.Hyperlink_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Hyperlink_Static};

    // ----- HyperlinkClickEventArgs class --------------------

    static PyObject* _new_HyperlinkClickEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Documents::HyperlinkClickEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Documents::HyperlinkClickEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_HyperlinkClickEventArgs(py::wrapper::Microsoft::UI::Xaml::Documents::HyperlinkClickEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_HyperlinkClickEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::HyperlinkClickEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HyperlinkClickEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::HyperlinkClickEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HyperlinkClickEventArgs[] = {
        { "_assign_array_", _assign_array_HyperlinkClickEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HyperlinkClickEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_HyperlinkClickEventArgs[] = {
        { }};

    static PyType_Slot _type_slots_HyperlinkClickEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_HyperlinkClickEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HyperlinkClickEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HyperlinkClickEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HyperlinkClickEventArgs) },
        { }};

    static PyType_Spec type_spec_HyperlinkClickEventArgs = {
        "winrt._winrt_microsoft_ui_xaml_documents.HyperlinkClickEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Documents::HyperlinkClickEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HyperlinkClickEventArgs};

    // ----- Inline class --------------------

    struct PyWinrtInline;
    using BasePyWinrtInline = winrt::Microsoft::UI::Xaml::Documents::InlineT<PyWinrtInline, py::IPywinrtObject>;

    struct PyWinrtInline : py::py_obj_ref, BasePyWinrtInline
    {

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtInline* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_Inline(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Documents::Inline>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Documents::Inline>::type_name);
        return nullptr;
    }

    static void _dealloc_Inline(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Inline(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::Inline>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Inline(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::Inline>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Inline[] = {
        { "_assign_array_", _assign_array_Inline, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Inline), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Inline[] = {
        { }};

    static PyType_Slot _type_slots_Inline[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Inline) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Inline) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Inline) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Inline) },
        { }};

    static PyType_Spec type_spec_Inline = {
        "winrt._winrt_microsoft_ui_xaml_documents.Inline",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_Inline};

    static PyGetSetDef getset_Inline_Static[] = {
        { }};

    static PyMethodDef methods_Inline_Static[] = {
        { }};

    static PyType_Slot type_slots_Inline_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Inline_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Inline_Static) },
        { }
    };

    static PyType_Spec type_spec_Inline_Static = {
        "winrt._winrt_microsoft_ui_xaml_documents.Inline_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_Inline_Static};

    // ----- InlineCollection class --------------------

    static PyObject* _new_InlineCollection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Documents::InlineCollection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Documents::InlineCollection>::type_name);
        return nullptr;
    }

    static void _dealloc_InlineCollection(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InlineCollection_Append(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.InlineCollection", L"Append", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Documents::Inline>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.Append(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InlineCollection_Clear(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.InlineCollection", L"Clear", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Clear();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InlineCollection_First(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.InlineCollection", L"First", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.First();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InlineCollection_GetAt(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.InlineCollection", L"GetAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetAt(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InlineCollection_GetMany(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.InlineCollection", L"GetMany", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Microsoft::UI::Xaml::Documents::Inline, true>>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetMany(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InlineCollection_GetView(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.InlineCollection", L"GetView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetView();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InlineCollection_IndexOf(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.InlineCollection", L"IndexOf", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Documents::Inline>(args, 0);
                uint32_t param1{};

                auto return_value = [&]()
                {
                    auto _gil = release_gil();
                    return self->obj.IndexOf(param0, param1);
                }();

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }

                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InlineCollection_InsertAt(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.InlineCollection", L"InsertAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Documents::Inline>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.InsertAt(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InlineCollection_RemoveAt(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.InlineCollection", L"RemoveAt", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.RemoveAt(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InlineCollection_RemoveAtEnd(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.InlineCollection", L"RemoveAtEnd", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.RemoveAtEnd();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InlineCollection_ReplaceAll(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.InlineCollection", L"ReplaceAll", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Microsoft::UI::Xaml::Documents::Inline, false>>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.ReplaceAll(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InlineCollection_SetAt(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.InlineCollection", L"SetAt", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Documents::Inline>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.SetAt(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InlineCollection_get_Size(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.InlineCollection", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Size();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_InlineCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::InlineCollection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InlineCollection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::InlineCollection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_InlineCollection(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection* self) noexcept
    {
        try
        {
            return py::convert([&]()
            {
                auto _gil = py::release_gil();
                return self->obj.First();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_InlineCollection(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection* self) noexcept
    {
        try
        {
            auto _gil = py::release_gil();
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_InlineCollection(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert([&]()
            {
                auto _gil = py::release_gil();
                return self->obj.GetAt(static_cast<uint32_t>(i));
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _seq_subscript_InlineCollection(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection* self, PyObject* slice) noexcept
    {
        try
        {
            if (PyIndex_Check(slice))
            {
                pyobj_handle index{PyNumber_Index(slice)};

                if (!index)
                {
                    return nullptr;
                }

                auto i = PyNumber_AsSsize_t(index.get(), PyExc_IndexError);

                if (i == -1 && PyErr_Occurred())
                {
                    return nullptr;
                }

                return _seq_item_InlineCollection(self, i);
            }

            if (!PySlice_Check(slice))
            {
                PyErr_Format(PyExc_TypeError, "indices must be integers, not '%s'", Py_TYPE(slice)->tp_name);
            }

            Py_ssize_t start, stop, step, length;

            auto size = [&]()
            {
                auto _gil = py::release_gil();
                return self->obj.Size();
            }();
            if (PySlice_GetIndicesEx(slice, size, &start, &stop, &step, &length) < 0)
            {
                return nullptr;
            }

            if (step != 1)
            {
                PyErr_SetString(PyExc_NotImplementedError, "slices with step other than 1 are not implemented");
                return nullptr;
            }

            winrt::com_array<winrt::Microsoft::UI::Xaml::Documents::Inline> items(static_cast<uint32_t>(length), empty_instance<winrt::Microsoft::UI::Xaml::Documents::Inline>::get());

            auto count = [&]()
            {
                auto _gil = py::release_gil();
                return self->obj.GetMany(static_cast<uint32_t>(start), items);
            }();

            if (count != static_cast<uint32_t>(length))
            {
                PyErr_Format(PyExc_RuntimeError, "returned count %d did not match requested length %zd", count, length);
                return nullptr;
            }

            return convert(items);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _seq_assign_InlineCollection(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection* self, Py_ssize_t i, PyObject* value) noexcept
    {
        try
        {
            if (!value)
            {
                auto _gil = py::release_gil();
                self->obj.RemoveAt(static_cast<uint32_t>(i));
            }
            else
            {
                auto _value = py::convert_to<winrt::Microsoft::UI::Xaml::Documents::Inline>(value);
                {
                    auto _gil = py::release_gil();
                    self->obj.SetAt(static_cast<uint32_t>(i), _value);
                }
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_InlineCollection[] = {
        { "append", reinterpret_cast<PyCFunction>(InlineCollection_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(InlineCollection_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(InlineCollection_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(InlineCollection_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(InlineCollection_GetMany), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(InlineCollection_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(InlineCollection_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(InlineCollection_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(InlineCollection_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(InlineCollection_RemoveAtEnd), METH_VARARGS, nullptr },
        { "replace_all", reinterpret_cast<PyCFunction>(InlineCollection_ReplaceAll), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(InlineCollection_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_InlineCollection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InlineCollection), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InlineCollection[] = {
        { "size", reinterpret_cast<getter>(InlineCollection_get_Size), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_InlineCollection[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InlineCollection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InlineCollection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InlineCollection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InlineCollection) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_InlineCollection) },
        { Py_sq_length, reinterpret_cast<void*>(_seq_length_InlineCollection) },
        { Py_sq_item, reinterpret_cast<void*>(_seq_item_InlineCollection) },
        { Py_mp_subscript, reinterpret_cast<void*>(_seq_subscript_InlineCollection) },
        { Py_sq_ass_item, reinterpret_cast<void*>(_seq_assign_InlineCollection) },
        { }};

    static PyType_Spec type_spec_InlineCollection = {
        "winrt._winrt_microsoft_ui_xaml_documents.InlineCollection",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Documents::InlineCollection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InlineCollection};

    // ----- InlineUIContainer class --------------------

    static PyObject* _new_InlineUIContainer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Documents::InlineUIContainer instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InlineUIContainer(py::wrapper::Microsoft::UI::Xaml::Documents::InlineUIContainer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InlineUIContainer_get_Child(py::wrapper::Microsoft::UI::Xaml::Documents::InlineUIContainer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.InlineUIContainer", L"Child");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Child();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InlineUIContainer_put_Child(py::wrapper::Microsoft::UI::Xaml::Documents::InlineUIContainer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.InlineUIContainer", L"Child");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(arg);

            {
                auto _gil = release_gil();
                self->obj.Child(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_InlineUIContainer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::InlineUIContainer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InlineUIContainer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::InlineUIContainer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InlineUIContainer[] = {
        { "_assign_array_", _assign_array_InlineUIContainer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InlineUIContainer), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_InlineUIContainer[] = {
        { "child", reinterpret_cast<getter>(InlineUIContainer_get_Child), reinterpret_cast<setter>(InlineUIContainer_put_Child), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_InlineUIContainer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InlineUIContainer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InlineUIContainer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InlineUIContainer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InlineUIContainer) },
        { }};

    static PyType_Spec type_spec_InlineUIContainer = {
        "winrt._winrt_microsoft_ui_xaml_documents.InlineUIContainer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Documents::InlineUIContainer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InlineUIContainer};

    // ----- Italic class --------------------

    static PyObject* _new_Italic(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Documents::Italic instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Italic(py::wrapper::Microsoft::UI::Xaml::Documents::Italic* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Italic(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::Italic>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Italic(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::Italic>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Italic[] = {
        { "_assign_array_", _assign_array_Italic, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Italic), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Italic[] = {
        { }};

    static PyType_Slot _type_slots_Italic[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Italic) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Italic) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Italic) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Italic) },
        { }};

    static PyType_Spec type_spec_Italic = {
        "winrt._winrt_microsoft_ui_xaml_documents.Italic",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Documents::Italic),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Italic};

    // ----- LineBreak class --------------------

    static PyObject* _new_LineBreak(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Documents::LineBreak instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LineBreak(py::wrapper::Microsoft::UI::Xaml::Documents::LineBreak* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_LineBreak(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::LineBreak>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LineBreak(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::LineBreak>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineBreak[] = {
        { "_assign_array_", _assign_array_LineBreak, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LineBreak), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_LineBreak[] = {
        { }};

    static PyType_Slot _type_slots_LineBreak[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LineBreak) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LineBreak) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LineBreak) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LineBreak) },
        { }};

    static PyType_Spec type_spec_LineBreak = {
        "winrt._winrt_microsoft_ui_xaml_documents.LineBreak",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Documents::LineBreak),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineBreak};

    // ----- Paragraph class --------------------

    static PyObject* _new_Paragraph(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Documents::Paragraph instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Paragraph(py::wrapper::Microsoft::UI::Xaml::Documents::Paragraph* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Paragraph_get_TextIndent(py::wrapper::Microsoft::UI::Xaml::Documents::Paragraph* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Paragraph", L"TextIndent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TextIndent();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Paragraph_put_TextIndent(py::wrapper::Microsoft::UI::Xaml::Documents::Paragraph* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Paragraph", L"TextIndent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.TextIndent(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Paragraph_get_Inlines(py::wrapper::Microsoft::UI::Xaml::Documents::Paragraph* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Paragraph", L"Inlines");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Inlines();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Paragraph_get_TextIndentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Paragraph", L"TextIndentProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Paragraph::TextIndentProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Paragraph(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::Paragraph>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Paragraph(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::Paragraph>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Paragraph[] = {
        { "_assign_array_", _assign_array_Paragraph, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Paragraph), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Paragraph[] = {
        { "text_indent", reinterpret_cast<getter>(Paragraph_get_TextIndent), reinterpret_cast<setter>(Paragraph_put_TextIndent), nullptr, nullptr },
        { "inlines", reinterpret_cast<getter>(Paragraph_get_Inlines), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Paragraph[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Paragraph) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Paragraph) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Paragraph) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Paragraph) },
        { }};

    static PyType_Spec type_spec_Paragraph = {
        "winrt._winrt_microsoft_ui_xaml_documents.Paragraph",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Documents::Paragraph),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Paragraph};

    static PyGetSetDef getset_Paragraph_Static[] = {
        { "text_indent_property", reinterpret_cast<getter>(Paragraph_get_TextIndentProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_Paragraph_Static[] = {
        { }};

    static PyType_Slot type_slots_Paragraph_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Paragraph_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Paragraph_Static) },
        { }
    };

    static PyType_Spec type_spec_Paragraph_Static = {
        "winrt._winrt_microsoft_ui_xaml_documents.Paragraph_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Paragraph_Static};

    // ----- Run class --------------------

    static PyObject* _new_Run(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Documents::Run instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Run(py::wrapper::Microsoft::UI::Xaml::Documents::Run* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Run_get_Text(py::wrapper::Microsoft::UI::Xaml::Documents::Run* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Run", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Text();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Run_put_Text(py::wrapper::Microsoft::UI::Xaml::Documents::Run* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Run", L"Text");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Text(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Run_get_FlowDirection(py::wrapper::Microsoft::UI::Xaml::Documents::Run* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Run", L"FlowDirection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FlowDirection();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Run_put_FlowDirection(py::wrapper::Microsoft::UI::Xaml::Documents::Run* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Run", L"FlowDirection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::FlowDirection>(arg);

            {
                auto _gil = release_gil();
                self->obj.FlowDirection(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Run_get_FlowDirectionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Run", L"FlowDirectionProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Run::FlowDirectionProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Run(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::Run>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Run(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::Run>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Run[] = {
        { "_assign_array_", _assign_array_Run, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Run), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Run[] = {
        { "text", reinterpret_cast<getter>(Run_get_Text), reinterpret_cast<setter>(Run_put_Text), nullptr, nullptr },
        { "flow_direction", reinterpret_cast<getter>(Run_get_FlowDirection), reinterpret_cast<setter>(Run_put_FlowDirection), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Run[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Run) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Run) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Run) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Run) },
        { }};

    static PyType_Spec type_spec_Run = {
        "winrt._winrt_microsoft_ui_xaml_documents.Run",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Documents::Run),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Run};

    static PyGetSetDef getset_Run_Static[] = {
        { "flow_direction_property", reinterpret_cast<getter>(Run_get_FlowDirectionProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_Run_Static[] = {
        { }};

    static PyType_Slot type_slots_Run_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Run_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Run_Static) },
        { }
    };

    static PyType_Spec type_spec_Run_Static = {
        "winrt._winrt_microsoft_ui_xaml_documents.Run_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Run_Static};

    // ----- Span class --------------------

    struct PyWinrtSpan;
    using BasePyWinrtSpan = winrt::Microsoft::UI::Xaml::Documents::SpanT<PyWinrtSpan, py::IPywinrtObject>;

    struct PyWinrtSpan : py::py_obj_ref, BasePyWinrtSpan
    {
        PyWinrtSpan(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtSpan() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtSpan* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_Span(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Documents::Span>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtSpan>(self.get());

                    auto obj = py::make_py_obj<PyWinrtSpan>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Documents::Span instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Span(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Span_get_Inlines(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Span", L"Inlines");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::Span>().Inlines();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Span_put_Inlines(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Span", L"Inlines");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Documents::InlineCollection>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::Span>().Inlines(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_Span(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::Span>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Span(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::Span>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Span[] = {
        { "_assign_array_", _assign_array_Span, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Span), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Span[] = {
        { "inlines", reinterpret_cast<getter>(Span_get_Inlines), reinterpret_cast<setter>(Span_put_Inlines), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_Span[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Span) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Span) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Span) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Span) },
        { }};

    static PyType_Spec type_spec_Span = {
        "winrt._winrt_microsoft_ui_xaml_documents.Span",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_Span};

    static PyGetSetDef getset_Span_Static[] = {
        { }};

    static PyMethodDef methods_Span_Static[] = {
        { }};

    static PyType_Slot type_slots_Span_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Span_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Span_Static) },
        { }
    };

    static PyType_Spec type_spec_Span_Static = {
        "winrt._winrt_microsoft_ui_xaml_documents.Span_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_Span_Static};

    // ----- TextElement class --------------------

    static PyObject* _new_TextElement(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Documents::TextElement>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Documents::TextElement>::type_name);
        return nullptr;
    }

    static void _dealloc_TextElement(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TextElement_FindName(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"FindName", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().FindName(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TextElement_OnDisconnectVisualChildren(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"OnDisconnectVisualChildren", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    py::get_inner_or_self(self->obj).try_as<winrt::Microsoft::UI::Xaml::Documents::ITextElementOverrides>().OnDisconnectVisualChildren();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TextElement_get_XamlRoot(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"XamlRoot");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().XamlRoot();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextElement_put_XamlRoot(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"XamlRoot");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::XamlRoot>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().XamlRoot(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextElement_get_TextDecorations(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"TextDecorations");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().TextDecorations();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextElement_put_TextDecorations(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"TextDecorations");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::TextDecorations>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().TextDecorations(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextElement_get_Language(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"Language");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().Language();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextElement_put_Language(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"Language");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().Language(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextElement_get_KeyTipVerticalOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"KeyTipVerticalOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().KeyTipVerticalOffset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextElement_put_KeyTipVerticalOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"KeyTipVerticalOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().KeyTipVerticalOffset(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextElement_get_KeyTipPlacementMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"KeyTipPlacementMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().KeyTipPlacementMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextElement_put_KeyTipPlacementMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"KeyTipPlacementMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Input::KeyTipPlacementMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().KeyTipPlacementMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextElement_get_KeyTipHorizontalOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"KeyTipHorizontalOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().KeyTipHorizontalOffset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextElement_put_KeyTipHorizontalOffset(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"KeyTipHorizontalOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().KeyTipHorizontalOffset(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextElement_get_IsTextScaleFactorEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"IsTextScaleFactorEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().IsTextScaleFactorEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextElement_put_IsTextScaleFactorEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"IsTextScaleFactorEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().IsTextScaleFactorEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextElement_get_IsAccessKeyScope(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"IsAccessKeyScope");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().IsAccessKeyScope();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextElement_put_IsAccessKeyScope(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"IsAccessKeyScope");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().IsAccessKeyScope(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextElement_get_Foreground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"Foreground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().Foreground();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextElement_put_Foreground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"Foreground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().Foreground(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextElement_get_FontWeight(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"FontWeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().FontWeight();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextElement_put_FontWeight(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"FontWeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::FontWeight>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().FontWeight(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextElement_get_FontStyle(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"FontStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().FontStyle();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextElement_put_FontStyle(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"FontStyle");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::FontStyle>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().FontStyle(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextElement_get_FontStretch(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"FontStretch");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().FontStretch();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextElement_put_FontStretch(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"FontStretch");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Text::FontStretch>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().FontStretch(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextElement_get_FontSize(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"FontSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().FontSize();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextElement_put_FontSize(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"FontSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().FontSize(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextElement_get_FontFamily(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"FontFamily");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().FontFamily();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextElement_put_FontFamily(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"FontFamily");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::FontFamily>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().FontFamily(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextElement_get_ExitDisplayModeOnAccessKeyInvoked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"ExitDisplayModeOnAccessKeyInvoked");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().ExitDisplayModeOnAccessKeyInvoked();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextElement_put_ExitDisplayModeOnAccessKeyInvoked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"ExitDisplayModeOnAccessKeyInvoked");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().ExitDisplayModeOnAccessKeyInvoked(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextElement_get_CharacterSpacing(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"CharacterSpacing");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().CharacterSpacing();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextElement_put_CharacterSpacing(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"CharacterSpacing");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().CharacterSpacing(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextElement_get_AllowFocusOnInteraction(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"AllowFocusOnInteraction");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().AllowFocusOnInteraction();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextElement_put_AllowFocusOnInteraction(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"AllowFocusOnInteraction");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().AllowFocusOnInteraction(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextElement_get_AccessKeyScopeOwner(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"AccessKeyScopeOwner");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().AccessKeyScopeOwner();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextElement_put_AccessKeyScopeOwner(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"AccessKeyScopeOwner");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().AccessKeyScopeOwner(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextElement_get_AccessKey(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"AccessKey");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().AccessKey();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextElement_put_AccessKey(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"AccessKey");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().AccessKey(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextElement_get_ContentEnd(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"ContentEnd");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().ContentEnd();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_ContentStart(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"ContentStart");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().ContentStart();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_ElementEnd(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"ElementEnd");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().ElementEnd();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_ElementStart(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"ElementStart");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().ElementStart();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_Name(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().Name();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_AccessKeyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"AccessKeyProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::TextElement::AccessKeyProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_AccessKeyScopeOwnerProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"AccessKeyScopeOwnerProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::TextElement::AccessKeyScopeOwnerProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_AllowFocusOnInteractionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"AllowFocusOnInteractionProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::TextElement::AllowFocusOnInteractionProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_CharacterSpacingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"CharacterSpacingProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::TextElement::CharacterSpacingProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_ExitDisplayModeOnAccessKeyInvokedProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"ExitDisplayModeOnAccessKeyInvokedProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::TextElement::ExitDisplayModeOnAccessKeyInvokedProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_FontFamilyProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"FontFamilyProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::TextElement::FontFamilyProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_FontSizeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"FontSizeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::TextElement::FontSizeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_FontStretchProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"FontStretchProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::TextElement::FontStretchProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_FontStyleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"FontStyleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::TextElement::FontStyleProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_FontWeightProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"FontWeightProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::TextElement::FontWeightProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_ForegroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"ForegroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::TextElement::ForegroundProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_IsAccessKeyScopeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"IsAccessKeyScopeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::TextElement::IsAccessKeyScopeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_IsTextScaleFactorEnabledProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"IsTextScaleFactorEnabledProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::TextElement::IsTextScaleFactorEnabledProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_KeyTipHorizontalOffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"KeyTipHorizontalOffsetProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::TextElement::KeyTipHorizontalOffsetProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_KeyTipPlacementModeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"KeyTipPlacementModeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::TextElement::KeyTipPlacementModeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_KeyTipVerticalOffsetProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"KeyTipVerticalOffsetProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::TextElement::KeyTipVerticalOffsetProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_LanguageProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"LanguageProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::TextElement::LanguageProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_get_TextDecorationsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"TextDecorationsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::TextElement::TextDecorationsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_add_AccessKeyDisplayDismissed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"AccessKeyDisplayDismissed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Documents::TextElement, winrt::Microsoft::UI::Xaml::Input::AccessKeyDisplayDismissedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().AccessKeyDisplayDismissed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_remove_AccessKeyDisplayDismissed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"AccessKeyDisplayDismissed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().AccessKeyDisplayDismissed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_add_AccessKeyDisplayRequested(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"AccessKeyDisplayRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Documents::TextElement, winrt::Microsoft::UI::Xaml::Input::AccessKeyDisplayRequestedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().AccessKeyDisplayRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_remove_AccessKeyDisplayRequested(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"AccessKeyDisplayRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().AccessKeyDisplayRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_add_AccessKeyInvoked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"AccessKeyInvoked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Documents::TextElement, winrt::Microsoft::UI::Xaml::Input::AccessKeyInvokedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().AccessKeyInvoked(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextElement_remove_AccessKeyInvoked(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Documents.TextElement", L"AccessKeyInvoked");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextElement>().AccessKeyInvoked(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TextElement(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::TextElement>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TextElement(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::TextElement>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TextElement[] = {
        { "find_name", reinterpret_cast<PyCFunction>(TextElement_FindName), METH_VARARGS, nullptr },
        { "_on_disconnect_visual_children", reinterpret_cast<PyCFunction>(TextElement_OnDisconnectVisualChildren), METH_VARARGS, nullptr },
        { "add_access_key_display_dismissed", reinterpret_cast<PyCFunction>(TextElement_add_AccessKeyDisplayDismissed), METH_O, nullptr },
        { "remove_access_key_display_dismissed", reinterpret_cast<PyCFunction>(TextElement_remove_AccessKeyDisplayDismissed), METH_O, nullptr },
        { "add_access_key_display_requested", reinterpret_cast<PyCFunction>(TextElement_add_AccessKeyDisplayRequested), METH_O, nullptr },
        { "remove_access_key_display_requested", reinterpret_cast<PyCFunction>(TextElement_remove_AccessKeyDisplayRequested), METH_O, nullptr },
        { "add_access_key_invoked", reinterpret_cast<PyCFunction>(TextElement_add_AccessKeyInvoked), METH_O, nullptr },
        { "remove_access_key_invoked", reinterpret_cast<PyCFunction>(TextElement_remove_AccessKeyInvoked), METH_O, nullptr },
        { "_assign_array_", _assign_array_TextElement, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TextElement), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TextElement[] = {
        { "xaml_root", reinterpret_cast<getter>(TextElement_get_XamlRoot), reinterpret_cast<setter>(TextElement_put_XamlRoot), nullptr, nullptr },
        { "text_decorations", reinterpret_cast<getter>(TextElement_get_TextDecorations), reinterpret_cast<setter>(TextElement_put_TextDecorations), nullptr, nullptr },
        { "language", reinterpret_cast<getter>(TextElement_get_Language), reinterpret_cast<setter>(TextElement_put_Language), nullptr, nullptr },
        { "key_tip_vertical_offset", reinterpret_cast<getter>(TextElement_get_KeyTipVerticalOffset), reinterpret_cast<setter>(TextElement_put_KeyTipVerticalOffset), nullptr, nullptr },
        { "key_tip_placement_mode", reinterpret_cast<getter>(TextElement_get_KeyTipPlacementMode), reinterpret_cast<setter>(TextElement_put_KeyTipPlacementMode), nullptr, nullptr },
        { "key_tip_horizontal_offset", reinterpret_cast<getter>(TextElement_get_KeyTipHorizontalOffset), reinterpret_cast<setter>(TextElement_put_KeyTipHorizontalOffset), nullptr, nullptr },
        { "is_text_scale_factor_enabled", reinterpret_cast<getter>(TextElement_get_IsTextScaleFactorEnabled), reinterpret_cast<setter>(TextElement_put_IsTextScaleFactorEnabled), nullptr, nullptr },
        { "is_access_key_scope", reinterpret_cast<getter>(TextElement_get_IsAccessKeyScope), reinterpret_cast<setter>(TextElement_put_IsAccessKeyScope), nullptr, nullptr },
        { "foreground", reinterpret_cast<getter>(TextElement_get_Foreground), reinterpret_cast<setter>(TextElement_put_Foreground), nullptr, nullptr },
        { "font_weight", reinterpret_cast<getter>(TextElement_get_FontWeight), reinterpret_cast<setter>(TextElement_put_FontWeight), nullptr, nullptr },
        { "font_style", reinterpret_cast<getter>(TextElement_get_FontStyle), reinterpret_cast<setter>(TextElement_put_FontStyle), nullptr, nullptr },
        { "font_stretch", reinterpret_cast<getter>(TextElement_get_FontStretch), reinterpret_cast<setter>(TextElement_put_FontStretch), nullptr, nullptr },
        { "font_size", reinterpret_cast<getter>(TextElement_get_FontSize), reinterpret_cast<setter>(TextElement_put_FontSize), nullptr, nullptr },
        { "font_family", reinterpret_cast<getter>(TextElement_get_FontFamily), reinterpret_cast<setter>(TextElement_put_FontFamily), nullptr, nullptr },
        { "exit_display_mode_on_access_key_invoked", reinterpret_cast<getter>(TextElement_get_ExitDisplayModeOnAccessKeyInvoked), reinterpret_cast<setter>(TextElement_put_ExitDisplayModeOnAccessKeyInvoked), nullptr, nullptr },
        { "character_spacing", reinterpret_cast<getter>(TextElement_get_CharacterSpacing), reinterpret_cast<setter>(TextElement_put_CharacterSpacing), nullptr, nullptr },
        { "allow_focus_on_interaction", reinterpret_cast<getter>(TextElement_get_AllowFocusOnInteraction), reinterpret_cast<setter>(TextElement_put_AllowFocusOnInteraction), nullptr, nullptr },
        { "access_key_scope_owner", reinterpret_cast<getter>(TextElement_get_AccessKeyScopeOwner), reinterpret_cast<setter>(TextElement_put_AccessKeyScopeOwner), nullptr, nullptr },
        { "access_key", reinterpret_cast<getter>(TextElement_get_AccessKey), reinterpret_cast<setter>(TextElement_put_AccessKey), nullptr, nullptr },
        { "content_end", reinterpret_cast<getter>(TextElement_get_ContentEnd), nullptr, nullptr, nullptr },
        { "content_start", reinterpret_cast<getter>(TextElement_get_ContentStart), nullptr, nullptr, nullptr },
        { "element_end", reinterpret_cast<getter>(TextElement_get_ElementEnd), nullptr, nullptr, nullptr },
        { "element_start", reinterpret_cast<getter>(TextElement_get_ElementStart), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(TextElement_get_Name), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TextElement[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TextElement) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TextElement) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TextElement) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TextElement) },
        { }};

    static PyType_Spec type_spec_TextElement = {
        "winrt._winrt_microsoft_ui_xaml_documents.TextElement",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_TextElement};

    static PyGetSetDef getset_TextElement_Static[] = {
        { "access_key_property", reinterpret_cast<getter>(TextElement_get_AccessKeyProperty), nullptr, nullptr, nullptr },
        { "access_key_scope_owner_property", reinterpret_cast<getter>(TextElement_get_AccessKeyScopeOwnerProperty), nullptr, nullptr, nullptr },
        { "allow_focus_on_interaction_property", reinterpret_cast<getter>(TextElement_get_AllowFocusOnInteractionProperty), nullptr, nullptr, nullptr },
        { "character_spacing_property", reinterpret_cast<getter>(TextElement_get_CharacterSpacingProperty), nullptr, nullptr, nullptr },
        { "exit_display_mode_on_access_key_invoked_property", reinterpret_cast<getter>(TextElement_get_ExitDisplayModeOnAccessKeyInvokedProperty), nullptr, nullptr, nullptr },
        { "font_family_property", reinterpret_cast<getter>(TextElement_get_FontFamilyProperty), nullptr, nullptr, nullptr },
        { "font_size_property", reinterpret_cast<getter>(TextElement_get_FontSizeProperty), nullptr, nullptr, nullptr },
        { "font_stretch_property", reinterpret_cast<getter>(TextElement_get_FontStretchProperty), nullptr, nullptr, nullptr },
        { "font_style_property", reinterpret_cast<getter>(TextElement_get_FontStyleProperty), nullptr, nullptr, nullptr },
        { "font_weight_property", reinterpret_cast<getter>(TextElement_get_FontWeightProperty), nullptr, nullptr, nullptr },
        { "foreground_property", reinterpret_cast<getter>(TextElement_get_ForegroundProperty), nullptr, nullptr, nullptr },
        { "is_access_key_scope_property", reinterpret_cast<getter>(TextElement_get_IsAccessKeyScopeProperty), nullptr, nullptr, nullptr },
        { "is_text_scale_factor_enabled_property", reinterpret_cast<getter>(TextElement_get_IsTextScaleFactorEnabledProperty), nullptr, nullptr, nullptr },
        { "key_tip_horizontal_offset_property", reinterpret_cast<getter>(TextElement_get_KeyTipHorizontalOffsetProperty), nullptr, nullptr, nullptr },
        { "key_tip_placement_mode_property", reinterpret_cast<getter>(TextElement_get_KeyTipPlacementModeProperty), nullptr, nullptr, nullptr },
        { "key_tip_vertical_offset_property", reinterpret_cast<getter>(TextElement_get_KeyTipVerticalOffsetProperty), nullptr, nullptr, nullptr },
        { "language_property", reinterpret_cast<getter>(TextElement_get_LanguageProperty), nullptr, nullptr, nullptr },
        { "text_decorations_property", reinterpret_cast<getter>(TextElement_get_TextDecorationsProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_TextElement_Static[] = {
        { }};

    static PyType_Slot type_slots_TextElement_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TextElement_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TextElement_Static) },
        { }
    };

    static PyType_Spec type_spec_TextElement_Static = {
        "winrt._winrt_microsoft_ui_xaml_documents.TextElement_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_TextElement_Static};

    // ----- TextHighlighter class --------------------

    struct PyWinrtTextHighlighter;
    using BasePyWinrtTextHighlighter = winrt::Microsoft::UI::Xaml::Documents::TextHighlighterT<PyWinrtTextHighlighter, py::IPywinrtObject>;

    struct PyWinrtTextHighlighter : py::py_obj_ref, BasePyWinrtTextHighlighter
    {
        PyWinrtTextHighlighter(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtTextHighlighter() {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtTextHighlighter* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_TextHighlighter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Documents::TextHighlighter>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtTextHighlighter>(self.get());

                    auto obj = py::make_py_obj<PyWinrtTextHighlighter>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Documents::TextHighlighter instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TextHighlighter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TextHighlighter_get_Foreground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextHighlighter", L"Foreground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextHighlighter>().Foreground();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextHighlighter_put_Foreground(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextHighlighter", L"Foreground");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextHighlighter>().Foreground(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextHighlighter_get_Background(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextHighlighter", L"Background");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextHighlighter>().Background();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TextHighlighter_put_Background(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextHighlighter", L"Background");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Brush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextHighlighter>().Background(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TextHighlighter_get_Ranges(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextHighlighter", L"Ranges");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Documents::TextHighlighter>().Ranges();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextHighlighter_get_BackgroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextHighlighter", L"BackgroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::TextHighlighter::BackgroundProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextHighlighter_get_ForegroundProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextHighlighter", L"ForegroundProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::TextHighlighter::ForegroundProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TextHighlighter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::TextHighlighter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TextHighlighter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::TextHighlighter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TextHighlighter[] = {
        { "_assign_array_", _assign_array_TextHighlighter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TextHighlighter), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TextHighlighter[] = {
        { "foreground", reinterpret_cast<getter>(TextHighlighter_get_Foreground), reinterpret_cast<setter>(TextHighlighter_put_Foreground), nullptr, nullptr },
        { "background", reinterpret_cast<getter>(TextHighlighter_get_Background), reinterpret_cast<setter>(TextHighlighter_put_Background), nullptr, nullptr },
        { "ranges", reinterpret_cast<getter>(TextHighlighter_get_Ranges), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TextHighlighter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TextHighlighter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TextHighlighter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TextHighlighter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TextHighlighter) },
        { }};

    static PyType_Spec type_spec_TextHighlighter = {
        "winrt._winrt_microsoft_ui_xaml_documents.TextHighlighter",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_TextHighlighter};

    static PyGetSetDef getset_TextHighlighter_Static[] = {
        { "background_property", reinterpret_cast<getter>(TextHighlighter_get_BackgroundProperty), nullptr, nullptr, nullptr },
        { "foreground_property", reinterpret_cast<getter>(TextHighlighter_get_ForegroundProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_TextHighlighter_Static[] = {
        { }};

    static PyType_Slot type_slots_TextHighlighter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TextHighlighter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TextHighlighter_Static) },
        { }
    };

    static PyType_Spec type_spec_TextHighlighter_Static = {
        "winrt._winrt_microsoft_ui_xaml_documents.TextHighlighter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_TextHighlighter_Static};

    // ----- TextHighlighterBase class --------------------

    static PyObject* _new_TextHighlighterBase(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Documents::TextHighlighterBase>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Documents::TextHighlighterBase>::type_name);
        return nullptr;
    }

    static void _dealloc_TextHighlighterBase(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TextHighlighterBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::TextHighlighterBase>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TextHighlighterBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::TextHighlighterBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TextHighlighterBase[] = {
        { "_assign_array_", _assign_array_TextHighlighterBase, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TextHighlighterBase), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TextHighlighterBase[] = {
        { }};

    static PyType_Slot _type_slots_TextHighlighterBase[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TextHighlighterBase) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TextHighlighterBase) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TextHighlighterBase) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TextHighlighterBase) },
        { }};

    static PyType_Spec type_spec_TextHighlighterBase = {
        "winrt._winrt_microsoft_ui_xaml_documents.TextHighlighterBase",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_TextHighlighterBase};

    static PyGetSetDef getset_TextHighlighterBase_Static[] = {
        { }};

    static PyMethodDef methods_TextHighlighterBase_Static[] = {
        { }};

    static PyType_Slot type_slots_TextHighlighterBase_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TextHighlighterBase_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TextHighlighterBase_Static) },
        { }
    };

    static PyType_Spec type_spec_TextHighlighterBase_Static = {
        "winrt._winrt_microsoft_ui_xaml_documents.TextHighlighterBase_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_TextHighlighterBase_Static};

    // ----- TextPointer class --------------------

    static PyObject* _new_TextPointer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Documents::TextPointer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Documents::TextPointer>::type_name);
        return nullptr;
    }

    static void _dealloc_TextPointer(py::wrapper::Microsoft::UI::Xaml::Documents::TextPointer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TextPointer_GetCharacterRect(py::wrapper::Microsoft::UI::Xaml::Documents::TextPointer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.TextPointer", L"GetCharacterRect", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Documents::LogicalDirection>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetCharacterRect(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TextPointer_GetPositionAtOffset(py::wrapper::Microsoft::UI::Xaml::Documents::TextPointer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.TextPointer", L"GetPositionAtOffset", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Documents::LogicalDirection>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetPositionAtOffset(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TextPointer_get_LogicalDirection(py::wrapper::Microsoft::UI::Xaml::Documents::TextPointer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextPointer", L"LogicalDirection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LogicalDirection();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextPointer_get_Offset(py::wrapper::Microsoft::UI::Xaml::Documents::TextPointer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextPointer", L"Offset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Offset();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextPointer_get_Parent(py::wrapper::Microsoft::UI::Xaml::Documents::TextPointer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextPointer", L"Parent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Parent();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextPointer_get_VisualParent(py::wrapper::Microsoft::UI::Xaml::Documents::TextPointer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.TextPointer", L"VisualParent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VisualParent();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TextPointer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::TextPointer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TextPointer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::TextPointer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TextPointer[] = {
        { "get_character_rect", reinterpret_cast<PyCFunction>(TextPointer_GetCharacterRect), METH_VARARGS, nullptr },
        { "get_position_at_offset", reinterpret_cast<PyCFunction>(TextPointer_GetPositionAtOffset), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TextPointer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TextPointer), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_TextPointer[] = {
        { "logical_direction", reinterpret_cast<getter>(TextPointer_get_LogicalDirection), nullptr, nullptr, nullptr },
        { "offset", reinterpret_cast<getter>(TextPointer_get_Offset), nullptr, nullptr, nullptr },
        { "parent", reinterpret_cast<getter>(TextPointer_get_Parent), nullptr, nullptr, nullptr },
        { "visual_parent", reinterpret_cast<getter>(TextPointer_get_VisualParent), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_TextPointer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TextPointer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TextPointer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TextPointer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TextPointer) },
        { }};

    static PyType_Spec type_spec_TextPointer = {
        "winrt._winrt_microsoft_ui_xaml_documents.TextPointer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Documents::TextPointer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TextPointer};

    // ----- Typography class --------------------

    static PyObject* _new_Typography(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Documents::Typography>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Documents::Typography>::type_name);
        return nullptr;
    }

    static void _dealloc_Typography(py::wrapper::Microsoft::UI::Xaml::Documents::Typography* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Typography_GetAnnotationAlternates(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetAnnotationAlternates", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetAnnotationAlternates(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetCapitalSpacing(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetCapitalSpacing", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetCapitalSpacing(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetCapitals(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetCapitals", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetCapitals(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetCaseSensitiveForms(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetCaseSensitiveForms", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetCaseSensitiveForms(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetContextualAlternates(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetContextualAlternates", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetContextualAlternates(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetContextualLigatures(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetContextualLigatures", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetContextualLigatures(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetContextualSwashes(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetContextualSwashes", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetContextualSwashes(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetDiscretionaryLigatures(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetDiscretionaryLigatures", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetDiscretionaryLigatures(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetEastAsianExpertForms(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetEastAsianExpertForms", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetEastAsianExpertForms(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetEastAsianLanguage(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetEastAsianLanguage", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetEastAsianLanguage(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetEastAsianWidths(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetEastAsianWidths", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetEastAsianWidths(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetFraction(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetFraction", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetFraction(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetHistoricalForms(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetHistoricalForms", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetHistoricalForms(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetHistoricalLigatures(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetHistoricalLigatures", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetHistoricalLigatures(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetKerning(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetKerning", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetKerning(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetMathematicalGreek(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetMathematicalGreek", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetMathematicalGreek(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetNumeralAlignment(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetNumeralAlignment", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetNumeralAlignment(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetNumeralStyle(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetNumeralStyle", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetNumeralStyle(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetSlashedZero(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetSlashedZero", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetSlashedZero(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStandardLigatures(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStandardLigatures", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetStandardLigatures(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStandardSwashes(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStandardSwashes", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetStandardSwashes(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticAlternates(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticAlternates", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticAlternates(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet1(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet1", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet1(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet10(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet10", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet10(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet11(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet11", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet11(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet12(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet12", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet12(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet13(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet13", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet13(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet14(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet14", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet14(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet15(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet15", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet15(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet16(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet16", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet16(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet17(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet17", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet17(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet18(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet18", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet18(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet19(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet19", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet19(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet2(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet2", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet2(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet20(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet20", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet20(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet3(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet3", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet3(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet4(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet4", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet4(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet5(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet5", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet5(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet6(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet6", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet6(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet7(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet7", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet7(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet8(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet8", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet8(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetStylisticSet9(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetStylisticSet9", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetStylisticSet9(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_GetVariants(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"GetVariants", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Xaml::Documents::Typography::GetVariants(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetAnnotationAlternates(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetAnnotationAlternates", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetAnnotationAlternates(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetCapitalSpacing(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetCapitalSpacing", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetCapitalSpacing(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetCapitals(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetCapitals", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::FontCapitals>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetCapitals(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetCaseSensitiveForms(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetCaseSensitiveForms", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetCaseSensitiveForms(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetContextualAlternates(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetContextualAlternates", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetContextualAlternates(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetContextualLigatures(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetContextualLigatures", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetContextualLigatures(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetContextualSwashes(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetContextualSwashes", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetContextualSwashes(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetDiscretionaryLigatures(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetDiscretionaryLigatures", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetDiscretionaryLigatures(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetEastAsianExpertForms(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetEastAsianExpertForms", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetEastAsianExpertForms(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetEastAsianLanguage(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetEastAsianLanguage", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::FontEastAsianLanguage>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetEastAsianLanguage(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetEastAsianWidths(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetEastAsianWidths", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::FontEastAsianWidths>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetEastAsianWidths(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetFraction(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetFraction", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::FontFraction>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetFraction(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetHistoricalForms(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetHistoricalForms", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetHistoricalForms(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetHistoricalLigatures(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetHistoricalLigatures", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetHistoricalLigatures(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetKerning(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetKerning", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetKerning(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetMathematicalGreek(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetMathematicalGreek", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetMathematicalGreek(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetNumeralAlignment(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetNumeralAlignment", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::FontNumeralAlignment>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetNumeralAlignment(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetNumeralStyle(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetNumeralStyle", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::FontNumeralStyle>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetNumeralStyle(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetSlashedZero(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetSlashedZero", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetSlashedZero(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStandardLigatures(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStandardLigatures", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetStandardLigatures(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStandardSwashes(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStandardSwashes", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetStandardSwashes(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticAlternates(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticAlternates", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticAlternates(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet1(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet1", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet1(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet10(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet10", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet10(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet11(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet11", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet11(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet12(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet12", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet12(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet13(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet13", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet13(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet14(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet14", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet14(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet15(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet15", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet15(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet16(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet16", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet16(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet17(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet17", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet17(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet18(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet18", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet18(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet19(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet19", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet19(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet2(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet2", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet2(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet20(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet20", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet20(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet3(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet3", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet3(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet4(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet4", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet4(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet5(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet5", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet5(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet6(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet6", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet6(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet7(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet7", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet7(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet8(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet8", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet8(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetStylisticSet9(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetStylisticSet9", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetStylisticSet9(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_SetVariants(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SetVariants", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::DependencyObject>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::FontVariants>(args, 1);

                {
                    auto _gil = release_gil();
                    winrt::Microsoft::UI::Xaml::Documents::Typography::SetVariants(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Typography_get_AnnotationAlternatesProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"AnnotationAlternatesProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::AnnotationAlternatesProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_CapitalSpacingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"CapitalSpacingProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::CapitalSpacingProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_CapitalsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"CapitalsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::CapitalsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_CaseSensitiveFormsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"CaseSensitiveFormsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::CaseSensitiveFormsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_ContextualAlternatesProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"ContextualAlternatesProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::ContextualAlternatesProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_ContextualLigaturesProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"ContextualLigaturesProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::ContextualLigaturesProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_ContextualSwashesProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"ContextualSwashesProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::ContextualSwashesProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_DiscretionaryLigaturesProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"DiscretionaryLigaturesProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::DiscretionaryLigaturesProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_EastAsianExpertFormsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"EastAsianExpertFormsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::EastAsianExpertFormsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_EastAsianLanguageProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"EastAsianLanguageProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::EastAsianLanguageProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_EastAsianWidthsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"EastAsianWidthsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::EastAsianWidthsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_FractionProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"FractionProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::FractionProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_HistoricalFormsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"HistoricalFormsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::HistoricalFormsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_HistoricalLigaturesProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"HistoricalLigaturesProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::HistoricalLigaturesProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_KerningProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"KerningProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::KerningProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_MathematicalGreekProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"MathematicalGreekProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::MathematicalGreekProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_NumeralAlignmentProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"NumeralAlignmentProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::NumeralAlignmentProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_NumeralStyleProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"NumeralStyleProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::NumeralStyleProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_SlashedZeroProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"SlashedZeroProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::SlashedZeroProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StandardLigaturesProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StandardLigaturesProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::StandardLigaturesProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StandardSwashesProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StandardSwashesProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::StandardSwashesProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticAlternatesProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticAlternatesProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticAlternatesProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet10Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet10Property");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet10Property();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet11Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet11Property");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet11Property();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet12Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet12Property");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet12Property();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet13Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet13Property");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet13Property();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet14Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet14Property");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet14Property();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet15Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet15Property");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet15Property();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet16Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet16Property");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet16Property();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet17Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet17Property");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet17Property();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet18Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet18Property");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet18Property();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet19Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet19Property");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet19Property();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet1Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet1Property");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet1Property();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet20Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet20Property");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet20Property();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet2Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet2Property");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet2Property();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet3Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet3Property");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet3Property();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet4Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet4Property");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet4Property();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet5Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet5Property");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet5Property();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet6Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet6Property");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet6Property();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet7Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet7Property");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet7Property();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet8Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet8Property");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet8Property();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_StylisticSet9Property(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"StylisticSet9Property");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::StylisticSet9Property();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Typography_get_VariantsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Documents.Typography", L"VariantsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Documents::Typography::VariantsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_Typography(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::Typography>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Typography(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::Typography>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Typography[] = {
        { "_assign_array_", _assign_array_Typography, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Typography), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Typography[] = {
        { }};

    static PyType_Slot _type_slots_Typography[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Typography) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Typography) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Typography) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Typography) },
        { }};

    static PyType_Spec type_spec_Typography = {
        "winrt._winrt_microsoft_ui_xaml_documents.Typography",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Documents::Typography),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Typography};

    static PyGetSetDef getset_Typography_Static[] = {
        { "annotation_alternates_property", reinterpret_cast<getter>(Typography_get_AnnotationAlternatesProperty), nullptr, nullptr, nullptr },
        { "capital_spacing_property", reinterpret_cast<getter>(Typography_get_CapitalSpacingProperty), nullptr, nullptr, nullptr },
        { "capitals_property", reinterpret_cast<getter>(Typography_get_CapitalsProperty), nullptr, nullptr, nullptr },
        { "case_sensitive_forms_property", reinterpret_cast<getter>(Typography_get_CaseSensitiveFormsProperty), nullptr, nullptr, nullptr },
        { "contextual_alternates_property", reinterpret_cast<getter>(Typography_get_ContextualAlternatesProperty), nullptr, nullptr, nullptr },
        { "contextual_ligatures_property", reinterpret_cast<getter>(Typography_get_ContextualLigaturesProperty), nullptr, nullptr, nullptr },
        { "contextual_swashes_property", reinterpret_cast<getter>(Typography_get_ContextualSwashesProperty), nullptr, nullptr, nullptr },
        { "discretionary_ligatures_property", reinterpret_cast<getter>(Typography_get_DiscretionaryLigaturesProperty), nullptr, nullptr, nullptr },
        { "east_asian_expert_forms_property", reinterpret_cast<getter>(Typography_get_EastAsianExpertFormsProperty), nullptr, nullptr, nullptr },
        { "east_asian_language_property", reinterpret_cast<getter>(Typography_get_EastAsianLanguageProperty), nullptr, nullptr, nullptr },
        { "east_asian_widths_property", reinterpret_cast<getter>(Typography_get_EastAsianWidthsProperty), nullptr, nullptr, nullptr },
        { "fraction_property", reinterpret_cast<getter>(Typography_get_FractionProperty), nullptr, nullptr, nullptr },
        { "historical_forms_property", reinterpret_cast<getter>(Typography_get_HistoricalFormsProperty), nullptr, nullptr, nullptr },
        { "historical_ligatures_property", reinterpret_cast<getter>(Typography_get_HistoricalLigaturesProperty), nullptr, nullptr, nullptr },
        { "kerning_property", reinterpret_cast<getter>(Typography_get_KerningProperty), nullptr, nullptr, nullptr },
        { "mathematical_greek_property", reinterpret_cast<getter>(Typography_get_MathematicalGreekProperty), nullptr, nullptr, nullptr },
        { "numeral_alignment_property", reinterpret_cast<getter>(Typography_get_NumeralAlignmentProperty), nullptr, nullptr, nullptr },
        { "numeral_style_property", reinterpret_cast<getter>(Typography_get_NumeralStyleProperty), nullptr, nullptr, nullptr },
        { "slashed_zero_property", reinterpret_cast<getter>(Typography_get_SlashedZeroProperty), nullptr, nullptr, nullptr },
        { "standard_ligatures_property", reinterpret_cast<getter>(Typography_get_StandardLigaturesProperty), nullptr, nullptr, nullptr },
        { "standard_swashes_property", reinterpret_cast<getter>(Typography_get_StandardSwashesProperty), nullptr, nullptr, nullptr },
        { "stylistic_alternates_property", reinterpret_cast<getter>(Typography_get_StylisticAlternatesProperty), nullptr, nullptr, nullptr },
        { "stylistic_set10_property", reinterpret_cast<getter>(Typography_get_StylisticSet10Property), nullptr, nullptr, nullptr },
        { "stylistic_set11_property", reinterpret_cast<getter>(Typography_get_StylisticSet11Property), nullptr, nullptr, nullptr },
        { "stylistic_set12_property", reinterpret_cast<getter>(Typography_get_StylisticSet12Property), nullptr, nullptr, nullptr },
        { "stylistic_set13_property", reinterpret_cast<getter>(Typography_get_StylisticSet13Property), nullptr, nullptr, nullptr },
        { "stylistic_set14_property", reinterpret_cast<getter>(Typography_get_StylisticSet14Property), nullptr, nullptr, nullptr },
        { "stylistic_set15_property", reinterpret_cast<getter>(Typography_get_StylisticSet15Property), nullptr, nullptr, nullptr },
        { "stylistic_set16_property", reinterpret_cast<getter>(Typography_get_StylisticSet16Property), nullptr, nullptr, nullptr },
        { "stylistic_set17_property", reinterpret_cast<getter>(Typography_get_StylisticSet17Property), nullptr, nullptr, nullptr },
        { "stylistic_set18_property", reinterpret_cast<getter>(Typography_get_StylisticSet18Property), nullptr, nullptr, nullptr },
        { "stylistic_set19_property", reinterpret_cast<getter>(Typography_get_StylisticSet19Property), nullptr, nullptr, nullptr },
        { "stylistic_set1_property", reinterpret_cast<getter>(Typography_get_StylisticSet1Property), nullptr, nullptr, nullptr },
        { "stylistic_set20_property", reinterpret_cast<getter>(Typography_get_StylisticSet20Property), nullptr, nullptr, nullptr },
        { "stylistic_set2_property", reinterpret_cast<getter>(Typography_get_StylisticSet2Property), nullptr, nullptr, nullptr },
        { "stylistic_set3_property", reinterpret_cast<getter>(Typography_get_StylisticSet3Property), nullptr, nullptr, nullptr },
        { "stylistic_set4_property", reinterpret_cast<getter>(Typography_get_StylisticSet4Property), nullptr, nullptr, nullptr },
        { "stylistic_set5_property", reinterpret_cast<getter>(Typography_get_StylisticSet5Property), nullptr, nullptr, nullptr },
        { "stylistic_set6_property", reinterpret_cast<getter>(Typography_get_StylisticSet6Property), nullptr, nullptr, nullptr },
        { "stylistic_set7_property", reinterpret_cast<getter>(Typography_get_StylisticSet7Property), nullptr, nullptr, nullptr },
        { "stylistic_set8_property", reinterpret_cast<getter>(Typography_get_StylisticSet8Property), nullptr, nullptr, nullptr },
        { "stylistic_set9_property", reinterpret_cast<getter>(Typography_get_StylisticSet9Property), nullptr, nullptr, nullptr },
        { "variants_property", reinterpret_cast<getter>(Typography_get_VariantsProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_Typography_Static[] = {
        { "get_annotation_alternates", reinterpret_cast<PyCFunction>(Typography_GetAnnotationAlternates), METH_VARARGS, nullptr },
        { "get_capital_spacing", reinterpret_cast<PyCFunction>(Typography_GetCapitalSpacing), METH_VARARGS, nullptr },
        { "get_capitals", reinterpret_cast<PyCFunction>(Typography_GetCapitals), METH_VARARGS, nullptr },
        { "get_case_sensitive_forms", reinterpret_cast<PyCFunction>(Typography_GetCaseSensitiveForms), METH_VARARGS, nullptr },
        { "get_contextual_alternates", reinterpret_cast<PyCFunction>(Typography_GetContextualAlternates), METH_VARARGS, nullptr },
        { "get_contextual_ligatures", reinterpret_cast<PyCFunction>(Typography_GetContextualLigatures), METH_VARARGS, nullptr },
        { "get_contextual_swashes", reinterpret_cast<PyCFunction>(Typography_GetContextualSwashes), METH_VARARGS, nullptr },
        { "get_discretionary_ligatures", reinterpret_cast<PyCFunction>(Typography_GetDiscretionaryLigatures), METH_VARARGS, nullptr },
        { "get_east_asian_expert_forms", reinterpret_cast<PyCFunction>(Typography_GetEastAsianExpertForms), METH_VARARGS, nullptr },
        { "get_east_asian_language", reinterpret_cast<PyCFunction>(Typography_GetEastAsianLanguage), METH_VARARGS, nullptr },
        { "get_east_asian_widths", reinterpret_cast<PyCFunction>(Typography_GetEastAsianWidths), METH_VARARGS, nullptr },
        { "get_fraction", reinterpret_cast<PyCFunction>(Typography_GetFraction), METH_VARARGS, nullptr },
        { "get_historical_forms", reinterpret_cast<PyCFunction>(Typography_GetHistoricalForms), METH_VARARGS, nullptr },
        { "get_historical_ligatures", reinterpret_cast<PyCFunction>(Typography_GetHistoricalLigatures), METH_VARARGS, nullptr },
        { "get_kerning", reinterpret_cast<PyCFunction>(Typography_GetKerning), METH_VARARGS, nullptr },
        { "get_mathematical_greek", reinterpret_cast<PyCFunction>(Typography_GetMathematicalGreek), METH_VARARGS, nullptr },
        { "get_numeral_alignment", reinterpret_cast<PyCFunction>(Typography_GetNumeralAlignment), METH_VARARGS, nullptr },
        { "get_numeral_style", reinterpret_cast<PyCFunction>(Typography_GetNumeralStyle), METH_VARARGS, nullptr },
        { "get_slashed_zero", reinterpret_cast<PyCFunction>(Typography_GetSlashedZero), METH_VARARGS, nullptr },
        { "get_standard_ligatures", reinterpret_cast<PyCFunction>(Typography_GetStandardLigatures), METH_VARARGS, nullptr },
        { "get_standard_swashes", reinterpret_cast<PyCFunction>(Typography_GetStandardSwashes), METH_VARARGS, nullptr },
        { "get_stylistic_alternates", reinterpret_cast<PyCFunction>(Typography_GetStylisticAlternates), METH_VARARGS, nullptr },
        { "get_stylistic_set1", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet1), METH_VARARGS, nullptr },
        { "get_stylistic_set10", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet10), METH_VARARGS, nullptr },
        { "get_stylistic_set11", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet11), METH_VARARGS, nullptr },
        { "get_stylistic_set12", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet12), METH_VARARGS, nullptr },
        { "get_stylistic_set13", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet13), METH_VARARGS, nullptr },
        { "get_stylistic_set14", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet14), METH_VARARGS, nullptr },
        { "get_stylistic_set15", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet15), METH_VARARGS, nullptr },
        { "get_stylistic_set16", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet16), METH_VARARGS, nullptr },
        { "get_stylistic_set17", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet17), METH_VARARGS, nullptr },
        { "get_stylistic_set18", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet18), METH_VARARGS, nullptr },
        { "get_stylistic_set19", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet19), METH_VARARGS, nullptr },
        { "get_stylistic_set2", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet2), METH_VARARGS, nullptr },
        { "get_stylistic_set20", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet20), METH_VARARGS, nullptr },
        { "get_stylistic_set3", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet3), METH_VARARGS, nullptr },
        { "get_stylistic_set4", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet4), METH_VARARGS, nullptr },
        { "get_stylistic_set5", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet5), METH_VARARGS, nullptr },
        { "get_stylistic_set6", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet6), METH_VARARGS, nullptr },
        { "get_stylistic_set7", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet7), METH_VARARGS, nullptr },
        { "get_stylistic_set8", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet8), METH_VARARGS, nullptr },
        { "get_stylistic_set9", reinterpret_cast<PyCFunction>(Typography_GetStylisticSet9), METH_VARARGS, nullptr },
        { "get_variants", reinterpret_cast<PyCFunction>(Typography_GetVariants), METH_VARARGS, nullptr },
        { "set_annotation_alternates", reinterpret_cast<PyCFunction>(Typography_SetAnnotationAlternates), METH_VARARGS, nullptr },
        { "set_capital_spacing", reinterpret_cast<PyCFunction>(Typography_SetCapitalSpacing), METH_VARARGS, nullptr },
        { "set_capitals", reinterpret_cast<PyCFunction>(Typography_SetCapitals), METH_VARARGS, nullptr },
        { "set_case_sensitive_forms", reinterpret_cast<PyCFunction>(Typography_SetCaseSensitiveForms), METH_VARARGS, nullptr },
        { "set_contextual_alternates", reinterpret_cast<PyCFunction>(Typography_SetContextualAlternates), METH_VARARGS, nullptr },
        { "set_contextual_ligatures", reinterpret_cast<PyCFunction>(Typography_SetContextualLigatures), METH_VARARGS, nullptr },
        { "set_contextual_swashes", reinterpret_cast<PyCFunction>(Typography_SetContextualSwashes), METH_VARARGS, nullptr },
        { "set_discretionary_ligatures", reinterpret_cast<PyCFunction>(Typography_SetDiscretionaryLigatures), METH_VARARGS, nullptr },
        { "set_east_asian_expert_forms", reinterpret_cast<PyCFunction>(Typography_SetEastAsianExpertForms), METH_VARARGS, nullptr },
        { "set_east_asian_language", reinterpret_cast<PyCFunction>(Typography_SetEastAsianLanguage), METH_VARARGS, nullptr },
        { "set_east_asian_widths", reinterpret_cast<PyCFunction>(Typography_SetEastAsianWidths), METH_VARARGS, nullptr },
        { "set_fraction", reinterpret_cast<PyCFunction>(Typography_SetFraction), METH_VARARGS, nullptr },
        { "set_historical_forms", reinterpret_cast<PyCFunction>(Typography_SetHistoricalForms), METH_VARARGS, nullptr },
        { "set_historical_ligatures", reinterpret_cast<PyCFunction>(Typography_SetHistoricalLigatures), METH_VARARGS, nullptr },
        { "set_kerning", reinterpret_cast<PyCFunction>(Typography_SetKerning), METH_VARARGS, nullptr },
        { "set_mathematical_greek", reinterpret_cast<PyCFunction>(Typography_SetMathematicalGreek), METH_VARARGS, nullptr },
        { "set_numeral_alignment", reinterpret_cast<PyCFunction>(Typography_SetNumeralAlignment), METH_VARARGS, nullptr },
        { "set_numeral_style", reinterpret_cast<PyCFunction>(Typography_SetNumeralStyle), METH_VARARGS, nullptr },
        { "set_slashed_zero", reinterpret_cast<PyCFunction>(Typography_SetSlashedZero), METH_VARARGS, nullptr },
        { "set_standard_ligatures", reinterpret_cast<PyCFunction>(Typography_SetStandardLigatures), METH_VARARGS, nullptr },
        { "set_standard_swashes", reinterpret_cast<PyCFunction>(Typography_SetStandardSwashes), METH_VARARGS, nullptr },
        { "set_stylistic_alternates", reinterpret_cast<PyCFunction>(Typography_SetStylisticAlternates), METH_VARARGS, nullptr },
        { "set_stylistic_set1", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet1), METH_VARARGS, nullptr },
        { "set_stylistic_set10", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet10), METH_VARARGS, nullptr },
        { "set_stylistic_set11", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet11), METH_VARARGS, nullptr },
        { "set_stylistic_set12", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet12), METH_VARARGS, nullptr },
        { "set_stylistic_set13", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet13), METH_VARARGS, nullptr },
        { "set_stylistic_set14", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet14), METH_VARARGS, nullptr },
        { "set_stylistic_set15", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet15), METH_VARARGS, nullptr },
        { "set_stylistic_set16", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet16), METH_VARARGS, nullptr },
        { "set_stylistic_set17", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet17), METH_VARARGS, nullptr },
        { "set_stylistic_set18", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet18), METH_VARARGS, nullptr },
        { "set_stylistic_set19", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet19), METH_VARARGS, nullptr },
        { "set_stylistic_set2", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet2), METH_VARARGS, nullptr },
        { "set_stylistic_set20", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet20), METH_VARARGS, nullptr },
        { "set_stylistic_set3", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet3), METH_VARARGS, nullptr },
        { "set_stylistic_set4", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet4), METH_VARARGS, nullptr },
        { "set_stylistic_set5", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet5), METH_VARARGS, nullptr },
        { "set_stylistic_set6", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet6), METH_VARARGS, nullptr },
        { "set_stylistic_set7", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet7), METH_VARARGS, nullptr },
        { "set_stylistic_set8", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet8), METH_VARARGS, nullptr },
        { "set_stylistic_set9", reinterpret_cast<PyCFunction>(Typography_SetStylisticSet9), METH_VARARGS, nullptr },
        { "set_variants", reinterpret_cast<PyCFunction>(Typography_SetVariants), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_Typography_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_Typography_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_Typography_Static) },
        { }
    };

    static PyType_Spec type_spec_Typography_Static = {
        "winrt._winrt_microsoft_ui_xaml_documents.Typography_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_Typography_Static};

    // ----- Underline class --------------------

    static PyObject* _new_Underline(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Documents::Underline instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Underline(py::wrapper::Microsoft::UI::Xaml::Documents::Underline* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_Underline(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::Underline>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_Underline(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Documents::Underline>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Underline[] = {
        { "_assign_array_", _assign_array_Underline, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Underline), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_Underline[] = {
        { }};

    static PyType_Slot _type_slots_Underline[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_Underline) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_Underline) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_Underline) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_Underline) },
        { }};

    static PyType_Spec type_spec_Underline = {
        "winrt._winrt_microsoft_ui_xaml_documents.Underline",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Documents::Underline),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Underline};

    // ----- TextRange struct --------------------

    winrt::Microsoft::UI::Xaml::Documents::TextRange TextRange_from_tuple(PyObject* tuple)
    {
        if (PyTuple_GET_SIZE(tuple) != 2)
        {
            PyErr_SetString(PyExc_TypeError, "Incorrect number of fields");
            throw python_exception();
        }

        winrt::Microsoft::UI::Xaml::Documents::TextRange result{};

        result.StartIndex = py::convert_to<int32_t>(tuple, 0);
        result.Length = py::convert_to<int32_t>(tuple, 1);

        return result;
    }

    PyObject* _new_TextRange(PyTypeObject* subclass, PyObject* args, PyObject* kwds) noexcept
    {
        pyobj_handle self_obj{(subclass->tp_alloc(subclass, 0))};
        if (!self_obj)
        {
            return nullptr;
        }

        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Microsoft::UI::Xaml::Documents::TextRange>*>(self_obj.get());
        std::construct_at(&self->obj);

        auto tuple_size = PyTuple_GET_SIZE(args);
        if ((tuple_size == 0) && (!kwds))
        {
            return self_obj.detach();
        }

        int32_t _StartIndex{};
        int32_t _Length{};

        static const char* kwlist[] = {"start_index", "length", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "|ii", const_cast<char**>(kwlist), &_StartIndex, &_Length))
        {
            return nullptr;
        }

        try
        {
            self->obj.StartIndex = _StartIndex;
            self->obj.Length = _Length;

            return self_obj.detach();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_TextRange(py::wrapper::Microsoft::UI::Xaml::Documents::TextRange* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TextRange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Documents::TextRange>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    PyObject* _replace_TextRange(py::wrapper::Microsoft::UI::Xaml::Documents::TextRange* self, PyObject* args, PyObject* kwds) noexcept
    {
        try
        {
            int32_t _StartIndex{self->obj.StartIndex};
            int32_t _Length{self->obj.Length};

            static const char* kwlist[] = {"start_index", "length", nullptr};
            if (!PyArg_ParseTupleAndKeywords(args, kwds, "|$ii", const_cast<char**>(kwlist), &_StartIndex, &_Length))
            {
                return nullptr;
            }

            auto copy = self->obj;
            copy.StartIndex = _StartIndex;
            copy.Length = _Length;

            return convert(copy);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    PyObject* unpack_TextRange(py::wrapper::Microsoft::UI::Xaml::Documents::TextRange* self, PyObject* /*unused*/) noexcept
    {
        py::pyobj_handle StartIndex{convert(self->obj.StartIndex)};
        if (!StartIndex)
        {
            return nullptr;
        }

        py::pyobj_handle Length{convert(self->obj.Length)};
        if (!Length)
        {
            return nullptr;
        }

        pyobj_handle tuple{PyTuple_New(2)};
        if (!tuple)
        {
            return nullptr;
        }

        PyTuple_SET_ITEM(tuple.get(), 0, StartIndex.detach());
        PyTuple_SET_ITEM(tuple.get(), 1, Length.detach());

        return tuple.detach();
    }

    static PyMethodDef _methods_TextRange[] = {
        { "_assign_array_", _assign_array_TextRange, METH_O | METH_STATIC, nullptr },
        { "__replace__", reinterpret_cast<PyCFunction>(reinterpret_cast<void*>(_replace_TextRange)), METH_VARARGS | METH_KEYWORDS, nullptr },
        { "unpack", reinterpret_cast<PyCFunction>(unpack_TextRange), METH_NOARGS, nullptr },
        { }};

    static PyObject* TextRange_get_StartIndex(py::wrapper::Microsoft::UI::Xaml::Documents::TextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartIndex);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextRange_get_Length(py::wrapper::Microsoft::UI::Xaml::Documents::TextRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Length);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyGetSetDef _getset_TextRange[] = {
        { "start_index", reinterpret_cast<getter>(TextRange_get_StartIndex), nullptr, nullptr, nullptr },
        { "length", reinterpret_cast<getter>(TextRange_get_Length), nullptr, nullptr, nullptr },
        { }};

    static PyObject* _richcompare_TextRange(py::wrapper::Microsoft::UI::Xaml::Documents::TextRange* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Microsoft::UI::Xaml::Documents::TextRange>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_TextRange(PyObject* self) noexcept
    {
        py::pyobj_handle StartIndex{PyObject_GetAttrString(self, "start_index")};
        if (!StartIndex)
        {
            return nullptr;
        }

        py::pyobj_handle Length{PyObject_GetAttrString(self, "length")};
        if (!Length)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("TextRange(start_index=%R, length=%R)", StartIndex.get(), Length.get());
    }

    static PyType_Slot _type_slots_TextRange[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TextRange) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TextRange) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TextRange) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TextRange) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_TextRange) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_TextRange) },
        { }};

    static PyType_Spec type_spec_TextRange = {
        "winrt._winrt_microsoft_ui_xaml_documents.TextRange",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Documents::TextRange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TextRange};

    // ----- Microsoft.UI.Xaml.Documents Initialization --------------------

    PyDoc_STRVAR(module_doc, "Microsoft.UI.Xaml.Documents");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_microsoft_ui_xaml_documents",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Microsoft::UI::Xaml::Documents

PyMODINIT_FUNC PyInit__winrt_microsoft_ui_xaml_documents(void) noexcept
{
    using namespace py::cpp::Microsoft::UI::Xaml::Documents;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle microsoft_ui_xaml_module{PyImport_ImportModule("winrt._winrt_microsoft_ui_xaml")};
    if (!microsoft_ui_xaml_module)
    {
        return nullptr;
    }

    py::pyobj_handle microsoft_ui_xaml_FrameworkElement_type{PyObject_GetAttrString(microsoft_ui_xaml_module.get(), "FrameworkElement")};
    if (!microsoft_ui_xaml_FrameworkElement_type)
    {
        return nullptr;
    }

    py::pyobj_handle microsoft_ui_xaml_RoutedEventArgs_type{PyObject_GetAttrString(microsoft_ui_xaml_module.get(), "RoutedEventArgs")};
    if (!microsoft_ui_xaml_RoutedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle microsoft_ui_xaml_DependencyObject_type{PyObject_GetAttrString(microsoft_ui_xaml_module.get(), "DependencyObject")};
    if (!microsoft_ui_xaml_DependencyObject_type)
    {
        return nullptr;
    }

    py::pyobj_handle TextElement_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_xaml_DependencyObject_type.get())))};
    if (!TextElement_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TextElement_Static{PyType_FromSpecWithBases(&type_spec_TextElement_Static, TextElement_Static_bases.get())};
    if (!type_TextElement_Static)
    {
        return nullptr;
    }

    py::pyobj_handle TextElement_bases{PyTuple_Pack(1, microsoft_ui_xaml_DependencyObject_type.get())};
    if (!TextElement_bases)
    {
        return nullptr;
    }

    py::pytype_handle TextElement_type{py::register_python_type(module.get(), &type_spec_TextElement, TextElement_bases.get(), reinterpret_cast<PyTypeObject*>(type_TextElement_Static.get()))};
    if (!TextElement_type)
    {
        return nullptr;
    }

    py::pyobj_handle Block_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(TextElement_type.get())))};
    if (!Block_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Block_Static{PyType_FromSpecWithBases(&type_spec_Block_Static, Block_Static_bases.get())};
    if (!type_Block_Static)
    {
        return nullptr;
    }

    py::pyobj_handle Block_bases{PyTuple_Pack(1, TextElement_type.get())};
    if (!Block_bases)
    {
        return nullptr;
    }

    py::pytype_handle Block_type{py::register_python_type(module.get(), &type_spec_Block, Block_bases.get(), reinterpret_cast<PyTypeObject*>(type_Block_Static.get()))};
    if (!Block_type)
    {
        return nullptr;
    }

    py::pytype_handle BlockCollection_type{py::register_python_type(module.get(), &type_spec_BlockCollection, object_bases.get(), inspectable_meta_type)};
    if (!BlockCollection_type)
    {
        return nullptr;
    }

    py::pyobj_handle Inline_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(TextElement_type.get())))};
    if (!Inline_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Inline_Static{PyType_FromSpecWithBases(&type_spec_Inline_Static, Inline_Static_bases.get())};
    if (!type_Inline_Static)
    {
        return nullptr;
    }

    py::pyobj_handle Inline_bases{PyTuple_Pack(1, TextElement_type.get())};
    if (!Inline_bases)
    {
        return nullptr;
    }

    py::pytype_handle Inline_type{py::register_python_type(module.get(), &type_spec_Inline, Inline_bases.get(), reinterpret_cast<PyTypeObject*>(type_Inline_Static.get()))};
    if (!Inline_type)
    {
        return nullptr;
    }

    py::pyobj_handle Span_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(Inline_type.get())))};
    if (!Span_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Span_Static{PyType_FromSpecWithBases(&type_spec_Span_Static, Span_Static_bases.get())};
    if (!type_Span_Static)
    {
        return nullptr;
    }

    py::pyobj_handle Span_bases{PyTuple_Pack(1, Inline_type.get())};
    if (!Span_bases)
    {
        return nullptr;
    }

    py::pytype_handle Span_type{py::register_python_type(module.get(), &type_spec_Span, Span_bases.get(), reinterpret_cast<PyTypeObject*>(type_Span_Static.get()))};
    if (!Span_type)
    {
        return nullptr;
    }

    py::pyobj_handle Bold_bases{PyTuple_Pack(1, Span_type.get())};
    if (!Bold_bases)
    {
        return nullptr;
    }

    py::pytype_handle Bold_type{py::register_python_type(module.get(), &type_spec_Bold, Bold_bases.get(), inspectable_meta_type)};
    if (!Bold_type)
    {
        return nullptr;
    }

    py::pyobj_handle Glyphs_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_xaml_FrameworkElement_type.get())))};
    if (!Glyphs_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Glyphs_Static{PyType_FromSpecWithBases(&type_spec_Glyphs_Static, Glyphs_Static_bases.get())};
    if (!type_Glyphs_Static)
    {
        return nullptr;
    }

    py::pyobj_handle Glyphs_bases{PyTuple_Pack(1, microsoft_ui_xaml_FrameworkElement_type.get())};
    if (!Glyphs_bases)
    {
        return nullptr;
    }

    py::pytype_handle Glyphs_type{py::register_python_type(module.get(), &type_spec_Glyphs, Glyphs_bases.get(), reinterpret_cast<PyTypeObject*>(type_Glyphs_Static.get()))};
    if (!Glyphs_type)
    {
        return nullptr;
    }

    py::pyobj_handle Hyperlink_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(Span_type.get())))};
    if (!Hyperlink_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Hyperlink_Static{PyType_FromSpecWithBases(&type_spec_Hyperlink_Static, Hyperlink_Static_bases.get())};
    if (!type_Hyperlink_Static)
    {
        return nullptr;
    }

    py::pyobj_handle Hyperlink_bases{PyTuple_Pack(1, Span_type.get())};
    if (!Hyperlink_bases)
    {
        return nullptr;
    }

    py::pytype_handle Hyperlink_type{py::register_python_type(module.get(), &type_spec_Hyperlink, Hyperlink_bases.get(), reinterpret_cast<PyTypeObject*>(type_Hyperlink_Static.get()))};
    if (!Hyperlink_type)
    {
        return nullptr;
    }

    py::pyobj_handle HyperlinkClickEventArgs_bases{PyTuple_Pack(1, microsoft_ui_xaml_RoutedEventArgs_type.get())};
    if (!HyperlinkClickEventArgs_bases)
    {
        return nullptr;
    }

    py::pytype_handle HyperlinkClickEventArgs_type{py::register_python_type(module.get(), &type_spec_HyperlinkClickEventArgs, HyperlinkClickEventArgs_bases.get(), inspectable_meta_type)};
    if (!HyperlinkClickEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle InlineCollection_type{py::register_python_type(module.get(), &type_spec_InlineCollection, object_bases.get(), inspectable_meta_type)};
    if (!InlineCollection_type)
    {
        return nullptr;
    }

    py::pyobj_handle InlineUIContainer_bases{PyTuple_Pack(1, Inline_type.get())};
    if (!InlineUIContainer_bases)
    {
        return nullptr;
    }

    py::pytype_handle InlineUIContainer_type{py::register_python_type(module.get(), &type_spec_InlineUIContainer, InlineUIContainer_bases.get(), inspectable_meta_type)};
    if (!InlineUIContainer_type)
    {
        return nullptr;
    }

    py::pyobj_handle Italic_bases{PyTuple_Pack(1, Span_type.get())};
    if (!Italic_bases)
    {
        return nullptr;
    }

    py::pytype_handle Italic_type{py::register_python_type(module.get(), &type_spec_Italic, Italic_bases.get(), inspectable_meta_type)};
    if (!Italic_type)
    {
        return nullptr;
    }

    py::pyobj_handle LineBreak_bases{PyTuple_Pack(1, Inline_type.get())};
    if (!LineBreak_bases)
    {
        return nullptr;
    }

    py::pytype_handle LineBreak_type{py::register_python_type(module.get(), &type_spec_LineBreak, LineBreak_bases.get(), inspectable_meta_type)};
    if (!LineBreak_type)
    {
        return nullptr;
    }

    py::pyobj_handle Paragraph_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(Block_type.get())))};
    if (!Paragraph_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Paragraph_Static{PyType_FromSpecWithBases(&type_spec_Paragraph_Static, Paragraph_Static_bases.get())};
    if (!type_Paragraph_Static)
    {
        return nullptr;
    }

    py::pyobj_handle Paragraph_bases{PyTuple_Pack(1, Block_type.get())};
    if (!Paragraph_bases)
    {
        return nullptr;
    }

    py::pytype_handle Paragraph_type{py::register_python_type(module.get(), &type_spec_Paragraph, Paragraph_bases.get(), reinterpret_cast<PyTypeObject*>(type_Paragraph_Static.get()))};
    if (!Paragraph_type)
    {
        return nullptr;
    }

    py::pyobj_handle Run_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(Inline_type.get())))};
    if (!Run_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Run_Static{PyType_FromSpecWithBases(&type_spec_Run_Static, Run_Static_bases.get())};
    if (!type_Run_Static)
    {
        return nullptr;
    }

    py::pyobj_handle Run_bases{PyTuple_Pack(1, Inline_type.get())};
    if (!Run_bases)
    {
        return nullptr;
    }

    py::pytype_handle Run_type{py::register_python_type(module.get(), &type_spec_Run, Run_bases.get(), reinterpret_cast<PyTypeObject*>(type_Run_Static.get()))};
    if (!Run_type)
    {
        return nullptr;
    }

    py::pyobj_handle TextHighlighter_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!TextHighlighter_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TextHighlighter_Static{PyType_FromSpecWithBases(&type_spec_TextHighlighter_Static, TextHighlighter_Static_bases.get())};
    if (!type_TextHighlighter_Static)
    {
        return nullptr;
    }

    py::pytype_handle TextHighlighter_type{py::register_python_type(module.get(), &type_spec_TextHighlighter, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TextHighlighter_Static.get()))};
    if (!TextHighlighter_type)
    {
        return nullptr;
    }

    py::pyobj_handle TextHighlighterBase_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_xaml_DependencyObject_type.get())))};
    if (!TextHighlighterBase_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_TextHighlighterBase_Static{PyType_FromSpecWithBases(&type_spec_TextHighlighterBase_Static, TextHighlighterBase_Static_bases.get())};
    if (!type_TextHighlighterBase_Static)
    {
        return nullptr;
    }

    py::pyobj_handle TextHighlighterBase_bases{PyTuple_Pack(1, microsoft_ui_xaml_DependencyObject_type.get())};
    if (!TextHighlighterBase_bases)
    {
        return nullptr;
    }

    py::pytype_handle TextHighlighterBase_type{py::register_python_type(module.get(), &type_spec_TextHighlighterBase, TextHighlighterBase_bases.get(), reinterpret_cast<PyTypeObject*>(type_TextHighlighterBase_Static.get()))};
    if (!TextHighlighterBase_type)
    {
        return nullptr;
    }

    py::pytype_handle TextPointer_type{py::register_python_type(module.get(), &type_spec_TextPointer, object_bases.get(), inspectable_meta_type)};
    if (!TextPointer_type)
    {
        return nullptr;
    }

    py::pyobj_handle Typography_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!Typography_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_Typography_Static{PyType_FromSpecWithBases(&type_spec_Typography_Static, Typography_Static_bases.get())};
    if (!type_Typography_Static)
    {
        return nullptr;
    }

    py::pytype_handle Typography_type{py::register_python_type(module.get(), &type_spec_Typography, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_Typography_Static.get()))};
    if (!Typography_type)
    {
        return nullptr;
    }

    py::pyobj_handle Underline_bases{PyTuple_Pack(1, Span_type.get())};
    if (!Underline_bases)
    {
        return nullptr;
    }

    py::pytype_handle Underline_type{py::register_python_type(module.get(), &type_spec_Underline, Underline_bases.get(), inspectable_meta_type)};
    if (!Underline_type)
    {
        return nullptr;
    }

    py::pytype_handle TextRange_type{py::register_python_type(module.get(), &type_spec_TextRange, nullptr, nullptr)};
    if (!TextRange_type)
    {
        return nullptr;
    }

    py::pyobj_handle TextRange_from_tuple_capsule{PyCapsule_New(reinterpret_cast<void*>(TextRange_from_tuple),"winrt._winrt_microsoft_ui_xaml_documents.TextRange_from_tuple", nullptr)};
    if (!TextRange_from_tuple_capsule)
    {
        return nullptr;
    }

    if (PyModule_AddObjectRef(module.get(), "TextRange_from_tuple", TextRange_from_tuple_capsule.get()) == -1)
    {
        return nullptr;
    }

    return module.detach();
}
