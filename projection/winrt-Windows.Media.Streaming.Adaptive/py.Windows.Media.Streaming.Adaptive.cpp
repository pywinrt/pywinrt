// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.2.0

#include "py.Windows.Media.Streaming.Adaptive.h"

namespace py::cpp::Windows::Media::Streaming::Adaptive
{
    // ----- AdaptiveMediaSource class --------------------

    static PyObject* _new_AdaptiveMediaSource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource>::type_name);
        return nullptr;
    }

    static void _dealloc_AdaptiveMediaSource(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AdaptiveMediaSource_Close(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_CreateFromStreamAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", L"CreateFromStreamAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource::CreateFromStreamAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", L"CreateFromStreamAsync", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Web::Http::HttpClient>(args, 3);

                return py::convert(winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource::CreateFromStreamAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_CreateFromUriAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", L"CreateFromUriAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource::CreateFromUriAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", L"CreateFromUriAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Web::Http::HttpClient>(args, 1);

                return py::convert(winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource::CreateFromUriAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_GetCorrelatedTimes(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", L"GetCorrelatedTimes", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetCorrelatedTimes());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_IsContentTypeSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", L"IsContentTypeSupported", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource::IsContentTypeSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_get_InitialBitrate(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", L"InitialBitrate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InitialBitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveMediaSource_put_InitialBitrate(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", L"InitialBitrate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.InitialBitrate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AdaptiveMediaSource_get_InboundBitsPerSecondWindow(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", L"InboundBitsPerSecondWindow");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InboundBitsPerSecondWindow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveMediaSource_put_InboundBitsPerSecondWindow(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", L"InboundBitsPerSecondWindow");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.InboundBitsPerSecondWindow(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AdaptiveMediaSource_get_DesiredMaxBitrate(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", L"DesiredMaxBitrate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DesiredMaxBitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveMediaSource_put_DesiredMaxBitrate(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", L"DesiredMaxBitrate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.DesiredMaxBitrate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AdaptiveMediaSource_get_DesiredLiveOffset(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", L"DesiredLiveOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DesiredLiveOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveMediaSource_put_DesiredLiveOffset(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", L"DesiredLiveOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.DesiredLiveOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AdaptiveMediaSource_get_DesiredMinBitrate(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", L"DesiredMinBitrate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DesiredMinBitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveMediaSource_put_DesiredMinBitrate(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", L"DesiredMinBitrate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.DesiredMinBitrate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AdaptiveMediaSource_get_CurrentPlaybackBitrate(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", L"CurrentPlaybackBitrate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CurrentPlaybackBitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_get_AudioOnlyPlayback(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", L"AudioOnlyPlayback");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AudioOnlyPlayback());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_get_InboundBitsPerSecond(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", L"InboundBitsPerSecond");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InboundBitsPerSecond());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_get_AvailableBitrates(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", L"AvailableBitrates");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AvailableBitrates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_get_CurrentDownloadBitrate(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", L"CurrentDownloadBitrate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CurrentDownloadBitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_get_IsLive(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", L"IsLive");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsLive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_get_AdvancedSettings(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", L"AdvancedSettings");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AdvancedSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_get_DesiredSeekableWindowSize(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", L"DesiredSeekableWindowSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DesiredSeekableWindowSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveMediaSource_put_DesiredSeekableWindowSize(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", L"DesiredSeekableWindowSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.DesiredSeekableWindowSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AdaptiveMediaSource_get_Diagnostics(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", L"Diagnostics");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Diagnostics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_get_MaxSeekableWindowSize(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", L"MaxSeekableWindowSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxSeekableWindowSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_get_MinLiveOffset(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", L"MinLiveOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinLiveOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_add_DownloadBitrateChanged(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", L"DownloadBitrateChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource, winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadBitrateChangedEventArgs>>(arg);

            return py::convert(self->obj.DownloadBitrateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_remove_DownloadBitrateChanged(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", L"DownloadBitrateChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DownloadBitrateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_add_DownloadCompleted(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", L"DownloadCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource, winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadCompletedEventArgs>>(arg);

            return py::convert(self->obj.DownloadCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_remove_DownloadCompleted(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", L"DownloadCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DownloadCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_add_DownloadFailed(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", L"DownloadFailed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource, winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadFailedEventArgs>>(arg);

            return py::convert(self->obj.DownloadFailed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_remove_DownloadFailed(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", L"DownloadFailed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DownloadFailed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_add_DownloadRequested(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", L"DownloadRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource, winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedEventArgs>>(arg);

            return py::convert(self->obj.DownloadRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_remove_DownloadRequested(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", L"DownloadRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DownloadRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_add_PlaybackBitrateChanged(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", L"PlaybackBitrateChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource, winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourcePlaybackBitrateChangedEventArgs>>(arg);

            return py::convert(self->obj.PlaybackBitrateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSource_remove_PlaybackBitrateChanged(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSource", L"PlaybackBitrateChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PlaybackBitrateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AdaptiveMediaSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AdaptiveMediaSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AdaptiveMediaSource(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_AdaptiveMediaSource(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdaptiveMediaSource[] = {
        { "close", reinterpret_cast<PyCFunction>(AdaptiveMediaSource_Close), METH_VARARGS, nullptr },
        { "get_correlated_times", reinterpret_cast<PyCFunction>(AdaptiveMediaSource_GetCorrelatedTimes), METH_VARARGS, nullptr },
        { "add_download_bitrate_changed", reinterpret_cast<PyCFunction>(AdaptiveMediaSource_add_DownloadBitrateChanged), METH_O, nullptr },
        { "remove_download_bitrate_changed", reinterpret_cast<PyCFunction>(AdaptiveMediaSource_remove_DownloadBitrateChanged), METH_O, nullptr },
        { "add_download_completed", reinterpret_cast<PyCFunction>(AdaptiveMediaSource_add_DownloadCompleted), METH_O, nullptr },
        { "remove_download_completed", reinterpret_cast<PyCFunction>(AdaptiveMediaSource_remove_DownloadCompleted), METH_O, nullptr },
        { "add_download_failed", reinterpret_cast<PyCFunction>(AdaptiveMediaSource_add_DownloadFailed), METH_O, nullptr },
        { "remove_download_failed", reinterpret_cast<PyCFunction>(AdaptiveMediaSource_remove_DownloadFailed), METH_O, nullptr },
        { "add_download_requested", reinterpret_cast<PyCFunction>(AdaptiveMediaSource_add_DownloadRequested), METH_O, nullptr },
        { "remove_download_requested", reinterpret_cast<PyCFunction>(AdaptiveMediaSource_remove_DownloadRequested), METH_O, nullptr },
        { "add_playback_bitrate_changed", reinterpret_cast<PyCFunction>(AdaptiveMediaSource_add_PlaybackBitrateChanged), METH_O, nullptr },
        { "remove_playback_bitrate_changed", reinterpret_cast<PyCFunction>(AdaptiveMediaSource_remove_PlaybackBitrateChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_AdaptiveMediaSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AdaptiveMediaSource), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AdaptiveMediaSource), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_AdaptiveMediaSource), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_AdaptiveMediaSource[] = {
        { "initial_bitrate", reinterpret_cast<getter>(AdaptiveMediaSource_get_InitialBitrate), reinterpret_cast<setter>(AdaptiveMediaSource_put_InitialBitrate), nullptr, nullptr },
        { "inbound_bits_per_second_window", reinterpret_cast<getter>(AdaptiveMediaSource_get_InboundBitsPerSecondWindow), reinterpret_cast<setter>(AdaptiveMediaSource_put_InboundBitsPerSecondWindow), nullptr, nullptr },
        { "desired_max_bitrate", reinterpret_cast<getter>(AdaptiveMediaSource_get_DesiredMaxBitrate), reinterpret_cast<setter>(AdaptiveMediaSource_put_DesiredMaxBitrate), nullptr, nullptr },
        { "desired_live_offset", reinterpret_cast<getter>(AdaptiveMediaSource_get_DesiredLiveOffset), reinterpret_cast<setter>(AdaptiveMediaSource_put_DesiredLiveOffset), nullptr, nullptr },
        { "desired_min_bitrate", reinterpret_cast<getter>(AdaptiveMediaSource_get_DesiredMinBitrate), reinterpret_cast<setter>(AdaptiveMediaSource_put_DesiredMinBitrate), nullptr, nullptr },
        { "current_playback_bitrate", reinterpret_cast<getter>(AdaptiveMediaSource_get_CurrentPlaybackBitrate), nullptr, nullptr, nullptr },
        { "audio_only_playback", reinterpret_cast<getter>(AdaptiveMediaSource_get_AudioOnlyPlayback), nullptr, nullptr, nullptr },
        { "inbound_bits_per_second", reinterpret_cast<getter>(AdaptiveMediaSource_get_InboundBitsPerSecond), nullptr, nullptr, nullptr },
        { "available_bitrates", reinterpret_cast<getter>(AdaptiveMediaSource_get_AvailableBitrates), nullptr, nullptr, nullptr },
        { "current_download_bitrate", reinterpret_cast<getter>(AdaptiveMediaSource_get_CurrentDownloadBitrate), nullptr, nullptr, nullptr },
        { "is_live", reinterpret_cast<getter>(AdaptiveMediaSource_get_IsLive), nullptr, nullptr, nullptr },
        { "advanced_settings", reinterpret_cast<getter>(AdaptiveMediaSource_get_AdvancedSettings), nullptr, nullptr, nullptr },
        { "desired_seekable_window_size", reinterpret_cast<getter>(AdaptiveMediaSource_get_DesiredSeekableWindowSize), reinterpret_cast<setter>(AdaptiveMediaSource_put_DesiredSeekableWindowSize), nullptr, nullptr },
        { "diagnostics", reinterpret_cast<getter>(AdaptiveMediaSource_get_Diagnostics), nullptr, nullptr, nullptr },
        { "max_seekable_window_size", reinterpret_cast<getter>(AdaptiveMediaSource_get_MaxSeekableWindowSize), nullptr, nullptr, nullptr },
        { "min_live_offset", reinterpret_cast<getter>(AdaptiveMediaSource_get_MinLiveOffset), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AdaptiveMediaSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AdaptiveMediaSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AdaptiveMediaSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AdaptiveMediaSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AdaptiveMediaSource) },
        { }
    };

    static PyType_Spec type_spec_AdaptiveMediaSource = {
        "winrt._winrt_windows_media_streaming_adaptive.AdaptiveMediaSource",
        sizeof(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdaptiveMediaSource};

    static PyGetSetDef getset_AdaptiveMediaSource_Static[] = {
        { }
    };

    static PyMethodDef methods_AdaptiveMediaSource_Static[] = {
        { "create_from_stream_async", reinterpret_cast<PyCFunction>(AdaptiveMediaSource_CreateFromStreamAsync), METH_VARARGS, nullptr },
        { "create_from_uri_async", reinterpret_cast<PyCFunction>(AdaptiveMediaSource_CreateFromUriAsync), METH_VARARGS, nullptr },
        { "is_content_type_supported", reinterpret_cast<PyCFunction>(AdaptiveMediaSource_IsContentTypeSupported), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AdaptiveMediaSource_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AdaptiveMediaSource_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AdaptiveMediaSource_Static) },
        { }
    };

    static PyType_Spec type_spec_AdaptiveMediaSource_Static =
    {
        "winrt._winrt_windows_media_streaming_adaptive.AdaptiveMediaSource_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AdaptiveMediaSource_Static
    };

    // ----- AdaptiveMediaSourceAdvancedSettings class --------------------

    static PyObject* _new_AdaptiveMediaSourceAdvancedSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceAdvancedSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceAdvancedSettings>::type_name);
        return nullptr;
    }

    static void _dealloc_AdaptiveMediaSourceAdvancedSettings(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceAdvancedSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AdaptiveMediaSourceAdvancedSettings_get_DesiredBitrateHeadroomRatio(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceAdvancedSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceAdvancedSettings", L"DesiredBitrateHeadroomRatio");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DesiredBitrateHeadroomRatio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveMediaSourceAdvancedSettings_put_DesiredBitrateHeadroomRatio(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceAdvancedSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceAdvancedSettings", L"DesiredBitrateHeadroomRatio");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<double>>(arg);

            self->obj.DesiredBitrateHeadroomRatio(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AdaptiveMediaSourceAdvancedSettings_get_BitrateDowngradeTriggerRatio(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceAdvancedSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceAdvancedSettings", L"BitrateDowngradeTriggerRatio");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BitrateDowngradeTriggerRatio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveMediaSourceAdvancedSettings_put_BitrateDowngradeTriggerRatio(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceAdvancedSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceAdvancedSettings", L"BitrateDowngradeTriggerRatio");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<double>>(arg);

            self->obj.BitrateDowngradeTriggerRatio(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AdaptiveMediaSourceAdvancedSettings_get_AllSegmentsIndependent(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceAdvancedSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceAdvancedSettings", L"AllSegmentsIndependent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllSegmentsIndependent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveMediaSourceAdvancedSettings_put_AllSegmentsIndependent(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceAdvancedSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceAdvancedSettings", L"AllSegmentsIndependent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllSegmentsIndependent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AdaptiveMediaSourceAdvancedSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceAdvancedSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AdaptiveMediaSourceAdvancedSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceAdvancedSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdaptiveMediaSourceAdvancedSettings[] = {
        { "_assign_array_", _assign_array_AdaptiveMediaSourceAdvancedSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AdaptiveMediaSourceAdvancedSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AdaptiveMediaSourceAdvancedSettings[] = {
        { "desired_bitrate_headroom_ratio", reinterpret_cast<getter>(AdaptiveMediaSourceAdvancedSettings_get_DesiredBitrateHeadroomRatio), reinterpret_cast<setter>(AdaptiveMediaSourceAdvancedSettings_put_DesiredBitrateHeadroomRatio), nullptr, nullptr },
        { "bitrate_downgrade_trigger_ratio", reinterpret_cast<getter>(AdaptiveMediaSourceAdvancedSettings_get_BitrateDowngradeTriggerRatio), reinterpret_cast<setter>(AdaptiveMediaSourceAdvancedSettings_put_BitrateDowngradeTriggerRatio), nullptr, nullptr },
        { "all_segments_independent", reinterpret_cast<getter>(AdaptiveMediaSourceAdvancedSettings_get_AllSegmentsIndependent), reinterpret_cast<setter>(AdaptiveMediaSourceAdvancedSettings_put_AllSegmentsIndependent), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AdaptiveMediaSourceAdvancedSettings[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AdaptiveMediaSourceAdvancedSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AdaptiveMediaSourceAdvancedSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AdaptiveMediaSourceAdvancedSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AdaptiveMediaSourceAdvancedSettings) },
        { }
    };

    static PyType_Spec type_spec_AdaptiveMediaSourceAdvancedSettings = {
        "winrt._winrt_windows_media_streaming_adaptive.AdaptiveMediaSourceAdvancedSettings",
        sizeof(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceAdvancedSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdaptiveMediaSourceAdvancedSettings};

    // ----- AdaptiveMediaSourceCorrelatedTimes class --------------------

    static PyObject* _new_AdaptiveMediaSourceCorrelatedTimes(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceCorrelatedTimes>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceCorrelatedTimes>::type_name);
        return nullptr;
    }

    static void _dealloc_AdaptiveMediaSourceCorrelatedTimes(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceCorrelatedTimes* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AdaptiveMediaSourceCorrelatedTimes_get_Position(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceCorrelatedTimes* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceCorrelatedTimes", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceCorrelatedTimes_get_PresentationTimeStamp(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceCorrelatedTimes* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceCorrelatedTimes", L"PresentationTimeStamp");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PresentationTimeStamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceCorrelatedTimes_get_ProgramDateTime(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceCorrelatedTimes* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceCorrelatedTimes", L"ProgramDateTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ProgramDateTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AdaptiveMediaSourceCorrelatedTimes(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceCorrelatedTimes>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AdaptiveMediaSourceCorrelatedTimes(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceCorrelatedTimes>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdaptiveMediaSourceCorrelatedTimes[] = {
        { "_assign_array_", _assign_array_AdaptiveMediaSourceCorrelatedTimes, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AdaptiveMediaSourceCorrelatedTimes), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AdaptiveMediaSourceCorrelatedTimes[] = {
        { "position", reinterpret_cast<getter>(AdaptiveMediaSourceCorrelatedTimes_get_Position), nullptr, nullptr, nullptr },
        { "presentation_time_stamp", reinterpret_cast<getter>(AdaptiveMediaSourceCorrelatedTimes_get_PresentationTimeStamp), nullptr, nullptr, nullptr },
        { "program_date_time", reinterpret_cast<getter>(AdaptiveMediaSourceCorrelatedTimes_get_ProgramDateTime), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AdaptiveMediaSourceCorrelatedTimes[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AdaptiveMediaSourceCorrelatedTimes) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AdaptiveMediaSourceCorrelatedTimes) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AdaptiveMediaSourceCorrelatedTimes) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AdaptiveMediaSourceCorrelatedTimes) },
        { }
    };

    static PyType_Spec type_spec_AdaptiveMediaSourceCorrelatedTimes = {
        "winrt._winrt_windows_media_streaming_adaptive.AdaptiveMediaSourceCorrelatedTimes",
        sizeof(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceCorrelatedTimes),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdaptiveMediaSourceCorrelatedTimes};

    // ----- AdaptiveMediaSourceCreationResult class --------------------

    static PyObject* _new_AdaptiveMediaSourceCreationResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceCreationResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceCreationResult>::type_name);
        return nullptr;
    }

    static void _dealloc_AdaptiveMediaSourceCreationResult(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceCreationResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AdaptiveMediaSourceCreationResult_get_HttpResponseMessage(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceCreationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceCreationResult", L"HttpResponseMessage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HttpResponseMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceCreationResult_get_MediaSource(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceCreationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceCreationResult", L"MediaSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MediaSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceCreationResult_get_Status(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceCreationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceCreationResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceCreationResult_get_ExtendedError(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceCreationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceCreationResult", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AdaptiveMediaSourceCreationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceCreationResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AdaptiveMediaSourceCreationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceCreationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdaptiveMediaSourceCreationResult[] = {
        { "_assign_array_", _assign_array_AdaptiveMediaSourceCreationResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AdaptiveMediaSourceCreationResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AdaptiveMediaSourceCreationResult[] = {
        { "http_response_message", reinterpret_cast<getter>(AdaptiveMediaSourceCreationResult_get_HttpResponseMessage), nullptr, nullptr, nullptr },
        { "media_source", reinterpret_cast<getter>(AdaptiveMediaSourceCreationResult_get_MediaSource), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(AdaptiveMediaSourceCreationResult_get_Status), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(AdaptiveMediaSourceCreationResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AdaptiveMediaSourceCreationResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AdaptiveMediaSourceCreationResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AdaptiveMediaSourceCreationResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AdaptiveMediaSourceCreationResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AdaptiveMediaSourceCreationResult) },
        { }
    };

    static PyType_Spec type_spec_AdaptiveMediaSourceCreationResult = {
        "winrt._winrt_windows_media_streaming_adaptive.AdaptiveMediaSourceCreationResult",
        sizeof(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceCreationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdaptiveMediaSourceCreationResult};

    // ----- AdaptiveMediaSourceDiagnosticAvailableEventArgs class --------------------

    static PyObject* _new_AdaptiveMediaSourceDiagnosticAvailableEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnosticAvailableEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnosticAvailableEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AdaptiveMediaSourceDiagnosticAvailableEventArgs(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnosticAvailableEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_Bitrate(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnosticAvailableEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDiagnosticAvailableEventArgs", L"Bitrate");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Bitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_DiagnosticType(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnosticAvailableEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDiagnosticAvailableEventArgs", L"DiagnosticType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DiagnosticType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_Position(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnosticAvailableEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDiagnosticAvailableEventArgs", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_RequestId(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnosticAvailableEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDiagnosticAvailableEventArgs", L"RequestId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RequestId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_ResourceByteRangeLength(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnosticAvailableEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDiagnosticAvailableEventArgs", L"ResourceByteRangeLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResourceByteRangeLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_ResourceByteRangeOffset(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnosticAvailableEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDiagnosticAvailableEventArgs", L"ResourceByteRangeOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResourceByteRangeOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_ResourceType(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnosticAvailableEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDiagnosticAvailableEventArgs", L"ResourceType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResourceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_ResourceUri(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnosticAvailableEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDiagnosticAvailableEventArgs", L"ResourceUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResourceUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_SegmentId(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnosticAvailableEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDiagnosticAvailableEventArgs", L"SegmentId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SegmentId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_ExtendedError(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnosticAvailableEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDiagnosticAvailableEventArgs", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_ResourceContentType(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnosticAvailableEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDiagnosticAvailableEventArgs", L"ResourceContentType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResourceContentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_ResourceDuration(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnosticAvailableEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDiagnosticAvailableEventArgs", L"ResourceDuration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResourceDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AdaptiveMediaSourceDiagnosticAvailableEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnosticAvailableEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AdaptiveMediaSourceDiagnosticAvailableEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnosticAvailableEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdaptiveMediaSourceDiagnosticAvailableEventArgs[] = {
        { "_assign_array_", _assign_array_AdaptiveMediaSourceDiagnosticAvailableEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AdaptiveMediaSourceDiagnosticAvailableEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AdaptiveMediaSourceDiagnosticAvailableEventArgs[] = {
        { "bitrate", reinterpret_cast<getter>(AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_Bitrate), nullptr, nullptr, nullptr },
        { "diagnostic_type", reinterpret_cast<getter>(AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_DiagnosticType), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_Position), nullptr, nullptr, nullptr },
        { "request_id", reinterpret_cast<getter>(AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_RequestId), nullptr, nullptr, nullptr },
        { "resource_byte_range_length", reinterpret_cast<getter>(AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_ResourceByteRangeLength), nullptr, nullptr, nullptr },
        { "resource_byte_range_offset", reinterpret_cast<getter>(AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_ResourceByteRangeOffset), nullptr, nullptr, nullptr },
        { "resource_type", reinterpret_cast<getter>(AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_ResourceType), nullptr, nullptr, nullptr },
        { "resource_uri", reinterpret_cast<getter>(AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_ResourceUri), nullptr, nullptr, nullptr },
        { "segment_id", reinterpret_cast<getter>(AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_SegmentId), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_ExtendedError), nullptr, nullptr, nullptr },
        { "resource_content_type", reinterpret_cast<getter>(AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_ResourceContentType), nullptr, nullptr, nullptr },
        { "resource_duration", reinterpret_cast<getter>(AdaptiveMediaSourceDiagnosticAvailableEventArgs_get_ResourceDuration), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AdaptiveMediaSourceDiagnosticAvailableEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AdaptiveMediaSourceDiagnosticAvailableEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AdaptiveMediaSourceDiagnosticAvailableEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AdaptiveMediaSourceDiagnosticAvailableEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AdaptiveMediaSourceDiagnosticAvailableEventArgs) },
        { }
    };

    static PyType_Spec type_spec_AdaptiveMediaSourceDiagnosticAvailableEventArgs = {
        "winrt._winrt_windows_media_streaming_adaptive.AdaptiveMediaSourceDiagnosticAvailableEventArgs",
        sizeof(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnosticAvailableEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdaptiveMediaSourceDiagnosticAvailableEventArgs};

    // ----- AdaptiveMediaSourceDiagnostics class --------------------

    static PyObject* _new_AdaptiveMediaSourceDiagnostics(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnostics>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnostics>::type_name);
        return nullptr;
    }

    static void _dealloc_AdaptiveMediaSourceDiagnostics(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnostics* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AdaptiveMediaSourceDiagnostics_add_DiagnosticAvailable(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnostics* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDiagnostics", L"DiagnosticAvailable");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnostics, winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnosticAvailableEventArgs>>(arg);

            return py::convert(self->obj.DiagnosticAvailable(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDiagnostics_remove_DiagnosticAvailable(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnostics* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDiagnostics", L"DiagnosticAvailable");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DiagnosticAvailable(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AdaptiveMediaSourceDiagnostics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnostics>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AdaptiveMediaSourceDiagnostics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnostics>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdaptiveMediaSourceDiagnostics[] = {
        { "add_diagnostic_available", reinterpret_cast<PyCFunction>(AdaptiveMediaSourceDiagnostics_add_DiagnosticAvailable), METH_O, nullptr },
        { "remove_diagnostic_available", reinterpret_cast<PyCFunction>(AdaptiveMediaSourceDiagnostics_remove_DiagnosticAvailable), METH_O, nullptr },
        { "_assign_array_", _assign_array_AdaptiveMediaSourceDiagnostics, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AdaptiveMediaSourceDiagnostics), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AdaptiveMediaSourceDiagnostics[] = {
        { }
    };

    static PyType_Slot _type_slots_AdaptiveMediaSourceDiagnostics[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AdaptiveMediaSourceDiagnostics) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AdaptiveMediaSourceDiagnostics) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AdaptiveMediaSourceDiagnostics) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AdaptiveMediaSourceDiagnostics) },
        { }
    };

    static PyType_Spec type_spec_AdaptiveMediaSourceDiagnostics = {
        "winrt._winrt_windows_media_streaming_adaptive.AdaptiveMediaSourceDiagnostics",
        sizeof(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDiagnostics),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdaptiveMediaSourceDiagnostics};

    // ----- AdaptiveMediaSourceDownloadBitrateChangedEventArgs class --------------------

    static PyObject* _new_AdaptiveMediaSourceDownloadBitrateChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadBitrateChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadBitrateChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AdaptiveMediaSourceDownloadBitrateChangedEventArgs(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadBitrateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AdaptiveMediaSourceDownloadBitrateChangedEventArgs_get_NewValue(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadBitrateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadBitrateChangedEventArgs", L"NewValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NewValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadBitrateChangedEventArgs_get_OldValue(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadBitrateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadBitrateChangedEventArgs", L"OldValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OldValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadBitrateChangedEventArgs_get_Reason(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadBitrateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadBitrateChangedEventArgs", L"Reason");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AdaptiveMediaSourceDownloadBitrateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadBitrateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AdaptiveMediaSourceDownloadBitrateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadBitrateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdaptiveMediaSourceDownloadBitrateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_AdaptiveMediaSourceDownloadBitrateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AdaptiveMediaSourceDownloadBitrateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AdaptiveMediaSourceDownloadBitrateChangedEventArgs[] = {
        { "new_value", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadBitrateChangedEventArgs_get_NewValue), nullptr, nullptr, nullptr },
        { "old_value", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadBitrateChangedEventArgs_get_OldValue), nullptr, nullptr, nullptr },
        { "reason", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadBitrateChangedEventArgs_get_Reason), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AdaptiveMediaSourceDownloadBitrateChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AdaptiveMediaSourceDownloadBitrateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AdaptiveMediaSourceDownloadBitrateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AdaptiveMediaSourceDownloadBitrateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AdaptiveMediaSourceDownloadBitrateChangedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_AdaptiveMediaSourceDownloadBitrateChangedEventArgs = {
        "winrt._winrt_windows_media_streaming_adaptive.AdaptiveMediaSourceDownloadBitrateChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadBitrateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdaptiveMediaSourceDownloadBitrateChangedEventArgs};

    // ----- AdaptiveMediaSourceDownloadCompletedEventArgs class --------------------

    static PyObject* _new_AdaptiveMediaSourceDownloadCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AdaptiveMediaSourceDownloadCompletedEventArgs(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AdaptiveMediaSourceDownloadCompletedEventArgs_get_HttpResponseMessage(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadCompletedEventArgs", L"HttpResponseMessage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HttpResponseMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadCompletedEventArgs_get_ResourceByteRangeLength(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadCompletedEventArgs", L"ResourceByteRangeLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResourceByteRangeLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadCompletedEventArgs_get_ResourceByteRangeOffset(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadCompletedEventArgs", L"ResourceByteRangeOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResourceByteRangeOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadCompletedEventArgs_get_ResourceType(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadCompletedEventArgs", L"ResourceType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResourceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadCompletedEventArgs_get_ResourceUri(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadCompletedEventArgs", L"ResourceUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResourceUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadCompletedEventArgs_get_Position(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadCompletedEventArgs", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadCompletedEventArgs_get_RequestId(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadCompletedEventArgs", L"RequestId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RequestId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadCompletedEventArgs_get_Statistics(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadCompletedEventArgs", L"Statistics");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Statistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadCompletedEventArgs_get_ResourceContentType(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadCompletedEventArgs", L"ResourceContentType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResourceContentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadCompletedEventArgs_get_ResourceDuration(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadCompletedEventArgs", L"ResourceDuration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResourceDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AdaptiveMediaSourceDownloadCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AdaptiveMediaSourceDownloadCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdaptiveMediaSourceDownloadCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_AdaptiveMediaSourceDownloadCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AdaptiveMediaSourceDownloadCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AdaptiveMediaSourceDownloadCompletedEventArgs[] = {
        { "http_response_message", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadCompletedEventArgs_get_HttpResponseMessage), nullptr, nullptr, nullptr },
        { "resource_byte_range_length", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadCompletedEventArgs_get_ResourceByteRangeLength), nullptr, nullptr, nullptr },
        { "resource_byte_range_offset", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadCompletedEventArgs_get_ResourceByteRangeOffset), nullptr, nullptr, nullptr },
        { "resource_type", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadCompletedEventArgs_get_ResourceType), nullptr, nullptr, nullptr },
        { "resource_uri", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadCompletedEventArgs_get_ResourceUri), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadCompletedEventArgs_get_Position), nullptr, nullptr, nullptr },
        { "request_id", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadCompletedEventArgs_get_RequestId), nullptr, nullptr, nullptr },
        { "statistics", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadCompletedEventArgs_get_Statistics), nullptr, nullptr, nullptr },
        { "resource_content_type", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadCompletedEventArgs_get_ResourceContentType), nullptr, nullptr, nullptr },
        { "resource_duration", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadCompletedEventArgs_get_ResourceDuration), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AdaptiveMediaSourceDownloadCompletedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AdaptiveMediaSourceDownloadCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AdaptiveMediaSourceDownloadCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AdaptiveMediaSourceDownloadCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AdaptiveMediaSourceDownloadCompletedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_AdaptiveMediaSourceDownloadCompletedEventArgs = {
        "winrt._winrt_windows_media_streaming_adaptive.AdaptiveMediaSourceDownloadCompletedEventArgs",
        sizeof(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdaptiveMediaSourceDownloadCompletedEventArgs};

    // ----- AdaptiveMediaSourceDownloadFailedEventArgs class --------------------

    static PyObject* _new_AdaptiveMediaSourceDownloadFailedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadFailedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadFailedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AdaptiveMediaSourceDownloadFailedEventArgs(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadFailedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AdaptiveMediaSourceDownloadFailedEventArgs_get_HttpResponseMessage(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadFailedEventArgs", L"HttpResponseMessage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HttpResponseMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadFailedEventArgs_get_ResourceByteRangeLength(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadFailedEventArgs", L"ResourceByteRangeLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResourceByteRangeLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadFailedEventArgs_get_ResourceByteRangeOffset(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadFailedEventArgs", L"ResourceByteRangeOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResourceByteRangeOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadFailedEventArgs_get_ResourceType(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadFailedEventArgs", L"ResourceType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResourceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadFailedEventArgs_get_ResourceUri(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadFailedEventArgs", L"ResourceUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResourceUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadFailedEventArgs_get_ExtendedError(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadFailedEventArgs", L"ExtendedError");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadFailedEventArgs_get_Position(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadFailedEventArgs", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadFailedEventArgs_get_RequestId(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadFailedEventArgs", L"RequestId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RequestId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadFailedEventArgs_get_Statistics(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadFailedEventArgs", L"Statistics");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Statistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadFailedEventArgs_get_ResourceContentType(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadFailedEventArgs", L"ResourceContentType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResourceContentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadFailedEventArgs_get_ResourceDuration(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadFailedEventArgs", L"ResourceDuration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResourceDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AdaptiveMediaSourceDownloadFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadFailedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AdaptiveMediaSourceDownloadFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadFailedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdaptiveMediaSourceDownloadFailedEventArgs[] = {
        { "_assign_array_", _assign_array_AdaptiveMediaSourceDownloadFailedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AdaptiveMediaSourceDownloadFailedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AdaptiveMediaSourceDownloadFailedEventArgs[] = {
        { "http_response_message", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadFailedEventArgs_get_HttpResponseMessage), nullptr, nullptr, nullptr },
        { "resource_byte_range_length", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadFailedEventArgs_get_ResourceByteRangeLength), nullptr, nullptr, nullptr },
        { "resource_byte_range_offset", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadFailedEventArgs_get_ResourceByteRangeOffset), nullptr, nullptr, nullptr },
        { "resource_type", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadFailedEventArgs_get_ResourceType), nullptr, nullptr, nullptr },
        { "resource_uri", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadFailedEventArgs_get_ResourceUri), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadFailedEventArgs_get_ExtendedError), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadFailedEventArgs_get_Position), nullptr, nullptr, nullptr },
        { "request_id", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadFailedEventArgs_get_RequestId), nullptr, nullptr, nullptr },
        { "statistics", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadFailedEventArgs_get_Statistics), nullptr, nullptr, nullptr },
        { "resource_content_type", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadFailedEventArgs_get_ResourceContentType), nullptr, nullptr, nullptr },
        { "resource_duration", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadFailedEventArgs_get_ResourceDuration), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AdaptiveMediaSourceDownloadFailedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AdaptiveMediaSourceDownloadFailedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AdaptiveMediaSourceDownloadFailedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AdaptiveMediaSourceDownloadFailedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AdaptiveMediaSourceDownloadFailedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_AdaptiveMediaSourceDownloadFailedEventArgs = {
        "winrt._winrt_windows_media_streaming_adaptive.AdaptiveMediaSourceDownloadFailedEventArgs",
        sizeof(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadFailedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdaptiveMediaSourceDownloadFailedEventArgs};

    // ----- AdaptiveMediaSourceDownloadRequestedDeferral class --------------------

    static PyObject* _new_AdaptiveMediaSourceDownloadRequestedDeferral(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedDeferral>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedDeferral>::type_name);
        return nullptr;
    }

    static void _dealloc_AdaptiveMediaSourceDownloadRequestedDeferral(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AdaptiveMediaSourceDownloadRequestedDeferral_Complete(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadRequestedDeferral", L"Complete", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_AdaptiveMediaSourceDownloadRequestedDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AdaptiveMediaSourceDownloadRequestedDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdaptiveMediaSourceDownloadRequestedDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(AdaptiveMediaSourceDownloadRequestedDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AdaptiveMediaSourceDownloadRequestedDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AdaptiveMediaSourceDownloadRequestedDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AdaptiveMediaSourceDownloadRequestedDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_AdaptiveMediaSourceDownloadRequestedDeferral[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AdaptiveMediaSourceDownloadRequestedDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AdaptiveMediaSourceDownloadRequestedDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AdaptiveMediaSourceDownloadRequestedDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AdaptiveMediaSourceDownloadRequestedDeferral) },
        { }
    };

    static PyType_Spec type_spec_AdaptiveMediaSourceDownloadRequestedDeferral = {
        "winrt._winrt_windows_media_streaming_adaptive.AdaptiveMediaSourceDownloadRequestedDeferral",
        sizeof(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdaptiveMediaSourceDownloadRequestedDeferral};

    // ----- AdaptiveMediaSourceDownloadRequestedEventArgs class --------------------

    static PyObject* _new_AdaptiveMediaSourceDownloadRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AdaptiveMediaSourceDownloadRequestedEventArgs(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AdaptiveMediaSourceDownloadRequestedEventArgs_GetDeferral(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadRequestedEventArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadRequestedEventArgs_get_ResourceByteRangeLength(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadRequestedEventArgs", L"ResourceByteRangeLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResourceByteRangeLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadRequestedEventArgs_get_ResourceByteRangeOffset(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadRequestedEventArgs", L"ResourceByteRangeOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResourceByteRangeOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadRequestedEventArgs_get_ResourceType(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadRequestedEventArgs", L"ResourceType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResourceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadRequestedEventArgs_get_ResourceUri(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadRequestedEventArgs", L"ResourceUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResourceUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadRequestedEventArgs_get_Result(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadRequestedEventArgs", L"Result");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Result());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadRequestedEventArgs_get_Position(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadRequestedEventArgs", L"Position");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadRequestedEventArgs_get_RequestId(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadRequestedEventArgs", L"RequestId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RequestId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadRequestedEventArgs_get_ResourceContentType(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadRequestedEventArgs", L"ResourceContentType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResourceContentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadRequestedEventArgs_get_ResourceDuration(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadRequestedEventArgs", L"ResourceDuration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResourceDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AdaptiveMediaSourceDownloadRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AdaptiveMediaSourceDownloadRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdaptiveMediaSourceDownloadRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(AdaptiveMediaSourceDownloadRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AdaptiveMediaSourceDownloadRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AdaptiveMediaSourceDownloadRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AdaptiveMediaSourceDownloadRequestedEventArgs[] = {
        { "resource_byte_range_length", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadRequestedEventArgs_get_ResourceByteRangeLength), nullptr, nullptr, nullptr },
        { "resource_byte_range_offset", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadRequestedEventArgs_get_ResourceByteRangeOffset), nullptr, nullptr, nullptr },
        { "resource_type", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadRequestedEventArgs_get_ResourceType), nullptr, nullptr, nullptr },
        { "resource_uri", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadRequestedEventArgs_get_ResourceUri), nullptr, nullptr, nullptr },
        { "result", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadRequestedEventArgs_get_Result), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadRequestedEventArgs_get_Position), nullptr, nullptr, nullptr },
        { "request_id", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadRequestedEventArgs_get_RequestId), nullptr, nullptr, nullptr },
        { "resource_content_type", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadRequestedEventArgs_get_ResourceContentType), nullptr, nullptr, nullptr },
        { "resource_duration", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadRequestedEventArgs_get_ResourceDuration), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AdaptiveMediaSourceDownloadRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AdaptiveMediaSourceDownloadRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AdaptiveMediaSourceDownloadRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AdaptiveMediaSourceDownloadRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AdaptiveMediaSourceDownloadRequestedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_AdaptiveMediaSourceDownloadRequestedEventArgs = {
        "winrt._winrt_windows_media_streaming_adaptive.AdaptiveMediaSourceDownloadRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdaptiveMediaSourceDownloadRequestedEventArgs};

    // ----- AdaptiveMediaSourceDownloadResult class --------------------

    static PyObject* _new_AdaptiveMediaSourceDownloadResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadResult>::type_name);
        return nullptr;
    }

    static void _dealloc_AdaptiveMediaSourceDownloadResult(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AdaptiveMediaSourceDownloadResult_get_ResourceUri(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadResult", L"ResourceUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResourceUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveMediaSourceDownloadResult_put_ResourceUri(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadResult", L"ResourceUri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.ResourceUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadResult_get_InputStream(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadResult", L"InputStream");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveMediaSourceDownloadResult_put_InputStream(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadResult", L"InputStream");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(arg);

            self->obj.InputStream(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadResult_get_ExtendedStatus(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadResult", L"ExtendedStatus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveMediaSourceDownloadResult_put_ExtendedStatus(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadResult", L"ExtendedStatus");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ExtendedStatus(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadResult_get_ContentType(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadResult", L"ContentType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveMediaSourceDownloadResult_put_ContentType(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadResult", L"ContentType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContentType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadResult_get_Buffer(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadResult", L"Buffer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Buffer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveMediaSourceDownloadResult_put_Buffer(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadResult", L"Buffer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            self->obj.Buffer(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadResult_get_ResourceByteRangeOffset(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadResult", L"ResourceByteRangeOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResourceByteRangeOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveMediaSourceDownloadResult_put_ResourceByteRangeOffset(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadResult", L"ResourceByteRangeOffset");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint64_t>>(arg);

            self->obj.ResourceByteRangeOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadResult_get_ResourceByteRangeLength(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadResult", L"ResourceByteRangeLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ResourceByteRangeLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdaptiveMediaSourceDownloadResult_put_ResourceByteRangeLength(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadResult", L"ResourceByteRangeLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint64_t>>(arg);

            self->obj.ResourceByteRangeLength(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AdaptiveMediaSourceDownloadResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AdaptiveMediaSourceDownloadResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdaptiveMediaSourceDownloadResult[] = {
        { "_assign_array_", _assign_array_AdaptiveMediaSourceDownloadResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AdaptiveMediaSourceDownloadResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AdaptiveMediaSourceDownloadResult[] = {
        { "resource_uri", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadResult_get_ResourceUri), reinterpret_cast<setter>(AdaptiveMediaSourceDownloadResult_put_ResourceUri), nullptr, nullptr },
        { "input_stream", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadResult_get_InputStream), reinterpret_cast<setter>(AdaptiveMediaSourceDownloadResult_put_InputStream), nullptr, nullptr },
        { "extended_status", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadResult_get_ExtendedStatus), reinterpret_cast<setter>(AdaptiveMediaSourceDownloadResult_put_ExtendedStatus), nullptr, nullptr },
        { "content_type", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadResult_get_ContentType), reinterpret_cast<setter>(AdaptiveMediaSourceDownloadResult_put_ContentType), nullptr, nullptr },
        { "buffer", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadResult_get_Buffer), reinterpret_cast<setter>(AdaptiveMediaSourceDownloadResult_put_Buffer), nullptr, nullptr },
        { "resource_byte_range_offset", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadResult_get_ResourceByteRangeOffset), reinterpret_cast<setter>(AdaptiveMediaSourceDownloadResult_put_ResourceByteRangeOffset), nullptr, nullptr },
        { "resource_byte_range_length", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadResult_get_ResourceByteRangeLength), reinterpret_cast<setter>(AdaptiveMediaSourceDownloadResult_put_ResourceByteRangeLength), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AdaptiveMediaSourceDownloadResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AdaptiveMediaSourceDownloadResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AdaptiveMediaSourceDownloadResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AdaptiveMediaSourceDownloadResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AdaptiveMediaSourceDownloadResult) },
        { }
    };

    static PyType_Spec type_spec_AdaptiveMediaSourceDownloadResult = {
        "winrt._winrt_windows_media_streaming_adaptive.AdaptiveMediaSourceDownloadResult",
        sizeof(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdaptiveMediaSourceDownloadResult};

    // ----- AdaptiveMediaSourceDownloadStatistics class --------------------

    static PyObject* _new_AdaptiveMediaSourceDownloadStatistics(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadStatistics>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadStatistics>::type_name);
        return nullptr;
    }

    static void _dealloc_AdaptiveMediaSourceDownloadStatistics(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadStatistics* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AdaptiveMediaSourceDownloadStatistics_get_ContentBytesReceivedCount(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadStatistics", L"ContentBytesReceivedCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentBytesReceivedCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadStatistics_get_TimeToFirstByteReceived(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadStatistics", L"TimeToFirstByteReceived");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TimeToFirstByteReceived());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadStatistics_get_TimeToHeadersReceived(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadStatistics", L"TimeToHeadersReceived");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TimeToHeadersReceived());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourceDownloadStatistics_get_TimeToLastByteReceived(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourceDownloadStatistics", L"TimeToLastByteReceived");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TimeToLastByteReceived());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AdaptiveMediaSourceDownloadStatistics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadStatistics>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AdaptiveMediaSourceDownloadStatistics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadStatistics>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdaptiveMediaSourceDownloadStatistics[] = {
        { "_assign_array_", _assign_array_AdaptiveMediaSourceDownloadStatistics, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AdaptiveMediaSourceDownloadStatistics), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AdaptiveMediaSourceDownloadStatistics[] = {
        { "content_bytes_received_count", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadStatistics_get_ContentBytesReceivedCount), nullptr, nullptr, nullptr },
        { "time_to_first_byte_received", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadStatistics_get_TimeToFirstByteReceived), nullptr, nullptr, nullptr },
        { "time_to_headers_received", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadStatistics_get_TimeToHeadersReceived), nullptr, nullptr, nullptr },
        { "time_to_last_byte_received", reinterpret_cast<getter>(AdaptiveMediaSourceDownloadStatistics_get_TimeToLastByteReceived), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AdaptiveMediaSourceDownloadStatistics[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AdaptiveMediaSourceDownloadStatistics) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AdaptiveMediaSourceDownloadStatistics) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AdaptiveMediaSourceDownloadStatistics) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AdaptiveMediaSourceDownloadStatistics) },
        { }
    };

    static PyType_Spec type_spec_AdaptiveMediaSourceDownloadStatistics = {
        "winrt._winrt_windows_media_streaming_adaptive.AdaptiveMediaSourceDownloadStatistics",
        sizeof(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourceDownloadStatistics),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdaptiveMediaSourceDownloadStatistics};

    // ----- AdaptiveMediaSourcePlaybackBitrateChangedEventArgs class --------------------

    static PyObject* _new_AdaptiveMediaSourcePlaybackBitrateChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourcePlaybackBitrateChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourcePlaybackBitrateChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AdaptiveMediaSourcePlaybackBitrateChangedEventArgs(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourcePlaybackBitrateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AdaptiveMediaSourcePlaybackBitrateChangedEventArgs_get_AudioOnly(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourcePlaybackBitrateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourcePlaybackBitrateChangedEventArgs", L"AudioOnly");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AudioOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourcePlaybackBitrateChangedEventArgs_get_NewValue(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourcePlaybackBitrateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourcePlaybackBitrateChangedEventArgs", L"NewValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NewValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdaptiveMediaSourcePlaybackBitrateChangedEventArgs_get_OldValue(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourcePlaybackBitrateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Streaming.Adaptive.AdaptiveMediaSourcePlaybackBitrateChangedEventArgs", L"OldValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OldValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AdaptiveMediaSourcePlaybackBitrateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourcePlaybackBitrateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AdaptiveMediaSourcePlaybackBitrateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourcePlaybackBitrateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdaptiveMediaSourcePlaybackBitrateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_AdaptiveMediaSourcePlaybackBitrateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AdaptiveMediaSourcePlaybackBitrateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AdaptiveMediaSourcePlaybackBitrateChangedEventArgs[] = {
        { "audio_only", reinterpret_cast<getter>(AdaptiveMediaSourcePlaybackBitrateChangedEventArgs_get_AudioOnly), nullptr, nullptr, nullptr },
        { "new_value", reinterpret_cast<getter>(AdaptiveMediaSourcePlaybackBitrateChangedEventArgs_get_NewValue), nullptr, nullptr, nullptr },
        { "old_value", reinterpret_cast<getter>(AdaptiveMediaSourcePlaybackBitrateChangedEventArgs_get_OldValue), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AdaptiveMediaSourcePlaybackBitrateChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AdaptiveMediaSourcePlaybackBitrateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AdaptiveMediaSourcePlaybackBitrateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AdaptiveMediaSourcePlaybackBitrateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AdaptiveMediaSourcePlaybackBitrateChangedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_AdaptiveMediaSourcePlaybackBitrateChangedEventArgs = {
        "winrt._winrt_windows_media_streaming_adaptive.AdaptiveMediaSourcePlaybackBitrateChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Streaming::Adaptive::AdaptiveMediaSourcePlaybackBitrateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdaptiveMediaSourcePlaybackBitrateChangedEventArgs};

    // ----- Windows.Media.Streaming.Adaptive Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Media.Streaming.Adaptive");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_media_streaming_adaptive",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Media::Streaming::Adaptive

PyMODINIT_FUNC PyInit__winrt_windows_media_streaming_adaptive(void) noexcept
{
    using namespace py::cpp::Windows::Media::Streaming::Adaptive;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AdaptiveMediaSource_Static{PyType_FromSpec(&type_spec_AdaptiveMediaSource_Static)};
    if (!type_AdaptiveMediaSource_Static)
    {
        return nullptr;
    }

    py::pytype_handle AdaptiveMediaSource_type{py::register_python_type(module.get(), &type_spec_AdaptiveMediaSource, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AdaptiveMediaSource_Static.get()))};
    if (!AdaptiveMediaSource_type)
    {
        return nullptr;
    }

    py::pytype_handle AdaptiveMediaSourceAdvancedSettings_type{py::register_python_type(module.get(), &type_spec_AdaptiveMediaSourceAdvancedSettings, object_bases.get(), nullptr)};
    if (!AdaptiveMediaSourceAdvancedSettings_type)
    {
        return nullptr;
    }

    py::pytype_handle AdaptiveMediaSourceCorrelatedTimes_type{py::register_python_type(module.get(), &type_spec_AdaptiveMediaSourceCorrelatedTimes, object_bases.get(), nullptr)};
    if (!AdaptiveMediaSourceCorrelatedTimes_type)
    {
        return nullptr;
    }

    py::pytype_handle AdaptiveMediaSourceCreationResult_type{py::register_python_type(module.get(), &type_spec_AdaptiveMediaSourceCreationResult, object_bases.get(), nullptr)};
    if (!AdaptiveMediaSourceCreationResult_type)
    {
        return nullptr;
    }

    py::pytype_handle AdaptiveMediaSourceDiagnosticAvailableEventArgs_type{py::register_python_type(module.get(), &type_spec_AdaptiveMediaSourceDiagnosticAvailableEventArgs, object_bases.get(), nullptr)};
    if (!AdaptiveMediaSourceDiagnosticAvailableEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle AdaptiveMediaSourceDiagnostics_type{py::register_python_type(module.get(), &type_spec_AdaptiveMediaSourceDiagnostics, object_bases.get(), nullptr)};
    if (!AdaptiveMediaSourceDiagnostics_type)
    {
        return nullptr;
    }

    py::pytype_handle AdaptiveMediaSourceDownloadBitrateChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_AdaptiveMediaSourceDownloadBitrateChangedEventArgs, object_bases.get(), nullptr)};
    if (!AdaptiveMediaSourceDownloadBitrateChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle AdaptiveMediaSourceDownloadCompletedEventArgs_type{py::register_python_type(module.get(), &type_spec_AdaptiveMediaSourceDownloadCompletedEventArgs, object_bases.get(), nullptr)};
    if (!AdaptiveMediaSourceDownloadCompletedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle AdaptiveMediaSourceDownloadFailedEventArgs_type{py::register_python_type(module.get(), &type_spec_AdaptiveMediaSourceDownloadFailedEventArgs, object_bases.get(), nullptr)};
    if (!AdaptiveMediaSourceDownloadFailedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle AdaptiveMediaSourceDownloadRequestedDeferral_type{py::register_python_type(module.get(), &type_spec_AdaptiveMediaSourceDownloadRequestedDeferral, object_bases.get(), nullptr)};
    if (!AdaptiveMediaSourceDownloadRequestedDeferral_type)
    {
        return nullptr;
    }

    py::pytype_handle AdaptiveMediaSourceDownloadRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_AdaptiveMediaSourceDownloadRequestedEventArgs, object_bases.get(), nullptr)};
    if (!AdaptiveMediaSourceDownloadRequestedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle AdaptiveMediaSourceDownloadResult_type{py::register_python_type(module.get(), &type_spec_AdaptiveMediaSourceDownloadResult, object_bases.get(), nullptr)};
    if (!AdaptiveMediaSourceDownloadResult_type)
    {
        return nullptr;
    }

    py::pytype_handle AdaptiveMediaSourceDownloadStatistics_type{py::register_python_type(module.get(), &type_spec_AdaptiveMediaSourceDownloadStatistics, object_bases.get(), nullptr)};
    if (!AdaptiveMediaSourceDownloadStatistics_type)
    {
        return nullptr;
    }

    py::pytype_handle AdaptiveMediaSourcePlaybackBitrateChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_AdaptiveMediaSourcePlaybackBitrateChangedEventArgs, object_bases.get(), nullptr)};
    if (!AdaptiveMediaSourcePlaybackBitrateChangedEventArgs_type)
    {
        return nullptr;
    }


    return module.detach();
}
