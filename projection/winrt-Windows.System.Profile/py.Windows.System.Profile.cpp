// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

#include "py.Windows.System.Profile.h"


namespace py::cpp::Windows::System::Profile
{
    // ----- AnalyticsInfo class --------------------

    static PyObject* _new_AnalyticsInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Profile::AnalyticsInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Profile::AnalyticsInfo>::type_name);
        return nullptr;
    }

    static PyObject* AnalyticsInfo_GetSystemPropertiesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Profile.AnalyticsInfo", L"GetSystemPropertiesAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(winrt::Windows::System::Profile::AnalyticsInfo::GetSystemPropertiesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AnalyticsInfo_get_DeviceForm(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.AnalyticsInfo", L"DeviceForm"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::AnalyticsInfo::DeviceForm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AnalyticsInfo_get_VersionInfo(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.AnalyticsInfo", L"VersionInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::AnalyticsInfo::VersionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AnalyticsInfo[] = {
        { }
    };

    static PyGetSetDef _getset_AnalyticsInfo[] = {
        { }
    };

    static PyType_Slot _type_slots_AnalyticsInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AnalyticsInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AnalyticsInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AnalyticsInfo) },
        { },
    };

    static PyType_Spec type_spec_AnalyticsInfo =
    {
        "winrt._winrt_windows_system_profile.AnalyticsInfo",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AnalyticsInfo
    };

    static PyGetSetDef getset_AnalyticsInfo_Static[] = {
        { "device_form", reinterpret_cast<getter>(AnalyticsInfo_get_DeviceForm), nullptr, nullptr, nullptr },
        { "version_info", reinterpret_cast<getter>(AnalyticsInfo_get_VersionInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_AnalyticsInfo_Static[] = {
        { "get_system_properties_async", reinterpret_cast<PyCFunction>(AnalyticsInfo_GetSystemPropertiesAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AnalyticsInfo_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AnalyticsInfo_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AnalyticsInfo_Static) },
        { }
    };

    static PyType_Spec type_spec_AnalyticsInfo_Static =
    {
        "winrt._winrt_windows_system_profile.AnalyticsInfo_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AnalyticsInfo_Static
    };

    // ----- AnalyticsVersionInfo class --------------------

    static PyObject* _new_AnalyticsVersionInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Profile::AnalyticsVersionInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Profile::AnalyticsVersionInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_AnalyticsVersionInfo(py::wrapper::Windows::System::Profile::AnalyticsVersionInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AnalyticsVersionInfo_get_DeviceFamily(py::wrapper::Windows::System::Profile::AnalyticsVersionInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.AnalyticsVersionInfo", L"DeviceFamily"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceFamily());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AnalyticsVersionInfo_get_DeviceFamilyVersion(py::wrapper::Windows::System::Profile::AnalyticsVersionInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.AnalyticsVersionInfo", L"DeviceFamilyVersion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceFamilyVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AnalyticsVersionInfo_get_ProductName(py::wrapper::Windows::System::Profile::AnalyticsVersionInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.AnalyticsVersionInfo", L"ProductName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProductName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AnalyticsVersionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Profile::AnalyticsVersionInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AnalyticsVersionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Profile::AnalyticsVersionInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AnalyticsVersionInfo[] = {
        { "_assign_array_", _assign_array_AnalyticsVersionInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AnalyticsVersionInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AnalyticsVersionInfo[] = {
        { "device_family", reinterpret_cast<getter>(AnalyticsVersionInfo_get_DeviceFamily), nullptr, nullptr, nullptr },
        { "device_family_version", reinterpret_cast<getter>(AnalyticsVersionInfo_get_DeviceFamilyVersion), nullptr, nullptr, nullptr },
        { "product_name", reinterpret_cast<getter>(AnalyticsVersionInfo_get_ProductName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AnalyticsVersionInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AnalyticsVersionInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AnalyticsVersionInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AnalyticsVersionInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AnalyticsVersionInfo) },
        { },
    };

    static PyType_Spec type_spec_AnalyticsVersionInfo =
    {
        "winrt._winrt_windows_system_profile.AnalyticsVersionInfo",
        sizeof(py::wrapper::Windows::System::Profile::AnalyticsVersionInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AnalyticsVersionInfo
    };

    // ----- AppApplicability class --------------------

    static PyObject* _new_AppApplicability(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Profile::AppApplicability>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Profile::AppApplicability>::type_name);
        return nullptr;
    }

    static PyObject* AppApplicability_GetUnsupportedAppRequirements(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Profile.AppApplicability", L"GetUnsupportedAppRequirements", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(winrt::Windows::System::Profile::AppApplicability::GetUnsupportedAppRequirements(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppApplicability[] = {
        { }
    };

    static PyGetSetDef _getset_AppApplicability[] = {
        { }
    };

    static PyType_Slot _type_slots_AppApplicability[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppApplicability) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppApplicability) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppApplicability) },
        { },
    };

    static PyType_Spec type_spec_AppApplicability =
    {
        "winrt._winrt_windows_system_profile.AppApplicability",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppApplicability
    };

    static PyGetSetDef getset_AppApplicability_Static[] = {
        { }
    };

    static PyMethodDef methods_AppApplicability_Static[] = {
        { "get_unsupported_app_requirements", reinterpret_cast<PyCFunction>(AppApplicability_GetUnsupportedAppRequirements), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AppApplicability_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AppApplicability_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AppApplicability_Static) },
        { }
    };

    static PyType_Spec type_spec_AppApplicability_Static =
    {
        "winrt._winrt_windows_system_profile.AppApplicability_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AppApplicability_Static
    };

    // ----- EducationSettings class --------------------

    static PyObject* _new_EducationSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Profile::EducationSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Profile::EducationSettings>::type_name);
        return nullptr;
    }

    static PyObject* EducationSettings_get_IsEducationEnvironment(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.EducationSettings", L"IsEducationEnvironment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::EducationSettings::IsEducationEnvironment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EducationSettings[] = {
        { }
    };

    static PyGetSetDef _getset_EducationSettings[] = {
        { }
    };

    static PyType_Slot _type_slots_EducationSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EducationSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EducationSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EducationSettings) },
        { },
    };

    static PyType_Spec type_spec_EducationSettings =
    {
        "winrt._winrt_windows_system_profile.EducationSettings",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EducationSettings
    };

    static PyGetSetDef getset_EducationSettings_Static[] = {
        { "is_education_environment", reinterpret_cast<getter>(EducationSettings_get_IsEducationEnvironment), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_EducationSettings_Static[] = {
        { }
    };

    static PyType_Slot type_slots_EducationSettings_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_EducationSettings_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_EducationSettings_Static) },
        { }
    };

    static PyType_Spec type_spec_EducationSettings_Static =
    {
        "winrt._winrt_windows_system_profile.EducationSettings_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_EducationSettings_Static
    };

    // ----- HardwareIdentification class --------------------

    static PyObject* _new_HardwareIdentification(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Profile::HardwareIdentification>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Profile::HardwareIdentification>::type_name);
        return nullptr;
    }

    static PyObject* HardwareIdentification_GetPackageSpecificToken(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Profile.HardwareIdentification", L"GetPackageSpecificToken", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(winrt::Windows::System::Profile::HardwareIdentification::GetPackageSpecificToken(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_HardwareIdentification[] = {
        { }
    };

    static PyGetSetDef _getset_HardwareIdentification[] = {
        { }
    };

    static PyType_Slot _type_slots_HardwareIdentification[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HardwareIdentification) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HardwareIdentification) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HardwareIdentification) },
        { },
    };

    static PyType_Spec type_spec_HardwareIdentification =
    {
        "winrt._winrt_windows_system_profile.HardwareIdentification",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HardwareIdentification
    };

    static PyGetSetDef getset_HardwareIdentification_Static[] = {
        { }
    };

    static PyMethodDef methods_HardwareIdentification_Static[] = {
        { "get_package_specific_token", reinterpret_cast<PyCFunction>(HardwareIdentification_GetPackageSpecificToken), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_HardwareIdentification_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HardwareIdentification_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HardwareIdentification_Static) },
        { }
    };

    static PyType_Spec type_spec_HardwareIdentification_Static =
    {
        "winrt._winrt_windows_system_profile.HardwareIdentification_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_HardwareIdentification_Static
    };

    // ----- HardwareToken class --------------------

    static PyObject* _new_HardwareToken(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Profile::HardwareToken>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Profile::HardwareToken>::type_name);
        return nullptr;
    }

    static void _dealloc_HardwareToken(py::wrapper::Windows::System::Profile::HardwareToken* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HardwareToken_get_Certificate(py::wrapper::Windows::System::Profile::HardwareToken* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.HardwareToken", L"Certificate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Certificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HardwareToken_get_Id(py::wrapper::Windows::System::Profile::HardwareToken* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.HardwareToken", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HardwareToken_get_Signature(py::wrapper::Windows::System::Profile::HardwareToken* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.HardwareToken", L"Signature"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Signature());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HardwareToken(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Profile::HardwareToken>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HardwareToken(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Profile::HardwareToken>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HardwareToken[] = {
        { "_assign_array_", _assign_array_HardwareToken, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HardwareToken), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HardwareToken[] = {
        { "certificate", reinterpret_cast<getter>(HardwareToken_get_Certificate), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(HardwareToken_get_Id), nullptr, nullptr, nullptr },
        { "signature", reinterpret_cast<getter>(HardwareToken_get_Signature), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HardwareToken[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HardwareToken) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HardwareToken) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HardwareToken) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HardwareToken) },
        { },
    };

    static PyType_Spec type_spec_HardwareToken =
    {
        "winrt._winrt_windows_system_profile.HardwareToken",
        sizeof(py::wrapper::Windows::System::Profile::HardwareToken),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HardwareToken
    };

    // ----- KnownRetailInfoProperties class --------------------

    static PyObject* _new_KnownRetailInfoProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Profile::KnownRetailInfoProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Profile::KnownRetailInfoProperties>::type_name);
        return nullptr;
    }

    static PyObject* KnownRetailInfoProperties_get_BatteryLifeDescription(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"BatteryLifeDescription"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::BatteryLifeDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_DisplayDescription(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"DisplayDescription"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::DisplayDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_DisplayModelName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"DisplayModelName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::DisplayModelName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_FormFactor(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"FormFactor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::FormFactor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_FrontCameraDescription(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"FrontCameraDescription"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::FrontCameraDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_GraphicsDescription(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"GraphicsDescription"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::GraphicsDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_HasNfc(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"HasNfc"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::HasNfc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_HasOpticalDrive(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"HasOpticalDrive"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::HasOpticalDrive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_HasSdSlot(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"HasSdSlot"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::HasSdSlot());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_IsFeatured(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"IsFeatured"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::IsFeatured());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_IsOfficeInstalled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"IsOfficeInstalled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::IsOfficeInstalled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_ManufacturerName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"ManufacturerName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::ManufacturerName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_Memory(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"Memory"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::Memory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_ModelName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"ModelName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::ModelName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_Price(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"Price"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::Price());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_ProcessorDescription(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"ProcessorDescription"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::ProcessorDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_RearCameraDescription(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"RearCameraDescription"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::RearCameraDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_RetailAccessCode(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"RetailAccessCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::RetailAccessCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_ScreenSize(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"ScreenSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::ScreenSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_StorageDescription(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"StorageDescription"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::StorageDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_Weight(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"Weight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::Weight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRetailInfoProperties_get_WindowsEdition(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.KnownRetailInfoProperties", L"WindowsEdition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::KnownRetailInfoProperties::WindowsEdition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownRetailInfoProperties[] = {
        { }
    };

    static PyGetSetDef _getset_KnownRetailInfoProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownRetailInfoProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownRetailInfoProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownRetailInfoProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownRetailInfoProperties) },
        { },
    };

    static PyType_Spec type_spec_KnownRetailInfoProperties =
    {
        "winrt._winrt_windows_system_profile.KnownRetailInfoProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownRetailInfoProperties
    };

    static PyGetSetDef getset_KnownRetailInfoProperties_Static[] = {
        { "battery_life_description", reinterpret_cast<getter>(KnownRetailInfoProperties_get_BatteryLifeDescription), nullptr, nullptr, nullptr },
        { "display_description", reinterpret_cast<getter>(KnownRetailInfoProperties_get_DisplayDescription), nullptr, nullptr, nullptr },
        { "display_model_name", reinterpret_cast<getter>(KnownRetailInfoProperties_get_DisplayModelName), nullptr, nullptr, nullptr },
        { "form_factor", reinterpret_cast<getter>(KnownRetailInfoProperties_get_FormFactor), nullptr, nullptr, nullptr },
        { "front_camera_description", reinterpret_cast<getter>(KnownRetailInfoProperties_get_FrontCameraDescription), nullptr, nullptr, nullptr },
        { "graphics_description", reinterpret_cast<getter>(KnownRetailInfoProperties_get_GraphicsDescription), nullptr, nullptr, nullptr },
        { "has_nfc", reinterpret_cast<getter>(KnownRetailInfoProperties_get_HasNfc), nullptr, nullptr, nullptr },
        { "has_optical_drive", reinterpret_cast<getter>(KnownRetailInfoProperties_get_HasOpticalDrive), nullptr, nullptr, nullptr },
        { "has_sd_slot", reinterpret_cast<getter>(KnownRetailInfoProperties_get_HasSdSlot), nullptr, nullptr, nullptr },
        { "is_featured", reinterpret_cast<getter>(KnownRetailInfoProperties_get_IsFeatured), nullptr, nullptr, nullptr },
        { "is_office_installed", reinterpret_cast<getter>(KnownRetailInfoProperties_get_IsOfficeInstalled), nullptr, nullptr, nullptr },
        { "manufacturer_name", reinterpret_cast<getter>(KnownRetailInfoProperties_get_ManufacturerName), nullptr, nullptr, nullptr },
        { "memory", reinterpret_cast<getter>(KnownRetailInfoProperties_get_Memory), nullptr, nullptr, nullptr },
        { "model_name", reinterpret_cast<getter>(KnownRetailInfoProperties_get_ModelName), nullptr, nullptr, nullptr },
        { "price", reinterpret_cast<getter>(KnownRetailInfoProperties_get_Price), nullptr, nullptr, nullptr },
        { "processor_description", reinterpret_cast<getter>(KnownRetailInfoProperties_get_ProcessorDescription), nullptr, nullptr, nullptr },
        { "rear_camera_description", reinterpret_cast<getter>(KnownRetailInfoProperties_get_RearCameraDescription), nullptr, nullptr, nullptr },
        { "retail_access_code", reinterpret_cast<getter>(KnownRetailInfoProperties_get_RetailAccessCode), nullptr, nullptr, nullptr },
        { "screen_size", reinterpret_cast<getter>(KnownRetailInfoProperties_get_ScreenSize), nullptr, nullptr, nullptr },
        { "storage_description", reinterpret_cast<getter>(KnownRetailInfoProperties_get_StorageDescription), nullptr, nullptr, nullptr },
        { "weight", reinterpret_cast<getter>(KnownRetailInfoProperties_get_Weight), nullptr, nullptr, nullptr },
        { "windows_edition", reinterpret_cast<getter>(KnownRetailInfoProperties_get_WindowsEdition), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_KnownRetailInfoProperties_Static[] = {
        { }
    };

    static PyType_Slot type_slots_KnownRetailInfoProperties_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownRetailInfoProperties_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_KnownRetailInfoProperties_Static) },
        { }
    };

    static PyType_Spec type_spec_KnownRetailInfoProperties_Static =
    {
        "winrt._winrt_windows_system_profile.KnownRetailInfoProperties_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownRetailInfoProperties_Static
    };

    // ----- PlatformDiagnosticsAndUsageDataSettings class --------------------

    static PyObject* _new_PlatformDiagnosticsAndUsageDataSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Profile::PlatformDiagnosticsAndUsageDataSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Profile::PlatformDiagnosticsAndUsageDataSettings>::type_name);
        return nullptr;
    }

    static PyObject* PlatformDiagnosticsAndUsageDataSettings_CanCollectDiagnostics(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Profile.PlatformDiagnosticsAndUsageDataSettings", L"CanCollectDiagnostics", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::Profile::PlatformDataCollectionLevel>(args, 0);

                return py::convert(winrt::Windows::System::Profile::PlatformDiagnosticsAndUsageDataSettings::CanCollectDiagnostics(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlatformDiagnosticsAndUsageDataSettings_get_CollectionLevel(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.PlatformDiagnosticsAndUsageDataSettings", L"CollectionLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::PlatformDiagnosticsAndUsageDataSettings::CollectionLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlatformDiagnosticsAndUsageDataSettings_add_CollectionLevelChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.Profile.PlatformDiagnosticsAndUsageDataSettings", L"CollectionLevelChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::System::Profile::PlatformDiagnosticsAndUsageDataSettings::CollectionLevelChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlatformDiagnosticsAndUsageDataSettings_remove_CollectionLevelChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.Profile.PlatformDiagnosticsAndUsageDataSettings", L"CollectionLevelChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::System::Profile::PlatformDiagnosticsAndUsageDataSettings::CollectionLevelChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlatformDiagnosticsAndUsageDataSettings[] = {
        { "add_collection_level_changed", reinterpret_cast<PyCFunction>(PlatformDiagnosticsAndUsageDataSettings_add_CollectionLevelChanged), METH_O | METH_STATIC, nullptr },
        { "remove_collection_level_changed", reinterpret_cast<PyCFunction>(PlatformDiagnosticsAndUsageDataSettings_remove_CollectionLevelChanged), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlatformDiagnosticsAndUsageDataSettings[] = {
        { }
    };

    static PyType_Slot _type_slots_PlatformDiagnosticsAndUsageDataSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PlatformDiagnosticsAndUsageDataSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PlatformDiagnosticsAndUsageDataSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PlatformDiagnosticsAndUsageDataSettings) },
        { },
    };

    static PyType_Spec type_spec_PlatformDiagnosticsAndUsageDataSettings =
    {
        "winrt._winrt_windows_system_profile.PlatformDiagnosticsAndUsageDataSettings",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlatformDiagnosticsAndUsageDataSettings
    };

    static PyGetSetDef getset_PlatformDiagnosticsAndUsageDataSettings_Static[] = {
        { "collection_level", reinterpret_cast<getter>(PlatformDiagnosticsAndUsageDataSettings_get_CollectionLevel), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_PlatformDiagnosticsAndUsageDataSettings_Static[] = {
        { "can_collect_diagnostics", reinterpret_cast<PyCFunction>(PlatformDiagnosticsAndUsageDataSettings_CanCollectDiagnostics), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_PlatformDiagnosticsAndUsageDataSettings_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PlatformDiagnosticsAndUsageDataSettings_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PlatformDiagnosticsAndUsageDataSettings_Static) },
        { }
    };

    static PyType_Spec type_spec_PlatformDiagnosticsAndUsageDataSettings_Static =
    {
        "winrt._winrt_windows_system_profile.PlatformDiagnosticsAndUsageDataSettings_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PlatformDiagnosticsAndUsageDataSettings_Static
    };

    // ----- RetailInfo class --------------------

    static PyObject* _new_RetailInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Profile::RetailInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Profile::RetailInfo>::type_name);
        return nullptr;
    }

    static PyObject* RetailInfo_get_IsDemoModeEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.RetailInfo", L"IsDemoModeEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::RetailInfo::IsDemoModeEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RetailInfo_get_Properties(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.RetailInfo", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::RetailInfo::Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RetailInfo[] = {
        { }
    };

    static PyGetSetDef _getset_RetailInfo[] = {
        { }
    };

    static PyType_Slot _type_slots_RetailInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_RetailInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RetailInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RetailInfo) },
        { },
    };

    static PyType_Spec type_spec_RetailInfo =
    {
        "winrt._winrt_windows_system_profile.RetailInfo",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RetailInfo
    };

    static PyGetSetDef getset_RetailInfo_Static[] = {
        { "is_demo_mode_enabled", reinterpret_cast<getter>(RetailInfo_get_IsDemoModeEnabled), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(RetailInfo_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_RetailInfo_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RetailInfo_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RetailInfo_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RetailInfo_Static) },
        { }
    };

    static PyType_Spec type_spec_RetailInfo_Static =
    {
        "winrt._winrt_windows_system_profile.RetailInfo_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RetailInfo_Static
    };

    // ----- SharedModeSettings class --------------------

    static PyObject* _new_SharedModeSettings(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Profile::SharedModeSettings>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Profile::SharedModeSettings>::type_name);
        return nullptr;
    }

    static PyObject* SharedModeSettings_get_IsEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.SharedModeSettings", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::SharedModeSettings::IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SharedModeSettings_get_ShouldAvoidLocalStorage(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.SharedModeSettings", L"ShouldAvoidLocalStorage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::SharedModeSettings::ShouldAvoidLocalStorage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SharedModeSettings[] = {
        { }
    };

    static PyGetSetDef _getset_SharedModeSettings[] = {
        { }
    };

    static PyType_Slot _type_slots_SharedModeSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SharedModeSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SharedModeSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SharedModeSettings) },
        { },
    };

    static PyType_Spec type_spec_SharedModeSettings =
    {
        "winrt._winrt_windows_system_profile.SharedModeSettings",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SharedModeSettings
    };

    static PyGetSetDef getset_SharedModeSettings_Static[] = {
        { "is_enabled", reinterpret_cast<getter>(SharedModeSettings_get_IsEnabled), nullptr, nullptr, nullptr },
        { "should_avoid_local_storage", reinterpret_cast<getter>(SharedModeSettings_get_ShouldAvoidLocalStorage), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_SharedModeSettings_Static[] = {
        { }
    };

    static PyType_Slot type_slots_SharedModeSettings_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SharedModeSettings_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SharedModeSettings_Static) },
        { }
    };

    static PyType_Spec type_spec_SharedModeSettings_Static =
    {
        "winrt._winrt_windows_system_profile.SharedModeSettings_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SharedModeSettings_Static
    };

    // ----- SmartAppControlPolicy class --------------------

    static PyObject* _new_SmartAppControlPolicy(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Profile::SmartAppControlPolicy>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Profile::SmartAppControlPolicy>::type_name);
        return nullptr;
    }

    static PyObject* SmartAppControlPolicy_get_IsEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.SmartAppControlPolicy", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::SmartAppControlPolicy::IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartAppControlPolicy_add_Changed(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.Profile.SmartAppControlPolicy", L"Changed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::System::Profile::SmartAppControlPolicy::Changed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmartAppControlPolicy_remove_Changed(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.Profile.SmartAppControlPolicy", L"Changed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::System::Profile::SmartAppControlPolicy::Changed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmartAppControlPolicy[] = {
        { "add_changed", reinterpret_cast<PyCFunction>(SmartAppControlPolicy_add_Changed), METH_O | METH_STATIC, nullptr },
        { "remove_changed", reinterpret_cast<PyCFunction>(SmartAppControlPolicy_remove_Changed), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmartAppControlPolicy[] = {
        { }
    };

    static PyType_Slot _type_slots_SmartAppControlPolicy[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SmartAppControlPolicy) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SmartAppControlPolicy) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SmartAppControlPolicy) },
        { },
    };

    static PyType_Spec type_spec_SmartAppControlPolicy =
    {
        "winrt._winrt_windows_system_profile.SmartAppControlPolicy",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmartAppControlPolicy
    };

    static PyGetSetDef getset_SmartAppControlPolicy_Static[] = {
        { "is_enabled", reinterpret_cast<getter>(SmartAppControlPolicy_get_IsEnabled), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_SmartAppControlPolicy_Static[] = {
        { }
    };

    static PyType_Slot type_slots_SmartAppControlPolicy_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SmartAppControlPolicy_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SmartAppControlPolicy_Static) },
        { }
    };

    static PyType_Spec type_spec_SmartAppControlPolicy_Static =
    {
        "winrt._winrt_windows_system_profile.SmartAppControlPolicy_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SmartAppControlPolicy_Static
    };

    // ----- SystemIdentification class --------------------

    static PyObject* _new_SystemIdentification(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Profile::SystemIdentification>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Profile::SystemIdentification>::type_name);
        return nullptr;
    }

    static PyObject* SystemIdentification_GetSystemIdForPublisher(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Profile.SystemIdentification", L"GetSystemIdForPublisher", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::System::Profile::SystemIdentification::GetSystemIdForPublisher());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SystemIdentification_GetSystemIdForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.System.Profile.SystemIdentification", L"GetSystemIdForUser", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::System::Profile::SystemIdentification::GetSystemIdForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemIdentification[] = {
        { }
    };

    static PyGetSetDef _getset_SystemIdentification[] = {
        { }
    };

    static PyType_Slot _type_slots_SystemIdentification[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemIdentification) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemIdentification) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemIdentification) },
        { },
    };

    static PyType_Spec type_spec_SystemIdentification =
    {
        "winrt._winrt_windows_system_profile.SystemIdentification",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemIdentification
    };

    static PyGetSetDef getset_SystemIdentification_Static[] = {
        { }
    };

    static PyMethodDef methods_SystemIdentification_Static[] = {
        { "get_system_id_for_publisher", reinterpret_cast<PyCFunction>(SystemIdentification_GetSystemIdForPublisher), METH_VARARGS, nullptr },
        { "get_system_id_for_user", reinterpret_cast<PyCFunction>(SystemIdentification_GetSystemIdForUser), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_SystemIdentification_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SystemIdentification_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SystemIdentification_Static) },
        { }
    };

    static PyType_Spec type_spec_SystemIdentification_Static =
    {
        "winrt._winrt_windows_system_profile.SystemIdentification_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SystemIdentification_Static
    };

    // ----- SystemIdentificationInfo class --------------------

    static PyObject* _new_SystemIdentificationInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Profile::SystemIdentificationInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Profile::SystemIdentificationInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_SystemIdentificationInfo(py::wrapper::Windows::System::Profile::SystemIdentificationInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SystemIdentificationInfo_get_Id(py::wrapper::Windows::System::Profile::SystemIdentificationInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.SystemIdentificationInfo", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemIdentificationInfo_get_Source(py::wrapper::Windows::System::Profile::SystemIdentificationInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.SystemIdentificationInfo", L"Source"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SystemIdentificationInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Profile::SystemIdentificationInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SystemIdentificationInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Profile::SystemIdentificationInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemIdentificationInfo[] = {
        { "_assign_array_", _assign_array_SystemIdentificationInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemIdentificationInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemIdentificationInfo[] = {
        { "id", reinterpret_cast<getter>(SystemIdentificationInfo_get_Id), nullptr, nullptr, nullptr },
        { "source", reinterpret_cast<getter>(SystemIdentificationInfo_get_Source), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SystemIdentificationInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemIdentificationInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SystemIdentificationInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemIdentificationInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemIdentificationInfo) },
        { },
    };

    static PyType_Spec type_spec_SystemIdentificationInfo =
    {
        "winrt._winrt_windows_system_profile.SystemIdentificationInfo",
        sizeof(py::wrapper::Windows::System::Profile::SystemIdentificationInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemIdentificationInfo
    };

    // ----- SystemSetupInfo class --------------------

    static PyObject* _new_SystemSetupInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Profile::SystemSetupInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Profile::SystemSetupInfo>::type_name);
        return nullptr;
    }

    static PyObject* SystemSetupInfo_get_OutOfBoxExperienceState(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.SystemSetupInfo", L"OutOfBoxExperienceState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::SystemSetupInfo::OutOfBoxExperienceState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemSetupInfo_add_OutOfBoxExperienceStateChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.Profile.SystemSetupInfo", L"OutOfBoxExperienceStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::System::Profile::SystemSetupInfo::OutOfBoxExperienceStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemSetupInfo_remove_OutOfBoxExperienceStateChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.Profile.SystemSetupInfo", L"OutOfBoxExperienceStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::System::Profile::SystemSetupInfo::OutOfBoxExperienceStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemSetupInfo[] = {
        { "add_out_of_box_experience_state_changed", reinterpret_cast<PyCFunction>(SystemSetupInfo_add_OutOfBoxExperienceStateChanged), METH_O | METH_STATIC, nullptr },
        { "remove_out_of_box_experience_state_changed", reinterpret_cast<PyCFunction>(SystemSetupInfo_remove_OutOfBoxExperienceStateChanged), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemSetupInfo[] = {
        { }
    };

    static PyType_Slot _type_slots_SystemSetupInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SystemSetupInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SystemSetupInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SystemSetupInfo) },
        { },
    };

    static PyType_Spec type_spec_SystemSetupInfo =
    {
        "winrt._winrt_windows_system_profile.SystemSetupInfo",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemSetupInfo
    };

    static PyGetSetDef getset_SystemSetupInfo_Static[] = {
        { "out_of_box_experience_state", reinterpret_cast<getter>(SystemSetupInfo_get_OutOfBoxExperienceState), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_SystemSetupInfo_Static[] = {
        { }
    };

    static PyType_Slot type_slots_SystemSetupInfo_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SystemSetupInfo_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SystemSetupInfo_Static) },
        { }
    };

    static PyType_Spec type_spec_SystemSetupInfo_Static =
    {
        "winrt._winrt_windows_system_profile.SystemSetupInfo_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SystemSetupInfo_Static
    };

    // ----- UnsupportedAppRequirement class --------------------

    static PyObject* _new_UnsupportedAppRequirement(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Profile::UnsupportedAppRequirement>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Profile::UnsupportedAppRequirement>::type_name);
        return nullptr;
    }

    static void _dealloc_UnsupportedAppRequirement(py::wrapper::Windows::System::Profile::UnsupportedAppRequirement* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UnsupportedAppRequirement_get_Reasons(py::wrapper::Windows::System::Profile::UnsupportedAppRequirement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.UnsupportedAppRequirement", L"Reasons"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Reasons());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UnsupportedAppRequirement_get_Requirement(py::wrapper::Windows::System::Profile::UnsupportedAppRequirement* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.UnsupportedAppRequirement", L"Requirement"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Requirement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UnsupportedAppRequirement(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::System::Profile::UnsupportedAppRequirement>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UnsupportedAppRequirement(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Profile::UnsupportedAppRequirement>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UnsupportedAppRequirement[] = {
        { "_assign_array_", _assign_array_UnsupportedAppRequirement, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UnsupportedAppRequirement), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UnsupportedAppRequirement[] = {
        { "reasons", reinterpret_cast<getter>(UnsupportedAppRequirement_get_Reasons), nullptr, nullptr, nullptr },
        { "requirement", reinterpret_cast<getter>(UnsupportedAppRequirement_get_Requirement), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UnsupportedAppRequirement[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_UnsupportedAppRequirement) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UnsupportedAppRequirement) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UnsupportedAppRequirement) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UnsupportedAppRequirement) },
        { },
    };

    static PyType_Spec type_spec_UnsupportedAppRequirement =
    {
        "winrt._winrt_windows_system_profile.UnsupportedAppRequirement",
        sizeof(py::wrapper::Windows::System::Profile::UnsupportedAppRequirement),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UnsupportedAppRequirement
    };

    // ----- WindowsIntegrityPolicy class --------------------

    static PyObject* _new_WindowsIntegrityPolicy(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::System::Profile::WindowsIntegrityPolicy>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::System::Profile::WindowsIntegrityPolicy>::type_name);
        return nullptr;
    }

    static PyObject* WindowsIntegrityPolicy_get_CanDisable(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.WindowsIntegrityPolicy", L"CanDisable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::WindowsIntegrityPolicy::CanDisable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsIntegrityPolicy_get_IsDisableSupported(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.WindowsIntegrityPolicy", L"IsDisableSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::WindowsIntegrityPolicy::IsDisableSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsIntegrityPolicy_get_IsEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.WindowsIntegrityPolicy", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::WindowsIntegrityPolicy::IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsIntegrityPolicy_get_IsEnabledForTrial(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.System.Profile.WindowsIntegrityPolicy", L"IsEnabledForTrial"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::System::Profile::WindowsIntegrityPolicy::IsEnabledForTrial());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsIntegrityPolicy_add_PolicyChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.Profile.WindowsIntegrityPolicy", L"PolicyChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::System::Profile::WindowsIntegrityPolicy::PolicyChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WindowsIntegrityPolicy_remove_PolicyChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.System.Profile.WindowsIntegrityPolicy", L"PolicyChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::System::Profile::WindowsIntegrityPolicy::PolicyChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WindowsIntegrityPolicy[] = {
        { "add_policy_changed", reinterpret_cast<PyCFunction>(WindowsIntegrityPolicy_add_PolicyChanged), METH_O | METH_STATIC, nullptr },
        { "remove_policy_changed", reinterpret_cast<PyCFunction>(WindowsIntegrityPolicy_remove_PolicyChanged), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WindowsIntegrityPolicy[] = {
        { }
    };

    static PyType_Slot _type_slots_WindowsIntegrityPolicy[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_WindowsIntegrityPolicy) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WindowsIntegrityPolicy) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WindowsIntegrityPolicy) },
        { },
    };

    static PyType_Spec type_spec_WindowsIntegrityPolicy =
    {
        "winrt._winrt_windows_system_profile.WindowsIntegrityPolicy",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WindowsIntegrityPolicy
    };

    static PyGetSetDef getset_WindowsIntegrityPolicy_Static[] = {
        { "can_disable", reinterpret_cast<getter>(WindowsIntegrityPolicy_get_CanDisable), nullptr, nullptr, nullptr },
        { "is_disable_supported", reinterpret_cast<getter>(WindowsIntegrityPolicy_get_IsDisableSupported), nullptr, nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(WindowsIntegrityPolicy_get_IsEnabled), nullptr, nullptr, nullptr },
        { "is_enabled_for_trial", reinterpret_cast<getter>(WindowsIntegrityPolicy_get_IsEnabledForTrial), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_WindowsIntegrityPolicy_Static[] = {
        { }
    };

    static PyType_Slot type_slots_WindowsIntegrityPolicy_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_WindowsIntegrityPolicy_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_WindowsIntegrityPolicy_Static) },
        { }
    };

    static PyType_Spec type_spec_WindowsIntegrityPolicy_Static =
    {
        "winrt._winrt_windows_system_profile.WindowsIntegrityPolicy_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_WindowsIntegrityPolicy_Static
    };

    // ----- Windows.System.Profile Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::System::Profile");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_system_profile",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::System::Profile

PyMODINIT_FUNC PyInit__winrt_windows_system_profile(void) noexcept
{
    using namespace py::cpp::Windows::System::Profile;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AnalyticsInfo_Static{PyType_FromSpec(&type_spec_AnalyticsInfo_Static)};
    if (!type_AnalyticsInfo_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AnalyticsInfo, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AnalyticsInfo_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AnalyticsVersionInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_AppApplicability_Static{PyType_FromSpec(&type_spec_AppApplicability_Static)};
    if (!type_AppApplicability_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppApplicability, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AppApplicability_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_EducationSettings_Static{PyType_FromSpec(&type_spec_EducationSettings_Static)};
    if (!type_EducationSettings_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EducationSettings, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_EducationSettings_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_HardwareIdentification_Static{PyType_FromSpec(&type_spec_HardwareIdentification_Static)};
    if (!type_HardwareIdentification_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HardwareIdentification, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_HardwareIdentification_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HardwareToken, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownRetailInfoProperties_Static{PyType_FromSpec(&type_spec_KnownRetailInfoProperties_Static)};
    if (!type_KnownRetailInfoProperties_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_KnownRetailInfoProperties, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KnownRetailInfoProperties_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_PlatformDiagnosticsAndUsageDataSettings_Static{PyType_FromSpec(&type_spec_PlatformDiagnosticsAndUsageDataSettings_Static)};
    if (!type_PlatformDiagnosticsAndUsageDataSettings_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PlatformDiagnosticsAndUsageDataSettings, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PlatformDiagnosticsAndUsageDataSettings_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_RetailInfo_Static{PyType_FromSpec(&type_spec_RetailInfo_Static)};
    if (!type_RetailInfo_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_RetailInfo, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RetailInfo_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_SharedModeSettings_Static{PyType_FromSpec(&type_spec_SharedModeSettings_Static)};
    if (!type_SharedModeSettings_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SharedModeSettings, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SharedModeSettings_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_SmartAppControlPolicy_Static{PyType_FromSpec(&type_spec_SmartAppControlPolicy_Static)};
    if (!type_SmartAppControlPolicy_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SmartAppControlPolicy, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SmartAppControlPolicy_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_SystemIdentification_Static{PyType_FromSpec(&type_spec_SystemIdentification_Static)};
    if (!type_SystemIdentification_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SystemIdentification, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SystemIdentification_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SystemIdentificationInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_SystemSetupInfo_Static{PyType_FromSpec(&type_spec_SystemSetupInfo_Static)};
    if (!type_SystemSetupInfo_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SystemSetupInfo, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SystemSetupInfo_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UnsupportedAppRequirement, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_WindowsIntegrityPolicy_Static{PyType_FromSpec(&type_spec_WindowsIntegrityPolicy_Static)};
    if (!type_WindowsIntegrityPolicy_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_WindowsIntegrityPolicy, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_WindowsIntegrityPolicy_Static.get())) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
