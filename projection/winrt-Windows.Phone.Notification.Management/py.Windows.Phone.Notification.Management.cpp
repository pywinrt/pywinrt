// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

#include "py.Windows.Phone.Notification.Management.h"


namespace py::cpp::Windows::Phone::Notification::Management
{
    // ----- AccessoryManager class --------------------

    static PyObject* _new_AccessoryManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Phone::Notification::Management::AccessoryManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Phone::Notification::Management::AccessoryManager>::type_name);
        return nullptr;
    }

    static PyObject* AccessoryManager_AcceptPhoneCall(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"AcceptPhoneCall", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::AcceptPhoneCall(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"AcceptPhoneCall", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Phone::Notification::Management::PhoneCallAudioEndpoint>(args, 1);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::AcceptPhoneCall(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_AcceptPhoneCallWithVideo(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"AcceptPhoneCallWithVideo", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::AcceptPhoneCallWithVideo(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"AcceptPhoneCallWithVideo", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Phone::Notification::Management::PhoneCallAudioEndpoint>(args, 1);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::AcceptPhoneCallWithVideo(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_ClearToast(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"ClearToast", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::ClearToast(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_DecreaseVolume(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"DecreaseVolume", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::DecreaseVolume(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_DisableAllAccessoryNotificationTypes(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"DisableAllAccessoryNotificationTypes", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::Windows::Phone::Notification::Management::AccessoryManager::DisableAllAccessoryNotificationTypes();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_DisableEmailNotificationEmailAccount(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"DisableEmailNotificationEmailAccount", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::DisableEmailNotificationEmailAccount(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_DisableNotificationsForApplication(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"DisableNotificationsForApplication", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::DisableNotificationsForApplication(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_DismissAlarm(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"DismissAlarm", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::DismissAlarm(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_DismissAlarmByInstanceId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"DismissAlarmByInstanceId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::DismissAlarmByInstanceId(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_DismissReminder(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"DismissReminder", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::DismissReminder(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_DismissReminderByInstanceId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"DismissReminderByInstanceId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::DismissReminderByInstanceId(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_EnableAccessoryNotificationTypes(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"EnableAccessoryNotificationTypes", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::EnableAccessoryNotificationTypes(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_EnableEmailNotificationEmailAccount(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"EnableEmailNotificationEmailAccount", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::EnableEmailNotificationEmailAccount(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_EnableEmailNotificationFolderFilter(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"EnableEmailNotificationFolderFilter", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::hstring>>(args, 1);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::EnableEmailNotificationFolderFilter(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_EnableNotificationsForApplication(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"EnableNotificationsForApplication", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::EnableNotificationsForApplication(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_EndPhoneCall(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"EndPhoneCall", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::EndPhoneCall(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_GetAllEmailAccounts(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"GetAllEmailAccounts", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::GetAllEmailAccounts());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_GetAppIcon(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"GetAppIcon", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::GetAppIcon(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_GetApps(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"GetApps", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::GetApps());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_GetEnabledAccessoryNotificationTypes(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"GetEnabledAccessoryNotificationTypes", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::GetEnabledAccessoryNotificationTypes());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_GetFolders(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"GetFolders", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::GetFolders(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_GetMediaMetadata(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"GetMediaMetadata", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::GetMediaMetadata());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_GetNextTriggerDetails(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"GetNextTriggerDetails", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::GetNextTriggerDetails());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_GetPhoneLineDetails(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"GetPhoneLineDetails", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::GetPhoneLineDetails(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_GetUserConsent(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"GetUserConsent", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::GetUserConsent());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_HoldPhoneCall(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"HoldPhoneCall", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::HoldPhoneCall(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_IncreaseVolume(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"IncreaseVolume", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::IncreaseVolume(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_IsNotificationEnabledForApplication(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"IsNotificationEnabledForApplication", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::IsNotificationEnabledForApplication(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_MakePhoneCall(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"MakePhoneCall", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::MakePhoneCall(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"MakePhoneCall", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Phone::Notification::Management::PhoneCallAudioEndpoint>(args, 2);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::MakePhoneCall(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_MakePhoneCallWithVideo(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"MakePhoneCallWithVideo", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::MakePhoneCallWithVideo(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"MakePhoneCallWithVideo", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Phone::Notification::Management::PhoneCallAudioEndpoint>(args, 2);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::MakePhoneCallWithVideo(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_PerformMediaPlaybackCommand(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"PerformMediaPlaybackCommand", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Phone::Notification::Management::PlaybackCommand>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::PerformMediaPlaybackCommand(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_ProcessTriggerDetails(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"ProcessTriggerDetails", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Phone::Notification::Management::IAccessoryNotificationTriggerDetails>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::ProcessTriggerDetails(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_RegisterAccessoryApp(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"RegisterAccessoryApp", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::RegisterAccessoryApp());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_RejectPhoneCall(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"RejectPhoneCall", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::RejectPhoneCall(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"RejectPhoneCall", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::RejectPhoneCall(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_RingDevice(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"RingDevice", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::Windows::Phone::Notification::Management::AccessoryManager::RingDevice();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_SetMute(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"SetMute", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::SetMute(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_SetRingerVibrate(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"SetRingerVibrate", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::SetRingerVibrate(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_SnoozeAlarm(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"SnoozeAlarm", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::SnoozeAlarm(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"SnoozeAlarm", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::SnoozeAlarm(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_SnoozeAlarmByInstanceId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"SnoozeAlarmByInstanceId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::SnoozeAlarmByInstanceId(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_SnoozeReminder(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"SnoozeReminder", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::SnoozeReminder(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"SnoozeReminder", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::SnoozeReminder(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_SnoozeReminderByInstanceId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"SnoozeReminderByInstanceId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::SnoozeReminderByInstanceId(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_SwapPhoneCalls(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"SwapPhoneCalls", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::SwapPhoneCalls(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_UpdateEmailReadStatus(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"UpdateEmailReadStatus", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Phone::Notification::Management::BinaryId>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                winrt::Windows::Phone::Notification::Management::AccessoryManager::UpdateEmailReadStatus(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_get_PhoneMute(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"PhoneMute"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::PhoneMute());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AccessoryManager_put_PhoneMute(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"PhoneMute"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            winrt::Windows::Phone::Notification::Management::AccessoryManager::PhoneMute(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AccessoryManager_get_PhoneCallAudioEndpoint(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"PhoneCallAudioEndpoint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::PhoneCallAudioEndpoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AccessoryManager_put_PhoneCallAudioEndpoint(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"PhoneCallAudioEndpoint"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Phone::Notification::Management::PhoneCallAudioEndpoint>(arg);

            winrt::Windows::Phone::Notification::Management::AccessoryManager::PhoneCallAudioEndpoint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AccessoryManager_get_BatterySaverState(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"BatterySaverState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::BatterySaverState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_get_DoNotDisturbEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"DoNotDisturbEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::DoNotDisturbEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_get_DrivingModeEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"DrivingModeEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::DrivingModeEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_get_MediaPlaybackCapabilities(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"MediaPlaybackCapabilities"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::MediaPlaybackCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_get_MediaPlaybackStatus(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"MediaPlaybackStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::MediaPlaybackStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_get_PhoneLineDetails(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"PhoneLineDetails"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::PhoneLineDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_get_IsPhonePinLocked(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"IsPhonePinLocked"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::IsPhonePinLocked());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_get_SpeedDialList(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"SpeedDialList"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::SpeedDialList());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccessoryManager_get_VolumeInfo(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AccessoryManager", L"VolumeInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Phone::Notification::Management::AccessoryManager::VolumeInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AccessoryManager[] = {
        { }
    };

    static PyGetSetDef _getset_AccessoryManager[] = {
        { }
    };

    static PyType_Slot _type_slots_AccessoryManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AccessoryManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AccessoryManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AccessoryManager) },
        { },
    };

    static PyType_Spec type_spec_AccessoryManager =
    {
        "winrt._winrt_windows_phone_notification_management.AccessoryManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AccessoryManager
    };

    static PyGetSetDef getset_AccessoryManager_Static[] = {
        { "phone_mute", reinterpret_cast<getter>(AccessoryManager_get_PhoneMute), reinterpret_cast<setter>(AccessoryManager_put_PhoneMute), nullptr, nullptr },
        { "phone_call_audio_endpoint", reinterpret_cast<getter>(AccessoryManager_get_PhoneCallAudioEndpoint), reinterpret_cast<setter>(AccessoryManager_put_PhoneCallAudioEndpoint), nullptr, nullptr },
        { "battery_saver_state", reinterpret_cast<getter>(AccessoryManager_get_BatterySaverState), nullptr, nullptr, nullptr },
        { "do_not_disturb_enabled", reinterpret_cast<getter>(AccessoryManager_get_DoNotDisturbEnabled), nullptr, nullptr, nullptr },
        { "driving_mode_enabled", reinterpret_cast<getter>(AccessoryManager_get_DrivingModeEnabled), nullptr, nullptr, nullptr },
        { "media_playback_capabilities", reinterpret_cast<getter>(AccessoryManager_get_MediaPlaybackCapabilities), nullptr, nullptr, nullptr },
        { "media_playback_status", reinterpret_cast<getter>(AccessoryManager_get_MediaPlaybackStatus), nullptr, nullptr, nullptr },
        { "phone_line_details", reinterpret_cast<getter>(AccessoryManager_get_PhoneLineDetails), nullptr, nullptr, nullptr },
        { "is_phone_pin_locked", reinterpret_cast<getter>(AccessoryManager_get_IsPhonePinLocked), nullptr, nullptr, nullptr },
        { "speed_dial_list", reinterpret_cast<getter>(AccessoryManager_get_SpeedDialList), nullptr, nullptr, nullptr },
        { "volume_info", reinterpret_cast<getter>(AccessoryManager_get_VolumeInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_AccessoryManager_Static[] = {
        { "accept_phone_call", reinterpret_cast<PyCFunction>(AccessoryManager_AcceptPhoneCall), METH_VARARGS, nullptr },
        { "accept_phone_call_with_video", reinterpret_cast<PyCFunction>(AccessoryManager_AcceptPhoneCallWithVideo), METH_VARARGS, nullptr },
        { "clear_toast", reinterpret_cast<PyCFunction>(AccessoryManager_ClearToast), METH_VARARGS, nullptr },
        { "decrease_volume", reinterpret_cast<PyCFunction>(AccessoryManager_DecreaseVolume), METH_VARARGS, nullptr },
        { "disable_all_accessory_notification_types", reinterpret_cast<PyCFunction>(AccessoryManager_DisableAllAccessoryNotificationTypes), METH_VARARGS, nullptr },
        { "disable_email_notification_email_account", reinterpret_cast<PyCFunction>(AccessoryManager_DisableEmailNotificationEmailAccount), METH_VARARGS, nullptr },
        { "disable_notifications_for_application", reinterpret_cast<PyCFunction>(AccessoryManager_DisableNotificationsForApplication), METH_VARARGS, nullptr },
        { "dismiss_alarm", reinterpret_cast<PyCFunction>(AccessoryManager_DismissAlarm), METH_VARARGS, nullptr },
        { "dismiss_alarm_by_instance_id", reinterpret_cast<PyCFunction>(AccessoryManager_DismissAlarmByInstanceId), METH_VARARGS, nullptr },
        { "dismiss_reminder", reinterpret_cast<PyCFunction>(AccessoryManager_DismissReminder), METH_VARARGS, nullptr },
        { "dismiss_reminder_by_instance_id", reinterpret_cast<PyCFunction>(AccessoryManager_DismissReminderByInstanceId), METH_VARARGS, nullptr },
        { "enable_accessory_notification_types", reinterpret_cast<PyCFunction>(AccessoryManager_EnableAccessoryNotificationTypes), METH_VARARGS, nullptr },
        { "enable_email_notification_email_account", reinterpret_cast<PyCFunction>(AccessoryManager_EnableEmailNotificationEmailAccount), METH_VARARGS, nullptr },
        { "enable_email_notification_folder_filter", reinterpret_cast<PyCFunction>(AccessoryManager_EnableEmailNotificationFolderFilter), METH_VARARGS, nullptr },
        { "enable_notifications_for_application", reinterpret_cast<PyCFunction>(AccessoryManager_EnableNotificationsForApplication), METH_VARARGS, nullptr },
        { "end_phone_call", reinterpret_cast<PyCFunction>(AccessoryManager_EndPhoneCall), METH_VARARGS, nullptr },
        { "get_all_email_accounts", reinterpret_cast<PyCFunction>(AccessoryManager_GetAllEmailAccounts), METH_VARARGS, nullptr },
        { "get_app_icon", reinterpret_cast<PyCFunction>(AccessoryManager_GetAppIcon), METH_VARARGS, nullptr },
        { "get_apps", reinterpret_cast<PyCFunction>(AccessoryManager_GetApps), METH_VARARGS, nullptr },
        { "get_enabled_accessory_notification_types", reinterpret_cast<PyCFunction>(AccessoryManager_GetEnabledAccessoryNotificationTypes), METH_VARARGS, nullptr },
        { "get_folders", reinterpret_cast<PyCFunction>(AccessoryManager_GetFolders), METH_VARARGS, nullptr },
        { "get_media_metadata", reinterpret_cast<PyCFunction>(AccessoryManager_GetMediaMetadata), METH_VARARGS, nullptr },
        { "get_next_trigger_details", reinterpret_cast<PyCFunction>(AccessoryManager_GetNextTriggerDetails), METH_VARARGS, nullptr },
        { "get_phone_line_details", reinterpret_cast<PyCFunction>(AccessoryManager_GetPhoneLineDetails), METH_VARARGS, nullptr },
        { "get_user_consent", reinterpret_cast<PyCFunction>(AccessoryManager_GetUserConsent), METH_VARARGS, nullptr },
        { "hold_phone_call", reinterpret_cast<PyCFunction>(AccessoryManager_HoldPhoneCall), METH_VARARGS, nullptr },
        { "increase_volume", reinterpret_cast<PyCFunction>(AccessoryManager_IncreaseVolume), METH_VARARGS, nullptr },
        { "is_notification_enabled_for_application", reinterpret_cast<PyCFunction>(AccessoryManager_IsNotificationEnabledForApplication), METH_VARARGS, nullptr },
        { "make_phone_call", reinterpret_cast<PyCFunction>(AccessoryManager_MakePhoneCall), METH_VARARGS, nullptr },
        { "make_phone_call_with_video", reinterpret_cast<PyCFunction>(AccessoryManager_MakePhoneCallWithVideo), METH_VARARGS, nullptr },
        { "perform_media_playback_command", reinterpret_cast<PyCFunction>(AccessoryManager_PerformMediaPlaybackCommand), METH_VARARGS, nullptr },
        { "process_trigger_details", reinterpret_cast<PyCFunction>(AccessoryManager_ProcessTriggerDetails), METH_VARARGS, nullptr },
        { "register_accessory_app", reinterpret_cast<PyCFunction>(AccessoryManager_RegisterAccessoryApp), METH_VARARGS, nullptr },
        { "reject_phone_call", reinterpret_cast<PyCFunction>(AccessoryManager_RejectPhoneCall), METH_VARARGS, nullptr },
        { "ring_device", reinterpret_cast<PyCFunction>(AccessoryManager_RingDevice), METH_VARARGS, nullptr },
        { "set_mute", reinterpret_cast<PyCFunction>(AccessoryManager_SetMute), METH_VARARGS, nullptr },
        { "set_ringer_vibrate", reinterpret_cast<PyCFunction>(AccessoryManager_SetRingerVibrate), METH_VARARGS, nullptr },
        { "snooze_alarm", reinterpret_cast<PyCFunction>(AccessoryManager_SnoozeAlarm), METH_VARARGS, nullptr },
        { "snooze_alarm_by_instance_id", reinterpret_cast<PyCFunction>(AccessoryManager_SnoozeAlarmByInstanceId), METH_VARARGS, nullptr },
        { "snooze_reminder", reinterpret_cast<PyCFunction>(AccessoryManager_SnoozeReminder), METH_VARARGS, nullptr },
        { "snooze_reminder_by_instance_id", reinterpret_cast<PyCFunction>(AccessoryManager_SnoozeReminderByInstanceId), METH_VARARGS, nullptr },
        { "swap_phone_calls", reinterpret_cast<PyCFunction>(AccessoryManager_SwapPhoneCalls), METH_VARARGS, nullptr },
        { "update_email_read_status", reinterpret_cast<PyCFunction>(AccessoryManager_UpdateEmailReadStatus), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AccessoryManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AccessoryManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AccessoryManager_Static) },
        { }
    };

    static PyType_Spec type_spec_AccessoryManager_Static =
    {
        "winrt._winrt_windows_phone_notification_management.AccessoryManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AccessoryManager_Static
    };

    // ----- AlarmNotificationTriggerDetails class --------------------

    static PyObject* _new_AlarmNotificationTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Phone::Notification::Management::AlarmNotificationTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Phone::Notification::Management::AlarmNotificationTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_AlarmNotificationTriggerDetails(py::wrapper::Windows::Phone::Notification::Management::AlarmNotificationTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AlarmNotificationTriggerDetails_get_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::AlarmNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AlarmNotificationTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartedProcessing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AlarmNotificationTriggerDetails_put_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::AlarmNotificationTriggerDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AlarmNotificationTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.StartedProcessing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AlarmNotificationTriggerDetails_get_AccessoryNotificationType(py::wrapper::Windows::Phone::Notification::Management::AlarmNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AlarmNotificationTriggerDetails", L"AccessoryNotificationType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccessoryNotificationType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AlarmNotificationTriggerDetails_get_AppDisplayName(py::wrapper::Windows::Phone::Notification::Management::AlarmNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AlarmNotificationTriggerDetails", L"AppDisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AlarmNotificationTriggerDetails_get_AppId(py::wrapper::Windows::Phone::Notification::Management::AlarmNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AlarmNotificationTriggerDetails", L"AppId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AlarmNotificationTriggerDetails_get_TimeCreated(py::wrapper::Windows::Phone::Notification::Management::AlarmNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AlarmNotificationTriggerDetails", L"TimeCreated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimeCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AlarmNotificationTriggerDetails_get_AlarmId(py::wrapper::Windows::Phone::Notification::Management::AlarmNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AlarmNotificationTriggerDetails", L"AlarmId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AlarmId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AlarmNotificationTriggerDetails_get_ReminderState(py::wrapper::Windows::Phone::Notification::Management::AlarmNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AlarmNotificationTriggerDetails", L"ReminderState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReminderState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AlarmNotificationTriggerDetails_get_Timestamp(py::wrapper::Windows::Phone::Notification::Management::AlarmNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AlarmNotificationTriggerDetails", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AlarmNotificationTriggerDetails_get_Title(py::wrapper::Windows::Phone::Notification::Management::AlarmNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AlarmNotificationTriggerDetails", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AlarmNotificationTriggerDetails_get_InstanceId(py::wrapper::Windows::Phone::Notification::Management::AlarmNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AlarmNotificationTriggerDetails", L"InstanceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InstanceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AlarmNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::AlarmNotificationTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AlarmNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::AlarmNotificationTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AlarmNotificationTriggerDetails[] = {
        { "_assign_array_", _assign_array_AlarmNotificationTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AlarmNotificationTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AlarmNotificationTriggerDetails[] = {
        { "started_processing", reinterpret_cast<getter>(AlarmNotificationTriggerDetails_get_StartedProcessing), reinterpret_cast<setter>(AlarmNotificationTriggerDetails_put_StartedProcessing), nullptr, nullptr },
        { "accessory_notification_type", reinterpret_cast<getter>(AlarmNotificationTriggerDetails_get_AccessoryNotificationType), nullptr, nullptr, nullptr },
        { "app_display_name", reinterpret_cast<getter>(AlarmNotificationTriggerDetails_get_AppDisplayName), nullptr, nullptr, nullptr },
        { "app_id", reinterpret_cast<getter>(AlarmNotificationTriggerDetails_get_AppId), nullptr, nullptr, nullptr },
        { "time_created", reinterpret_cast<getter>(AlarmNotificationTriggerDetails_get_TimeCreated), nullptr, nullptr, nullptr },
        { "alarm_id", reinterpret_cast<getter>(AlarmNotificationTriggerDetails_get_AlarmId), nullptr, nullptr, nullptr },
        { "reminder_state", reinterpret_cast<getter>(AlarmNotificationTriggerDetails_get_ReminderState), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(AlarmNotificationTriggerDetails_get_Timestamp), nullptr, nullptr, nullptr },
        { "title", reinterpret_cast<getter>(AlarmNotificationTriggerDetails_get_Title), nullptr, nullptr, nullptr },
        { "instance_id", reinterpret_cast<getter>(AlarmNotificationTriggerDetails_get_InstanceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AlarmNotificationTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AlarmNotificationTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AlarmNotificationTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AlarmNotificationTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AlarmNotificationTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_AlarmNotificationTriggerDetails =
    {
        "winrt._winrt_windows_phone_notification_management.AlarmNotificationTriggerDetails",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::AlarmNotificationTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AlarmNotificationTriggerDetails
    };

    // ----- AppNotificationInfo class --------------------

    static PyObject* _new_AppNotificationInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Phone::Notification::Management::AppNotificationInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Phone::Notification::Management::AppNotificationInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_AppNotificationInfo(py::wrapper::Windows::Phone::Notification::Management::AppNotificationInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppNotificationInfo_get_Id(py::wrapper::Windows::Phone::Notification::Management::AppNotificationInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AppNotificationInfo", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppNotificationInfo_get_Name(py::wrapper::Windows::Phone::Notification::Management::AppNotificationInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.AppNotificationInfo", L"Name"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppNotificationInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::AppNotificationInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppNotificationInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::AppNotificationInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppNotificationInfo[] = {
        { "_assign_array_", _assign_array_AppNotificationInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppNotificationInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppNotificationInfo[] = {
        { "id", reinterpret_cast<getter>(AppNotificationInfo_get_Id), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(AppNotificationInfo_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppNotificationInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppNotificationInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppNotificationInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppNotificationInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppNotificationInfo) },
        { },
    };

    static PyType_Spec type_spec_AppNotificationInfo =
    {
        "winrt._winrt_windows_phone_notification_management.AppNotificationInfo",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::AppNotificationInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppNotificationInfo
    };

    // ----- BinaryId class --------------------

    static PyObject* _new_BinaryId(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Phone::Notification::Management::BinaryId>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Phone::Notification::Management::BinaryId>::type_name);
        return nullptr;
    }

    static void _dealloc_BinaryId(py::wrapper::Windows::Phone::Notification::Management::BinaryId* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BinaryId_get_Id(py::wrapper::Windows::Phone::Notification::Management::BinaryId* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.BinaryId", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BinaryId_get_Length(py::wrapper::Windows::Phone::Notification::Management::BinaryId* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.BinaryId", L"Length"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Length());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BinaryId(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::BinaryId>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BinaryId(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::BinaryId>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BinaryId[] = {
        { "_assign_array_", _assign_array_BinaryId, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BinaryId), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BinaryId[] = {
        { "id", reinterpret_cast<getter>(BinaryId_get_Id), nullptr, nullptr, nullptr },
        { "length", reinterpret_cast<getter>(BinaryId_get_Length), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BinaryId[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BinaryId) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BinaryId) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BinaryId) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BinaryId) },
        { },
    };

    static PyType_Spec type_spec_BinaryId =
    {
        "winrt._winrt_windows_phone_notification_management.BinaryId",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::BinaryId),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BinaryId
    };

    // ----- CalendarChangedNotificationTriggerDetails class --------------------

    static PyObject* _new_CalendarChangedNotificationTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Phone::Notification::Management::CalendarChangedNotificationTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Phone::Notification::Management::CalendarChangedNotificationTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_CalendarChangedNotificationTriggerDetails(py::wrapper::Windows::Phone::Notification::Management::CalendarChangedNotificationTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CalendarChangedNotificationTriggerDetails_get_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::CalendarChangedNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CalendarChangedNotificationTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartedProcessing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CalendarChangedNotificationTriggerDetails_put_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::CalendarChangedNotificationTriggerDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CalendarChangedNotificationTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.StartedProcessing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CalendarChangedNotificationTriggerDetails_get_AccessoryNotificationType(py::wrapper::Windows::Phone::Notification::Management::CalendarChangedNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CalendarChangedNotificationTriggerDetails", L"AccessoryNotificationType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccessoryNotificationType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarChangedNotificationTriggerDetails_get_AppDisplayName(py::wrapper::Windows::Phone::Notification::Management::CalendarChangedNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CalendarChangedNotificationTriggerDetails", L"AppDisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarChangedNotificationTriggerDetails_get_AppId(py::wrapper::Windows::Phone::Notification::Management::CalendarChangedNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CalendarChangedNotificationTriggerDetails", L"AppId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarChangedNotificationTriggerDetails_get_TimeCreated(py::wrapper::Windows::Phone::Notification::Management::CalendarChangedNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CalendarChangedNotificationTriggerDetails", L"TimeCreated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimeCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarChangedNotificationTriggerDetails_get_EventType(py::wrapper::Windows::Phone::Notification::Management::CalendarChangedNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CalendarChangedNotificationTriggerDetails", L"EventType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EventType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarChangedNotificationTriggerDetails_get_ItemId(py::wrapper::Windows::Phone::Notification::Management::CalendarChangedNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CalendarChangedNotificationTriggerDetails", L"ItemId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ItemId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CalendarChangedNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::CalendarChangedNotificationTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CalendarChangedNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::CalendarChangedNotificationTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CalendarChangedNotificationTriggerDetails[] = {
        { "_assign_array_", _assign_array_CalendarChangedNotificationTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CalendarChangedNotificationTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CalendarChangedNotificationTriggerDetails[] = {
        { "started_processing", reinterpret_cast<getter>(CalendarChangedNotificationTriggerDetails_get_StartedProcessing), reinterpret_cast<setter>(CalendarChangedNotificationTriggerDetails_put_StartedProcessing), nullptr, nullptr },
        { "accessory_notification_type", reinterpret_cast<getter>(CalendarChangedNotificationTriggerDetails_get_AccessoryNotificationType), nullptr, nullptr, nullptr },
        { "app_display_name", reinterpret_cast<getter>(CalendarChangedNotificationTriggerDetails_get_AppDisplayName), nullptr, nullptr, nullptr },
        { "app_id", reinterpret_cast<getter>(CalendarChangedNotificationTriggerDetails_get_AppId), nullptr, nullptr, nullptr },
        { "time_created", reinterpret_cast<getter>(CalendarChangedNotificationTriggerDetails_get_TimeCreated), nullptr, nullptr, nullptr },
        { "event_type", reinterpret_cast<getter>(CalendarChangedNotificationTriggerDetails_get_EventType), nullptr, nullptr, nullptr },
        { "item_id", reinterpret_cast<getter>(CalendarChangedNotificationTriggerDetails_get_ItemId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CalendarChangedNotificationTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CalendarChangedNotificationTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CalendarChangedNotificationTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CalendarChangedNotificationTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CalendarChangedNotificationTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_CalendarChangedNotificationTriggerDetails =
    {
        "winrt._winrt_windows_phone_notification_management.CalendarChangedNotificationTriggerDetails",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::CalendarChangedNotificationTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CalendarChangedNotificationTriggerDetails
    };

    // ----- CortanaTileNotificationTriggerDetails class --------------------

    static PyObject* _new_CortanaTileNotificationTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_CortanaTileNotificationTriggerDetails(py::wrapper::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CortanaTileNotificationTriggerDetails_get_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CortanaTileNotificationTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartedProcessing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CortanaTileNotificationTriggerDetails_put_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CortanaTileNotificationTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.StartedProcessing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CortanaTileNotificationTriggerDetails_get_AccessoryNotificationType(py::wrapper::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CortanaTileNotificationTriggerDetails", L"AccessoryNotificationType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccessoryNotificationType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CortanaTileNotificationTriggerDetails_get_AppDisplayName(py::wrapper::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CortanaTileNotificationTriggerDetails", L"AppDisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CortanaTileNotificationTriggerDetails_get_AppId(py::wrapper::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CortanaTileNotificationTriggerDetails", L"AppId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CortanaTileNotificationTriggerDetails_get_TimeCreated(py::wrapper::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CortanaTileNotificationTriggerDetails", L"TimeCreated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimeCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CortanaTileNotificationTriggerDetails_get_Content(py::wrapper::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CortanaTileNotificationTriggerDetails", L"Content"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Content());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CortanaTileNotificationTriggerDetails_get_EmphasizedText(py::wrapper::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CortanaTileNotificationTriggerDetails", L"EmphasizedText"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EmphasizedText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CortanaTileNotificationTriggerDetails_get_LargeContent1(py::wrapper::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CortanaTileNotificationTriggerDetails", L"LargeContent1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LargeContent1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CortanaTileNotificationTriggerDetails_get_LargeContent2(py::wrapper::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CortanaTileNotificationTriggerDetails", L"LargeContent2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LargeContent2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CortanaTileNotificationTriggerDetails_get_NonWrappedSmallContent1(py::wrapper::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CortanaTileNotificationTriggerDetails", L"NonWrappedSmallContent1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NonWrappedSmallContent1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CortanaTileNotificationTriggerDetails_get_NonWrappedSmallContent2(py::wrapper::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CortanaTileNotificationTriggerDetails", L"NonWrappedSmallContent2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NonWrappedSmallContent2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CortanaTileNotificationTriggerDetails_get_NonWrappedSmallContent3(py::wrapper::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CortanaTileNotificationTriggerDetails", L"NonWrappedSmallContent3"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NonWrappedSmallContent3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CortanaTileNotificationTriggerDetails_get_NonWrappedSmallContent4(py::wrapper::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CortanaTileNotificationTriggerDetails", L"NonWrappedSmallContent4"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NonWrappedSmallContent4());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CortanaTileNotificationTriggerDetails_get_Source(py::wrapper::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CortanaTileNotificationTriggerDetails", L"Source"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CortanaTileNotificationTriggerDetails_get_TileId(py::wrapper::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.CortanaTileNotificationTriggerDetails", L"TileId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TileId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CortanaTileNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CortanaTileNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CortanaTileNotificationTriggerDetails[] = {
        { "_assign_array_", _assign_array_CortanaTileNotificationTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CortanaTileNotificationTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CortanaTileNotificationTriggerDetails[] = {
        { "started_processing", reinterpret_cast<getter>(CortanaTileNotificationTriggerDetails_get_StartedProcessing), reinterpret_cast<setter>(CortanaTileNotificationTriggerDetails_put_StartedProcessing), nullptr, nullptr },
        { "accessory_notification_type", reinterpret_cast<getter>(CortanaTileNotificationTriggerDetails_get_AccessoryNotificationType), nullptr, nullptr, nullptr },
        { "app_display_name", reinterpret_cast<getter>(CortanaTileNotificationTriggerDetails_get_AppDisplayName), nullptr, nullptr, nullptr },
        { "app_id", reinterpret_cast<getter>(CortanaTileNotificationTriggerDetails_get_AppId), nullptr, nullptr, nullptr },
        { "time_created", reinterpret_cast<getter>(CortanaTileNotificationTriggerDetails_get_TimeCreated), nullptr, nullptr, nullptr },
        { "content", reinterpret_cast<getter>(CortanaTileNotificationTriggerDetails_get_Content), nullptr, nullptr, nullptr },
        { "emphasized_text", reinterpret_cast<getter>(CortanaTileNotificationTriggerDetails_get_EmphasizedText), nullptr, nullptr, nullptr },
        { "large_content1", reinterpret_cast<getter>(CortanaTileNotificationTriggerDetails_get_LargeContent1), nullptr, nullptr, nullptr },
        { "large_content2", reinterpret_cast<getter>(CortanaTileNotificationTriggerDetails_get_LargeContent2), nullptr, nullptr, nullptr },
        { "non_wrapped_small_content1", reinterpret_cast<getter>(CortanaTileNotificationTriggerDetails_get_NonWrappedSmallContent1), nullptr, nullptr, nullptr },
        { "non_wrapped_small_content2", reinterpret_cast<getter>(CortanaTileNotificationTriggerDetails_get_NonWrappedSmallContent2), nullptr, nullptr, nullptr },
        { "non_wrapped_small_content3", reinterpret_cast<getter>(CortanaTileNotificationTriggerDetails_get_NonWrappedSmallContent3), nullptr, nullptr, nullptr },
        { "non_wrapped_small_content4", reinterpret_cast<getter>(CortanaTileNotificationTriggerDetails_get_NonWrappedSmallContent4), nullptr, nullptr, nullptr },
        { "source", reinterpret_cast<getter>(CortanaTileNotificationTriggerDetails_get_Source), nullptr, nullptr, nullptr },
        { "tile_id", reinterpret_cast<getter>(CortanaTileNotificationTriggerDetails_get_TileId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CortanaTileNotificationTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CortanaTileNotificationTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CortanaTileNotificationTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CortanaTileNotificationTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CortanaTileNotificationTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_CortanaTileNotificationTriggerDetails =
    {
        "winrt._winrt_windows_phone_notification_management.CortanaTileNotificationTriggerDetails",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::CortanaTileNotificationTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CortanaTileNotificationTriggerDetails
    };

    // ----- EmailAccountInfo class --------------------

    static PyObject* _new_EmailAccountInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Phone::Notification::Management::EmailAccountInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Phone::Notification::Management::EmailAccountInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailAccountInfo(py::wrapper::Windows::Phone::Notification::Management::EmailAccountInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailAccountInfo_get_DisplayName(py::wrapper::Windows::Phone::Notification::Management::EmailAccountInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailAccountInfo", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailAccountInfo_get_IsNotificationEnabled(py::wrapper::Windows::Phone::Notification::Management::EmailAccountInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailAccountInfo", L"IsNotificationEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsNotificationEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailAccountInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::EmailAccountInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailAccountInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::EmailAccountInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailAccountInfo[] = {
        { "_assign_array_", _assign_array_EmailAccountInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailAccountInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailAccountInfo[] = {
        { "display_name", reinterpret_cast<getter>(EmailAccountInfo_get_DisplayName), nullptr, nullptr, nullptr },
        { "is_notification_enabled", reinterpret_cast<getter>(EmailAccountInfo_get_IsNotificationEnabled), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailAccountInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailAccountInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailAccountInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailAccountInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailAccountInfo) },
        { },
    };

    static PyType_Spec type_spec_EmailAccountInfo =
    {
        "winrt._winrt_windows_phone_notification_management.EmailAccountInfo",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::EmailAccountInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailAccountInfo
    };

    // ----- EmailFolderInfo class --------------------

    static PyObject* _new_EmailFolderInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Phone::Notification::Management::EmailFolderInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Phone::Notification::Management::EmailFolderInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailFolderInfo(py::wrapper::Windows::Phone::Notification::Management::EmailFolderInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailFolderInfo_get_DisplayName(py::wrapper::Windows::Phone::Notification::Management::EmailFolderInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailFolderInfo", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailFolderInfo_get_IsNotificationEnabled(py::wrapper::Windows::Phone::Notification::Management::EmailFolderInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailFolderInfo", L"IsNotificationEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsNotificationEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailFolderInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::EmailFolderInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailFolderInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::EmailFolderInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailFolderInfo[] = {
        { "_assign_array_", _assign_array_EmailFolderInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailFolderInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailFolderInfo[] = {
        { "display_name", reinterpret_cast<getter>(EmailFolderInfo_get_DisplayName), nullptr, nullptr, nullptr },
        { "is_notification_enabled", reinterpret_cast<getter>(EmailFolderInfo_get_IsNotificationEnabled), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailFolderInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailFolderInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailFolderInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailFolderInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailFolderInfo) },
        { },
    };

    static PyType_Spec type_spec_EmailFolderInfo =
    {
        "winrt._winrt_windows_phone_notification_management.EmailFolderInfo",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::EmailFolderInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailFolderInfo
    };

    // ----- EmailNotificationTriggerDetails class --------------------

    static PyObject* _new_EmailNotificationTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Phone::Notification::Management::EmailNotificationTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Phone::Notification::Management::EmailNotificationTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailNotificationTriggerDetails(py::wrapper::Windows::Phone::Notification::Management::EmailNotificationTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailNotificationTriggerDetails_get_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::EmailNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailNotificationTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartedProcessing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailNotificationTriggerDetails_put_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::EmailNotificationTriggerDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailNotificationTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.StartedProcessing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailNotificationTriggerDetails_get_AccessoryNotificationType(py::wrapper::Windows::Phone::Notification::Management::EmailNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailNotificationTriggerDetails", L"AccessoryNotificationType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccessoryNotificationType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailNotificationTriggerDetails_get_AppDisplayName(py::wrapper::Windows::Phone::Notification::Management::EmailNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailNotificationTriggerDetails", L"AppDisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailNotificationTriggerDetails_get_AppId(py::wrapper::Windows::Phone::Notification::Management::EmailNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailNotificationTriggerDetails", L"AppId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailNotificationTriggerDetails_get_TimeCreated(py::wrapper::Windows::Phone::Notification::Management::EmailNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailNotificationTriggerDetails", L"TimeCreated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimeCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailNotificationTriggerDetails_get_AccountName(py::wrapper::Windows::Phone::Notification::Management::EmailNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailNotificationTriggerDetails", L"AccountName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccountName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailNotificationTriggerDetails_get_EmailMessage(py::wrapper::Windows::Phone::Notification::Management::EmailNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailNotificationTriggerDetails", L"EmailMessage"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EmailMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailNotificationTriggerDetails_get_ParentFolderName(py::wrapper::Windows::Phone::Notification::Management::EmailNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailNotificationTriggerDetails", L"ParentFolderName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ParentFolderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailNotificationTriggerDetails_get_SenderAddress(py::wrapper::Windows::Phone::Notification::Management::EmailNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailNotificationTriggerDetails", L"SenderAddress"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SenderAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailNotificationTriggerDetails_get_SenderName(py::wrapper::Windows::Phone::Notification::Management::EmailNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailNotificationTriggerDetails", L"SenderName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SenderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailNotificationTriggerDetails_get_Timestamp(py::wrapper::Windows::Phone::Notification::Management::EmailNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailNotificationTriggerDetails", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailNotificationTriggerDetails_get_MessageEntryId(py::wrapper::Windows::Phone::Notification::Management::EmailNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailNotificationTriggerDetails", L"MessageEntryId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MessageEntryId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::EmailNotificationTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::EmailNotificationTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailNotificationTriggerDetails[] = {
        { "_assign_array_", _assign_array_EmailNotificationTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailNotificationTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailNotificationTriggerDetails[] = {
        { "started_processing", reinterpret_cast<getter>(EmailNotificationTriggerDetails_get_StartedProcessing), reinterpret_cast<setter>(EmailNotificationTriggerDetails_put_StartedProcessing), nullptr, nullptr },
        { "accessory_notification_type", reinterpret_cast<getter>(EmailNotificationTriggerDetails_get_AccessoryNotificationType), nullptr, nullptr, nullptr },
        { "app_display_name", reinterpret_cast<getter>(EmailNotificationTriggerDetails_get_AppDisplayName), nullptr, nullptr, nullptr },
        { "app_id", reinterpret_cast<getter>(EmailNotificationTriggerDetails_get_AppId), nullptr, nullptr, nullptr },
        { "time_created", reinterpret_cast<getter>(EmailNotificationTriggerDetails_get_TimeCreated), nullptr, nullptr, nullptr },
        { "account_name", reinterpret_cast<getter>(EmailNotificationTriggerDetails_get_AccountName), nullptr, nullptr, nullptr },
        { "email_message", reinterpret_cast<getter>(EmailNotificationTriggerDetails_get_EmailMessage), nullptr, nullptr, nullptr },
        { "parent_folder_name", reinterpret_cast<getter>(EmailNotificationTriggerDetails_get_ParentFolderName), nullptr, nullptr, nullptr },
        { "sender_address", reinterpret_cast<getter>(EmailNotificationTriggerDetails_get_SenderAddress), nullptr, nullptr, nullptr },
        { "sender_name", reinterpret_cast<getter>(EmailNotificationTriggerDetails_get_SenderName), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(EmailNotificationTriggerDetails_get_Timestamp), nullptr, nullptr, nullptr },
        { "message_entry_id", reinterpret_cast<getter>(EmailNotificationTriggerDetails_get_MessageEntryId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailNotificationTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailNotificationTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailNotificationTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailNotificationTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailNotificationTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_EmailNotificationTriggerDetails =
    {
        "winrt._winrt_windows_phone_notification_management.EmailNotificationTriggerDetails",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::EmailNotificationTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailNotificationTriggerDetails
    };

    // ----- EmailReadNotificationTriggerDetails class --------------------

    static PyObject* _new_EmailReadNotificationTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Phone::Notification::Management::EmailReadNotificationTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Phone::Notification::Management::EmailReadNotificationTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_EmailReadNotificationTriggerDetails(py::wrapper::Windows::Phone::Notification::Management::EmailReadNotificationTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EmailReadNotificationTriggerDetails_get_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::EmailReadNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailReadNotificationTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartedProcessing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EmailReadNotificationTriggerDetails_put_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::EmailReadNotificationTriggerDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailReadNotificationTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.StartedProcessing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EmailReadNotificationTriggerDetails_get_AccessoryNotificationType(py::wrapper::Windows::Phone::Notification::Management::EmailReadNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailReadNotificationTriggerDetails", L"AccessoryNotificationType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccessoryNotificationType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailReadNotificationTriggerDetails_get_AppDisplayName(py::wrapper::Windows::Phone::Notification::Management::EmailReadNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailReadNotificationTriggerDetails", L"AppDisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailReadNotificationTriggerDetails_get_AppId(py::wrapper::Windows::Phone::Notification::Management::EmailReadNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailReadNotificationTriggerDetails", L"AppId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailReadNotificationTriggerDetails_get_TimeCreated(py::wrapper::Windows::Phone::Notification::Management::EmailReadNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailReadNotificationTriggerDetails", L"TimeCreated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimeCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailReadNotificationTriggerDetails_get_AccountName(py::wrapper::Windows::Phone::Notification::Management::EmailReadNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailReadNotificationTriggerDetails", L"AccountName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccountName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailReadNotificationTriggerDetails_get_IsRead(py::wrapper::Windows::Phone::Notification::Management::EmailReadNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailReadNotificationTriggerDetails", L"IsRead"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsRead());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailReadNotificationTriggerDetails_get_MessageEntryId(py::wrapper::Windows::Phone::Notification::Management::EmailReadNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailReadNotificationTriggerDetails", L"MessageEntryId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MessageEntryId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EmailReadNotificationTriggerDetails_get_ParentFolderName(py::wrapper::Windows::Phone::Notification::Management::EmailReadNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.EmailReadNotificationTriggerDetails", L"ParentFolderName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ParentFolderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EmailReadNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::EmailReadNotificationTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EmailReadNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::EmailReadNotificationTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EmailReadNotificationTriggerDetails[] = {
        { "_assign_array_", _assign_array_EmailReadNotificationTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EmailReadNotificationTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EmailReadNotificationTriggerDetails[] = {
        { "started_processing", reinterpret_cast<getter>(EmailReadNotificationTriggerDetails_get_StartedProcessing), reinterpret_cast<setter>(EmailReadNotificationTriggerDetails_put_StartedProcessing), nullptr, nullptr },
        { "accessory_notification_type", reinterpret_cast<getter>(EmailReadNotificationTriggerDetails_get_AccessoryNotificationType), nullptr, nullptr, nullptr },
        { "app_display_name", reinterpret_cast<getter>(EmailReadNotificationTriggerDetails_get_AppDisplayName), nullptr, nullptr, nullptr },
        { "app_id", reinterpret_cast<getter>(EmailReadNotificationTriggerDetails_get_AppId), nullptr, nullptr, nullptr },
        { "time_created", reinterpret_cast<getter>(EmailReadNotificationTriggerDetails_get_TimeCreated), nullptr, nullptr, nullptr },
        { "account_name", reinterpret_cast<getter>(EmailReadNotificationTriggerDetails_get_AccountName), nullptr, nullptr, nullptr },
        { "is_read", reinterpret_cast<getter>(EmailReadNotificationTriggerDetails_get_IsRead), nullptr, nullptr, nullptr },
        { "message_entry_id", reinterpret_cast<getter>(EmailReadNotificationTriggerDetails_get_MessageEntryId), nullptr, nullptr, nullptr },
        { "parent_folder_name", reinterpret_cast<getter>(EmailReadNotificationTriggerDetails_get_ParentFolderName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EmailReadNotificationTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EmailReadNotificationTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EmailReadNotificationTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EmailReadNotificationTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EmailReadNotificationTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_EmailReadNotificationTriggerDetails =
    {
        "winrt._winrt_windows_phone_notification_management.EmailReadNotificationTriggerDetails",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::EmailReadNotificationTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EmailReadNotificationTriggerDetails
    };

    // ----- MediaControlsTriggerDetails class --------------------

    static PyObject* _new_MediaControlsTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Phone::Notification::Management::MediaControlsTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Phone::Notification::Management::MediaControlsTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaControlsTriggerDetails(py::wrapper::Windows::Phone::Notification::Management::MediaControlsTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaControlsTriggerDetails_get_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::MediaControlsTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.MediaControlsTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartedProcessing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaControlsTriggerDetails_put_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::MediaControlsTriggerDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.MediaControlsTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.StartedProcessing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaControlsTriggerDetails_get_AccessoryNotificationType(py::wrapper::Windows::Phone::Notification::Management::MediaControlsTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.MediaControlsTriggerDetails", L"AccessoryNotificationType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccessoryNotificationType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControlsTriggerDetails_get_AppDisplayName(py::wrapper::Windows::Phone::Notification::Management::MediaControlsTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.MediaControlsTriggerDetails", L"AppDisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControlsTriggerDetails_get_AppId(py::wrapper::Windows::Phone::Notification::Management::MediaControlsTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.MediaControlsTriggerDetails", L"AppId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControlsTriggerDetails_get_TimeCreated(py::wrapper::Windows::Phone::Notification::Management::MediaControlsTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.MediaControlsTriggerDetails", L"TimeCreated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimeCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControlsTriggerDetails_get_MediaMetadata(py::wrapper::Windows::Phone::Notification::Management::MediaControlsTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.MediaControlsTriggerDetails", L"MediaMetadata"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MediaMetadata());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaControlsTriggerDetails_get_PlaybackStatus(py::wrapper::Windows::Phone::Notification::Management::MediaControlsTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.MediaControlsTriggerDetails", L"PlaybackStatus"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PlaybackStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaControlsTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::MediaControlsTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaControlsTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::MediaControlsTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaControlsTriggerDetails[] = {
        { "_assign_array_", _assign_array_MediaControlsTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaControlsTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaControlsTriggerDetails[] = {
        { "started_processing", reinterpret_cast<getter>(MediaControlsTriggerDetails_get_StartedProcessing), reinterpret_cast<setter>(MediaControlsTriggerDetails_put_StartedProcessing), nullptr, nullptr },
        { "accessory_notification_type", reinterpret_cast<getter>(MediaControlsTriggerDetails_get_AccessoryNotificationType), nullptr, nullptr, nullptr },
        { "app_display_name", reinterpret_cast<getter>(MediaControlsTriggerDetails_get_AppDisplayName), nullptr, nullptr, nullptr },
        { "app_id", reinterpret_cast<getter>(MediaControlsTriggerDetails_get_AppId), nullptr, nullptr, nullptr },
        { "time_created", reinterpret_cast<getter>(MediaControlsTriggerDetails_get_TimeCreated), nullptr, nullptr, nullptr },
        { "media_metadata", reinterpret_cast<getter>(MediaControlsTriggerDetails_get_MediaMetadata), nullptr, nullptr, nullptr },
        { "playback_status", reinterpret_cast<getter>(MediaControlsTriggerDetails_get_PlaybackStatus), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaControlsTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaControlsTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaControlsTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaControlsTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaControlsTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_MediaControlsTriggerDetails =
    {
        "winrt._winrt_windows_phone_notification_management.MediaControlsTriggerDetails",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::MediaControlsTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaControlsTriggerDetails
    };

    // ----- MediaMetadata class --------------------

    static PyObject* _new_MediaMetadata(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Phone::Notification::Management::MediaMetadata>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Phone::Notification::Management::MediaMetadata>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaMetadata(py::wrapper::Windows::Phone::Notification::Management::MediaMetadata* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaMetadata_get_Album(py::wrapper::Windows::Phone::Notification::Management::MediaMetadata* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.MediaMetadata", L"Album"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Album());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaMetadata_get_Artist(py::wrapper::Windows::Phone::Notification::Management::MediaMetadata* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.MediaMetadata", L"Artist"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Artist());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaMetadata_get_Duration(py::wrapper::Windows::Phone::Notification::Management::MediaMetadata* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.MediaMetadata", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaMetadata_get_Subtitle(py::wrapper::Windows::Phone::Notification::Management::MediaMetadata* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.MediaMetadata", L"Subtitle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Subtitle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaMetadata_get_Thumbnail(py::wrapper::Windows::Phone::Notification::Management::MediaMetadata* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.MediaMetadata", L"Thumbnail"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Thumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaMetadata_get_Title(py::wrapper::Windows::Phone::Notification::Management::MediaMetadata* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.MediaMetadata", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaMetadata_get_Track(py::wrapper::Windows::Phone::Notification::Management::MediaMetadata* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.MediaMetadata", L"Track"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Track());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaMetadata(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::MediaMetadata>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaMetadata(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::MediaMetadata>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaMetadata[] = {
        { "_assign_array_", _assign_array_MediaMetadata, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaMetadata), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaMetadata[] = {
        { "album", reinterpret_cast<getter>(MediaMetadata_get_Album), nullptr, nullptr, nullptr },
        { "artist", reinterpret_cast<getter>(MediaMetadata_get_Artist), nullptr, nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(MediaMetadata_get_Duration), nullptr, nullptr, nullptr },
        { "subtitle", reinterpret_cast<getter>(MediaMetadata_get_Subtitle), nullptr, nullptr, nullptr },
        { "thumbnail", reinterpret_cast<getter>(MediaMetadata_get_Thumbnail), nullptr, nullptr, nullptr },
        { "title", reinterpret_cast<getter>(MediaMetadata_get_Title), nullptr, nullptr, nullptr },
        { "track", reinterpret_cast<getter>(MediaMetadata_get_Track), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaMetadata[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaMetadata) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaMetadata) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaMetadata) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaMetadata) },
        { },
    };

    static PyType_Spec type_spec_MediaMetadata =
    {
        "winrt._winrt_windows_phone_notification_management.MediaMetadata",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::MediaMetadata),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaMetadata
    };

    // ----- PhoneCallDetails class --------------------

    static PyObject* _new_PhoneCallDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Phone::Notification::Management::PhoneCallDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Phone::Notification::Management::PhoneCallDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_PhoneCallDetails(py::wrapper::Windows::Phone::Notification::Management::PhoneCallDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneCallDetails_get_CallDirection(py::wrapper::Windows::Phone::Notification::Management::PhoneCallDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneCallDetails", L"CallDirection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CallDirection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallDetails_get_CallId(py::wrapper::Windows::Phone::Notification::Management::PhoneCallDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneCallDetails", L"CallId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CallId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallDetails_get_CallMediaType(py::wrapper::Windows::Phone::Notification::Management::PhoneCallDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneCallDetails", L"CallMediaType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CallMediaType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallDetails_get_CallTransport(py::wrapper::Windows::Phone::Notification::Management::PhoneCallDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneCallDetails", L"CallTransport"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CallTransport());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallDetails_get_ConferenceCallId(py::wrapper::Windows::Phone::Notification::Management::PhoneCallDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneCallDetails", L"ConferenceCallId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConferenceCallId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallDetails_get_ContactName(py::wrapper::Windows::Phone::Notification::Management::PhoneCallDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneCallDetails", L"ContactName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContactName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallDetails_get_EndTime(py::wrapper::Windows::Phone::Notification::Management::PhoneCallDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneCallDetails", L"EndTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallDetails_get_PhoneLine(py::wrapper::Windows::Phone::Notification::Management::PhoneCallDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneCallDetails", L"PhoneLine"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhoneLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallDetails_get_PhoneNumber(py::wrapper::Windows::Phone::Notification::Management::PhoneCallDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneCallDetails", L"PhoneNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhoneNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallDetails_get_PresetTextResponses(py::wrapper::Windows::Phone::Notification::Management::PhoneCallDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneCallDetails", L"PresetTextResponses"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PresetTextResponses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallDetails_get_StartTime(py::wrapper::Windows::Phone::Notification::Management::PhoneCallDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneCallDetails", L"StartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallDetails_get_State(py::wrapper::Windows::Phone::Notification::Management::PhoneCallDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneCallDetails", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneCallDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::PhoneCallDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneCallDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::PhoneCallDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallDetails[] = {
        { "_assign_array_", _assign_array_PhoneCallDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCallDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallDetails[] = {
        { "call_direction", reinterpret_cast<getter>(PhoneCallDetails_get_CallDirection), nullptr, nullptr, nullptr },
        { "call_id", reinterpret_cast<getter>(PhoneCallDetails_get_CallId), nullptr, nullptr, nullptr },
        { "call_media_type", reinterpret_cast<getter>(PhoneCallDetails_get_CallMediaType), nullptr, nullptr, nullptr },
        { "call_transport", reinterpret_cast<getter>(PhoneCallDetails_get_CallTransport), nullptr, nullptr, nullptr },
        { "conference_call_id", reinterpret_cast<getter>(PhoneCallDetails_get_ConferenceCallId), nullptr, nullptr, nullptr },
        { "contact_name", reinterpret_cast<getter>(PhoneCallDetails_get_ContactName), nullptr, nullptr, nullptr },
        { "end_time", reinterpret_cast<getter>(PhoneCallDetails_get_EndTime), nullptr, nullptr, nullptr },
        { "phone_line", reinterpret_cast<getter>(PhoneCallDetails_get_PhoneLine), nullptr, nullptr, nullptr },
        { "phone_number", reinterpret_cast<getter>(PhoneCallDetails_get_PhoneNumber), nullptr, nullptr, nullptr },
        { "preset_text_responses", reinterpret_cast<getter>(PhoneCallDetails_get_PresetTextResponses), nullptr, nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(PhoneCallDetails_get_StartTime), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(PhoneCallDetails_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneCallDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneCallDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneCallDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneCallDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneCallDetails) },
        { },
    };

    static PyType_Spec type_spec_PhoneCallDetails =
    {
        "winrt._winrt_windows_phone_notification_management.PhoneCallDetails",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::PhoneCallDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallDetails
    };

    // ----- PhoneLineDetails class --------------------

    static PyObject* _new_PhoneLineDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Phone::Notification::Management::PhoneLineDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Phone::Notification::Management::PhoneLineDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_PhoneLineDetails(py::wrapper::Windows::Phone::Notification::Management::PhoneLineDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneLineDetails_get_DefaultOutgoingLine(py::wrapper::Windows::Phone::Notification::Management::PhoneLineDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneLineDetails", L"DefaultOutgoingLine"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultOutgoingLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineDetails_get_DisplayName(py::wrapper::Windows::Phone::Notification::Management::PhoneLineDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneLineDetails", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineDetails_get_LineId(py::wrapper::Windows::Phone::Notification::Management::PhoneLineDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneLineDetails", L"LineId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LineId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineDetails_get_LineNumber(py::wrapper::Windows::Phone::Notification::Management::PhoneLineDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneLineDetails", L"LineNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LineNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineDetails_get_RegistrationState(py::wrapper::Windows::Phone::Notification::Management::PhoneLineDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneLineDetails", L"RegistrationState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RegistrationState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineDetails_get_VoicemailCount(py::wrapper::Windows::Phone::Notification::Management::PhoneLineDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneLineDetails", L"VoicemailCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VoicemailCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineDetails_get_MissedCallCount(py::wrapper::Windows::Phone::Notification::Management::PhoneLineDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneLineDetails", L"MissedCallCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MissedCallCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneLineDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::PhoneLineDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneLineDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::PhoneLineDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneLineDetails[] = {
        { "_assign_array_", _assign_array_PhoneLineDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneLineDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneLineDetails[] = {
        { "default_outgoing_line", reinterpret_cast<getter>(PhoneLineDetails_get_DefaultOutgoingLine), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(PhoneLineDetails_get_DisplayName), nullptr, nullptr, nullptr },
        { "line_id", reinterpret_cast<getter>(PhoneLineDetails_get_LineId), nullptr, nullptr, nullptr },
        { "line_number", reinterpret_cast<getter>(PhoneLineDetails_get_LineNumber), nullptr, nullptr, nullptr },
        { "registration_state", reinterpret_cast<getter>(PhoneLineDetails_get_RegistrationState), nullptr, nullptr, nullptr },
        { "voicemail_count", reinterpret_cast<getter>(PhoneLineDetails_get_VoicemailCount), nullptr, nullptr, nullptr },
        { "missed_call_count", reinterpret_cast<getter>(PhoneLineDetails_get_MissedCallCount), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneLineDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneLineDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneLineDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneLineDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneLineDetails) },
        { },
    };

    static PyType_Spec type_spec_PhoneLineDetails =
    {
        "winrt._winrt_windows_phone_notification_management.PhoneLineDetails",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::PhoneLineDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneLineDetails
    };

    // ----- PhoneNotificationTriggerDetails class --------------------

    static PyObject* _new_PhoneNotificationTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Phone::Notification::Management::PhoneNotificationTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Phone::Notification::Management::PhoneNotificationTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_PhoneNotificationTriggerDetails(py::wrapper::Windows::Phone::Notification::Management::PhoneNotificationTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneNotificationTriggerDetails_get_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::PhoneNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneNotificationTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartedProcessing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneNotificationTriggerDetails_put_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::PhoneNotificationTriggerDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneNotificationTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.StartedProcessing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneNotificationTriggerDetails_get_AccessoryNotificationType(py::wrapper::Windows::Phone::Notification::Management::PhoneNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneNotificationTriggerDetails", L"AccessoryNotificationType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccessoryNotificationType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneNotificationTriggerDetails_get_AppDisplayName(py::wrapper::Windows::Phone::Notification::Management::PhoneNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneNotificationTriggerDetails", L"AppDisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneNotificationTriggerDetails_get_AppId(py::wrapper::Windows::Phone::Notification::Management::PhoneNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneNotificationTriggerDetails", L"AppId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneNotificationTriggerDetails_get_TimeCreated(py::wrapper::Windows::Phone::Notification::Management::PhoneNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneNotificationTriggerDetails", L"TimeCreated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimeCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneNotificationTriggerDetails_get_CallDetails(py::wrapper::Windows::Phone::Notification::Management::PhoneNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneNotificationTriggerDetails", L"CallDetails"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CallDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneNotificationTriggerDetails_get_PhoneLineChangedId(py::wrapper::Windows::Phone::Notification::Management::PhoneNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneNotificationTriggerDetails", L"PhoneLineChangedId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhoneLineChangedId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneNotificationTriggerDetails_get_PhoneNotificationType(py::wrapper::Windows::Phone::Notification::Management::PhoneNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.PhoneNotificationTriggerDetails", L"PhoneNotificationType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhoneNotificationType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhoneNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::PhoneNotificationTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhoneNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::PhoneNotificationTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneNotificationTriggerDetails[] = {
        { "_assign_array_", _assign_array_PhoneNotificationTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneNotificationTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneNotificationTriggerDetails[] = {
        { "started_processing", reinterpret_cast<getter>(PhoneNotificationTriggerDetails_get_StartedProcessing), reinterpret_cast<setter>(PhoneNotificationTriggerDetails_put_StartedProcessing), nullptr, nullptr },
        { "accessory_notification_type", reinterpret_cast<getter>(PhoneNotificationTriggerDetails_get_AccessoryNotificationType), nullptr, nullptr, nullptr },
        { "app_display_name", reinterpret_cast<getter>(PhoneNotificationTriggerDetails_get_AppDisplayName), nullptr, nullptr, nullptr },
        { "app_id", reinterpret_cast<getter>(PhoneNotificationTriggerDetails_get_AppId), nullptr, nullptr, nullptr },
        { "time_created", reinterpret_cast<getter>(PhoneNotificationTriggerDetails_get_TimeCreated), nullptr, nullptr, nullptr },
        { "call_details", reinterpret_cast<getter>(PhoneNotificationTriggerDetails_get_CallDetails), nullptr, nullptr, nullptr },
        { "phone_line_changed_id", reinterpret_cast<getter>(PhoneNotificationTriggerDetails_get_PhoneLineChangedId), nullptr, nullptr, nullptr },
        { "phone_notification_type", reinterpret_cast<getter>(PhoneNotificationTriggerDetails_get_PhoneNotificationType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneNotificationTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhoneNotificationTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhoneNotificationTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhoneNotificationTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhoneNotificationTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_PhoneNotificationTriggerDetails =
    {
        "winrt._winrt_windows_phone_notification_management.PhoneNotificationTriggerDetails",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::PhoneNotificationTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneNotificationTriggerDetails
    };

    // ----- ReminderNotificationTriggerDetails class --------------------

    static PyObject* _new_ReminderNotificationTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_ReminderNotificationTriggerDetails(py::wrapper::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ReminderNotificationTriggerDetails_get_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ReminderNotificationTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartedProcessing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReminderNotificationTriggerDetails_put_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ReminderNotificationTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.StartedProcessing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReminderNotificationTriggerDetails_get_AccessoryNotificationType(py::wrapper::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ReminderNotificationTriggerDetails", L"AccessoryNotificationType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccessoryNotificationType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReminderNotificationTriggerDetails_get_AppDisplayName(py::wrapper::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ReminderNotificationTriggerDetails", L"AppDisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReminderNotificationTriggerDetails_get_AppId(py::wrapper::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ReminderNotificationTriggerDetails", L"AppId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReminderNotificationTriggerDetails_get_TimeCreated(py::wrapper::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ReminderNotificationTriggerDetails", L"TimeCreated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimeCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReminderNotificationTriggerDetails_get_Appointment(py::wrapper::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ReminderNotificationTriggerDetails", L"Appointment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Appointment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReminderNotificationTriggerDetails_get_Description(py::wrapper::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ReminderNotificationTriggerDetails", L"Description"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReminderNotificationTriggerDetails_get_Details(py::wrapper::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ReminderNotificationTriggerDetails", L"Details"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Details());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReminderNotificationTriggerDetails_get_ReminderId(py::wrapper::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ReminderNotificationTriggerDetails", L"ReminderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReminderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReminderNotificationTriggerDetails_get_ReminderState(py::wrapper::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ReminderNotificationTriggerDetails", L"ReminderState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReminderState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReminderNotificationTriggerDetails_get_Timestamp(py::wrapper::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ReminderNotificationTriggerDetails", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReminderNotificationTriggerDetails_get_Title(py::wrapper::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ReminderNotificationTriggerDetails", L"Title"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReminderNotificationTriggerDetails_get_InstanceId(py::wrapper::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ReminderNotificationTriggerDetails", L"InstanceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InstanceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ReminderNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ReminderNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ReminderNotificationTriggerDetails[] = {
        { "_assign_array_", _assign_array_ReminderNotificationTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ReminderNotificationTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ReminderNotificationTriggerDetails[] = {
        { "started_processing", reinterpret_cast<getter>(ReminderNotificationTriggerDetails_get_StartedProcessing), reinterpret_cast<setter>(ReminderNotificationTriggerDetails_put_StartedProcessing), nullptr, nullptr },
        { "accessory_notification_type", reinterpret_cast<getter>(ReminderNotificationTriggerDetails_get_AccessoryNotificationType), nullptr, nullptr, nullptr },
        { "app_display_name", reinterpret_cast<getter>(ReminderNotificationTriggerDetails_get_AppDisplayName), nullptr, nullptr, nullptr },
        { "app_id", reinterpret_cast<getter>(ReminderNotificationTriggerDetails_get_AppId), nullptr, nullptr, nullptr },
        { "time_created", reinterpret_cast<getter>(ReminderNotificationTriggerDetails_get_TimeCreated), nullptr, nullptr, nullptr },
        { "appointment", reinterpret_cast<getter>(ReminderNotificationTriggerDetails_get_Appointment), nullptr, nullptr, nullptr },
        { "description", reinterpret_cast<getter>(ReminderNotificationTriggerDetails_get_Description), nullptr, nullptr, nullptr },
        { "details", reinterpret_cast<getter>(ReminderNotificationTriggerDetails_get_Details), nullptr, nullptr, nullptr },
        { "reminder_id", reinterpret_cast<getter>(ReminderNotificationTriggerDetails_get_ReminderId), nullptr, nullptr, nullptr },
        { "reminder_state", reinterpret_cast<getter>(ReminderNotificationTriggerDetails_get_ReminderState), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(ReminderNotificationTriggerDetails_get_Timestamp), nullptr, nullptr, nullptr },
        { "title", reinterpret_cast<getter>(ReminderNotificationTriggerDetails_get_Title), nullptr, nullptr, nullptr },
        { "instance_id", reinterpret_cast<getter>(ReminderNotificationTriggerDetails_get_InstanceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ReminderNotificationTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ReminderNotificationTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ReminderNotificationTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ReminderNotificationTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ReminderNotificationTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_ReminderNotificationTriggerDetails =
    {
        "winrt._winrt_windows_phone_notification_management.ReminderNotificationTriggerDetails",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::ReminderNotificationTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ReminderNotificationTriggerDetails
    };

    // ----- SpeedDialEntry class --------------------

    static PyObject* _new_SpeedDialEntry(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Phone::Notification::Management::SpeedDialEntry>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Phone::Notification::Management::SpeedDialEntry>::type_name);
        return nullptr;
    }

    static void _dealloc_SpeedDialEntry(py::wrapper::Windows::Phone::Notification::Management::SpeedDialEntry* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeedDialEntry_get_ContactName(py::wrapper::Windows::Phone::Notification::Management::SpeedDialEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.SpeedDialEntry", L"ContactName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContactName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeedDialEntry_get_NumberType(py::wrapper::Windows::Phone::Notification::Management::SpeedDialEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.SpeedDialEntry", L"NumberType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NumberType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeedDialEntry_get_PhoneNumber(py::wrapper::Windows::Phone::Notification::Management::SpeedDialEntry* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.SpeedDialEntry", L"PhoneNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PhoneNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpeedDialEntry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::SpeedDialEntry>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpeedDialEntry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::SpeedDialEntry>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeedDialEntry[] = {
        { "_assign_array_", _assign_array_SpeedDialEntry, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeedDialEntry), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeedDialEntry[] = {
        { "contact_name", reinterpret_cast<getter>(SpeedDialEntry_get_ContactName), nullptr, nullptr, nullptr },
        { "number_type", reinterpret_cast<getter>(SpeedDialEntry_get_NumberType), nullptr, nullptr, nullptr },
        { "phone_number", reinterpret_cast<getter>(SpeedDialEntry_get_PhoneNumber), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeedDialEntry[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpeedDialEntry) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpeedDialEntry) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpeedDialEntry) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpeedDialEntry) },
        { },
    };

    static PyType_Spec type_spec_SpeedDialEntry =
    {
        "winrt._winrt_windows_phone_notification_management.SpeedDialEntry",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::SpeedDialEntry),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeedDialEntry
    };

    // ----- TextResponse class --------------------

    static PyObject* _new_TextResponse(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Phone::Notification::Management::TextResponse>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Phone::Notification::Management::TextResponse>::type_name);
        return nullptr;
    }

    static void _dealloc_TextResponse(py::wrapper::Windows::Phone::Notification::Management::TextResponse* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TextResponse_get_Content(py::wrapper::Windows::Phone::Notification::Management::TextResponse* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.TextResponse", L"Content"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Content());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TextResponse_get_Id(py::wrapper::Windows::Phone::Notification::Management::TextResponse* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.TextResponse", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TextResponse(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::TextResponse>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TextResponse(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::TextResponse>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TextResponse[] = {
        { "_assign_array_", _assign_array_TextResponse, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TextResponse), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TextResponse[] = {
        { "content", reinterpret_cast<getter>(TextResponse_get_Content), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(TextResponse_get_Id), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TextResponse[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TextResponse) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TextResponse) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TextResponse) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TextResponse) },
        { },
    };

    static PyType_Spec type_spec_TextResponse =
    {
        "winrt._winrt_windows_phone_notification_management.TextResponse",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::TextResponse),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TextResponse
    };

    // ----- ToastNotificationTriggerDetails class --------------------

    static PyObject* _new_ToastNotificationTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Phone::Notification::Management::ToastNotificationTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Phone::Notification::Management::ToastNotificationTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_ToastNotificationTriggerDetails(py::wrapper::Windows::Phone::Notification::Management::ToastNotificationTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToastNotificationTriggerDetails_get_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::ToastNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ToastNotificationTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartedProcessing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ToastNotificationTriggerDetails_put_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::ToastNotificationTriggerDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ToastNotificationTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.StartedProcessing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ToastNotificationTriggerDetails_get_AccessoryNotificationType(py::wrapper::Windows::Phone::Notification::Management::ToastNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ToastNotificationTriggerDetails", L"AccessoryNotificationType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccessoryNotificationType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationTriggerDetails_get_AppDisplayName(py::wrapper::Windows::Phone::Notification::Management::ToastNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ToastNotificationTriggerDetails", L"AppDisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationTriggerDetails_get_AppId(py::wrapper::Windows::Phone::Notification::Management::ToastNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ToastNotificationTriggerDetails", L"AppId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationTriggerDetails_get_TimeCreated(py::wrapper::Windows::Phone::Notification::Management::ToastNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ToastNotificationTriggerDetails", L"TimeCreated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimeCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationTriggerDetails_get_SuppressPopup(py::wrapper::Windows::Phone::Notification::Management::ToastNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ToastNotificationTriggerDetails", L"SuppressPopup"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SuppressPopup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationTriggerDetails_get_Text1(py::wrapper::Windows::Phone::Notification::Management::ToastNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ToastNotificationTriggerDetails", L"Text1"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Text1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationTriggerDetails_get_Text2(py::wrapper::Windows::Phone::Notification::Management::ToastNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ToastNotificationTriggerDetails", L"Text2"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Text2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationTriggerDetails_get_Text3(py::wrapper::Windows::Phone::Notification::Management::ToastNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ToastNotificationTriggerDetails", L"Text3"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Text3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationTriggerDetails_get_Text4(py::wrapper::Windows::Phone::Notification::Management::ToastNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ToastNotificationTriggerDetails", L"Text4"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Text4());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationTriggerDetails_get_InstanceId(py::wrapper::Windows::Phone::Notification::Management::ToastNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.ToastNotificationTriggerDetails", L"InstanceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InstanceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToastNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::ToastNotificationTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToastNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::ToastNotificationTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastNotificationTriggerDetails[] = {
        { "_assign_array_", _assign_array_ToastNotificationTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToastNotificationTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToastNotificationTriggerDetails[] = {
        { "started_processing", reinterpret_cast<getter>(ToastNotificationTriggerDetails_get_StartedProcessing), reinterpret_cast<setter>(ToastNotificationTriggerDetails_put_StartedProcessing), nullptr, nullptr },
        { "accessory_notification_type", reinterpret_cast<getter>(ToastNotificationTriggerDetails_get_AccessoryNotificationType), nullptr, nullptr, nullptr },
        { "app_display_name", reinterpret_cast<getter>(ToastNotificationTriggerDetails_get_AppDisplayName), nullptr, nullptr, nullptr },
        { "app_id", reinterpret_cast<getter>(ToastNotificationTriggerDetails_get_AppId), nullptr, nullptr, nullptr },
        { "time_created", reinterpret_cast<getter>(ToastNotificationTriggerDetails_get_TimeCreated), nullptr, nullptr, nullptr },
        { "suppress_popup", reinterpret_cast<getter>(ToastNotificationTriggerDetails_get_SuppressPopup), nullptr, nullptr, nullptr },
        { "text1", reinterpret_cast<getter>(ToastNotificationTriggerDetails_get_Text1), nullptr, nullptr, nullptr },
        { "text2", reinterpret_cast<getter>(ToastNotificationTriggerDetails_get_Text2), nullptr, nullptr, nullptr },
        { "text3", reinterpret_cast<getter>(ToastNotificationTriggerDetails_get_Text3), nullptr, nullptr, nullptr },
        { "text4", reinterpret_cast<getter>(ToastNotificationTriggerDetails_get_Text4), nullptr, nullptr, nullptr },
        { "instance_id", reinterpret_cast<getter>(ToastNotificationTriggerDetails_get_InstanceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ToastNotificationTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToastNotificationTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToastNotificationTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToastNotificationTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToastNotificationTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_ToastNotificationTriggerDetails =
    {
        "winrt._winrt_windows_phone_notification_management.ToastNotificationTriggerDetails",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::ToastNotificationTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastNotificationTriggerDetails
    };

    // ----- VolumeInfo class --------------------

    static PyObject* _new_VolumeInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Phone::Notification::Management::VolumeInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Phone::Notification::Management::VolumeInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_VolumeInfo(py::wrapper::Windows::Phone::Notification::Management::VolumeInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VolumeInfo_get_CallVolume(py::wrapper::Windows::Phone::Notification::Management::VolumeInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.VolumeInfo", L"CallVolume"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CallVolume());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VolumeInfo_get_IsMuted(py::wrapper::Windows::Phone::Notification::Management::VolumeInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.VolumeInfo", L"IsMuted"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsMuted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VolumeInfo_get_IsVibrateEnabled(py::wrapper::Windows::Phone::Notification::Management::VolumeInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.VolumeInfo", L"IsVibrateEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsVibrateEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VolumeInfo_get_MediaVolume(py::wrapper::Windows::Phone::Notification::Management::VolumeInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.VolumeInfo", L"MediaVolume"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MediaVolume());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VolumeInfo_get_SystemVolume(py::wrapper::Windows::Phone::Notification::Management::VolumeInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.VolumeInfo", L"SystemVolume"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SystemVolume());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_VolumeInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::VolumeInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VolumeInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::VolumeInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VolumeInfo[] = {
        { "_assign_array_", _assign_array_VolumeInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VolumeInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VolumeInfo[] = {
        { "call_volume", reinterpret_cast<getter>(VolumeInfo_get_CallVolume), nullptr, nullptr, nullptr },
        { "is_muted", reinterpret_cast<getter>(VolumeInfo_get_IsMuted), nullptr, nullptr, nullptr },
        { "is_vibrate_enabled", reinterpret_cast<getter>(VolumeInfo_get_IsVibrateEnabled), nullptr, nullptr, nullptr },
        { "media_volume", reinterpret_cast<getter>(VolumeInfo_get_MediaVolume), nullptr, nullptr, nullptr },
        { "system_volume", reinterpret_cast<getter>(VolumeInfo_get_SystemVolume), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VolumeInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_VolumeInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VolumeInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VolumeInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VolumeInfo) },
        { },
    };

    static PyType_Spec type_spec_VolumeInfo =
    {
        "winrt._winrt_windows_phone_notification_management.VolumeInfo",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::VolumeInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VolumeInfo
    };

    // ----- IAccessoryNotificationTriggerDetails interface --------------------

    static PyObject* _new_IAccessoryNotificationTriggerDetails(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Phone::Notification::Management::IAccessoryNotificationTriggerDetails>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Phone::Notification::Management::IAccessoryNotificationTriggerDetails>::type_name);
        return nullptr;
    }

    static void _dealloc_IAccessoryNotificationTriggerDetails(py::wrapper::Windows::Phone::Notification::Management::IAccessoryNotificationTriggerDetails* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAccessoryNotificationTriggerDetails_get_AccessoryNotificationType(py::wrapper::Windows::Phone::Notification::Management::IAccessoryNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.IAccessoryNotificationTriggerDetails", L"AccessoryNotificationType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AccessoryNotificationType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAccessoryNotificationTriggerDetails_get_AppDisplayName(py::wrapper::Windows::Phone::Notification::Management::IAccessoryNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.IAccessoryNotificationTriggerDetails", L"AppDisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAccessoryNotificationTriggerDetails_get_AppId(py::wrapper::Windows::Phone::Notification::Management::IAccessoryNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.IAccessoryNotificationTriggerDetails", L"AppId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAccessoryNotificationTriggerDetails_get_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::IAccessoryNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.IAccessoryNotificationTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartedProcessing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAccessoryNotificationTriggerDetails_put_StartedProcessing(py::wrapper::Windows::Phone::Notification::Management::IAccessoryNotificationTriggerDetails* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.IAccessoryNotificationTriggerDetails", L"StartedProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.StartedProcessing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAccessoryNotificationTriggerDetails_get_TimeCreated(py::wrapper::Windows::Phone::Notification::Management::IAccessoryNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Phone.Notification.Management.IAccessoryNotificationTriggerDetails", L"TimeCreated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimeCreated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IAccessoryNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Phone::Notification::Management::IAccessoryNotificationTriggerDetails>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAccessoryNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Phone::Notification::Management::IAccessoryNotificationTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAccessoryNotificationTriggerDetails[] = {
        { "_assign_array_", _assign_array_IAccessoryNotificationTriggerDetails, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAccessoryNotificationTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAccessoryNotificationTriggerDetails[] = {
        { "accessory_notification_type", reinterpret_cast<getter>(IAccessoryNotificationTriggerDetails_get_AccessoryNotificationType), nullptr, nullptr, nullptr },
        { "app_display_name", reinterpret_cast<getter>(IAccessoryNotificationTriggerDetails_get_AppDisplayName), nullptr, nullptr, nullptr },
        { "app_id", reinterpret_cast<getter>(IAccessoryNotificationTriggerDetails_get_AppId), nullptr, nullptr, nullptr },
        { "started_processing", reinterpret_cast<getter>(IAccessoryNotificationTriggerDetails_get_StartedProcessing), reinterpret_cast<setter>(IAccessoryNotificationTriggerDetails_put_StartedProcessing), nullptr, nullptr },
        { "time_created", reinterpret_cast<getter>(IAccessoryNotificationTriggerDetails_get_TimeCreated), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAccessoryNotificationTriggerDetails[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IAccessoryNotificationTriggerDetails) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAccessoryNotificationTriggerDetails) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAccessoryNotificationTriggerDetails) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAccessoryNotificationTriggerDetails) },
        { },
    };

    static PyType_Spec type_spec_IAccessoryNotificationTriggerDetails =
    {
        "winrt._winrt_windows_phone_notification_management.IAccessoryNotificationTriggerDetails",
        sizeof(py::wrapper::Windows::Phone::Notification::Management::IAccessoryNotificationTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAccessoryNotificationTriggerDetails
    };

    // ----- Windows.Phone.Notification.Management Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Phone::Notification::Management");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_phone_notification_management",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::Phone::Notification::Management

PyMODINIT_FUNC PyInit__winrt_windows_phone_notification_management(void) noexcept
{
    using namespace py::cpp::Windows::Phone::Notification::Management;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AccessoryManager_Static{PyType_FromSpec(&type_spec_AccessoryManager_Static)};
    if (!type_AccessoryManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AccessoryManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AccessoryManager_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AlarmNotificationTriggerDetails, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AppNotificationInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BinaryId, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CalendarChangedNotificationTriggerDetails, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CortanaTileNotificationTriggerDetails, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EmailAccountInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EmailFolderInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EmailNotificationTriggerDetails, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EmailReadNotificationTriggerDetails, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaControlsTriggerDetails, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaMetadata, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PhoneCallDetails, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PhoneLineDetails, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PhoneNotificationTriggerDetails, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ReminderNotificationTriggerDetails, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SpeedDialEntry, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TextResponse, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ToastNotificationTriggerDetails, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_VolumeInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IAccessoryNotificationTriggerDetails, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
