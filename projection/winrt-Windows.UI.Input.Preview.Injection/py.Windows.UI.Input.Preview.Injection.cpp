// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

#include "py.Windows.UI.Input.Preview.Injection.h"


namespace py::cpp::Windows::UI::Input::Preview::Injection
{
    // ----- InjectedInputGamepadInfo class --------------------

    static PyObject* _new_InjectedInputGamepadInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::GamepadReading>(args, 0);

                winrt::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InjectedInputGamepadInfo(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InjectedInputGamepadInfo_get_RightTrigger(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputGamepadInfo", L"RightTrigger"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RightTrigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputGamepadInfo_put_RightTrigger(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputGamepadInfo", L"RightTrigger"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.RightTrigger(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputGamepadInfo_get_RightThumbstickY(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputGamepadInfo", L"RightThumbstickY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RightThumbstickY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputGamepadInfo_put_RightThumbstickY(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputGamepadInfo", L"RightThumbstickY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.RightThumbstickY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputGamepadInfo_get_RightThumbstickX(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputGamepadInfo", L"RightThumbstickX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RightThumbstickX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputGamepadInfo_put_RightThumbstickX(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputGamepadInfo", L"RightThumbstickX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.RightThumbstickX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputGamepadInfo_get_LeftTrigger(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputGamepadInfo", L"LeftTrigger"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LeftTrigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputGamepadInfo_put_LeftTrigger(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputGamepadInfo", L"LeftTrigger"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.LeftTrigger(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputGamepadInfo_get_LeftThumbstickY(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputGamepadInfo", L"LeftThumbstickY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LeftThumbstickY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputGamepadInfo_put_LeftThumbstickY(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputGamepadInfo", L"LeftThumbstickY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.LeftThumbstickY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputGamepadInfo_get_LeftThumbstickX(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputGamepadInfo", L"LeftThumbstickX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LeftThumbstickX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputGamepadInfo_put_LeftThumbstickX(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputGamepadInfo", L"LeftThumbstickX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.LeftThumbstickX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputGamepadInfo_get_Buttons(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputGamepadInfo", L"Buttons"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Buttons());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputGamepadInfo_put_Buttons(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputGamepadInfo", L"Buttons"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Gaming::Input::GamepadButtons>(arg);

            self->obj.Buttons(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_InjectedInputGamepadInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InjectedInputGamepadInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InjectedInputGamepadInfo[] = {
        { "_assign_array_", _assign_array_InjectedInputGamepadInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InjectedInputGamepadInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InjectedInputGamepadInfo[] = {
        { "right_trigger", reinterpret_cast<getter>(InjectedInputGamepadInfo_get_RightTrigger), reinterpret_cast<setter>(InjectedInputGamepadInfo_put_RightTrigger), nullptr, nullptr },
        { "right_thumbstick_y", reinterpret_cast<getter>(InjectedInputGamepadInfo_get_RightThumbstickY), reinterpret_cast<setter>(InjectedInputGamepadInfo_put_RightThumbstickY), nullptr, nullptr },
        { "right_thumbstick_x", reinterpret_cast<getter>(InjectedInputGamepadInfo_get_RightThumbstickX), reinterpret_cast<setter>(InjectedInputGamepadInfo_put_RightThumbstickX), nullptr, nullptr },
        { "left_trigger", reinterpret_cast<getter>(InjectedInputGamepadInfo_get_LeftTrigger), reinterpret_cast<setter>(InjectedInputGamepadInfo_put_LeftTrigger), nullptr, nullptr },
        { "left_thumbstick_y", reinterpret_cast<getter>(InjectedInputGamepadInfo_get_LeftThumbstickY), reinterpret_cast<setter>(InjectedInputGamepadInfo_put_LeftThumbstickY), nullptr, nullptr },
        { "left_thumbstick_x", reinterpret_cast<getter>(InjectedInputGamepadInfo_get_LeftThumbstickX), reinterpret_cast<setter>(InjectedInputGamepadInfo_put_LeftThumbstickX), nullptr, nullptr },
        { "buttons", reinterpret_cast<getter>(InjectedInputGamepadInfo_get_Buttons), reinterpret_cast<setter>(InjectedInputGamepadInfo_put_Buttons), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InjectedInputGamepadInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InjectedInputGamepadInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InjectedInputGamepadInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InjectedInputGamepadInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InjectedInputGamepadInfo) },
        { },
    };

    static PyType_Spec type_spec_InjectedInputGamepadInfo =
    {
        "winrt._winrt_windows_ui_input_preview_injection.InjectedInputGamepadInfo",
        sizeof(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InjectedInputGamepadInfo
    };

    // ----- InjectedInputKeyboardInfo class --------------------

    static PyObject* _new_InjectedInputKeyboardInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Input::Preview::Injection::InjectedInputKeyboardInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InjectedInputKeyboardInfo(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputKeyboardInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InjectedInputKeyboardInfo_get_VirtualKey(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputKeyboardInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputKeyboardInfo", L"VirtualKey"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VirtualKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputKeyboardInfo_put_VirtualKey(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputKeyboardInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputKeyboardInfo", L"VirtualKey"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint16_t>(arg);

            self->obj.VirtualKey(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputKeyboardInfo_get_ScanCode(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputKeyboardInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputKeyboardInfo", L"ScanCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ScanCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputKeyboardInfo_put_ScanCode(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputKeyboardInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputKeyboardInfo", L"ScanCode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint16_t>(arg);

            self->obj.ScanCode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputKeyboardInfo_get_KeyOptions(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputKeyboardInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputKeyboardInfo", L"KeyOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.KeyOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputKeyboardInfo_put_KeyOptions(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputKeyboardInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputKeyboardInfo", L"KeyOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputKeyOptions>(arg);

            self->obj.KeyOptions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_InjectedInputKeyboardInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Preview::Injection::InjectedInputKeyboardInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InjectedInputKeyboardInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Preview::Injection::InjectedInputKeyboardInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InjectedInputKeyboardInfo[] = {
        { "_assign_array_", _assign_array_InjectedInputKeyboardInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InjectedInputKeyboardInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InjectedInputKeyboardInfo[] = {
        { "virtual_key", reinterpret_cast<getter>(InjectedInputKeyboardInfo_get_VirtualKey), reinterpret_cast<setter>(InjectedInputKeyboardInfo_put_VirtualKey), nullptr, nullptr },
        { "scan_code", reinterpret_cast<getter>(InjectedInputKeyboardInfo_get_ScanCode), reinterpret_cast<setter>(InjectedInputKeyboardInfo_put_ScanCode), nullptr, nullptr },
        { "key_options", reinterpret_cast<getter>(InjectedInputKeyboardInfo_get_KeyOptions), reinterpret_cast<setter>(InjectedInputKeyboardInfo_put_KeyOptions), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InjectedInputKeyboardInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InjectedInputKeyboardInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InjectedInputKeyboardInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InjectedInputKeyboardInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InjectedInputKeyboardInfo) },
        { },
    };

    static PyType_Spec type_spec_InjectedInputKeyboardInfo =
    {
        "winrt._winrt_windows_ui_input_preview_injection.InjectedInputKeyboardInfo",
        sizeof(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputKeyboardInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InjectedInputKeyboardInfo
    };

    // ----- InjectedInputMouseInfo class --------------------

    static PyObject* _new_InjectedInputMouseInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InjectedInputMouseInfo(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InjectedInputMouseInfo_get_TimeOffsetInMilliseconds(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputMouseInfo", L"TimeOffsetInMilliseconds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TimeOffsetInMilliseconds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputMouseInfo_put_TimeOffsetInMilliseconds(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputMouseInfo", L"TimeOffsetInMilliseconds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.TimeOffsetInMilliseconds(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputMouseInfo_get_MouseOptions(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputMouseInfo", L"MouseOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MouseOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputMouseInfo_put_MouseOptions(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputMouseInfo", L"MouseOptions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputMouseOptions>(arg);

            self->obj.MouseOptions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputMouseInfo_get_MouseData(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputMouseInfo", L"MouseData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MouseData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputMouseInfo_put_MouseData(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputMouseInfo", L"MouseData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.MouseData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputMouseInfo_get_DeltaY(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputMouseInfo", L"DeltaY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeltaY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputMouseInfo_put_DeltaY(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputMouseInfo", L"DeltaY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.DeltaY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputMouseInfo_get_DeltaX(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputMouseInfo", L"DeltaX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeltaX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputMouseInfo_put_DeltaX(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputMouseInfo", L"DeltaX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.DeltaX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_InjectedInputMouseInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InjectedInputMouseInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InjectedInputMouseInfo[] = {
        { "_assign_array_", _assign_array_InjectedInputMouseInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InjectedInputMouseInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InjectedInputMouseInfo[] = {
        { "time_offset_in_milliseconds", reinterpret_cast<getter>(InjectedInputMouseInfo_get_TimeOffsetInMilliseconds), reinterpret_cast<setter>(InjectedInputMouseInfo_put_TimeOffsetInMilliseconds), nullptr, nullptr },
        { "mouse_options", reinterpret_cast<getter>(InjectedInputMouseInfo_get_MouseOptions), reinterpret_cast<setter>(InjectedInputMouseInfo_put_MouseOptions), nullptr, nullptr },
        { "mouse_data", reinterpret_cast<getter>(InjectedInputMouseInfo_get_MouseData), reinterpret_cast<setter>(InjectedInputMouseInfo_put_MouseData), nullptr, nullptr },
        { "delta_y", reinterpret_cast<getter>(InjectedInputMouseInfo_get_DeltaY), reinterpret_cast<setter>(InjectedInputMouseInfo_put_DeltaY), nullptr, nullptr },
        { "delta_x", reinterpret_cast<getter>(InjectedInputMouseInfo_get_DeltaX), reinterpret_cast<setter>(InjectedInputMouseInfo_put_DeltaX), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InjectedInputMouseInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InjectedInputMouseInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InjectedInputMouseInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InjectedInputMouseInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InjectedInputMouseInfo) },
        { },
    };

    static PyType_Spec type_spec_InjectedInputMouseInfo =
    {
        "winrt._winrt_windows_ui_input_preview_injection.InjectedInputMouseInfo",
        sizeof(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InjectedInputMouseInfo
    };

    // ----- InjectedInputPenInfo class --------------------

    static PyObject* _new_InjectedInputPenInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InjectedInputPenInfo(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InjectedInputPenInfo_get_TiltY(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputPenInfo", L"TiltY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TiltY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPenInfo_put_TiltY(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputPenInfo", L"TiltY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.TiltY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputPenInfo_get_TiltX(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputPenInfo", L"TiltX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TiltX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPenInfo_put_TiltX(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputPenInfo", L"TiltX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.TiltX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputPenInfo_get_Rotation(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputPenInfo", L"Rotation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Rotation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPenInfo_put_Rotation(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputPenInfo", L"Rotation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Rotation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputPenInfo_get_Pressure(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputPenInfo", L"Pressure"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Pressure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPenInfo_put_Pressure(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputPenInfo", L"Pressure"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Pressure(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputPenInfo_get_PointerInfo(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputPenInfo", L"PointerInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPenInfo_put_PointerInfo(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputPenInfo", L"PointerInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo>(arg);

            self->obj.PointerInfo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputPenInfo_get_PenParameters(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputPenInfo", L"PenParameters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PenParameters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPenInfo_put_PenParameters(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputPenInfo", L"PenParameters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPenParameters>(arg);

            self->obj.PenParameters(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputPenInfo_get_PenButtons(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputPenInfo", L"PenButtons"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PenButtons());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPenInfo_put_PenButtons(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputPenInfo", L"PenButtons"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPenButtons>(arg);

            self->obj.PenButtons(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_InjectedInputPenInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InjectedInputPenInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InjectedInputPenInfo[] = {
        { "_assign_array_", _assign_array_InjectedInputPenInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InjectedInputPenInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InjectedInputPenInfo[] = {
        { "tilt_y", reinterpret_cast<getter>(InjectedInputPenInfo_get_TiltY), reinterpret_cast<setter>(InjectedInputPenInfo_put_TiltY), nullptr, nullptr },
        { "tilt_x", reinterpret_cast<getter>(InjectedInputPenInfo_get_TiltX), reinterpret_cast<setter>(InjectedInputPenInfo_put_TiltX), nullptr, nullptr },
        { "rotation", reinterpret_cast<getter>(InjectedInputPenInfo_get_Rotation), reinterpret_cast<setter>(InjectedInputPenInfo_put_Rotation), nullptr, nullptr },
        { "pressure", reinterpret_cast<getter>(InjectedInputPenInfo_get_Pressure), reinterpret_cast<setter>(InjectedInputPenInfo_put_Pressure), nullptr, nullptr },
        { "pointer_info", reinterpret_cast<getter>(InjectedInputPenInfo_get_PointerInfo), reinterpret_cast<setter>(InjectedInputPenInfo_put_PointerInfo), nullptr, nullptr },
        { "pen_parameters", reinterpret_cast<getter>(InjectedInputPenInfo_get_PenParameters), reinterpret_cast<setter>(InjectedInputPenInfo_put_PenParameters), nullptr, nullptr },
        { "pen_buttons", reinterpret_cast<getter>(InjectedInputPenInfo_get_PenButtons), reinterpret_cast<setter>(InjectedInputPenInfo_put_PenButtons), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InjectedInputPenInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InjectedInputPenInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InjectedInputPenInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InjectedInputPenInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InjectedInputPenInfo) },
        { },
    };

    static PyType_Spec type_spec_InjectedInputPenInfo =
    {
        "winrt._winrt_windows_ui_input_preview_injection.InjectedInputPenInfo",
        sizeof(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InjectedInputPenInfo
    };

    // ----- InjectedInputTouchInfo class --------------------

    static PyObject* _new_InjectedInputTouchInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InjectedInputTouchInfo(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InjectedInputTouchInfo_get_TouchParameters(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputTouchInfo", L"TouchParameters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TouchParameters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputTouchInfo_put_TouchParameters(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputTouchInfo", L"TouchParameters"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputTouchParameters>(arg);

            self->obj.TouchParameters(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputTouchInfo_get_Pressure(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputTouchInfo", L"Pressure"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Pressure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputTouchInfo_put_Pressure(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputTouchInfo", L"Pressure"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Pressure(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputTouchInfo_get_PointerInfo(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputTouchInfo", L"PointerInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PointerInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputTouchInfo_put_PointerInfo(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputTouchInfo", L"PointerInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo>(arg);

            self->obj.PointerInfo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputTouchInfo_get_Orientation(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputTouchInfo", L"Orientation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputTouchInfo_put_Orientation(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputTouchInfo", L"Orientation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Orientation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputTouchInfo_get_Contact(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputTouchInfo", L"Contact"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputTouchInfo_put_Contact(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Input.Preview.Injection.InjectedInputTouchInfo", L"Contact"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputRectangle>(arg);

            self->obj.Contact(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_InjectedInputTouchInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InjectedInputTouchInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InjectedInputTouchInfo[] = {
        { "_assign_array_", _assign_array_InjectedInputTouchInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InjectedInputTouchInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InjectedInputTouchInfo[] = {
        { "touch_parameters", reinterpret_cast<getter>(InjectedInputTouchInfo_get_TouchParameters), reinterpret_cast<setter>(InjectedInputTouchInfo_put_TouchParameters), nullptr, nullptr },
        { "pressure", reinterpret_cast<getter>(InjectedInputTouchInfo_get_Pressure), reinterpret_cast<setter>(InjectedInputTouchInfo_put_Pressure), nullptr, nullptr },
        { "pointer_info", reinterpret_cast<getter>(InjectedInputTouchInfo_get_PointerInfo), reinterpret_cast<setter>(InjectedInputTouchInfo_put_PointerInfo), nullptr, nullptr },
        { "orientation", reinterpret_cast<getter>(InjectedInputTouchInfo_get_Orientation), reinterpret_cast<setter>(InjectedInputTouchInfo_put_Orientation), nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(InjectedInputTouchInfo_get_Contact), reinterpret_cast<setter>(InjectedInputTouchInfo_put_Contact), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InjectedInputTouchInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InjectedInputTouchInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InjectedInputTouchInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InjectedInputTouchInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InjectedInputTouchInfo) },
        { },
    };

    static PyType_Spec type_spec_InjectedInputTouchInfo =
    {
        "winrt._winrt_windows_ui_input_preview_injection.InjectedInputTouchInfo",
        sizeof(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InjectedInputTouchInfo
    };

    // ----- InputInjector class --------------------

    static PyObject* _new_InputInjector(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Input::Preview::Injection::InputInjector>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Input::Preview::Injection::InputInjector>::type_name);
        return nullptr;
    }

    static void _dealloc_InputInjector(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InputInjector_InitializeGamepadInjection(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Preview.Injection.InputInjector", L"InitializeGamepadInjection", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.InitializeGamepadInjection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputInjector_InitializePenInjection(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Preview.Injection.InputInjector", L"InitializePenInjection", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputVisualizationMode>(args, 0);

                self->obj.InitializePenInjection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputInjector_InitializeTouchInjection(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Preview.Injection.InputInjector", L"InitializeTouchInjection", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputVisualizationMode>(args, 0);

                self->obj.InitializeTouchInjection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputInjector_InjectGamepadInput(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Preview.Injection.InputInjector", L"InjectGamepadInput", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo>(args, 0);

                self->obj.InjectGamepadInput(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputInjector_InjectKeyboardInput(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Preview.Injection.InputInjector", L"InjectKeyboardInput", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::UI::Input::Preview::Injection::InjectedInputKeyboardInfo>>(args, 0);

                self->obj.InjectKeyboardInput(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputInjector_InjectMouseInput(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Preview.Injection.InputInjector", L"InjectMouseInput", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo>>(args, 0);

                self->obj.InjectMouseInput(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputInjector_InjectPenInput(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Preview.Injection.InputInjector", L"InjectPenInput", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo>(args, 0);

                self->obj.InjectPenInput(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputInjector_InjectShortcut(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Preview.Injection.InputInjector", L"InjectShortcut", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputShortcut>(args, 0);

                self->obj.InjectShortcut(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputInjector_InjectTouchInput(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Preview.Injection.InputInjector", L"InjectTouchInput", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo>>(args, 0);

                self->obj.InjectTouchInput(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputInjector_TryCreate(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Preview.Injection.InputInjector", L"TryCreate", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::UI::Input::Preview::Injection::InputInjector::TryCreate());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputInjector_TryCreateForAppBroadcastOnly(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Preview.Injection.InputInjector", L"TryCreateForAppBroadcastOnly", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::UI::Input::Preview::Injection::InputInjector::TryCreateForAppBroadcastOnly());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputInjector_UninitializeGamepadInjection(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Preview.Injection.InputInjector", L"UninitializeGamepadInjection", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.UninitializeGamepadInjection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputInjector_UninitializePenInjection(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Preview.Injection.InputInjector", L"UninitializePenInjection", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.UninitializePenInjection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputInjector_UninitializeTouchInjection(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Input.Preview.Injection.InputInjector", L"UninitializeTouchInjection", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.UninitializeTouchInjection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_InputInjector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Preview::Injection::InputInjector>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InputInjector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Preview::Injection::InputInjector>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InputInjector[] = {
        { "initialize_gamepad_injection", reinterpret_cast<PyCFunction>(InputInjector_InitializeGamepadInjection), METH_VARARGS, nullptr },
        { "initialize_pen_injection", reinterpret_cast<PyCFunction>(InputInjector_InitializePenInjection), METH_VARARGS, nullptr },
        { "initialize_touch_injection", reinterpret_cast<PyCFunction>(InputInjector_InitializeTouchInjection), METH_VARARGS, nullptr },
        { "inject_gamepad_input", reinterpret_cast<PyCFunction>(InputInjector_InjectGamepadInput), METH_VARARGS, nullptr },
        { "inject_keyboard_input", reinterpret_cast<PyCFunction>(InputInjector_InjectKeyboardInput), METH_VARARGS, nullptr },
        { "inject_mouse_input", reinterpret_cast<PyCFunction>(InputInjector_InjectMouseInput), METH_VARARGS, nullptr },
        { "inject_pen_input", reinterpret_cast<PyCFunction>(InputInjector_InjectPenInput), METH_VARARGS, nullptr },
        { "inject_shortcut", reinterpret_cast<PyCFunction>(InputInjector_InjectShortcut), METH_VARARGS, nullptr },
        { "inject_touch_input", reinterpret_cast<PyCFunction>(InputInjector_InjectTouchInput), METH_VARARGS, nullptr },
        { "uninitialize_gamepad_injection", reinterpret_cast<PyCFunction>(InputInjector_UninitializeGamepadInjection), METH_VARARGS, nullptr },
        { "uninitialize_pen_injection", reinterpret_cast<PyCFunction>(InputInjector_UninitializePenInjection), METH_VARARGS, nullptr },
        { "uninitialize_touch_injection", reinterpret_cast<PyCFunction>(InputInjector_UninitializeTouchInjection), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_InputInjector, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InputInjector), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InputInjector[] = {
        { }
    };

    static PyType_Slot _type_slots_InputInjector[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InputInjector) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InputInjector) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InputInjector) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InputInjector) },
        { },
    };

    static PyType_Spec type_spec_InputInjector =
    {
        "winrt._winrt_windows_ui_input_preview_injection.InputInjector",
        sizeof(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InputInjector
    };

    static PyGetSetDef getset_InputInjector_Static[] = {
        { }
    };

    static PyMethodDef methods_InputInjector_Static[] = {
        { "try_create", reinterpret_cast<PyCFunction>(InputInjector_TryCreate), METH_VARARGS, nullptr },
        { "try_create_for_app_broadcast_only", reinterpret_cast<PyCFunction>(InputInjector_TryCreateForAppBroadcastOnly), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_InputInjector_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InputInjector_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InputInjector_Static) },
        { }
    };

    static PyType_Spec type_spec_InputInjector_Static =
    {
        "winrt._winrt_windows_ui_input_preview_injection.InputInjector_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InputInjector_Static
    };

    // ----- InjectedInputPoint struct --------------------

    winrt_struct_wrapper<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPoint>* _new_InjectedInputPoint(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPoint>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_InjectedInputPoint(winrt_struct_wrapper<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPoint>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        int32_t _PositionX{};
        int32_t _PositionY{};

        static const char* kwlist[] = {"position_x", "position_y", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ii", const_cast<char**>(kwlist), &_PositionX, &_PositionY))
        {
            return -1;
        }

        try
        {
            self->obj = {_PositionX, _PositionY};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_InjectedInputPoint(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPoint* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_InjectedInputPoint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPoint>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_InjectedInputPoint[] = {
        { "_assign_array_", _assign_array_InjectedInputPoint, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* InjectedInputPoint_get_PositionX(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PositionX);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPoint_set_PositionX(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPoint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.PositionX = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputPoint_get_PositionY(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PositionY);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPoint_set_PositionY(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPoint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.PositionY = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_InjectedInputPoint[] = {
        { "position_x", reinterpret_cast<getter>(InjectedInputPoint_get_PositionX), reinterpret_cast<setter>(InjectedInputPoint_set_PositionX), nullptr, nullptr },
        { "position_y", reinterpret_cast<getter>(InjectedInputPoint_get_PositionY), reinterpret_cast<setter>(InjectedInputPoint_set_PositionY), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InjectedInputPoint[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InjectedInputPoint) },
        { Py_tp_init, reinterpret_cast<void*>(_init_InjectedInputPoint) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InjectedInputPoint) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InjectedInputPoint) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InjectedInputPoint) },
        { },
    };

    static PyType_Spec type_spec_InjectedInputPoint =
    {
        "winrt._winrt_windows_ui_input_preview_injection.InjectedInputPoint",
        sizeof(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPoint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InjectedInputPoint
    };

    // ----- InjectedInputPointerInfo struct --------------------

    winrt_struct_wrapper<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo>* _new_InjectedInputPointerInfo(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_InjectedInputPointerInfo(winrt_struct_wrapper<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        uint32_t _PointerId{};
        uint32_t _PointerOptions{};
        PyObject* _PixelLocation{};
        uint32_t _TimeOffsetInMilliseconds{};
        uint64_t _PerformanceCount{};

        static const char* kwlist[] = {"pointer_id", "pointer_options", "pixel_location", "time_offset_in_milliseconds", "performance_count", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "IIOIK", const_cast<char**>(kwlist), &_PointerId, &_PointerOptions, &_PixelLocation, &_TimeOffsetInMilliseconds, &_PerformanceCount))
        {
            return -1;
        }

        try
        {
            self->obj = {_PointerId, static_cast<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerOptions>(_PointerOptions), py::converter<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPoint>::convert_to(_PixelLocation), _TimeOffsetInMilliseconds, _PerformanceCount};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_InjectedInputPointerInfo(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_InjectedInputPointerInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_InjectedInputPointerInfo[] = {
        { "_assign_array_", _assign_array_InjectedInputPointerInfo, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* InjectedInputPointerInfo_get_PointerId(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PointerId);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPointerInfo_set_PointerId(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.PointerId = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputPointerInfo_get_PointerOptions(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PointerOptions);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPointerInfo_set_PointerOptions(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.PointerOptions = py::converter<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerOptions>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputPointerInfo_get_PixelLocation(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PixelLocation);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPointerInfo_set_PixelLocation(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.PixelLocation = py::converter<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPoint>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputPointerInfo_get_TimeOffsetInMilliseconds(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TimeOffsetInMilliseconds);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPointerInfo_set_TimeOffsetInMilliseconds(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.TimeOffsetInMilliseconds = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputPointerInfo_get_PerformanceCount(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PerformanceCount);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPointerInfo_set_PerformanceCount(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.PerformanceCount = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_InjectedInputPointerInfo[] = {
        { "pointer_id", reinterpret_cast<getter>(InjectedInputPointerInfo_get_PointerId), reinterpret_cast<setter>(InjectedInputPointerInfo_set_PointerId), nullptr, nullptr },
        { "pointer_options", reinterpret_cast<getter>(InjectedInputPointerInfo_get_PointerOptions), reinterpret_cast<setter>(InjectedInputPointerInfo_set_PointerOptions), nullptr, nullptr },
        { "pixel_location", reinterpret_cast<getter>(InjectedInputPointerInfo_get_PixelLocation), reinterpret_cast<setter>(InjectedInputPointerInfo_set_PixelLocation), nullptr, nullptr },
        { "time_offset_in_milliseconds", reinterpret_cast<getter>(InjectedInputPointerInfo_get_TimeOffsetInMilliseconds), reinterpret_cast<setter>(InjectedInputPointerInfo_set_TimeOffsetInMilliseconds), nullptr, nullptr },
        { "performance_count", reinterpret_cast<getter>(InjectedInputPointerInfo_get_PerformanceCount), reinterpret_cast<setter>(InjectedInputPointerInfo_set_PerformanceCount), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InjectedInputPointerInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InjectedInputPointerInfo) },
        { Py_tp_init, reinterpret_cast<void*>(_init_InjectedInputPointerInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InjectedInputPointerInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InjectedInputPointerInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InjectedInputPointerInfo) },
        { },
    };

    static PyType_Spec type_spec_InjectedInputPointerInfo =
    {
        "winrt._winrt_windows_ui_input_preview_injection.InjectedInputPointerInfo",
        sizeof(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InjectedInputPointerInfo
    };

    // ----- InjectedInputRectangle struct --------------------

    winrt_struct_wrapper<winrt::Windows::UI::Input::Preview::Injection::InjectedInputRectangle>* _new_InjectedInputRectangle(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::UI::Input::Preview::Injection::InjectedInputRectangle>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_InjectedInputRectangle(winrt_struct_wrapper<winrt::Windows::UI::Input::Preview::Injection::InjectedInputRectangle>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        int32_t _Left{};
        int32_t _Top{};
        int32_t _Bottom{};
        int32_t _Right{};

        static const char* kwlist[] = {"left", "top", "bottom", "right", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "iiii", const_cast<char**>(kwlist), &_Left, &_Top, &_Bottom, &_Right))
        {
            return -1;
        }

        try
        {
            self->obj = {_Left, _Top, _Bottom, _Right};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_InjectedInputRectangle(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputRectangle* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_InjectedInputRectangle(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Input::Preview::Injection::InjectedInputRectangle>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_InjectedInputRectangle[] = {
        { "_assign_array_", _assign_array_InjectedInputRectangle, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* InjectedInputRectangle_get_Left(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputRectangle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Left);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputRectangle_set_Left(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputRectangle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Left = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputRectangle_get_Top(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputRectangle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Top);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputRectangle_set_Top(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputRectangle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Top = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputRectangle_get_Bottom(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputRectangle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Bottom);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputRectangle_set_Bottom(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputRectangle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Bottom = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputRectangle_get_Right(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputRectangle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Right);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputRectangle_set_Right(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputRectangle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Right = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_InjectedInputRectangle[] = {
        { "left", reinterpret_cast<getter>(InjectedInputRectangle_get_Left), reinterpret_cast<setter>(InjectedInputRectangle_set_Left), nullptr, nullptr },
        { "top", reinterpret_cast<getter>(InjectedInputRectangle_get_Top), reinterpret_cast<setter>(InjectedInputRectangle_set_Top), nullptr, nullptr },
        { "bottom", reinterpret_cast<getter>(InjectedInputRectangle_get_Bottom), reinterpret_cast<setter>(InjectedInputRectangle_set_Bottom), nullptr, nullptr },
        { "right", reinterpret_cast<getter>(InjectedInputRectangle_get_Right), reinterpret_cast<setter>(InjectedInputRectangle_set_Right), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InjectedInputRectangle[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_InjectedInputRectangle) },
        { Py_tp_init, reinterpret_cast<void*>(_init_InjectedInputRectangle) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InjectedInputRectangle) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InjectedInputRectangle) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InjectedInputRectangle) },
        { },
    };

    static PyType_Spec type_spec_InjectedInputRectangle =
    {
        "winrt._winrt_windows_ui_input_preview_injection.InjectedInputRectangle",
        sizeof(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputRectangle),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InjectedInputRectangle
    };

    // ----- Windows.UI.Input.Preview.Injection Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::UI::Input::Preview::Injection");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_ui_input_preview_injection",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::UI::Input::Preview::Injection

PyMODINIT_FUNC PyInit__winrt_windows_ui_input_preview_injection(void) noexcept
{
    using namespace py::cpp::Windows::UI::Input::Preview::Injection;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InjectedInputGamepadInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InjectedInputKeyboardInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InjectedInputMouseInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InjectedInputPenInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InjectedInputTouchInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_InputInjector_Static{PyType_FromSpec(&type_spec_InputInjector_Static)};
    if (!type_InputInjector_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InputInjector, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_InputInjector_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InjectedInputPoint, nullptr, nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InjectedInputPointerInfo, nullptr, nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_InjectedInputRectangle, nullptr, nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
