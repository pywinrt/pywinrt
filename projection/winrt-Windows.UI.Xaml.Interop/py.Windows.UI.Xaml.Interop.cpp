// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

#include "py.Windows.UI.Xaml.Interop.h"


namespace py::cpp::Windows::UI::Xaml::Interop
{
    // ----- NotifyCollectionChangedEventArgs class --------------------

    static PyObject* _new_NotifyCollectionChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Interop::NotifyCollectionChangedAction>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Xaml::Interop::IBindableVector>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Xaml::Interop::IBindableVector>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);
                auto param4 = py::convert_to<int32_t>(args, 4);

                winrt::Windows::UI::Xaml::Interop::NotifyCollectionChangedEventArgs instance{ param0, param1, param2, param3, param4 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NotifyCollectionChangedEventArgs(py::wrapper::Windows::UI::Xaml::Interop::NotifyCollectionChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NotifyCollectionChangedEventArgs_get_Action(py::wrapper::Windows::UI::Xaml::Interop::NotifyCollectionChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Interop.NotifyCollectionChangedEventArgs", L"Action"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Action());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NotifyCollectionChangedEventArgs_get_NewItems(py::wrapper::Windows::UI::Xaml::Interop::NotifyCollectionChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Interop.NotifyCollectionChangedEventArgs", L"NewItems"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NewItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NotifyCollectionChangedEventArgs_get_NewStartingIndex(py::wrapper::Windows::UI::Xaml::Interop::NotifyCollectionChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Interop.NotifyCollectionChangedEventArgs", L"NewStartingIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NewStartingIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NotifyCollectionChangedEventArgs_get_OldItems(py::wrapper::Windows::UI::Xaml::Interop::NotifyCollectionChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Interop.NotifyCollectionChangedEventArgs", L"OldItems"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OldItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NotifyCollectionChangedEventArgs_get_OldStartingIndex(py::wrapper::Windows::UI::Xaml::Interop::NotifyCollectionChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Interop.NotifyCollectionChangedEventArgs", L"OldStartingIndex"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OldStartingIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NotifyCollectionChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Interop::NotifyCollectionChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NotifyCollectionChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Interop::NotifyCollectionChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NotifyCollectionChangedEventArgs[] = {
        { "_assign_array_", _assign_array_NotifyCollectionChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NotifyCollectionChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NotifyCollectionChangedEventArgs[] = {
        { "action", reinterpret_cast<getter>(NotifyCollectionChangedEventArgs_get_Action), nullptr, nullptr, nullptr },
        { "new_items", reinterpret_cast<getter>(NotifyCollectionChangedEventArgs_get_NewItems), nullptr, nullptr, nullptr },
        { "new_starting_index", reinterpret_cast<getter>(NotifyCollectionChangedEventArgs_get_NewStartingIndex), nullptr, nullptr, nullptr },
        { "old_items", reinterpret_cast<getter>(NotifyCollectionChangedEventArgs_get_OldItems), nullptr, nullptr, nullptr },
        { "old_starting_index", reinterpret_cast<getter>(NotifyCollectionChangedEventArgs_get_OldStartingIndex), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NotifyCollectionChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_NotifyCollectionChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NotifyCollectionChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NotifyCollectionChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NotifyCollectionChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_NotifyCollectionChangedEventArgs =
    {
        "winrt._winrt_windows_ui_xaml_interop.NotifyCollectionChangedEventArgs",
        sizeof(py::wrapper::Windows::UI::Xaml::Interop::NotifyCollectionChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NotifyCollectionChangedEventArgs
    };

    // ----- IBindableIterable interface --------------------

    static PyObject* _new_IBindableIterable(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Interop::IBindableIterable>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Interop::IBindableIterable>::type_name);
        return nullptr;
    }

    static void _dealloc_IBindableIterable(py::wrapper::Windows::UI::Xaml::Interop::IBindableIterable* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBindableIterable_First(py::wrapper::Windows::UI::Xaml::Interop::IBindableIterable* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Interop.IBindableIterable", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IBindableIterable(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Interop::IBindableIterable>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBindableIterable(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Interop::IBindableIterable>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBindableIterable[] = {
        { "first", reinterpret_cast<PyCFunction>(IBindableIterable_First), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IBindableIterable, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBindableIterable), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBindableIterable[] = {
        { }
    };

    static PyType_Slot _type_slots_IBindableIterable[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBindableIterable) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBindableIterable) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBindableIterable) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBindableIterable) },
        { },
    };

    static PyType_Spec type_spec_IBindableIterable =
    {
        "winrt._winrt_windows_ui_xaml_interop.IBindableIterable",
        sizeof(py::wrapper::Windows::UI::Xaml::Interop::IBindableIterable),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBindableIterable
    };

    // ----- IBindableIterator interface --------------------

    static PyObject* _new_IBindableIterator(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Interop::IBindableIterator>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Interop::IBindableIterator>::type_name);
        return nullptr;
    }

    static void _dealloc_IBindableIterator(py::wrapper::Windows::UI::Xaml::Interop::IBindableIterator* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBindableIterator_MoveNext(py::wrapper::Windows::UI::Xaml::Interop::IBindableIterator* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Interop.IBindableIterator", L"MoveNext", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.MoveNext());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBindableIterator_get_Current(py::wrapper::Windows::UI::Xaml::Interop::IBindableIterator* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Interop.IBindableIterator", L"Current"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Current());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBindableIterator_get_HasCurrent(py::wrapper::Windows::UI::Xaml::Interop::IBindableIterator* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Interop.IBindableIterator", L"HasCurrent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasCurrent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IBindableIterator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Interop::IBindableIterator>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBindableIterator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Interop::IBindableIterator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBindableIterator[] = {
        { "move_next", reinterpret_cast<PyCFunction>(IBindableIterator_MoveNext), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IBindableIterator, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBindableIterator), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBindableIterator[] = {
        { "current", reinterpret_cast<getter>(IBindableIterator_get_Current), nullptr, nullptr, nullptr },
        { "has_current", reinterpret_cast<getter>(IBindableIterator_get_HasCurrent), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBindableIterator[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBindableIterator) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBindableIterator) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBindableIterator) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBindableIterator) },
        { },
    };

    static PyType_Spec type_spec_IBindableIterator =
    {
        "winrt._winrt_windows_ui_xaml_interop.IBindableIterator",
        sizeof(py::wrapper::Windows::UI::Xaml::Interop::IBindableIterator),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBindableIterator
    };

    // ----- IBindableObservableVector interface --------------------

    static PyObject* _new_IBindableObservableVector(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Interop::IBindableObservableVector>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Interop::IBindableObservableVector>::type_name);
        return nullptr;
    }

    static void _dealloc_IBindableObservableVector(py::wrapper::Windows::UI::Xaml::Interop::IBindableObservableVector* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBindableObservableVector_Append(py::wrapper::Windows::UI::Xaml::Interop::IBindableObservableVector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Interop.IBindableVector", L"Append", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBindableObservableVector_Clear(py::wrapper::Windows::UI::Xaml::Interop::IBindableObservableVector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Interop.IBindableVector", L"Clear", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBindableObservableVector_First(py::wrapper::Windows::UI::Xaml::Interop::IBindableObservableVector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Interop.IBindableIterable", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBindableObservableVector_GetAt(py::wrapper::Windows::UI::Xaml::Interop::IBindableObservableVector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Interop.IBindableVector", L"GetAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBindableObservableVector_GetView(py::wrapper::Windows::UI::Xaml::Interop::IBindableObservableVector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Interop.IBindableVector", L"GetView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBindableObservableVector_IndexOf(py::wrapper::Windows::UI::Xaml::Interop::IBindableObservableVector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Interop.IBindableVector", L"IndexOf", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBindableObservableVector_InsertAt(py::wrapper::Windows::UI::Xaml::Interop::IBindableObservableVector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Interop.IBindableVector", L"InsertAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBindableObservableVector_RemoveAt(py::wrapper::Windows::UI::Xaml::Interop::IBindableObservableVector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Interop.IBindableVector", L"RemoveAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBindableObservableVector_RemoveAtEnd(py::wrapper::Windows::UI::Xaml::Interop::IBindableObservableVector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Interop.IBindableVector", L"RemoveAtEnd", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBindableObservableVector_SetAt(py::wrapper::Windows::UI::Xaml::Interop::IBindableObservableVector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Interop.IBindableVector", L"SetAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBindableObservableVector_get_Size(py::wrapper::Windows::UI::Xaml::Interop::IBindableObservableVector* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Interop.IBindableVector", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBindableObservableVector_add_VectorChanged(py::wrapper::Windows::UI::Xaml::Interop::IBindableObservableVector* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Interop.IBindableObservableVector", L"VectorChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Interop::BindableVectorChangedEventHandler>(arg);

            return py::convert(self->obj.VectorChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBindableObservableVector_remove_VectorChanged(py::wrapper::Windows::UI::Xaml::Interop::IBindableObservableVector* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Interop.IBindableObservableVector", L"VectorChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VectorChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IBindableObservableVector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Interop::IBindableObservableVector>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBindableObservableVector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Interop::IBindableObservableVector>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBindableObservableVector[] = {
        { "append", reinterpret_cast<PyCFunction>(IBindableObservableVector_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(IBindableObservableVector_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(IBindableObservableVector_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(IBindableObservableVector_GetAt), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(IBindableObservableVector_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(IBindableObservableVector_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(IBindableObservableVector_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(IBindableObservableVector_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(IBindableObservableVector_RemoveAtEnd), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(IBindableObservableVector_SetAt), METH_VARARGS, nullptr },
        { "add_vector_changed", reinterpret_cast<PyCFunction>(IBindableObservableVector_add_VectorChanged), METH_O, nullptr },
        { "remove_vector_changed", reinterpret_cast<PyCFunction>(IBindableObservableVector_remove_VectorChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_IBindableObservableVector, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBindableObservableVector), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBindableObservableVector[] = {
        { "size", reinterpret_cast<getter>(IBindableObservableVector_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBindableObservableVector[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBindableObservableVector) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBindableObservableVector) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBindableObservableVector) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBindableObservableVector) },
        { },
    };

    static PyType_Spec type_spec_IBindableObservableVector =
    {
        "winrt._winrt_windows_ui_xaml_interop.IBindableObservableVector",
        sizeof(py::wrapper::Windows::UI::Xaml::Interop::IBindableObservableVector),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBindableObservableVector
    };

    // ----- IBindableVector interface --------------------

    static PyObject* _new_IBindableVector(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Interop::IBindableVector>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Interop::IBindableVector>::type_name);
        return nullptr;
    }

    static void _dealloc_IBindableVector(py::wrapper::Windows::UI::Xaml::Interop::IBindableVector* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBindableVector_Append(py::wrapper::Windows::UI::Xaml::Interop::IBindableVector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Interop.IBindableVector", L"Append", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBindableVector_Clear(py::wrapper::Windows::UI::Xaml::Interop::IBindableVector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Interop.IBindableVector", L"Clear", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBindableVector_First(py::wrapper::Windows::UI::Xaml::Interop::IBindableVector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Interop.IBindableIterable", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBindableVector_GetAt(py::wrapper::Windows::UI::Xaml::Interop::IBindableVector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Interop.IBindableVector", L"GetAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBindableVector_GetView(py::wrapper::Windows::UI::Xaml::Interop::IBindableVector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Interop.IBindableVector", L"GetView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBindableVector_IndexOf(py::wrapper::Windows::UI::Xaml::Interop::IBindableVector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Interop.IBindableVector", L"IndexOf", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBindableVector_InsertAt(py::wrapper::Windows::UI::Xaml::Interop::IBindableVector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Interop.IBindableVector", L"InsertAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.InsertAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBindableVector_RemoveAt(py::wrapper::Windows::UI::Xaml::Interop::IBindableVector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Interop.IBindableVector", L"RemoveAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.RemoveAt(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBindableVector_RemoveAtEnd(py::wrapper::Windows::UI::Xaml::Interop::IBindableVector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Interop.IBindableVector", L"RemoveAtEnd", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RemoveAtEnd();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBindableVector_SetAt(py::wrapper::Windows::UI::Xaml::Interop::IBindableVector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Interop.IBindableVector", L"SetAt", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.SetAt(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBindableVector_get_Size(py::wrapper::Windows::UI::Xaml::Interop::IBindableVector* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Interop.IBindableVector", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IBindableVector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Interop::IBindableVector>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBindableVector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Interop::IBindableVector>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBindableVector[] = {
        { "append", reinterpret_cast<PyCFunction>(IBindableVector_Append), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(IBindableVector_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(IBindableVector_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(IBindableVector_GetAt), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(IBindableVector_GetView), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(IBindableVector_IndexOf), METH_VARARGS, nullptr },
        { "insert_at", reinterpret_cast<PyCFunction>(IBindableVector_InsertAt), METH_VARARGS, nullptr },
        { "remove_at", reinterpret_cast<PyCFunction>(IBindableVector_RemoveAt), METH_VARARGS, nullptr },
        { "remove_at_end", reinterpret_cast<PyCFunction>(IBindableVector_RemoveAtEnd), METH_VARARGS, nullptr },
        { "set_at", reinterpret_cast<PyCFunction>(IBindableVector_SetAt), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IBindableVector, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBindableVector), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBindableVector[] = {
        { "size", reinterpret_cast<getter>(IBindableVector_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBindableVector[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBindableVector) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBindableVector) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBindableVector) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBindableVector) },
        { },
    };

    static PyType_Spec type_spec_IBindableVector =
    {
        "winrt._winrt_windows_ui_xaml_interop.IBindableVector",
        sizeof(py::wrapper::Windows::UI::Xaml::Interop::IBindableVector),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBindableVector
    };

    // ----- IBindableVectorView interface --------------------

    static PyObject* _new_IBindableVectorView(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Interop::IBindableVectorView>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Interop::IBindableVectorView>::type_name);
        return nullptr;
    }

    static void _dealloc_IBindableVectorView(py::wrapper::Windows::UI::Xaml::Interop::IBindableVectorView* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBindableVectorView_First(py::wrapper::Windows::UI::Xaml::Interop::IBindableVectorView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Interop.IBindableIterable", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBindableVectorView_GetAt(py::wrapper::Windows::UI::Xaml::Interop::IBindableVectorView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Interop.IBindableVectorView", L"GetAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBindableVectorView_IndexOf(py::wrapper::Windows::UI::Xaml::Interop::IBindableVectorView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.UI.Xaml.Interop.IBindableVectorView", L"IndexOf", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBindableVectorView_get_Size(py::wrapper::Windows::UI::Xaml::Interop::IBindableVectorView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.UI.Xaml.Interop.IBindableVectorView", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IBindableVectorView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Interop::IBindableVectorView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBindableVectorView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Interop::IBindableVectorView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBindableVectorView[] = {
        { "first", reinterpret_cast<PyCFunction>(IBindableVectorView_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(IBindableVectorView_GetAt), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(IBindableVectorView_IndexOf), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IBindableVectorView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBindableVectorView), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBindableVectorView[] = {
        { "size", reinterpret_cast<getter>(IBindableVectorView_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBindableVectorView[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBindableVectorView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBindableVectorView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBindableVectorView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBindableVectorView) },
        { },
    };

    static PyType_Spec type_spec_IBindableVectorView =
    {
        "winrt._winrt_windows_ui_xaml_interop.IBindableVectorView",
        sizeof(py::wrapper::Windows::UI::Xaml::Interop::IBindableVectorView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBindableVectorView
    };

    // ----- INotifyCollectionChanged interface --------------------

    static PyObject* _new_INotifyCollectionChanged(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::UI::Xaml::Interop::INotifyCollectionChanged>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::UI::Xaml::Interop::INotifyCollectionChanged>::type_name);
        return nullptr;
    }

    static void _dealloc_INotifyCollectionChanged(py::wrapper::Windows::UI::Xaml::Interop::INotifyCollectionChanged* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* INotifyCollectionChanged_add_CollectionChanged(py::wrapper::Windows::UI::Xaml::Interop::INotifyCollectionChanged* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Interop.INotifyCollectionChanged", L"CollectionChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Xaml::Interop::NotifyCollectionChangedEventHandler>(arg);

            return py::convert(self->obj.CollectionChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* INotifyCollectionChanged_remove_CollectionChanged(py::wrapper::Windows::UI::Xaml::Interop::INotifyCollectionChanged* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.UI.Xaml.Interop.INotifyCollectionChanged", L"CollectionChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CollectionChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_INotifyCollectionChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Interop::INotifyCollectionChanged>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_INotifyCollectionChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Xaml::Interop::INotifyCollectionChanged>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_INotifyCollectionChanged[] = {
        { "add_collection_changed", reinterpret_cast<PyCFunction>(INotifyCollectionChanged_add_CollectionChanged), METH_O, nullptr },
        { "remove_collection_changed", reinterpret_cast<PyCFunction>(INotifyCollectionChanged_remove_CollectionChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_INotifyCollectionChanged, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_INotifyCollectionChanged), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_INotifyCollectionChanged[] = {
        { }
    };

    static PyType_Slot _type_slots_INotifyCollectionChanged[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_INotifyCollectionChanged) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_INotifyCollectionChanged) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_INotifyCollectionChanged) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_INotifyCollectionChanged) },
        { },
    };

    static PyType_Spec type_spec_INotifyCollectionChanged =
    {
        "winrt._winrt_windows_ui_xaml_interop.INotifyCollectionChanged",
        sizeof(py::wrapper::Windows::UI::Xaml::Interop::INotifyCollectionChanged),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_INotifyCollectionChanged
    };

    // ----- TypeName struct --------------------

    winrt_struct_wrapper<winrt::Windows::UI::Xaml::Interop::TypeName>* _new_TypeName(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::UI::Xaml::Interop::TypeName>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_TypeName(winrt_struct_wrapper<winrt::Windows::UI::Xaml::Interop::TypeName>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        winrt::hstring _Name{};
        int32_t _Kind{};

        static const char* kwlist[] = {"name", "kind", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ui", const_cast<char**>(kwlist), &_Name, &_Kind))
        {
            return -1;
        }

        try
        {
            self->obj = {_Name, static_cast<winrt::Windows::UI::Xaml::Interop::TypeKind>(_Kind)};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_TypeName(py::wrapper::Windows::UI::Xaml::Interop::TypeName* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TypeName(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::UI::Xaml::Interop::TypeName>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_TypeName[] = {
        { "_assign_array_", _assign_array_TypeName, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* TypeName_get_Name(py::wrapper::Windows::UI::Xaml::Interop::TypeName* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TypeName_set_Name(py::wrapper::Windows::UI::Xaml::Interop::TypeName* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Name = py::converter<winrt::hstring>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TypeName_get_Kind(py::wrapper::Windows::UI::Xaml::Interop::TypeName* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TypeName_set_Kind(py::wrapper::Windows::UI::Xaml::Interop::TypeName* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Kind = py::converter<winrt::Windows::UI::Xaml::Interop::TypeKind>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_TypeName[] = {
        { "name", reinterpret_cast<getter>(TypeName_get_Name), reinterpret_cast<setter>(TypeName_set_Name), nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(TypeName_get_Kind), reinterpret_cast<setter>(TypeName_set_Kind), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TypeName[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_TypeName) },
        { Py_tp_init, reinterpret_cast<void*>(_init_TypeName) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TypeName) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TypeName) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TypeName) },
        { },
    };

    static PyType_Spec type_spec_TypeName =
    {
        "winrt._winrt_windows_ui_xaml_interop.TypeName",
        sizeof(py::wrapper::Windows::UI::Xaml::Interop::TypeName),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TypeName
    };

    // ----- Windows.UI.Xaml.Interop Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::UI::Xaml::Interop");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_ui_xaml_interop",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::UI::Xaml::Interop

PyMODINIT_FUNC PyInit__winrt_windows_ui_xaml_interop(void) noexcept
{
    using namespace py::cpp::Windows::UI::Xaml::Interop;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_NotifyCollectionChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IBindableIterable, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IBindableIterator, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IBindableObservableVector, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IBindableVector, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IBindableVectorView, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_INotifyCollectionChanged, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_TypeName, nullptr, nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
