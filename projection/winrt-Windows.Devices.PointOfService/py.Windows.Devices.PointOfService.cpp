// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.Devices.PointOfService.h"

namespace py::cpp::Windows::Devices::PointOfService
{
    // ----- BarcodeScanner class --------------------

    static PyObject* _new_BarcodeScanner(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::BarcodeScanner>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::BarcodeScanner>::type_name);
        return nullptr;
    }

    static void _dealloc_BarcodeScanner(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BarcodeScanner_CheckHealthAsync(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.BarcodeScanner", L"CheckHealthAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::UnifiedPosHealthCheckLevel>(args, 0);

                return py::convert(self->obj.CheckHealthAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_ClaimScannerAsync(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.BarcodeScanner", L"ClaimScannerAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ClaimScannerAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_Close(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.BarcodeScanner", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.BarcodeScanner", L"FromIdAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::BarcodeScanner::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_GetDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.BarcodeScanner", L"GetDefaultAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::PointOfService::BarcodeScanner::GetDefaultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.BarcodeScanner", L"GetDeviceSelector", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::PointOfService::BarcodeScanner::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.BarcodeScanner", L"GetDeviceSelector", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosConnectionTypes>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::BarcodeScanner::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_GetSupportedProfiles(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.BarcodeScanner", L"GetSupportedProfiles", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetSupportedProfiles());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_GetSupportedSymbologiesAsync(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.BarcodeScanner", L"GetSupportedSymbologiesAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetSupportedSymbologiesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_IsProfileSupported(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.BarcodeScanner", L"IsProfileSupported", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.IsProfileSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_IsSymbologySupportedAsync(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.BarcodeScanner", L"IsSymbologySupportedAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.IsSymbologySupportedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_RetrieveStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.BarcodeScanner", L"RetrieveStatisticsAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.RetrieveStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_get_Capabilities(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeScanner", L"Capabilities"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Capabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeScanner", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_get_VideoDeviceId(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeScanner", L"VideoDeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_add_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.BarcodeScanner", L"StatusUpdated"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::BarcodeScanner, winrt::Windows::Devices::PointOfService::BarcodeScannerStatusUpdatedEventArgs>>(arg);

            return py::convert(self->obj.StatusUpdated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScanner_remove_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.BarcodeScanner", L"StatusUpdated"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StatusUpdated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BarcodeScanner(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::BarcodeScanner>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BarcodeScanner(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::BarcodeScanner>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_BarcodeScanner(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_BarcodeScanner(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarcodeScanner[] = {
        { "check_health_async", reinterpret_cast<PyCFunction>(BarcodeScanner_CheckHealthAsync), METH_VARARGS, nullptr },
        { "claim_scanner_async", reinterpret_cast<PyCFunction>(BarcodeScanner_ClaimScannerAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(BarcodeScanner_Close), METH_VARARGS, nullptr },
        { "get_supported_profiles", reinterpret_cast<PyCFunction>(BarcodeScanner_GetSupportedProfiles), METH_VARARGS, nullptr },
        { "get_supported_symbologies_async", reinterpret_cast<PyCFunction>(BarcodeScanner_GetSupportedSymbologiesAsync), METH_VARARGS, nullptr },
        { "is_profile_supported", reinterpret_cast<PyCFunction>(BarcodeScanner_IsProfileSupported), METH_VARARGS, nullptr },
        { "is_symbology_supported_async", reinterpret_cast<PyCFunction>(BarcodeScanner_IsSymbologySupportedAsync), METH_VARARGS, nullptr },
        { "retrieve_statistics_async", reinterpret_cast<PyCFunction>(BarcodeScanner_RetrieveStatisticsAsync), METH_VARARGS, nullptr },
        { "add_status_updated", reinterpret_cast<PyCFunction>(BarcodeScanner_add_StatusUpdated), METH_O, nullptr },
        { "remove_status_updated", reinterpret_cast<PyCFunction>(BarcodeScanner_remove_StatusUpdated), METH_O, nullptr },
        { "_assign_array_", _assign_array_BarcodeScanner, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BarcodeScanner), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_BarcodeScanner), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_BarcodeScanner), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_BarcodeScanner[] = {
        { "capabilities", reinterpret_cast<getter>(BarcodeScanner_get_Capabilities), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(BarcodeScanner_get_DeviceId), nullptr, nullptr, nullptr },
        { "video_device_id", reinterpret_cast<getter>(BarcodeScanner_get_VideoDeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BarcodeScanner[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BarcodeScanner) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BarcodeScanner) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BarcodeScanner) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BarcodeScanner) },
        { }
    };

    static PyType_Spec type_spec_BarcodeScanner = {
        "winrt._winrt_windows_devices_pointofservice.BarcodeScanner",
        sizeof(py::wrapper::Windows::Devices::PointOfService::BarcodeScanner),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarcodeScanner};

    static PyGetSetDef getset_BarcodeScanner_Static[] = {
        { }
    };

    static PyMethodDef methods_BarcodeScanner_Static[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(BarcodeScanner_FromIdAsync), METH_VARARGS, nullptr },
        { "get_default_async", reinterpret_cast<PyCFunction>(BarcodeScanner_GetDefaultAsync), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(BarcodeScanner_GetDeviceSelector), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_BarcodeScanner_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BarcodeScanner_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BarcodeScanner_Static) },
        { }
    };

    static PyType_Spec type_spec_BarcodeScanner_Static =
    {
        "winrt._winrt_windows_devices_pointofservice.BarcodeScanner_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BarcodeScanner_Static
    };

    // ----- BarcodeScannerCapabilities class --------------------

    static PyObject* _new_BarcodeScannerCapabilities(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::BarcodeScannerCapabilities>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::BarcodeScannerCapabilities>::type_name);
        return nullptr;
    }

    static void _dealloc_BarcodeScannerCapabilities(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BarcodeScannerCapabilities_get_IsImagePreviewSupported(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeScannerCapabilities", L"IsImagePreviewSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsImagePreviewSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerCapabilities_get_IsStatisticsReportingSupported(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeScannerCapabilities", L"IsStatisticsReportingSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsStatisticsReportingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerCapabilities_get_IsStatisticsUpdatingSupported(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeScannerCapabilities", L"IsStatisticsUpdatingSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsStatisticsUpdatingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerCapabilities_get_PowerReportingType(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeScannerCapabilities", L"PowerReportingType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PowerReportingType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerCapabilities_get_IsSoftwareTriggerSupported(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeScannerCapabilities", L"IsSoftwareTriggerSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSoftwareTriggerSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerCapabilities_get_IsVideoPreviewSupported(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeScannerCapabilities", L"IsVideoPreviewSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsVideoPreviewSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BarcodeScannerCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::BarcodeScannerCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BarcodeScannerCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::BarcodeScannerCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarcodeScannerCapabilities[] = {
        { "_assign_array_", _assign_array_BarcodeScannerCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BarcodeScannerCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BarcodeScannerCapabilities[] = {
        { "is_image_preview_supported", reinterpret_cast<getter>(BarcodeScannerCapabilities_get_IsImagePreviewSupported), nullptr, nullptr, nullptr },
        { "is_statistics_reporting_supported", reinterpret_cast<getter>(BarcodeScannerCapabilities_get_IsStatisticsReportingSupported), nullptr, nullptr, nullptr },
        { "is_statistics_updating_supported", reinterpret_cast<getter>(BarcodeScannerCapabilities_get_IsStatisticsUpdatingSupported), nullptr, nullptr, nullptr },
        { "power_reporting_type", reinterpret_cast<getter>(BarcodeScannerCapabilities_get_PowerReportingType), nullptr, nullptr, nullptr },
        { "is_software_trigger_supported", reinterpret_cast<getter>(BarcodeScannerCapabilities_get_IsSoftwareTriggerSupported), nullptr, nullptr, nullptr },
        { "is_video_preview_supported", reinterpret_cast<getter>(BarcodeScannerCapabilities_get_IsVideoPreviewSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BarcodeScannerCapabilities[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BarcodeScannerCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BarcodeScannerCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BarcodeScannerCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BarcodeScannerCapabilities) },
        { }
    };

    static PyType_Spec type_spec_BarcodeScannerCapabilities = {
        "winrt._winrt_windows_devices_pointofservice.BarcodeScannerCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarcodeScannerCapabilities};

    // ----- BarcodeScannerDataReceivedEventArgs class --------------------

    static PyObject* _new_BarcodeScannerDataReceivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::BarcodeScannerDataReceivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::BarcodeScannerDataReceivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_BarcodeScannerDataReceivedEventArgs(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerDataReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BarcodeScannerDataReceivedEventArgs_get_Report(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeScannerDataReceivedEventArgs", L"Report"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Report());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BarcodeScannerDataReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::BarcodeScannerDataReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BarcodeScannerDataReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::BarcodeScannerDataReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarcodeScannerDataReceivedEventArgs[] = {
        { "_assign_array_", _assign_array_BarcodeScannerDataReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BarcodeScannerDataReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BarcodeScannerDataReceivedEventArgs[] = {
        { "report", reinterpret_cast<getter>(BarcodeScannerDataReceivedEventArgs_get_Report), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BarcodeScannerDataReceivedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BarcodeScannerDataReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BarcodeScannerDataReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BarcodeScannerDataReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BarcodeScannerDataReceivedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_BarcodeScannerDataReceivedEventArgs = {
        "winrt._winrt_windows_devices_pointofservice.BarcodeScannerDataReceivedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerDataReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarcodeScannerDataReceivedEventArgs};

    // ----- BarcodeScannerErrorOccurredEventArgs class --------------------

    static PyObject* _new_BarcodeScannerErrorOccurredEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::BarcodeScannerErrorOccurredEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::BarcodeScannerErrorOccurredEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_BarcodeScannerErrorOccurredEventArgs(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerErrorOccurredEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BarcodeScannerErrorOccurredEventArgs_get_ErrorData(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeScannerErrorOccurredEventArgs", L"ErrorData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ErrorData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerErrorOccurredEventArgs_get_IsRetriable(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeScannerErrorOccurredEventArgs", L"IsRetriable"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsRetriable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerErrorOccurredEventArgs_get_PartialInputData(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeScannerErrorOccurredEventArgs", L"PartialInputData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PartialInputData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BarcodeScannerErrorOccurredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::BarcodeScannerErrorOccurredEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BarcodeScannerErrorOccurredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::BarcodeScannerErrorOccurredEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarcodeScannerErrorOccurredEventArgs[] = {
        { "_assign_array_", _assign_array_BarcodeScannerErrorOccurredEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BarcodeScannerErrorOccurredEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BarcodeScannerErrorOccurredEventArgs[] = {
        { "error_data", reinterpret_cast<getter>(BarcodeScannerErrorOccurredEventArgs_get_ErrorData), nullptr, nullptr, nullptr },
        { "is_retriable", reinterpret_cast<getter>(BarcodeScannerErrorOccurredEventArgs_get_IsRetriable), nullptr, nullptr, nullptr },
        { "partial_input_data", reinterpret_cast<getter>(BarcodeScannerErrorOccurredEventArgs_get_PartialInputData), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BarcodeScannerErrorOccurredEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BarcodeScannerErrorOccurredEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BarcodeScannerErrorOccurredEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BarcodeScannerErrorOccurredEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BarcodeScannerErrorOccurredEventArgs) },
        { }
    };

    static PyType_Spec type_spec_BarcodeScannerErrorOccurredEventArgs = {
        "winrt._winrt_windows_devices_pointofservice.BarcodeScannerErrorOccurredEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerErrorOccurredEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarcodeScannerErrorOccurredEventArgs};

    // ----- BarcodeScannerImagePreviewReceivedEventArgs class --------------------

    static PyObject* _new_BarcodeScannerImagePreviewReceivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::BarcodeScannerImagePreviewReceivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::BarcodeScannerImagePreviewReceivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_BarcodeScannerImagePreviewReceivedEventArgs(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerImagePreviewReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BarcodeScannerImagePreviewReceivedEventArgs_get_Preview(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerImagePreviewReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeScannerImagePreviewReceivedEventArgs", L"Preview"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Preview());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BarcodeScannerImagePreviewReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::BarcodeScannerImagePreviewReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BarcodeScannerImagePreviewReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::BarcodeScannerImagePreviewReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarcodeScannerImagePreviewReceivedEventArgs[] = {
        { "_assign_array_", _assign_array_BarcodeScannerImagePreviewReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BarcodeScannerImagePreviewReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BarcodeScannerImagePreviewReceivedEventArgs[] = {
        { "preview", reinterpret_cast<getter>(BarcodeScannerImagePreviewReceivedEventArgs_get_Preview), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BarcodeScannerImagePreviewReceivedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BarcodeScannerImagePreviewReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BarcodeScannerImagePreviewReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BarcodeScannerImagePreviewReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BarcodeScannerImagePreviewReceivedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_BarcodeScannerImagePreviewReceivedEventArgs = {
        "winrt._winrt_windows_devices_pointofservice.BarcodeScannerImagePreviewReceivedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerImagePreviewReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarcodeScannerImagePreviewReceivedEventArgs};

    // ----- BarcodeScannerReport class --------------------

    static PyObject* _new_BarcodeScannerReport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 2);

                winrt::Windows::Devices::PointOfService::BarcodeScannerReport instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BarcodeScannerReport(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerReport* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BarcodeScannerReport_get_ScanData(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerReport* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeScannerReport", L"ScanData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ScanData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerReport_get_ScanDataLabel(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerReport* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeScannerReport", L"ScanDataLabel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ScanDataLabel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerReport_get_ScanDataType(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerReport* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeScannerReport", L"ScanDataType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ScanDataType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BarcodeScannerReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::BarcodeScannerReport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BarcodeScannerReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::BarcodeScannerReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarcodeScannerReport[] = {
        { "_assign_array_", _assign_array_BarcodeScannerReport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BarcodeScannerReport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BarcodeScannerReport[] = {
        { "scan_data", reinterpret_cast<getter>(BarcodeScannerReport_get_ScanData), nullptr, nullptr, nullptr },
        { "scan_data_label", reinterpret_cast<getter>(BarcodeScannerReport_get_ScanDataLabel), nullptr, nullptr, nullptr },
        { "scan_data_type", reinterpret_cast<getter>(BarcodeScannerReport_get_ScanDataType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BarcodeScannerReport[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BarcodeScannerReport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BarcodeScannerReport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BarcodeScannerReport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BarcodeScannerReport) },
        { }
    };

    static PyType_Spec type_spec_BarcodeScannerReport = {
        "winrt._winrt_windows_devices_pointofservice.BarcodeScannerReport",
        sizeof(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarcodeScannerReport};

    // ----- BarcodeScannerStatusUpdatedEventArgs class --------------------

    static PyObject* _new_BarcodeScannerStatusUpdatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::BarcodeScannerStatusUpdatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::BarcodeScannerStatusUpdatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_BarcodeScannerStatusUpdatedEventArgs(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerStatusUpdatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BarcodeScannerStatusUpdatedEventArgs_get_ExtendedStatus(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerStatusUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeScannerStatusUpdatedEventArgs", L"ExtendedStatus"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerStatusUpdatedEventArgs_get_Status(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerStatusUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeScannerStatusUpdatedEventArgs", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BarcodeScannerStatusUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::BarcodeScannerStatusUpdatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BarcodeScannerStatusUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::BarcodeScannerStatusUpdatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarcodeScannerStatusUpdatedEventArgs[] = {
        { "_assign_array_", _assign_array_BarcodeScannerStatusUpdatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BarcodeScannerStatusUpdatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BarcodeScannerStatusUpdatedEventArgs[] = {
        { "extended_status", reinterpret_cast<getter>(BarcodeScannerStatusUpdatedEventArgs_get_ExtendedStatus), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(BarcodeScannerStatusUpdatedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BarcodeScannerStatusUpdatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BarcodeScannerStatusUpdatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BarcodeScannerStatusUpdatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BarcodeScannerStatusUpdatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BarcodeScannerStatusUpdatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_BarcodeScannerStatusUpdatedEventArgs = {
        "winrt._winrt_windows_devices_pointofservice.BarcodeScannerStatusUpdatedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::BarcodeScannerStatusUpdatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarcodeScannerStatusUpdatedEventArgs};

    // ----- BarcodeSymbologies class --------------------

    static PyObject* _new_BarcodeSymbologies(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::BarcodeSymbologies>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::BarcodeSymbologies>::type_name);
        return nullptr;
    }

    static PyObject* BarcodeSymbologies_GetName(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"GetName", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::GetName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Code11(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Code11"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Code11());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_AusPost(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"AusPost"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::AusPost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Aztec(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Aztec"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Aztec());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_CanPost(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"CanPost"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::CanPost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ccab(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Ccab"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ccab());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ccc(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Ccc"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ccc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_ChinaPost(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"ChinaPost"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::ChinaPost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Codabar(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Codabar"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Codabar());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Codablock128(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Codablock128"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Codablock128());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_CodablockA(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"CodablockA"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::CodablockA());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_CodablockF(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"CodablockF"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::CodablockF());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_DutchKix(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"DutchKix"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::DutchKix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Code128(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Code128"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Code128());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Code16k(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Code16k"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Code16k());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Code32(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Code32"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Code32());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Code39(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Code39"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Code39());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Code39Ex(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Code39Ex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Code39Ex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Code49(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Code49"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Code49());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Code93(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Code93"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Code93());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Code93Ex(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Code93Ex"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Code93Ex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_DataCode(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"DataCode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::DataCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_DataMatrix(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"DataMatrix"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::DataMatrix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UsPostNet(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"UsPostNet"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UsPostNet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ean13(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Ean13"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ean13());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ean13Add2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Ean13Add2"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ean13Add2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ean13Add5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Ean13Add5"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ean13Add5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ean8(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Ean8"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ean8());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ean8Add2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Ean8Add2"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ean8Add2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ean8Add5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Ean8Add5"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ean8Add5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ean99(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Ean99"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ean99());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ean99Add2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Ean99Add2"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ean99Add2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ean99Add5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Ean99Add5"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ean99Add5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Eanv(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Eanv"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Eanv());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_EanvAdd2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"EanvAdd2"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::EanvAdd2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_EanvAdd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"EanvAdd5"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::EanvAdd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_ExtendedBase(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"ExtendedBase"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::ExtendedBase());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Gs1128(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Gs1128"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Gs1128());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Gs1128Coupon(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Gs1128Coupon"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Gs1128Coupon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Gs1DatabarType1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Gs1DatabarType1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Gs1DatabarType1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Gs1DatabarType2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Gs1DatabarType2"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Gs1DatabarType2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Gs1DatabarType3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Gs1DatabarType3"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Gs1DatabarType3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_HanXin(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"HanXin"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::HanXin());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_InfoMail(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"InfoMail"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::InfoMail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Isbn(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Isbn"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Isbn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_IsbnAdd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"IsbnAdd5"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::IsbnAdd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Isbt(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Isbt"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Isbt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Ismn(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Ismn"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Ismn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_IsmnAdd2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"IsmnAdd2"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::IsmnAdd2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_IsmnAdd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"IsmnAdd5"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::IsmnAdd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Issn(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Issn"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Issn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_IssnAdd2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"IssnAdd2"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::IssnAdd2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_IssnAdd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"IssnAdd5"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::IssnAdd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_ItalianPost25(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"ItalianPost25"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::ItalianPost25());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_ItalianPost39(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"ItalianPost39"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::ItalianPost39());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_JapanPost(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"JapanPost"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::JapanPost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_KoreanPost(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"KoreanPost"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::KoreanPost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Maxicode(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Maxicode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Maxicode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Micr(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Micr"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Micr());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_MicroPdf417(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"MicroPdf417"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::MicroPdf417());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_MicroQr(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"MicroQr"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::MicroQr());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_MsTag(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"MsTag"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::MsTag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Msi(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Msi"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Msi());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_OcrA(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"OcrA"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::OcrA());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_OcrB(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"OcrB"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::OcrB());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Pdf417(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Pdf417"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Pdf417());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Plessey(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Plessey"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Plessey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Pzn(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Pzn"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Pzn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Qr(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Qr"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Qr());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Sisac(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Sisac"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Sisac());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_SwedenPost(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"SwedenPost"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::SwedenPost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Telepen(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Telepen"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Telepen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_TfDis(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"TfDis"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::TfDis());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_TfIata(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"TfIata"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::TfIata());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_TfInd(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"TfInd"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::TfInd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_TfInt(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"TfInt"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::TfInt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_TfMat(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"TfMat"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::TfMat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_TfStd(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"TfStd"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::TfStd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Tlc39(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Tlc39"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Tlc39());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Trioptic39(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Trioptic39"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Trioptic39());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UccEan128(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"UccEan128"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UccEan128());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UkPost(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"UkPost"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UkPost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Unknown(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Unknown"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Unknown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UpcCoupon(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"UpcCoupon"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UpcCoupon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Upca(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Upca"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Upca());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UpcaAdd2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"UpcaAdd2"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UpcaAdd2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UpcaAdd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"UpcaAdd5"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UpcaAdd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Upce(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Upce"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Upce());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UpceAdd2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"UpceAdd2"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UpceAdd2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UpceAdd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"UpceAdd5"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UpceAdd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Us4StateFics(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Us4StateFics"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Us4StateFics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UsIntelligent(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"UsIntelligent"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UsIntelligent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UsIntelligentPkg(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"UsIntelligentPkg"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UsIntelligentPkg());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_UsPlanet(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"UsPlanet"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::UsPlanet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologies_get_Gs1DWCode(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologies", L"Gs1DWCode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::BarcodeSymbologies::Gs1DWCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarcodeSymbologies[] = {
        { }
    };

    static PyGetSetDef _getset_BarcodeSymbologies[] = {
        { }
    };

    static PyType_Slot _type_slots_BarcodeSymbologies[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BarcodeSymbologies) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BarcodeSymbologies) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BarcodeSymbologies) },
        { }
    };

    static PyType_Spec type_spec_BarcodeSymbologies = {
        "winrt._winrt_windows_devices_pointofservice.BarcodeSymbologies",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarcodeSymbologies};

    static PyGetSetDef getset_BarcodeSymbologies_Static[] = {
        { "code11", reinterpret_cast<getter>(BarcodeSymbologies_get_Code11), nullptr, nullptr, nullptr },
        { "aus_post", reinterpret_cast<getter>(BarcodeSymbologies_get_AusPost), nullptr, nullptr, nullptr },
        { "aztec", reinterpret_cast<getter>(BarcodeSymbologies_get_Aztec), nullptr, nullptr, nullptr },
        { "can_post", reinterpret_cast<getter>(BarcodeSymbologies_get_CanPost), nullptr, nullptr, nullptr },
        { "ccab", reinterpret_cast<getter>(BarcodeSymbologies_get_Ccab), nullptr, nullptr, nullptr },
        { "ccc", reinterpret_cast<getter>(BarcodeSymbologies_get_Ccc), nullptr, nullptr, nullptr },
        { "china_post", reinterpret_cast<getter>(BarcodeSymbologies_get_ChinaPost), nullptr, nullptr, nullptr },
        { "codabar", reinterpret_cast<getter>(BarcodeSymbologies_get_Codabar), nullptr, nullptr, nullptr },
        { "codablock128", reinterpret_cast<getter>(BarcodeSymbologies_get_Codablock128), nullptr, nullptr, nullptr },
        { "codablock_a", reinterpret_cast<getter>(BarcodeSymbologies_get_CodablockA), nullptr, nullptr, nullptr },
        { "codablock_f", reinterpret_cast<getter>(BarcodeSymbologies_get_CodablockF), nullptr, nullptr, nullptr },
        { "dutch_kix", reinterpret_cast<getter>(BarcodeSymbologies_get_DutchKix), nullptr, nullptr, nullptr },
        { "code128", reinterpret_cast<getter>(BarcodeSymbologies_get_Code128), nullptr, nullptr, nullptr },
        { "code16k", reinterpret_cast<getter>(BarcodeSymbologies_get_Code16k), nullptr, nullptr, nullptr },
        { "code32", reinterpret_cast<getter>(BarcodeSymbologies_get_Code32), nullptr, nullptr, nullptr },
        { "code39", reinterpret_cast<getter>(BarcodeSymbologies_get_Code39), nullptr, nullptr, nullptr },
        { "code39_ex", reinterpret_cast<getter>(BarcodeSymbologies_get_Code39Ex), nullptr, nullptr, nullptr },
        { "code49", reinterpret_cast<getter>(BarcodeSymbologies_get_Code49), nullptr, nullptr, nullptr },
        { "code93", reinterpret_cast<getter>(BarcodeSymbologies_get_Code93), nullptr, nullptr, nullptr },
        { "code93_ex", reinterpret_cast<getter>(BarcodeSymbologies_get_Code93Ex), nullptr, nullptr, nullptr },
        { "data_code", reinterpret_cast<getter>(BarcodeSymbologies_get_DataCode), nullptr, nullptr, nullptr },
        { "data_matrix", reinterpret_cast<getter>(BarcodeSymbologies_get_DataMatrix), nullptr, nullptr, nullptr },
        { "us_post_net", reinterpret_cast<getter>(BarcodeSymbologies_get_UsPostNet), nullptr, nullptr, nullptr },
        { "ean13", reinterpret_cast<getter>(BarcodeSymbologies_get_Ean13), nullptr, nullptr, nullptr },
        { "ean13_add2", reinterpret_cast<getter>(BarcodeSymbologies_get_Ean13Add2), nullptr, nullptr, nullptr },
        { "ean13_add5", reinterpret_cast<getter>(BarcodeSymbologies_get_Ean13Add5), nullptr, nullptr, nullptr },
        { "ean8", reinterpret_cast<getter>(BarcodeSymbologies_get_Ean8), nullptr, nullptr, nullptr },
        { "ean8_add2", reinterpret_cast<getter>(BarcodeSymbologies_get_Ean8Add2), nullptr, nullptr, nullptr },
        { "ean8_add5", reinterpret_cast<getter>(BarcodeSymbologies_get_Ean8Add5), nullptr, nullptr, nullptr },
        { "ean99", reinterpret_cast<getter>(BarcodeSymbologies_get_Ean99), nullptr, nullptr, nullptr },
        { "ean99_add2", reinterpret_cast<getter>(BarcodeSymbologies_get_Ean99Add2), nullptr, nullptr, nullptr },
        { "ean99_add5", reinterpret_cast<getter>(BarcodeSymbologies_get_Ean99Add5), nullptr, nullptr, nullptr },
        { "eanv", reinterpret_cast<getter>(BarcodeSymbologies_get_Eanv), nullptr, nullptr, nullptr },
        { "eanv_add2", reinterpret_cast<getter>(BarcodeSymbologies_get_EanvAdd2), nullptr, nullptr, nullptr },
        { "eanv_add5", reinterpret_cast<getter>(BarcodeSymbologies_get_EanvAdd5), nullptr, nullptr, nullptr },
        { "extended_base", reinterpret_cast<getter>(BarcodeSymbologies_get_ExtendedBase), nullptr, nullptr, nullptr },
        { "gs1128", reinterpret_cast<getter>(BarcodeSymbologies_get_Gs1128), nullptr, nullptr, nullptr },
        { "gs1128_coupon", reinterpret_cast<getter>(BarcodeSymbologies_get_Gs1128Coupon), nullptr, nullptr, nullptr },
        { "gs1_databar_type1", reinterpret_cast<getter>(BarcodeSymbologies_get_Gs1DatabarType1), nullptr, nullptr, nullptr },
        { "gs1_databar_type2", reinterpret_cast<getter>(BarcodeSymbologies_get_Gs1DatabarType2), nullptr, nullptr, nullptr },
        { "gs1_databar_type3", reinterpret_cast<getter>(BarcodeSymbologies_get_Gs1DatabarType3), nullptr, nullptr, nullptr },
        { "han_xin", reinterpret_cast<getter>(BarcodeSymbologies_get_HanXin), nullptr, nullptr, nullptr },
        { "info_mail", reinterpret_cast<getter>(BarcodeSymbologies_get_InfoMail), nullptr, nullptr, nullptr },
        { "isbn", reinterpret_cast<getter>(BarcodeSymbologies_get_Isbn), nullptr, nullptr, nullptr },
        { "isbn_add5", reinterpret_cast<getter>(BarcodeSymbologies_get_IsbnAdd5), nullptr, nullptr, nullptr },
        { "isbt", reinterpret_cast<getter>(BarcodeSymbologies_get_Isbt), nullptr, nullptr, nullptr },
        { "ismn", reinterpret_cast<getter>(BarcodeSymbologies_get_Ismn), nullptr, nullptr, nullptr },
        { "ismn_add2", reinterpret_cast<getter>(BarcodeSymbologies_get_IsmnAdd2), nullptr, nullptr, nullptr },
        { "ismn_add5", reinterpret_cast<getter>(BarcodeSymbologies_get_IsmnAdd5), nullptr, nullptr, nullptr },
        { "issn", reinterpret_cast<getter>(BarcodeSymbologies_get_Issn), nullptr, nullptr, nullptr },
        { "issn_add2", reinterpret_cast<getter>(BarcodeSymbologies_get_IssnAdd2), nullptr, nullptr, nullptr },
        { "issn_add5", reinterpret_cast<getter>(BarcodeSymbologies_get_IssnAdd5), nullptr, nullptr, nullptr },
        { "italian_post25", reinterpret_cast<getter>(BarcodeSymbologies_get_ItalianPost25), nullptr, nullptr, nullptr },
        { "italian_post39", reinterpret_cast<getter>(BarcodeSymbologies_get_ItalianPost39), nullptr, nullptr, nullptr },
        { "japan_post", reinterpret_cast<getter>(BarcodeSymbologies_get_JapanPost), nullptr, nullptr, nullptr },
        { "korean_post", reinterpret_cast<getter>(BarcodeSymbologies_get_KoreanPost), nullptr, nullptr, nullptr },
        { "maxicode", reinterpret_cast<getter>(BarcodeSymbologies_get_Maxicode), nullptr, nullptr, nullptr },
        { "micr", reinterpret_cast<getter>(BarcodeSymbologies_get_Micr), nullptr, nullptr, nullptr },
        { "micro_pdf417", reinterpret_cast<getter>(BarcodeSymbologies_get_MicroPdf417), nullptr, nullptr, nullptr },
        { "micro_qr", reinterpret_cast<getter>(BarcodeSymbologies_get_MicroQr), nullptr, nullptr, nullptr },
        { "ms_tag", reinterpret_cast<getter>(BarcodeSymbologies_get_MsTag), nullptr, nullptr, nullptr },
        { "msi", reinterpret_cast<getter>(BarcodeSymbologies_get_Msi), nullptr, nullptr, nullptr },
        { "ocr_a", reinterpret_cast<getter>(BarcodeSymbologies_get_OcrA), nullptr, nullptr, nullptr },
        { "ocr_b", reinterpret_cast<getter>(BarcodeSymbologies_get_OcrB), nullptr, nullptr, nullptr },
        { "pdf417", reinterpret_cast<getter>(BarcodeSymbologies_get_Pdf417), nullptr, nullptr, nullptr },
        { "plessey", reinterpret_cast<getter>(BarcodeSymbologies_get_Plessey), nullptr, nullptr, nullptr },
        { "pzn", reinterpret_cast<getter>(BarcodeSymbologies_get_Pzn), nullptr, nullptr, nullptr },
        { "qr", reinterpret_cast<getter>(BarcodeSymbologies_get_Qr), nullptr, nullptr, nullptr },
        { "sisac", reinterpret_cast<getter>(BarcodeSymbologies_get_Sisac), nullptr, nullptr, nullptr },
        { "sweden_post", reinterpret_cast<getter>(BarcodeSymbologies_get_SwedenPost), nullptr, nullptr, nullptr },
        { "telepen", reinterpret_cast<getter>(BarcodeSymbologies_get_Telepen), nullptr, nullptr, nullptr },
        { "tf_dis", reinterpret_cast<getter>(BarcodeSymbologies_get_TfDis), nullptr, nullptr, nullptr },
        { "tf_iata", reinterpret_cast<getter>(BarcodeSymbologies_get_TfIata), nullptr, nullptr, nullptr },
        { "tf_ind", reinterpret_cast<getter>(BarcodeSymbologies_get_TfInd), nullptr, nullptr, nullptr },
        { "tf_int", reinterpret_cast<getter>(BarcodeSymbologies_get_TfInt), nullptr, nullptr, nullptr },
        { "tf_mat", reinterpret_cast<getter>(BarcodeSymbologies_get_TfMat), nullptr, nullptr, nullptr },
        { "tf_std", reinterpret_cast<getter>(BarcodeSymbologies_get_TfStd), nullptr, nullptr, nullptr },
        { "tlc39", reinterpret_cast<getter>(BarcodeSymbologies_get_Tlc39), nullptr, nullptr, nullptr },
        { "trioptic39", reinterpret_cast<getter>(BarcodeSymbologies_get_Trioptic39), nullptr, nullptr, nullptr },
        { "ucc_ean128", reinterpret_cast<getter>(BarcodeSymbologies_get_UccEan128), nullptr, nullptr, nullptr },
        { "uk_post", reinterpret_cast<getter>(BarcodeSymbologies_get_UkPost), nullptr, nullptr, nullptr },
        { "unknown", reinterpret_cast<getter>(BarcodeSymbologies_get_Unknown), nullptr, nullptr, nullptr },
        { "upc_coupon", reinterpret_cast<getter>(BarcodeSymbologies_get_UpcCoupon), nullptr, nullptr, nullptr },
        { "upca", reinterpret_cast<getter>(BarcodeSymbologies_get_Upca), nullptr, nullptr, nullptr },
        { "upca_add2", reinterpret_cast<getter>(BarcodeSymbologies_get_UpcaAdd2), nullptr, nullptr, nullptr },
        { "upca_add5", reinterpret_cast<getter>(BarcodeSymbologies_get_UpcaAdd5), nullptr, nullptr, nullptr },
        { "upce", reinterpret_cast<getter>(BarcodeSymbologies_get_Upce), nullptr, nullptr, nullptr },
        { "upce_add2", reinterpret_cast<getter>(BarcodeSymbologies_get_UpceAdd2), nullptr, nullptr, nullptr },
        { "upce_add5", reinterpret_cast<getter>(BarcodeSymbologies_get_UpceAdd5), nullptr, nullptr, nullptr },
        { "us4_state_fics", reinterpret_cast<getter>(BarcodeSymbologies_get_Us4StateFics), nullptr, nullptr, nullptr },
        { "us_intelligent", reinterpret_cast<getter>(BarcodeSymbologies_get_UsIntelligent), nullptr, nullptr, nullptr },
        { "us_intelligent_pkg", reinterpret_cast<getter>(BarcodeSymbologies_get_UsIntelligentPkg), nullptr, nullptr, nullptr },
        { "us_planet", reinterpret_cast<getter>(BarcodeSymbologies_get_UsPlanet), nullptr, nullptr, nullptr },
        { "gs1_d_w_code", reinterpret_cast<getter>(BarcodeSymbologies_get_Gs1DWCode), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_BarcodeSymbologies_Static[] = {
        { "get_name", reinterpret_cast<PyCFunction>(BarcodeSymbologies_GetName), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_BarcodeSymbologies_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BarcodeSymbologies_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BarcodeSymbologies_Static) },
        { }
    };

    static PyType_Spec type_spec_BarcodeSymbologies_Static =
    {
        "winrt._winrt_windows_devices_pointofservice.BarcodeSymbologies_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BarcodeSymbologies_Static
    };

    // ----- BarcodeSymbologyAttributes class --------------------

    static PyObject* _new_BarcodeSymbologyAttributes(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::BarcodeSymbologyAttributes>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::BarcodeSymbologyAttributes>::type_name);
        return nullptr;
    }

    static void _dealloc_BarcodeSymbologyAttributes(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BarcodeSymbologyAttributes_get_IsCheckDigitValidationEnabled(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologyAttributes", L"IsCheckDigitValidationEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsCheckDigitValidationEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BarcodeSymbologyAttributes_put_IsCheckDigitValidationEnabled(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologyAttributes", L"IsCheckDigitValidationEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCheckDigitValidationEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BarcodeSymbologyAttributes_get_IsCheckDigitTransmissionEnabled(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologyAttributes", L"IsCheckDigitTransmissionEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsCheckDigitTransmissionEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BarcodeSymbologyAttributes_put_IsCheckDigitTransmissionEnabled(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologyAttributes", L"IsCheckDigitTransmissionEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCheckDigitTransmissionEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BarcodeSymbologyAttributes_get_DecodeLengthKind(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologyAttributes", L"DecodeLengthKind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DecodeLengthKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BarcodeSymbologyAttributes_put_DecodeLengthKind(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologyAttributes", L"DecodeLengthKind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::BarcodeSymbologyDecodeLengthKind>(arg);

            self->obj.DecodeLengthKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BarcodeSymbologyAttributes_get_DecodeLength2(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologyAttributes", L"DecodeLength2"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DecodeLength2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BarcodeSymbologyAttributes_put_DecodeLength2(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologyAttributes", L"DecodeLength2"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.DecodeLength2(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BarcodeSymbologyAttributes_get_DecodeLength1(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologyAttributes", L"DecodeLength1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DecodeLength1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BarcodeSymbologyAttributes_put_DecodeLength1(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologyAttributes", L"DecodeLength1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.DecodeLength1(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BarcodeSymbologyAttributes_get_IsCheckDigitTransmissionSupported(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologyAttributes", L"IsCheckDigitTransmissionSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsCheckDigitTransmissionSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologyAttributes_get_IsCheckDigitValidationSupported(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologyAttributes", L"IsCheckDigitValidationSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsCheckDigitValidationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeSymbologyAttributes_get_IsDecodeLengthSupported(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.BarcodeSymbologyAttributes", L"IsDecodeLengthSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDecodeLengthSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BarcodeSymbologyAttributes(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::BarcodeSymbologyAttributes>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BarcodeSymbologyAttributes(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::BarcodeSymbologyAttributes>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarcodeSymbologyAttributes[] = {
        { "_assign_array_", _assign_array_BarcodeSymbologyAttributes, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BarcodeSymbologyAttributes), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BarcodeSymbologyAttributes[] = {
        { "is_check_digit_validation_enabled", reinterpret_cast<getter>(BarcodeSymbologyAttributes_get_IsCheckDigitValidationEnabled), reinterpret_cast<setter>(BarcodeSymbologyAttributes_put_IsCheckDigitValidationEnabled), nullptr, nullptr },
        { "is_check_digit_transmission_enabled", reinterpret_cast<getter>(BarcodeSymbologyAttributes_get_IsCheckDigitTransmissionEnabled), reinterpret_cast<setter>(BarcodeSymbologyAttributes_put_IsCheckDigitTransmissionEnabled), nullptr, nullptr },
        { "decode_length_kind", reinterpret_cast<getter>(BarcodeSymbologyAttributes_get_DecodeLengthKind), reinterpret_cast<setter>(BarcodeSymbologyAttributes_put_DecodeLengthKind), nullptr, nullptr },
        { "decode_length2", reinterpret_cast<getter>(BarcodeSymbologyAttributes_get_DecodeLength2), reinterpret_cast<setter>(BarcodeSymbologyAttributes_put_DecodeLength2), nullptr, nullptr },
        { "decode_length1", reinterpret_cast<getter>(BarcodeSymbologyAttributes_get_DecodeLength1), reinterpret_cast<setter>(BarcodeSymbologyAttributes_put_DecodeLength1), nullptr, nullptr },
        { "is_check_digit_transmission_supported", reinterpret_cast<getter>(BarcodeSymbologyAttributes_get_IsCheckDigitTransmissionSupported), nullptr, nullptr, nullptr },
        { "is_check_digit_validation_supported", reinterpret_cast<getter>(BarcodeSymbologyAttributes_get_IsCheckDigitValidationSupported), nullptr, nullptr, nullptr },
        { "is_decode_length_supported", reinterpret_cast<getter>(BarcodeSymbologyAttributes_get_IsDecodeLengthSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BarcodeSymbologyAttributes[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BarcodeSymbologyAttributes) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BarcodeSymbologyAttributes) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BarcodeSymbologyAttributes) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BarcodeSymbologyAttributes) },
        { }
    };

    static PyType_Spec type_spec_BarcodeSymbologyAttributes = {
        "winrt._winrt_windows_devices_pointofservice.BarcodeSymbologyAttributes",
        sizeof(py::wrapper::Windows::Devices::PointOfService::BarcodeSymbologyAttributes),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarcodeSymbologyAttributes};

    // ----- CashDrawer class --------------------

    static PyObject* _new_CashDrawer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::CashDrawer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::CashDrawer>::type_name);
        return nullptr;
    }

    static void _dealloc_CashDrawer(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CashDrawer_CheckHealthAsync(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.CashDrawer", L"CheckHealthAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::UnifiedPosHealthCheckLevel>(args, 0);

                return py::convert(self->obj.CheckHealthAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CashDrawer_ClaimDrawerAsync(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.CashDrawer", L"ClaimDrawerAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ClaimDrawerAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CashDrawer_Close(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.CashDrawer", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CashDrawer_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.CashDrawer", L"FromIdAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::CashDrawer::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CashDrawer_GetDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.CashDrawer", L"GetDefaultAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::PointOfService::CashDrawer::GetDefaultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CashDrawer_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.CashDrawer", L"GetDeviceSelector", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::PointOfService::CashDrawer::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.CashDrawer", L"GetDeviceSelector", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosConnectionTypes>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::CashDrawer::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CashDrawer_GetStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.CashDrawer", L"GetStatisticsAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CashDrawer_get_Capabilities(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawer", L"Capabilities"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Capabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawer_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawer", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawer_get_DrawerEventSource(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawer", L"DrawerEventSource"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DrawerEventSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawer_get_IsDrawerOpen(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawer", L"IsDrawerOpen"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDrawerOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawer_get_Status(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawer", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawer_add_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.CashDrawer", L"StatusUpdated"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::CashDrawer, winrt::Windows::Devices::PointOfService::CashDrawerStatusUpdatedEventArgs>>(arg);

            return py::convert(self->obj.StatusUpdated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawer_remove_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.CashDrawer", L"StatusUpdated"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StatusUpdated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CashDrawer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::CashDrawer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CashDrawer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::CashDrawer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_CashDrawer(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_CashDrawer(py::wrapper::Windows::Devices::PointOfService::CashDrawer* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CashDrawer[] = {
        { "check_health_async", reinterpret_cast<PyCFunction>(CashDrawer_CheckHealthAsync), METH_VARARGS, nullptr },
        { "claim_drawer_async", reinterpret_cast<PyCFunction>(CashDrawer_ClaimDrawerAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(CashDrawer_Close), METH_VARARGS, nullptr },
        { "get_statistics_async", reinterpret_cast<PyCFunction>(CashDrawer_GetStatisticsAsync), METH_VARARGS, nullptr },
        { "add_status_updated", reinterpret_cast<PyCFunction>(CashDrawer_add_StatusUpdated), METH_O, nullptr },
        { "remove_status_updated", reinterpret_cast<PyCFunction>(CashDrawer_remove_StatusUpdated), METH_O, nullptr },
        { "_assign_array_", _assign_array_CashDrawer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CashDrawer), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_CashDrawer), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_CashDrawer), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_CashDrawer[] = {
        { "capabilities", reinterpret_cast<getter>(CashDrawer_get_Capabilities), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(CashDrawer_get_DeviceId), nullptr, nullptr, nullptr },
        { "drawer_event_source", reinterpret_cast<getter>(CashDrawer_get_DrawerEventSource), nullptr, nullptr, nullptr },
        { "is_drawer_open", reinterpret_cast<getter>(CashDrawer_get_IsDrawerOpen), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(CashDrawer_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CashDrawer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CashDrawer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CashDrawer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CashDrawer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CashDrawer) },
        { }
    };

    static PyType_Spec type_spec_CashDrawer = {
        "winrt._winrt_windows_devices_pointofservice.CashDrawer",
        sizeof(py::wrapper::Windows::Devices::PointOfService::CashDrawer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CashDrawer};

    static PyGetSetDef getset_CashDrawer_Static[] = {
        { }
    };

    static PyMethodDef methods_CashDrawer_Static[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(CashDrawer_FromIdAsync), METH_VARARGS, nullptr },
        { "get_default_async", reinterpret_cast<PyCFunction>(CashDrawer_GetDefaultAsync), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(CashDrawer_GetDeviceSelector), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_CashDrawer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CashDrawer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CashDrawer_Static) },
        { }
    };

    static PyType_Spec type_spec_CashDrawer_Static =
    {
        "winrt._winrt_windows_devices_pointofservice.CashDrawer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CashDrawer_Static
    };

    // ----- CashDrawerCapabilities class --------------------

    static PyObject* _new_CashDrawerCapabilities(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::CashDrawerCapabilities>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::CashDrawerCapabilities>::type_name);
        return nullptr;
    }

    static void _dealloc_CashDrawerCapabilities(py::wrapper::Windows::Devices::PointOfService::CashDrawerCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CashDrawerCapabilities_get_IsDrawerOpenSensorAvailable(py::wrapper::Windows::Devices::PointOfService::CashDrawerCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawerCapabilities", L"IsDrawerOpenSensorAvailable"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDrawerOpenSensorAvailable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerCapabilities_get_IsStatisticsReportingSupported(py::wrapper::Windows::Devices::PointOfService::CashDrawerCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawerCapabilities", L"IsStatisticsReportingSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsStatisticsReportingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerCapabilities_get_IsStatisticsUpdatingSupported(py::wrapper::Windows::Devices::PointOfService::CashDrawerCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawerCapabilities", L"IsStatisticsUpdatingSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsStatisticsUpdatingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerCapabilities_get_IsStatusMultiDrawerDetectSupported(py::wrapper::Windows::Devices::PointOfService::CashDrawerCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawerCapabilities", L"IsStatusMultiDrawerDetectSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsStatusMultiDrawerDetectSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerCapabilities_get_IsStatusReportingSupported(py::wrapper::Windows::Devices::PointOfService::CashDrawerCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawerCapabilities", L"IsStatusReportingSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsStatusReportingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerCapabilities_get_PowerReportingType(py::wrapper::Windows::Devices::PointOfService::CashDrawerCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawerCapabilities", L"PowerReportingType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PowerReportingType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CashDrawerCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::CashDrawerCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CashDrawerCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::CashDrawerCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CashDrawerCapabilities[] = {
        { "_assign_array_", _assign_array_CashDrawerCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CashDrawerCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CashDrawerCapabilities[] = {
        { "is_drawer_open_sensor_available", reinterpret_cast<getter>(CashDrawerCapabilities_get_IsDrawerOpenSensorAvailable), nullptr, nullptr, nullptr },
        { "is_statistics_reporting_supported", reinterpret_cast<getter>(CashDrawerCapabilities_get_IsStatisticsReportingSupported), nullptr, nullptr, nullptr },
        { "is_statistics_updating_supported", reinterpret_cast<getter>(CashDrawerCapabilities_get_IsStatisticsUpdatingSupported), nullptr, nullptr, nullptr },
        { "is_status_multi_drawer_detect_supported", reinterpret_cast<getter>(CashDrawerCapabilities_get_IsStatusMultiDrawerDetectSupported), nullptr, nullptr, nullptr },
        { "is_status_reporting_supported", reinterpret_cast<getter>(CashDrawerCapabilities_get_IsStatusReportingSupported), nullptr, nullptr, nullptr },
        { "power_reporting_type", reinterpret_cast<getter>(CashDrawerCapabilities_get_PowerReportingType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CashDrawerCapabilities[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CashDrawerCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CashDrawerCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CashDrawerCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CashDrawerCapabilities) },
        { }
    };

    static PyType_Spec type_spec_CashDrawerCapabilities = {
        "winrt._winrt_windows_devices_pointofservice.CashDrawerCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::CashDrawerCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CashDrawerCapabilities};

    // ----- CashDrawerCloseAlarm class --------------------

    static PyObject* _new_CashDrawerCloseAlarm(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::CashDrawerCloseAlarm>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::CashDrawerCloseAlarm>::type_name);
        return nullptr;
    }

    static void _dealloc_CashDrawerCloseAlarm(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CashDrawerCloseAlarm_StartAsync(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.CashDrawerCloseAlarm", L"StartAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.StartAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CashDrawerCloseAlarm_get_BeepFrequency(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawerCloseAlarm", L"BeepFrequency"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BeepFrequency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CashDrawerCloseAlarm_put_BeepFrequency(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawerCloseAlarm", L"BeepFrequency"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.BeepFrequency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CashDrawerCloseAlarm_get_BeepDuration(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawerCloseAlarm", L"BeepDuration"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BeepDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CashDrawerCloseAlarm_put_BeepDuration(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawerCloseAlarm", L"BeepDuration"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.BeepDuration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CashDrawerCloseAlarm_get_BeepDelay(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawerCloseAlarm", L"BeepDelay"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BeepDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CashDrawerCloseAlarm_put_BeepDelay(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawerCloseAlarm", L"BeepDelay"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.BeepDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CashDrawerCloseAlarm_get_AlarmTimeout(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawerCloseAlarm", L"AlarmTimeout"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AlarmTimeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CashDrawerCloseAlarm_put_AlarmTimeout(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawerCloseAlarm", L"AlarmTimeout"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.AlarmTimeout(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CashDrawerCloseAlarm_add_AlarmTimeoutExpired(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.CashDrawerCloseAlarm", L"AlarmTimeoutExpired"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::CashDrawerCloseAlarm, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.AlarmTimeoutExpired(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerCloseAlarm_remove_AlarmTimeoutExpired(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.CashDrawerCloseAlarm", L"AlarmTimeoutExpired"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AlarmTimeoutExpired(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CashDrawerCloseAlarm(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::CashDrawerCloseAlarm>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CashDrawerCloseAlarm(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::CashDrawerCloseAlarm>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CashDrawerCloseAlarm[] = {
        { "start_async", reinterpret_cast<PyCFunction>(CashDrawerCloseAlarm_StartAsync), METH_VARARGS, nullptr },
        { "add_alarm_timeout_expired", reinterpret_cast<PyCFunction>(CashDrawerCloseAlarm_add_AlarmTimeoutExpired), METH_O, nullptr },
        { "remove_alarm_timeout_expired", reinterpret_cast<PyCFunction>(CashDrawerCloseAlarm_remove_AlarmTimeoutExpired), METH_O, nullptr },
        { "_assign_array_", _assign_array_CashDrawerCloseAlarm, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CashDrawerCloseAlarm), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CashDrawerCloseAlarm[] = {
        { "beep_frequency", reinterpret_cast<getter>(CashDrawerCloseAlarm_get_BeepFrequency), reinterpret_cast<setter>(CashDrawerCloseAlarm_put_BeepFrequency), nullptr, nullptr },
        { "beep_duration", reinterpret_cast<getter>(CashDrawerCloseAlarm_get_BeepDuration), reinterpret_cast<setter>(CashDrawerCloseAlarm_put_BeepDuration), nullptr, nullptr },
        { "beep_delay", reinterpret_cast<getter>(CashDrawerCloseAlarm_get_BeepDelay), reinterpret_cast<setter>(CashDrawerCloseAlarm_put_BeepDelay), nullptr, nullptr },
        { "alarm_timeout", reinterpret_cast<getter>(CashDrawerCloseAlarm_get_AlarmTimeout), reinterpret_cast<setter>(CashDrawerCloseAlarm_put_AlarmTimeout), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CashDrawerCloseAlarm[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CashDrawerCloseAlarm) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CashDrawerCloseAlarm) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CashDrawerCloseAlarm) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CashDrawerCloseAlarm) },
        { }
    };

    static PyType_Spec type_spec_CashDrawerCloseAlarm = {
        "winrt._winrt_windows_devices_pointofservice.CashDrawerCloseAlarm",
        sizeof(py::wrapper::Windows::Devices::PointOfService::CashDrawerCloseAlarm),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CashDrawerCloseAlarm};

    // ----- CashDrawerClosedEventArgs class --------------------

    static PyObject* _new_CashDrawerClosedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::CashDrawerClosedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::CashDrawerClosedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CashDrawerClosedEventArgs(py::wrapper::Windows::Devices::PointOfService::CashDrawerClosedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CashDrawerClosedEventArgs_get_CashDrawer(py::wrapper::Windows::Devices::PointOfService::CashDrawerClosedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawerClosedEventArgs", L"CashDrawer"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CashDrawer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CashDrawerClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::CashDrawerClosedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CashDrawerClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::CashDrawerClosedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CashDrawerClosedEventArgs[] = {
        { "_assign_array_", _assign_array_CashDrawerClosedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CashDrawerClosedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CashDrawerClosedEventArgs[] = {
        { "cash_drawer", reinterpret_cast<getter>(CashDrawerClosedEventArgs_get_CashDrawer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CashDrawerClosedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CashDrawerClosedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CashDrawerClosedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CashDrawerClosedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CashDrawerClosedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_CashDrawerClosedEventArgs = {
        "winrt._winrt_windows_devices_pointofservice.CashDrawerClosedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::CashDrawerClosedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CashDrawerClosedEventArgs};

    // ----- CashDrawerEventSource class --------------------

    static PyObject* _new_CashDrawerEventSource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::CashDrawerEventSource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::CashDrawerEventSource>::type_name);
        return nullptr;
    }

    static void _dealloc_CashDrawerEventSource(py::wrapper::Windows::Devices::PointOfService::CashDrawerEventSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CashDrawerEventSource_add_DrawerClosed(py::wrapper::Windows::Devices::PointOfService::CashDrawerEventSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.CashDrawerEventSource", L"DrawerClosed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::CashDrawerEventSource, winrt::Windows::Devices::PointOfService::CashDrawerClosedEventArgs>>(arg);

            return py::convert(self->obj.DrawerClosed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerEventSource_remove_DrawerClosed(py::wrapper::Windows::Devices::PointOfService::CashDrawerEventSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.CashDrawerEventSource", L"DrawerClosed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DrawerClosed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerEventSource_add_DrawerOpened(py::wrapper::Windows::Devices::PointOfService::CashDrawerEventSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.CashDrawerEventSource", L"DrawerOpened"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::CashDrawerEventSource, winrt::Windows::Devices::PointOfService::CashDrawerOpenedEventArgs>>(arg);

            return py::convert(self->obj.DrawerOpened(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerEventSource_remove_DrawerOpened(py::wrapper::Windows::Devices::PointOfService::CashDrawerEventSource* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.CashDrawerEventSource", L"DrawerOpened"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DrawerOpened(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CashDrawerEventSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::CashDrawerEventSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CashDrawerEventSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::CashDrawerEventSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CashDrawerEventSource[] = {
        { "add_drawer_closed", reinterpret_cast<PyCFunction>(CashDrawerEventSource_add_DrawerClosed), METH_O, nullptr },
        { "remove_drawer_closed", reinterpret_cast<PyCFunction>(CashDrawerEventSource_remove_DrawerClosed), METH_O, nullptr },
        { "add_drawer_opened", reinterpret_cast<PyCFunction>(CashDrawerEventSource_add_DrawerOpened), METH_O, nullptr },
        { "remove_drawer_opened", reinterpret_cast<PyCFunction>(CashDrawerEventSource_remove_DrawerOpened), METH_O, nullptr },
        { "_assign_array_", _assign_array_CashDrawerEventSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CashDrawerEventSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CashDrawerEventSource[] = {
        { }
    };

    static PyType_Slot _type_slots_CashDrawerEventSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CashDrawerEventSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CashDrawerEventSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CashDrawerEventSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CashDrawerEventSource) },
        { }
    };

    static PyType_Spec type_spec_CashDrawerEventSource = {
        "winrt._winrt_windows_devices_pointofservice.CashDrawerEventSource",
        sizeof(py::wrapper::Windows::Devices::PointOfService::CashDrawerEventSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CashDrawerEventSource};

    // ----- CashDrawerOpenedEventArgs class --------------------

    static PyObject* _new_CashDrawerOpenedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::CashDrawerOpenedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::CashDrawerOpenedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CashDrawerOpenedEventArgs(py::wrapper::Windows::Devices::PointOfService::CashDrawerOpenedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CashDrawerOpenedEventArgs_get_CashDrawer(py::wrapper::Windows::Devices::PointOfService::CashDrawerOpenedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawerOpenedEventArgs", L"CashDrawer"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CashDrawer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CashDrawerOpenedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::CashDrawerOpenedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CashDrawerOpenedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::CashDrawerOpenedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CashDrawerOpenedEventArgs[] = {
        { "_assign_array_", _assign_array_CashDrawerOpenedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CashDrawerOpenedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CashDrawerOpenedEventArgs[] = {
        { "cash_drawer", reinterpret_cast<getter>(CashDrawerOpenedEventArgs_get_CashDrawer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CashDrawerOpenedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CashDrawerOpenedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CashDrawerOpenedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CashDrawerOpenedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CashDrawerOpenedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_CashDrawerOpenedEventArgs = {
        "winrt._winrt_windows_devices_pointofservice.CashDrawerOpenedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::CashDrawerOpenedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CashDrawerOpenedEventArgs};

    // ----- CashDrawerStatus class --------------------

    static PyObject* _new_CashDrawerStatus(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::CashDrawerStatus>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::CashDrawerStatus>::type_name);
        return nullptr;
    }

    static void _dealloc_CashDrawerStatus(py::wrapper::Windows::Devices::PointOfService::CashDrawerStatus* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CashDrawerStatus_get_ExtendedStatus(py::wrapper::Windows::Devices::PointOfService::CashDrawerStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawerStatus", L"ExtendedStatus"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CashDrawerStatus_get_StatusKind(py::wrapper::Windows::Devices::PointOfService::CashDrawerStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawerStatus", L"StatusKind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StatusKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CashDrawerStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::CashDrawerStatus>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CashDrawerStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::CashDrawerStatus>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CashDrawerStatus[] = {
        { "_assign_array_", _assign_array_CashDrawerStatus, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CashDrawerStatus), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CashDrawerStatus[] = {
        { "extended_status", reinterpret_cast<getter>(CashDrawerStatus_get_ExtendedStatus), nullptr, nullptr, nullptr },
        { "status_kind", reinterpret_cast<getter>(CashDrawerStatus_get_StatusKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CashDrawerStatus[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CashDrawerStatus) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CashDrawerStatus) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CashDrawerStatus) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CashDrawerStatus) },
        { }
    };

    static PyType_Spec type_spec_CashDrawerStatus = {
        "winrt._winrt_windows_devices_pointofservice.CashDrawerStatus",
        sizeof(py::wrapper::Windows::Devices::PointOfService::CashDrawerStatus),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CashDrawerStatus};

    // ----- CashDrawerStatusUpdatedEventArgs class --------------------

    static PyObject* _new_CashDrawerStatusUpdatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::CashDrawerStatusUpdatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::CashDrawerStatusUpdatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_CashDrawerStatusUpdatedEventArgs(py::wrapper::Windows::Devices::PointOfService::CashDrawerStatusUpdatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CashDrawerStatusUpdatedEventArgs_get_Status(py::wrapper::Windows::Devices::PointOfService::CashDrawerStatusUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.CashDrawerStatusUpdatedEventArgs", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CashDrawerStatusUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::CashDrawerStatusUpdatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CashDrawerStatusUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::CashDrawerStatusUpdatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CashDrawerStatusUpdatedEventArgs[] = {
        { "_assign_array_", _assign_array_CashDrawerStatusUpdatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CashDrawerStatusUpdatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CashDrawerStatusUpdatedEventArgs[] = {
        { "status", reinterpret_cast<getter>(CashDrawerStatusUpdatedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CashDrawerStatusUpdatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CashDrawerStatusUpdatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CashDrawerStatusUpdatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CashDrawerStatusUpdatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CashDrawerStatusUpdatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_CashDrawerStatusUpdatedEventArgs = {
        "winrt._winrt_windows_devices_pointofservice.CashDrawerStatusUpdatedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::CashDrawerStatusUpdatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CashDrawerStatusUpdatedEventArgs};

    // ----- ClaimedBarcodeScanner class --------------------

    static PyObject* _new_ClaimedBarcodeScanner(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner>::type_name);
        return nullptr;
    }

    static void _dealloc_ClaimedBarcodeScanner(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ClaimedBarcodeScanner_Close(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_DisableAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"DisableAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.DisableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_EnableAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"EnableAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.EnableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_GetSymbologyAttributesAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"GetSymbologyAttributesAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetSymbologyAttributesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_HideVideoPreview(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"HideVideoPreview", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.HideVideoPreview();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_ResetStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"ResetStatisticsAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.ResetStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_RetainDevice(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"RetainDevice", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RetainDevice();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_SetActiveProfileAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"SetActiveProfileAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.SetActiveProfileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_SetActiveSymbologiesAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"SetActiveSymbologiesAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint32_t>>(args, 0);

                return py::convert(self->obj.SetActiveSymbologiesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_SetSymbologyAttributesAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"SetSymbologyAttributesAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::BarcodeSymbologyAttributes>(args, 1);

                return py::convert(self->obj.SetSymbologyAttributesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_ShowVideoPreviewAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"ShowVideoPreviewAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ShowVideoPreviewAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_StartSoftwareTriggerAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"StartSoftwareTriggerAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.StartSoftwareTriggerAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_StopSoftwareTriggerAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"StopSoftwareTriggerAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.StopSoftwareTriggerAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_UpdateStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"UpdateStatisticsAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::hstring>>>(args, 0);

                return py::convert(self->obj.UpdateStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_get_IsDisabledOnDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"IsDisabledOnDataReceived"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDisabledOnDataReceived());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedBarcodeScanner_put_IsDisabledOnDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"IsDisabledOnDataReceived"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDisabledOnDataReceived(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedBarcodeScanner_get_IsDecodeDataEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"IsDecodeDataEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDecodeDataEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedBarcodeScanner_put_IsDecodeDataEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"IsDecodeDataEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDecodeDataEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedBarcodeScanner_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_get_IsEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"IsEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_get_IsVideoPreviewShownOnEnable(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"IsVideoPreviewShownOnEnable"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsVideoPreviewShownOnEnable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedBarcodeScanner_put_IsVideoPreviewShownOnEnable(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"IsVideoPreviewShownOnEnable"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsVideoPreviewShownOnEnable(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedBarcodeScanner_add_DataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"DataReceived"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner, winrt::Windows::Devices::PointOfService::BarcodeScannerDataReceivedEventArgs>>(arg);

            return py::convert(self->obj.DataReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_remove_DataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"DataReceived"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DataReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_add_ErrorOccurred(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"ErrorOccurred"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner, winrt::Windows::Devices::PointOfService::BarcodeScannerErrorOccurredEventArgs>>(arg);

            return py::convert(self->obj.ErrorOccurred(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_remove_ErrorOccurred(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"ErrorOccurred"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ErrorOccurred(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_add_ImagePreviewReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"ImagePreviewReceived"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner, winrt::Windows::Devices::PointOfService::BarcodeScannerImagePreviewReceivedEventArgs>>(arg);

            return py::convert(self->obj.ImagePreviewReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_remove_ImagePreviewReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"ImagePreviewReceived"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ImagePreviewReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_add_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"ReleaseDeviceRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner>>(arg);

            return py::convert(self->obj.ReleaseDeviceRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_remove_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"ReleaseDeviceRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReleaseDeviceRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_add_TriggerPressed(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"TriggerPressed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner>>(arg);

            return py::convert(self->obj.TriggerPressed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_remove_TriggerPressed(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"TriggerPressed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TriggerPressed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_add_TriggerReleased(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"TriggerReleased"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner>>(arg);

            return py::convert(self->obj.TriggerReleased(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_remove_TriggerReleased(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"TriggerReleased"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TriggerReleased(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_add_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"Closed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner, winrt::Windows::Devices::PointOfService::ClaimedBarcodeScannerClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedBarcodeScanner_remove_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedBarcodeScanner", L"Closed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ClaimedBarcodeScanner(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ClaimedBarcodeScanner(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScanner>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ClaimedBarcodeScanner(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_ClaimedBarcodeScanner(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedBarcodeScanner[] = {
        { "close", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_Close), METH_VARARGS, nullptr },
        { "disable_async", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_DisableAsync), METH_VARARGS, nullptr },
        { "enable_async", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_EnableAsync), METH_VARARGS, nullptr },
        { "get_symbology_attributes_async", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_GetSymbologyAttributesAsync), METH_VARARGS, nullptr },
        { "hide_video_preview", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_HideVideoPreview), METH_VARARGS, nullptr },
        { "reset_statistics_async", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_ResetStatisticsAsync), METH_VARARGS, nullptr },
        { "retain_device", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_RetainDevice), METH_VARARGS, nullptr },
        { "set_active_profile_async", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_SetActiveProfileAsync), METH_VARARGS, nullptr },
        { "set_active_symbologies_async", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_SetActiveSymbologiesAsync), METH_VARARGS, nullptr },
        { "set_symbology_attributes_async", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_SetSymbologyAttributesAsync), METH_VARARGS, nullptr },
        { "show_video_preview_async", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_ShowVideoPreviewAsync), METH_VARARGS, nullptr },
        { "start_software_trigger_async", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_StartSoftwareTriggerAsync), METH_VARARGS, nullptr },
        { "stop_software_trigger_async", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_StopSoftwareTriggerAsync), METH_VARARGS, nullptr },
        { "update_statistics_async", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_UpdateStatisticsAsync), METH_VARARGS, nullptr },
        { "add_data_received", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_add_DataReceived), METH_O, nullptr },
        { "remove_data_received", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_remove_DataReceived), METH_O, nullptr },
        { "add_error_occurred", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_add_ErrorOccurred), METH_O, nullptr },
        { "remove_error_occurred", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_remove_ErrorOccurred), METH_O, nullptr },
        { "add_image_preview_received", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_add_ImagePreviewReceived), METH_O, nullptr },
        { "remove_image_preview_received", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_remove_ImagePreviewReceived), METH_O, nullptr },
        { "add_release_device_requested", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_add_ReleaseDeviceRequested), METH_O, nullptr },
        { "remove_release_device_requested", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_remove_ReleaseDeviceRequested), METH_O, nullptr },
        { "add_trigger_pressed", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_add_TriggerPressed), METH_O, nullptr },
        { "remove_trigger_pressed", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_remove_TriggerPressed), METH_O, nullptr },
        { "add_trigger_released", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_add_TriggerReleased), METH_O, nullptr },
        { "remove_trigger_released", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_remove_TriggerReleased), METH_O, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(ClaimedBarcodeScanner_remove_Closed), METH_O, nullptr },
        { "_assign_array_", _assign_array_ClaimedBarcodeScanner, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClaimedBarcodeScanner), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ClaimedBarcodeScanner), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_ClaimedBarcodeScanner), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClaimedBarcodeScanner[] = {
        { "is_disabled_on_data_received", reinterpret_cast<getter>(ClaimedBarcodeScanner_get_IsDisabledOnDataReceived), reinterpret_cast<setter>(ClaimedBarcodeScanner_put_IsDisabledOnDataReceived), nullptr, nullptr },
        { "is_decode_data_enabled", reinterpret_cast<getter>(ClaimedBarcodeScanner_get_IsDecodeDataEnabled), reinterpret_cast<setter>(ClaimedBarcodeScanner_put_IsDecodeDataEnabled), nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(ClaimedBarcodeScanner_get_DeviceId), nullptr, nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(ClaimedBarcodeScanner_get_IsEnabled), nullptr, nullptr, nullptr },
        { "is_video_preview_shown_on_enable", reinterpret_cast<getter>(ClaimedBarcodeScanner_get_IsVideoPreviewShownOnEnable), reinterpret_cast<setter>(ClaimedBarcodeScanner_put_IsVideoPreviewShownOnEnable), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ClaimedBarcodeScanner[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ClaimedBarcodeScanner) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ClaimedBarcodeScanner) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ClaimedBarcodeScanner) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ClaimedBarcodeScanner) },
        { }
    };

    static PyType_Spec type_spec_ClaimedBarcodeScanner = {
        "winrt._winrt_windows_devices_pointofservice.ClaimedBarcodeScanner",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScanner),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedBarcodeScanner};

    // ----- ClaimedBarcodeScannerClosedEventArgs class --------------------

    static PyObject* _new_ClaimedBarcodeScannerClosedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScannerClosedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScannerClosedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ClaimedBarcodeScannerClosedEventArgs(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScannerClosedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ClaimedBarcodeScannerClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScannerClosedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ClaimedBarcodeScannerClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedBarcodeScannerClosedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedBarcodeScannerClosedEventArgs[] = {
        { "_assign_array_", _assign_array_ClaimedBarcodeScannerClosedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClaimedBarcodeScannerClosedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClaimedBarcodeScannerClosedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_ClaimedBarcodeScannerClosedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ClaimedBarcodeScannerClosedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ClaimedBarcodeScannerClosedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ClaimedBarcodeScannerClosedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ClaimedBarcodeScannerClosedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_ClaimedBarcodeScannerClosedEventArgs = {
        "winrt._winrt_windows_devices_pointofservice.ClaimedBarcodeScannerClosedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedBarcodeScannerClosedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedBarcodeScannerClosedEventArgs};

    // ----- ClaimedCashDrawer class --------------------

    static PyObject* _new_ClaimedCashDrawer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::ClaimedCashDrawer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::ClaimedCashDrawer>::type_name);
        return nullptr;
    }

    static void _dealloc_ClaimedCashDrawer(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ClaimedCashDrawer_Close(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedCashDrawer", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_DisableAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedCashDrawer", L"DisableAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.DisableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_EnableAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedCashDrawer", L"EnableAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.EnableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_OpenDrawerAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedCashDrawer", L"OpenDrawerAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.OpenDrawerAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_ResetStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedCashDrawer", L"ResetStatisticsAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.ResetStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_RetainDeviceAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedCashDrawer", L"RetainDeviceAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.RetainDeviceAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_UpdateStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedCashDrawer", L"UpdateStatisticsAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::hstring>>>(args, 0);

                return py::convert(self->obj.UpdateStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_get_CloseAlarm(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedCashDrawer", L"CloseAlarm"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CloseAlarm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedCashDrawer", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_get_IsDrawerOpen(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedCashDrawer", L"IsDrawerOpen"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDrawerOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_get_IsEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedCashDrawer", L"IsEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_add_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedCashDrawer", L"ReleaseDeviceRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedCashDrawer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ReleaseDeviceRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_remove_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedCashDrawer", L"ReleaseDeviceRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReleaseDeviceRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_add_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedCashDrawer", L"Closed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedCashDrawer, winrt::Windows::Devices::PointOfService::ClaimedCashDrawerClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedCashDrawer_remove_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedCashDrawer", L"Closed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ClaimedCashDrawer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::ClaimedCashDrawer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ClaimedCashDrawer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedCashDrawer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ClaimedCashDrawer(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_ClaimedCashDrawer(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedCashDrawer[] = {
        { "close", reinterpret_cast<PyCFunction>(ClaimedCashDrawer_Close), METH_VARARGS, nullptr },
        { "disable_async", reinterpret_cast<PyCFunction>(ClaimedCashDrawer_DisableAsync), METH_VARARGS, nullptr },
        { "enable_async", reinterpret_cast<PyCFunction>(ClaimedCashDrawer_EnableAsync), METH_VARARGS, nullptr },
        { "open_drawer_async", reinterpret_cast<PyCFunction>(ClaimedCashDrawer_OpenDrawerAsync), METH_VARARGS, nullptr },
        { "reset_statistics_async", reinterpret_cast<PyCFunction>(ClaimedCashDrawer_ResetStatisticsAsync), METH_VARARGS, nullptr },
        { "retain_device_async", reinterpret_cast<PyCFunction>(ClaimedCashDrawer_RetainDeviceAsync), METH_VARARGS, nullptr },
        { "update_statistics_async", reinterpret_cast<PyCFunction>(ClaimedCashDrawer_UpdateStatisticsAsync), METH_VARARGS, nullptr },
        { "add_release_device_requested", reinterpret_cast<PyCFunction>(ClaimedCashDrawer_add_ReleaseDeviceRequested), METH_O, nullptr },
        { "remove_release_device_requested", reinterpret_cast<PyCFunction>(ClaimedCashDrawer_remove_ReleaseDeviceRequested), METH_O, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(ClaimedCashDrawer_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(ClaimedCashDrawer_remove_Closed), METH_O, nullptr },
        { "_assign_array_", _assign_array_ClaimedCashDrawer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClaimedCashDrawer), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ClaimedCashDrawer), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_ClaimedCashDrawer), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClaimedCashDrawer[] = {
        { "close_alarm", reinterpret_cast<getter>(ClaimedCashDrawer_get_CloseAlarm), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(ClaimedCashDrawer_get_DeviceId), nullptr, nullptr, nullptr },
        { "is_drawer_open", reinterpret_cast<getter>(ClaimedCashDrawer_get_IsDrawerOpen), nullptr, nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(ClaimedCashDrawer_get_IsEnabled), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ClaimedCashDrawer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ClaimedCashDrawer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ClaimedCashDrawer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ClaimedCashDrawer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ClaimedCashDrawer) },
        { }
    };

    static PyType_Spec type_spec_ClaimedCashDrawer = {
        "winrt._winrt_windows_devices_pointofservice.ClaimedCashDrawer",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedCashDrawer};

    // ----- ClaimedCashDrawerClosedEventArgs class --------------------

    static PyObject* _new_ClaimedCashDrawerClosedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::ClaimedCashDrawerClosedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::ClaimedCashDrawerClosedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ClaimedCashDrawerClosedEventArgs(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawerClosedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ClaimedCashDrawerClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::ClaimedCashDrawerClosedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ClaimedCashDrawerClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedCashDrawerClosedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedCashDrawerClosedEventArgs[] = {
        { "_assign_array_", _assign_array_ClaimedCashDrawerClosedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClaimedCashDrawerClosedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClaimedCashDrawerClosedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_ClaimedCashDrawerClosedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ClaimedCashDrawerClosedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ClaimedCashDrawerClosedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ClaimedCashDrawerClosedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ClaimedCashDrawerClosedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_ClaimedCashDrawerClosedEventArgs = {
        "winrt._winrt_windows_devices_pointofservice.ClaimedCashDrawerClosedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedCashDrawerClosedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedCashDrawerClosedEventArgs};

    // ----- ClaimedJournalPrinter class --------------------

    static PyObject* _new_ClaimedJournalPrinter(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::ClaimedJournalPrinter>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::ClaimedJournalPrinter>::type_name);
        return nullptr;
    }

    static void _dealloc_ClaimedJournalPrinter(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ClaimedJournalPrinter_CreateJob(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"CreateJob", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateJob());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedJournalPrinter_ValidateData(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"ValidateData", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ValidateData(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_LineSpacing(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"LineSpacing"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LineSpacing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedJournalPrinter_put_LineSpacing(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"LineSpacing"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.LineSpacing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_LineHeight(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"LineHeight"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LineHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedJournalPrinter_put_LineHeight(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"LineHeight"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.LineHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_IsLetterQuality(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"IsLetterQuality"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsLetterQuality());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedJournalPrinter_put_IsLetterQuality(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"IsLetterQuality"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsLetterQuality(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_ColorCartridge(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"ColorCartridge"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ColorCartridge());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedJournalPrinter_put_ColorCartridge(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"ColorCartridge"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterColorCartridge>(arg);

            self->obj.ColorCartridge(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_CharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"CharactersPerLine"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CharactersPerLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedJournalPrinter_put_CharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"CharactersPerLine"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CharactersPerLine(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_IsCartridgeEmpty(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"IsCartridgeEmpty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsCartridgeEmpty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_IsCartridgeRemoved(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"IsCartridgeRemoved"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsCartridgeRemoved());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_IsCoverOpen(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"IsCoverOpen"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsCoverOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_IsHeadCleaning(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"IsHeadCleaning"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsHeadCleaning());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_IsPaperEmpty(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"IsPaperEmpty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPaperEmpty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_IsPaperNearEnd(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"IsPaperNearEnd"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPaperNearEnd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_IsReadyToPrint(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"IsReadyToPrint"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsReadyToPrint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedJournalPrinter_get_LineWidth(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedJournalPrinter", L"LineWidth"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LineWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ClaimedJournalPrinter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::ClaimedJournalPrinter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ClaimedJournalPrinter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedJournalPrinter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedJournalPrinter[] = {
        { "create_job", reinterpret_cast<PyCFunction>(ClaimedJournalPrinter_CreateJob), METH_VARARGS, nullptr },
        { "validate_data", reinterpret_cast<PyCFunction>(ClaimedJournalPrinter_ValidateData), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ClaimedJournalPrinter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClaimedJournalPrinter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClaimedJournalPrinter[] = {
        { "line_spacing", reinterpret_cast<getter>(ClaimedJournalPrinter_get_LineSpacing), reinterpret_cast<setter>(ClaimedJournalPrinter_put_LineSpacing), nullptr, nullptr },
        { "line_height", reinterpret_cast<getter>(ClaimedJournalPrinter_get_LineHeight), reinterpret_cast<setter>(ClaimedJournalPrinter_put_LineHeight), nullptr, nullptr },
        { "is_letter_quality", reinterpret_cast<getter>(ClaimedJournalPrinter_get_IsLetterQuality), reinterpret_cast<setter>(ClaimedJournalPrinter_put_IsLetterQuality), nullptr, nullptr },
        { "color_cartridge", reinterpret_cast<getter>(ClaimedJournalPrinter_get_ColorCartridge), reinterpret_cast<setter>(ClaimedJournalPrinter_put_ColorCartridge), nullptr, nullptr },
        { "characters_per_line", reinterpret_cast<getter>(ClaimedJournalPrinter_get_CharactersPerLine), reinterpret_cast<setter>(ClaimedJournalPrinter_put_CharactersPerLine), nullptr, nullptr },
        { "is_cartridge_empty", reinterpret_cast<getter>(ClaimedJournalPrinter_get_IsCartridgeEmpty), nullptr, nullptr, nullptr },
        { "is_cartridge_removed", reinterpret_cast<getter>(ClaimedJournalPrinter_get_IsCartridgeRemoved), nullptr, nullptr, nullptr },
        { "is_cover_open", reinterpret_cast<getter>(ClaimedJournalPrinter_get_IsCoverOpen), nullptr, nullptr, nullptr },
        { "is_head_cleaning", reinterpret_cast<getter>(ClaimedJournalPrinter_get_IsHeadCleaning), nullptr, nullptr, nullptr },
        { "is_paper_empty", reinterpret_cast<getter>(ClaimedJournalPrinter_get_IsPaperEmpty), nullptr, nullptr, nullptr },
        { "is_paper_near_end", reinterpret_cast<getter>(ClaimedJournalPrinter_get_IsPaperNearEnd), nullptr, nullptr, nullptr },
        { "is_ready_to_print", reinterpret_cast<getter>(ClaimedJournalPrinter_get_IsReadyToPrint), nullptr, nullptr, nullptr },
        { "line_width", reinterpret_cast<getter>(ClaimedJournalPrinter_get_LineWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ClaimedJournalPrinter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ClaimedJournalPrinter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ClaimedJournalPrinter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ClaimedJournalPrinter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ClaimedJournalPrinter) },
        { }
    };

    static PyType_Spec type_spec_ClaimedJournalPrinter = {
        "winrt._winrt_windows_devices_pointofservice.ClaimedJournalPrinter",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedJournalPrinter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedJournalPrinter};

    // ----- ClaimedLineDisplay class --------------------

    static PyObject* _new_ClaimedLineDisplay(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::ClaimedLineDisplay>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::ClaimedLineDisplay>::type_name);
        return nullptr;
    }

    static void _dealloc_ClaimedLineDisplay(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ClaimedLineDisplay_CheckHealthAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"CheckHealthAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::UnifiedPosHealthCheckLevel>(args, 0);

                return py::convert(self->obj.CheckHealthAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_CheckPowerStatusAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"CheckPowerStatusAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CheckPowerStatusAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_Close(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"FromIdAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::ClaimedLineDisplay::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_GetAttributes(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"GetAttributes", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetAttributes());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"GetDeviceSelector", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::PointOfService::ClaimedLineDisplay::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"GetDeviceSelector", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosConnectionTypes>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::ClaimedLineDisplay::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_GetStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"GetStatisticsAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_RetainDevice(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"RetainDevice", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RetainDevice();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_TryClearDescriptorsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"TryClearDescriptorsAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TryClearDescriptorsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_TryCreateWindowAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"TryCreateWindowAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Size>(args, 1);

                return py::convert(self->obj.TryCreateWindowAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_TrySetDescriptorAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"TrySetDescriptorAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayDescriptorState>(args, 1);

                return py::convert(self->obj.TrySetDescriptorAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_TryStoreStorageFileBitmapAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"TryStoreStorageFileBitmapAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);

                return py::convert(self->obj.TryStoreStorageFileBitmapAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"TryStoreStorageFileBitmapAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayHorizontalAlignment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayVerticalAlignment>(args, 2);

                return py::convert(self->obj.TryStoreStorageFileBitmapAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"TryStoreStorageFileBitmapAsync", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayHorizontalAlignment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayVerticalAlignment>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                return py::convert(self->obj.TryStoreStorageFileBitmapAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_TryUpdateAttributesAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"TryUpdateAttributesAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayAttributes>(args, 0);

                return py::convert(self->obj.TryUpdateAttributesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_Capabilities(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"Capabilities"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Capabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_DefaultWindow(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"DefaultWindow"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DefaultWindow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_DeviceControlDescription(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"DeviceControlDescription"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceControlDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_DeviceControlVersion(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"DeviceControlVersion"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceControlVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_DeviceServiceVersion(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"DeviceServiceVersion"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceServiceVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_PhysicalDeviceDescription(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"PhysicalDeviceDescription"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PhysicalDeviceDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_PhysicalDeviceName(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"PhysicalDeviceName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PhysicalDeviceName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_CustomGlyphs(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"CustomGlyphs"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CustomGlyphs());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_MaxBitmapSizeInPixels(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"MaxBitmapSizeInPixels"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxBitmapSizeInPixels());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_SupportedCharacterSets(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"SupportedCharacterSets"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedCharacterSets());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_get_SupportedScreenSizesInCharacters(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"SupportedScreenSizesInCharacters"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedScreenSizesInCharacters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_add_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"ReleaseDeviceRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedLineDisplay, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ReleaseDeviceRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_remove_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"ReleaseDeviceRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReleaseDeviceRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_add_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"StatusUpdated"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedLineDisplay, winrt::Windows::Devices::PointOfService::LineDisplayStatusUpdatedEventArgs>>(arg);

            return py::convert(self->obj.StatusUpdated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_remove_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"StatusUpdated"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StatusUpdated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_add_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"Closed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedLineDisplay, winrt::Windows::Devices::PointOfService::ClaimedLineDisplayClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedLineDisplay_remove_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedLineDisplay", L"Closed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ClaimedLineDisplay(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::ClaimedLineDisplay>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ClaimedLineDisplay(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedLineDisplay>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ClaimedLineDisplay(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_ClaimedLineDisplay(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedLineDisplay[] = {
        { "check_health_async", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_CheckHealthAsync), METH_VARARGS, nullptr },
        { "check_power_status_async", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_CheckPowerStatusAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_Close), METH_VARARGS, nullptr },
        { "get_attributes", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_GetAttributes), METH_VARARGS, nullptr },
        { "get_statistics_async", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_GetStatisticsAsync), METH_VARARGS, nullptr },
        { "retain_device", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_RetainDevice), METH_VARARGS, nullptr },
        { "try_clear_descriptors_async", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_TryClearDescriptorsAsync), METH_VARARGS, nullptr },
        { "try_create_window_async", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_TryCreateWindowAsync), METH_VARARGS, nullptr },
        { "try_set_descriptor_async", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_TrySetDescriptorAsync), METH_VARARGS, nullptr },
        { "try_store_storage_file_bitmap_async", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_TryStoreStorageFileBitmapAsync), METH_VARARGS, nullptr },
        { "try_update_attributes_async", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_TryUpdateAttributesAsync), METH_VARARGS, nullptr },
        { "add_release_device_requested", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_add_ReleaseDeviceRequested), METH_O, nullptr },
        { "remove_release_device_requested", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_remove_ReleaseDeviceRequested), METH_O, nullptr },
        { "add_status_updated", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_add_StatusUpdated), METH_O, nullptr },
        { "remove_status_updated", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_remove_StatusUpdated), METH_O, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_remove_Closed), METH_O, nullptr },
        { "_assign_array_", _assign_array_ClaimedLineDisplay, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClaimedLineDisplay), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ClaimedLineDisplay), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_ClaimedLineDisplay), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClaimedLineDisplay[] = {
        { "capabilities", reinterpret_cast<getter>(ClaimedLineDisplay_get_Capabilities), nullptr, nullptr, nullptr },
        { "default_window", reinterpret_cast<getter>(ClaimedLineDisplay_get_DefaultWindow), nullptr, nullptr, nullptr },
        { "device_control_description", reinterpret_cast<getter>(ClaimedLineDisplay_get_DeviceControlDescription), nullptr, nullptr, nullptr },
        { "device_control_version", reinterpret_cast<getter>(ClaimedLineDisplay_get_DeviceControlVersion), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(ClaimedLineDisplay_get_DeviceId), nullptr, nullptr, nullptr },
        { "device_service_version", reinterpret_cast<getter>(ClaimedLineDisplay_get_DeviceServiceVersion), nullptr, nullptr, nullptr },
        { "physical_device_description", reinterpret_cast<getter>(ClaimedLineDisplay_get_PhysicalDeviceDescription), nullptr, nullptr, nullptr },
        { "physical_device_name", reinterpret_cast<getter>(ClaimedLineDisplay_get_PhysicalDeviceName), nullptr, nullptr, nullptr },
        { "custom_glyphs", reinterpret_cast<getter>(ClaimedLineDisplay_get_CustomGlyphs), nullptr, nullptr, nullptr },
        { "max_bitmap_size_in_pixels", reinterpret_cast<getter>(ClaimedLineDisplay_get_MaxBitmapSizeInPixels), nullptr, nullptr, nullptr },
        { "supported_character_sets", reinterpret_cast<getter>(ClaimedLineDisplay_get_SupportedCharacterSets), nullptr, nullptr, nullptr },
        { "supported_screen_sizes_in_characters", reinterpret_cast<getter>(ClaimedLineDisplay_get_SupportedScreenSizesInCharacters), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ClaimedLineDisplay[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ClaimedLineDisplay) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ClaimedLineDisplay) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ClaimedLineDisplay) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ClaimedLineDisplay) },
        { }
    };

    static PyType_Spec type_spec_ClaimedLineDisplay = {
        "winrt._winrt_windows_devices_pointofservice.ClaimedLineDisplay",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplay),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedLineDisplay};

    static PyGetSetDef getset_ClaimedLineDisplay_Static[] = {
        { }
    };

    static PyMethodDef methods_ClaimedLineDisplay_Static[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_FromIdAsync), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(ClaimedLineDisplay_GetDeviceSelector), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_ClaimedLineDisplay_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ClaimedLineDisplay_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ClaimedLineDisplay_Static) },
        { }
    };

    static PyType_Spec type_spec_ClaimedLineDisplay_Static =
    {
        "winrt._winrt_windows_devices_pointofservice.ClaimedLineDisplay_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ClaimedLineDisplay_Static
    };

    // ----- ClaimedLineDisplayClosedEventArgs class --------------------

    static PyObject* _new_ClaimedLineDisplayClosedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::ClaimedLineDisplayClosedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::ClaimedLineDisplayClosedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ClaimedLineDisplayClosedEventArgs(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplayClosedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ClaimedLineDisplayClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::ClaimedLineDisplayClosedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ClaimedLineDisplayClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedLineDisplayClosedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedLineDisplayClosedEventArgs[] = {
        { "_assign_array_", _assign_array_ClaimedLineDisplayClosedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClaimedLineDisplayClosedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClaimedLineDisplayClosedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_ClaimedLineDisplayClosedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ClaimedLineDisplayClosedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ClaimedLineDisplayClosedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ClaimedLineDisplayClosedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ClaimedLineDisplayClosedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_ClaimedLineDisplayClosedEventArgs = {
        "winrt._winrt_windows_devices_pointofservice.ClaimedLineDisplayClosedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedLineDisplayClosedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedLineDisplayClosedEventArgs};

    // ----- ClaimedMagneticStripeReader class --------------------

    static PyObject* _new_ClaimedMagneticStripeReader(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReader>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReader>::type_name);
        return nullptr;
    }

    static void _dealloc_ClaimedMagneticStripeReader(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ClaimedMagneticStripeReader_AuthenticateDeviceAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"AuthenticateDeviceAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                return py::convert(self->obj.AuthenticateDeviceAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_Close(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_DeAuthenticateDeviceAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"DeAuthenticateDeviceAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 0);

                return py::convert(self->obj.DeAuthenticateDeviceAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_DisableAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"DisableAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.DisableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_EnableAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"EnableAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.EnableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_ResetStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"ResetStatisticsAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.ResetStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_RetainDevice(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"RetainDevice", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RetainDevice();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_RetrieveDeviceAuthenticationDataAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"RetrieveDeviceAuthenticationDataAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.RetrieveDeviceAuthenticationDataAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_SetErrorReportingType(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"SetErrorReportingType", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::MagneticStripeReaderErrorReportingType>(args, 0);

                self->obj.SetErrorReportingType(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_UpdateKeyAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"UpdateKeyAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.UpdateKeyAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_UpdateStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"UpdateStatisticsAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::hstring>>>(args, 0);

                return py::convert(self->obj.UpdateStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_get_TracksToRead(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"TracksToRead"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TracksToRead());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedMagneticStripeReader_put_TracksToRead(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"TracksToRead"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::MagneticStripeReaderTrackIds>(arg);

            self->obj.TracksToRead(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_get_IsTransmitSentinelsEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"IsTransmitSentinelsEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsTransmitSentinelsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedMagneticStripeReader_put_IsTransmitSentinelsEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"IsTransmitSentinelsEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsTransmitSentinelsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_get_IsDisabledOnDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"IsDisabledOnDataReceived"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDisabledOnDataReceived());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedMagneticStripeReader_put_IsDisabledOnDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"IsDisabledOnDataReceived"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDisabledOnDataReceived(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_get_IsDecodeDataEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"IsDecodeDataEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDecodeDataEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedMagneticStripeReader_put_IsDecodeDataEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"IsDecodeDataEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDecodeDataEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_get_DataEncryptionAlgorithm(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"DataEncryptionAlgorithm"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DataEncryptionAlgorithm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedMagneticStripeReader_put_DataEncryptionAlgorithm(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"DataEncryptionAlgorithm"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.DataEncryptionAlgorithm(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_get_IsDeviceAuthenticated(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"IsDeviceAuthenticated"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDeviceAuthenticated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_get_IsEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"IsEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_add_AamvaCardDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"AamvaCardDataReceived"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReader, winrt::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs>>(arg);

            return py::convert(self->obj.AamvaCardDataReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_remove_AamvaCardDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"AamvaCardDataReceived"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AamvaCardDataReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_add_BankCardDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"BankCardDataReceived"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReader, winrt::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs>>(arg);

            return py::convert(self->obj.BankCardDataReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_remove_BankCardDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"BankCardDataReceived"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BankCardDataReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_add_ErrorOccurred(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"ErrorOccurred"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReader, winrt::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs>>(arg);

            return py::convert(self->obj.ErrorOccurred(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_remove_ErrorOccurred(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"ErrorOccurred"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ErrorOccurred(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_add_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"ReleaseDeviceRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReader>>(arg);

            return py::convert(self->obj.ReleaseDeviceRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_remove_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"ReleaseDeviceRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReleaseDeviceRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_add_VendorSpecificDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"VendorSpecificDataReceived"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReader, winrt::Windows::Devices::PointOfService::MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs>>(arg);

            return py::convert(self->obj.VendorSpecificDataReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_remove_VendorSpecificDataReceived(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"VendorSpecificDataReceived"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VendorSpecificDataReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_add_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"Closed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReader, winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReaderClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedMagneticStripeReader_remove_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedMagneticStripeReader", L"Closed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ClaimedMagneticStripeReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ClaimedMagneticStripeReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ClaimedMagneticStripeReader(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_ClaimedMagneticStripeReader(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedMagneticStripeReader[] = {
        { "authenticate_device_async", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_AuthenticateDeviceAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_Close), METH_VARARGS, nullptr },
        { "de_authenticate_device_async", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_DeAuthenticateDeviceAsync), METH_VARARGS, nullptr },
        { "disable_async", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_DisableAsync), METH_VARARGS, nullptr },
        { "enable_async", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_EnableAsync), METH_VARARGS, nullptr },
        { "reset_statistics_async", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_ResetStatisticsAsync), METH_VARARGS, nullptr },
        { "retain_device", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_RetainDevice), METH_VARARGS, nullptr },
        { "retrieve_device_authentication_data_async", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_RetrieveDeviceAuthenticationDataAsync), METH_VARARGS, nullptr },
        { "set_error_reporting_type", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_SetErrorReportingType), METH_VARARGS, nullptr },
        { "update_key_async", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_UpdateKeyAsync), METH_VARARGS, nullptr },
        { "update_statistics_async", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_UpdateStatisticsAsync), METH_VARARGS, nullptr },
        { "add_aamva_card_data_received", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_add_AamvaCardDataReceived), METH_O, nullptr },
        { "remove_aamva_card_data_received", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_remove_AamvaCardDataReceived), METH_O, nullptr },
        { "add_bank_card_data_received", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_add_BankCardDataReceived), METH_O, nullptr },
        { "remove_bank_card_data_received", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_remove_BankCardDataReceived), METH_O, nullptr },
        { "add_error_occurred", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_add_ErrorOccurred), METH_O, nullptr },
        { "remove_error_occurred", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_remove_ErrorOccurred), METH_O, nullptr },
        { "add_release_device_requested", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_add_ReleaseDeviceRequested), METH_O, nullptr },
        { "remove_release_device_requested", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_remove_ReleaseDeviceRequested), METH_O, nullptr },
        { "add_vendor_specific_data_received", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_add_VendorSpecificDataReceived), METH_O, nullptr },
        { "remove_vendor_specific_data_received", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_remove_VendorSpecificDataReceived), METH_O, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(ClaimedMagneticStripeReader_remove_Closed), METH_O, nullptr },
        { "_assign_array_", _assign_array_ClaimedMagneticStripeReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClaimedMagneticStripeReader), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ClaimedMagneticStripeReader), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_ClaimedMagneticStripeReader), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClaimedMagneticStripeReader[] = {
        { "tracks_to_read", reinterpret_cast<getter>(ClaimedMagneticStripeReader_get_TracksToRead), reinterpret_cast<setter>(ClaimedMagneticStripeReader_put_TracksToRead), nullptr, nullptr },
        { "is_transmit_sentinels_enabled", reinterpret_cast<getter>(ClaimedMagneticStripeReader_get_IsTransmitSentinelsEnabled), reinterpret_cast<setter>(ClaimedMagneticStripeReader_put_IsTransmitSentinelsEnabled), nullptr, nullptr },
        { "is_disabled_on_data_received", reinterpret_cast<getter>(ClaimedMagneticStripeReader_get_IsDisabledOnDataReceived), reinterpret_cast<setter>(ClaimedMagneticStripeReader_put_IsDisabledOnDataReceived), nullptr, nullptr },
        { "is_decode_data_enabled", reinterpret_cast<getter>(ClaimedMagneticStripeReader_get_IsDecodeDataEnabled), reinterpret_cast<setter>(ClaimedMagneticStripeReader_put_IsDecodeDataEnabled), nullptr, nullptr },
        { "data_encryption_algorithm", reinterpret_cast<getter>(ClaimedMagneticStripeReader_get_DataEncryptionAlgorithm), reinterpret_cast<setter>(ClaimedMagneticStripeReader_put_DataEncryptionAlgorithm), nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(ClaimedMagneticStripeReader_get_DeviceId), nullptr, nullptr, nullptr },
        { "is_device_authenticated", reinterpret_cast<getter>(ClaimedMagneticStripeReader_get_IsDeviceAuthenticated), nullptr, nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(ClaimedMagneticStripeReader_get_IsEnabled), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ClaimedMagneticStripeReader[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ClaimedMagneticStripeReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ClaimedMagneticStripeReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ClaimedMagneticStripeReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ClaimedMagneticStripeReader) },
        { }
    };

    static PyType_Spec type_spec_ClaimedMagneticStripeReader = {
        "winrt._winrt_windows_devices_pointofservice.ClaimedMagneticStripeReader",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedMagneticStripeReader};

    // ----- ClaimedMagneticStripeReaderClosedEventArgs class --------------------

    static PyObject* _new_ClaimedMagneticStripeReaderClosedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReaderClosedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReaderClosedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ClaimedMagneticStripeReaderClosedEventArgs(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReaderClosedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ClaimedMagneticStripeReaderClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReaderClosedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ClaimedMagneticStripeReaderClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedMagneticStripeReaderClosedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedMagneticStripeReaderClosedEventArgs[] = {
        { "_assign_array_", _assign_array_ClaimedMagneticStripeReaderClosedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClaimedMagneticStripeReaderClosedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClaimedMagneticStripeReaderClosedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_ClaimedMagneticStripeReaderClosedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ClaimedMagneticStripeReaderClosedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ClaimedMagneticStripeReaderClosedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ClaimedMagneticStripeReaderClosedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ClaimedMagneticStripeReaderClosedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_ClaimedMagneticStripeReaderClosedEventArgs = {
        "winrt._winrt_windows_devices_pointofservice.ClaimedMagneticStripeReaderClosedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedMagneticStripeReaderClosedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedMagneticStripeReaderClosedEventArgs};

    // ----- ClaimedPosPrinter class --------------------

    static PyObject* _new_ClaimedPosPrinter(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::ClaimedPosPrinter>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::ClaimedPosPrinter>::type_name);
        return nullptr;
    }

    static void _dealloc_ClaimedPosPrinter(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ClaimedPosPrinter_Close(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_DisableAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"DisableAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.DisableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_EnableAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"EnableAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.EnableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_ResetStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"ResetStatisticsAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.ResetStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_RetainDeviceAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"RetainDeviceAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.RetainDeviceAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_UpdateStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"UpdateStatisticsAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::hstring>>>(args, 0);

                return py::convert(self->obj.UpdateStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_get_MapMode(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"MapMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MapMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedPosPrinter_put_MapMode(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"MapMode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterMapMode>(arg);

            self->obj.MapMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedPosPrinter_get_IsCharacterSetMappingEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"IsCharacterSetMappingEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsCharacterSetMappingEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedPosPrinter_put_IsCharacterSetMappingEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"IsCharacterSetMappingEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCharacterSetMappingEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedPosPrinter_get_CharacterSet(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"CharacterSet"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CharacterSet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedPosPrinter_put_CharacterSet(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"CharacterSet"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CharacterSet(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedPosPrinter_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_get_IsCoverOpen(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"IsCoverOpen"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsCoverOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_get_IsEnabled(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"IsEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_get_Journal(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"Journal"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Journal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_get_Receipt(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"Receipt"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Receipt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_get_Slip(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"Slip"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Slip());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_add_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"ReleaseDeviceRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedPosPrinter, winrt::Windows::Devices::PointOfService::PosPrinterReleaseDeviceRequestedEventArgs>>(arg);

            return py::convert(self->obj.ReleaseDeviceRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_remove_ReleaseDeviceRequested(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"ReleaseDeviceRequested"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ReleaseDeviceRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_add_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"Closed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::ClaimedPosPrinter, winrt::Windows::Devices::PointOfService::ClaimedPosPrinterClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedPosPrinter_remove_Closed(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.ClaimedPosPrinter", L"Closed"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ClaimedPosPrinter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::ClaimedPosPrinter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ClaimedPosPrinter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedPosPrinter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ClaimedPosPrinter(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_ClaimedPosPrinter(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedPosPrinter[] = {
        { "close", reinterpret_cast<PyCFunction>(ClaimedPosPrinter_Close), METH_VARARGS, nullptr },
        { "disable_async", reinterpret_cast<PyCFunction>(ClaimedPosPrinter_DisableAsync), METH_VARARGS, nullptr },
        { "enable_async", reinterpret_cast<PyCFunction>(ClaimedPosPrinter_EnableAsync), METH_VARARGS, nullptr },
        { "reset_statistics_async", reinterpret_cast<PyCFunction>(ClaimedPosPrinter_ResetStatisticsAsync), METH_VARARGS, nullptr },
        { "retain_device_async", reinterpret_cast<PyCFunction>(ClaimedPosPrinter_RetainDeviceAsync), METH_VARARGS, nullptr },
        { "update_statistics_async", reinterpret_cast<PyCFunction>(ClaimedPosPrinter_UpdateStatisticsAsync), METH_VARARGS, nullptr },
        { "add_release_device_requested", reinterpret_cast<PyCFunction>(ClaimedPosPrinter_add_ReleaseDeviceRequested), METH_O, nullptr },
        { "remove_release_device_requested", reinterpret_cast<PyCFunction>(ClaimedPosPrinter_remove_ReleaseDeviceRequested), METH_O, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(ClaimedPosPrinter_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(ClaimedPosPrinter_remove_Closed), METH_O, nullptr },
        { "_assign_array_", _assign_array_ClaimedPosPrinter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClaimedPosPrinter), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ClaimedPosPrinter), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_ClaimedPosPrinter), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClaimedPosPrinter[] = {
        { "map_mode", reinterpret_cast<getter>(ClaimedPosPrinter_get_MapMode), reinterpret_cast<setter>(ClaimedPosPrinter_put_MapMode), nullptr, nullptr },
        { "is_character_set_mapping_enabled", reinterpret_cast<getter>(ClaimedPosPrinter_get_IsCharacterSetMappingEnabled), reinterpret_cast<setter>(ClaimedPosPrinter_put_IsCharacterSetMappingEnabled), nullptr, nullptr },
        { "character_set", reinterpret_cast<getter>(ClaimedPosPrinter_get_CharacterSet), reinterpret_cast<setter>(ClaimedPosPrinter_put_CharacterSet), nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(ClaimedPosPrinter_get_DeviceId), nullptr, nullptr, nullptr },
        { "is_cover_open", reinterpret_cast<getter>(ClaimedPosPrinter_get_IsCoverOpen), nullptr, nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(ClaimedPosPrinter_get_IsEnabled), nullptr, nullptr, nullptr },
        { "journal", reinterpret_cast<getter>(ClaimedPosPrinter_get_Journal), nullptr, nullptr, nullptr },
        { "receipt", reinterpret_cast<getter>(ClaimedPosPrinter_get_Receipt), nullptr, nullptr, nullptr },
        { "slip", reinterpret_cast<getter>(ClaimedPosPrinter_get_Slip), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ClaimedPosPrinter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ClaimedPosPrinter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ClaimedPosPrinter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ClaimedPosPrinter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ClaimedPosPrinter) },
        { }
    };

    static PyType_Spec type_spec_ClaimedPosPrinter = {
        "winrt._winrt_windows_devices_pointofservice.ClaimedPosPrinter",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedPosPrinter};

    // ----- ClaimedPosPrinterClosedEventArgs class --------------------

    static PyObject* _new_ClaimedPosPrinterClosedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::ClaimedPosPrinterClosedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::ClaimedPosPrinterClosedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ClaimedPosPrinterClosedEventArgs(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinterClosedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ClaimedPosPrinterClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::ClaimedPosPrinterClosedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ClaimedPosPrinterClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedPosPrinterClosedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedPosPrinterClosedEventArgs[] = {
        { "_assign_array_", _assign_array_ClaimedPosPrinterClosedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClaimedPosPrinterClosedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClaimedPosPrinterClosedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_ClaimedPosPrinterClosedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ClaimedPosPrinterClosedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ClaimedPosPrinterClosedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ClaimedPosPrinterClosedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ClaimedPosPrinterClosedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_ClaimedPosPrinterClosedEventArgs = {
        "winrt._winrt_windows_devices_pointofservice.ClaimedPosPrinterClosedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedPosPrinterClosedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedPosPrinterClosedEventArgs};

    // ----- ClaimedReceiptPrinter class --------------------

    static PyObject* _new_ClaimedReceiptPrinter(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::ClaimedReceiptPrinter>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::ClaimedReceiptPrinter>::type_name);
        return nullptr;
    }

    static void _dealloc_ClaimedReceiptPrinter(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ClaimedReceiptPrinter_CreateJob(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"CreateJob", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateJob());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_ValidateData(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"ValidateData", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ValidateData(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_LinesToPaperCut(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"LinesToPaperCut"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LinesToPaperCut());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_PageSize(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"PageSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PageSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_PrintArea(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"PrintArea"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PrintArea());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_SidewaysMaxChars(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"SidewaysMaxChars"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SidewaysMaxChars());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_SidewaysMaxLines(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"SidewaysMaxLines"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SidewaysMaxLines());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_LineSpacing(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"LineSpacing"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LineSpacing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedReceiptPrinter_put_LineSpacing(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"LineSpacing"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.LineSpacing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_LineHeight(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"LineHeight"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LineHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedReceiptPrinter_put_LineHeight(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"LineHeight"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.LineHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_IsLetterQuality(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"IsLetterQuality"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsLetterQuality());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedReceiptPrinter_put_IsLetterQuality(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"IsLetterQuality"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsLetterQuality(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_ColorCartridge(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"ColorCartridge"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ColorCartridge());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedReceiptPrinter_put_ColorCartridge(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"ColorCartridge"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterColorCartridge>(arg);

            self->obj.ColorCartridge(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_CharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"CharactersPerLine"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CharactersPerLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedReceiptPrinter_put_CharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"CharactersPerLine"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CharactersPerLine(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_IsCartridgeEmpty(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"IsCartridgeEmpty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsCartridgeEmpty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_IsCartridgeRemoved(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"IsCartridgeRemoved"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsCartridgeRemoved());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_IsCoverOpen(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"IsCoverOpen"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsCoverOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_IsHeadCleaning(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"IsHeadCleaning"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsHeadCleaning());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_IsPaperEmpty(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"IsPaperEmpty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPaperEmpty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_IsPaperNearEnd(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"IsPaperNearEnd"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPaperNearEnd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_IsReadyToPrint(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"IsReadyToPrint"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsReadyToPrint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedReceiptPrinter_get_LineWidth(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedReceiptPrinter", L"LineWidth"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LineWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ClaimedReceiptPrinter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::ClaimedReceiptPrinter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ClaimedReceiptPrinter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedReceiptPrinter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedReceiptPrinter[] = {
        { "create_job", reinterpret_cast<PyCFunction>(ClaimedReceiptPrinter_CreateJob), METH_VARARGS, nullptr },
        { "validate_data", reinterpret_cast<PyCFunction>(ClaimedReceiptPrinter_ValidateData), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ClaimedReceiptPrinter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClaimedReceiptPrinter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClaimedReceiptPrinter[] = {
        { "lines_to_paper_cut", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_LinesToPaperCut), nullptr, nullptr, nullptr },
        { "page_size", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_PageSize), nullptr, nullptr, nullptr },
        { "print_area", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_PrintArea), nullptr, nullptr, nullptr },
        { "sideways_max_chars", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_SidewaysMaxChars), nullptr, nullptr, nullptr },
        { "sideways_max_lines", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_SidewaysMaxLines), nullptr, nullptr, nullptr },
        { "line_spacing", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_LineSpacing), reinterpret_cast<setter>(ClaimedReceiptPrinter_put_LineSpacing), nullptr, nullptr },
        { "line_height", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_LineHeight), reinterpret_cast<setter>(ClaimedReceiptPrinter_put_LineHeight), nullptr, nullptr },
        { "is_letter_quality", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_IsLetterQuality), reinterpret_cast<setter>(ClaimedReceiptPrinter_put_IsLetterQuality), nullptr, nullptr },
        { "color_cartridge", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_ColorCartridge), reinterpret_cast<setter>(ClaimedReceiptPrinter_put_ColorCartridge), nullptr, nullptr },
        { "characters_per_line", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_CharactersPerLine), reinterpret_cast<setter>(ClaimedReceiptPrinter_put_CharactersPerLine), nullptr, nullptr },
        { "is_cartridge_empty", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_IsCartridgeEmpty), nullptr, nullptr, nullptr },
        { "is_cartridge_removed", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_IsCartridgeRemoved), nullptr, nullptr, nullptr },
        { "is_cover_open", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_IsCoverOpen), nullptr, nullptr, nullptr },
        { "is_head_cleaning", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_IsHeadCleaning), nullptr, nullptr, nullptr },
        { "is_paper_empty", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_IsPaperEmpty), nullptr, nullptr, nullptr },
        { "is_paper_near_end", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_IsPaperNearEnd), nullptr, nullptr, nullptr },
        { "is_ready_to_print", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_IsReadyToPrint), nullptr, nullptr, nullptr },
        { "line_width", reinterpret_cast<getter>(ClaimedReceiptPrinter_get_LineWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ClaimedReceiptPrinter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ClaimedReceiptPrinter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ClaimedReceiptPrinter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ClaimedReceiptPrinter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ClaimedReceiptPrinter) },
        { }
    };

    static PyType_Spec type_spec_ClaimedReceiptPrinter = {
        "winrt._winrt_windows_devices_pointofservice.ClaimedReceiptPrinter",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedReceiptPrinter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedReceiptPrinter};

    // ----- ClaimedSlipPrinter class --------------------

    static PyObject* _new_ClaimedSlipPrinter(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::ClaimedSlipPrinter>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::ClaimedSlipPrinter>::type_name);
        return nullptr;
    }

    static void _dealloc_ClaimedSlipPrinter(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ClaimedSlipPrinter_ChangePrintSide(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"ChangePrintSide", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterPrintSide>(args, 0);

                self->obj.ChangePrintSide(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_CloseJaws(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"CloseJaws", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.CloseJaws();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_CreateJob(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"CreateJob", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateJob());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_InsertSlipAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"InsertSlipAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                return py::convert(self->obj.InsertSlipAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_OpenJaws(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"OpenJaws", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.OpenJaws();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_RemoveSlipAsync(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"RemoveSlipAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                return py::convert(self->obj.RemoveSlipAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_ValidateData(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"ValidateData", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ValidateData(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_LinesNearEndToEnd(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"LinesNearEndToEnd"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LinesNearEndToEnd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_MaxLines(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"MaxLines"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxLines());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_PageSize(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"PageSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PageSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_PrintArea(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"PrintArea"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PrintArea());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_PrintSide(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"PrintSide"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PrintSide());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_SidewaysMaxChars(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"SidewaysMaxChars"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SidewaysMaxChars());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_SidewaysMaxLines(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"SidewaysMaxLines"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SidewaysMaxLines());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_LineSpacing(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"LineSpacing"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LineSpacing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedSlipPrinter_put_LineSpacing(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"LineSpacing"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.LineSpacing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_LineHeight(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"LineHeight"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LineHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedSlipPrinter_put_LineHeight(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"LineHeight"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.LineHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_IsLetterQuality(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"IsLetterQuality"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsLetterQuality());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedSlipPrinter_put_IsLetterQuality(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"IsLetterQuality"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsLetterQuality(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_ColorCartridge(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"ColorCartridge"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ColorCartridge());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedSlipPrinter_put_ColorCartridge(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"ColorCartridge"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterColorCartridge>(arg);

            self->obj.ColorCartridge(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_CharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"CharactersPerLine"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CharactersPerLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClaimedSlipPrinter_put_CharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"CharactersPerLine"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CharactersPerLine(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_IsCartridgeEmpty(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"IsCartridgeEmpty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsCartridgeEmpty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_IsCartridgeRemoved(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"IsCartridgeRemoved"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsCartridgeRemoved());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_IsCoverOpen(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"IsCoverOpen"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsCoverOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_IsHeadCleaning(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"IsHeadCleaning"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsHeadCleaning());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_IsPaperEmpty(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"IsPaperEmpty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPaperEmpty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_IsPaperNearEnd(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"IsPaperNearEnd"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPaperNearEnd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_IsReadyToPrint(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"IsReadyToPrint"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsReadyToPrint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClaimedSlipPrinter_get_LineWidth(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ClaimedSlipPrinter", L"LineWidth"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LineWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ClaimedSlipPrinter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::ClaimedSlipPrinter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ClaimedSlipPrinter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ClaimedSlipPrinter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClaimedSlipPrinter[] = {
        { "change_print_side", reinterpret_cast<PyCFunction>(ClaimedSlipPrinter_ChangePrintSide), METH_VARARGS, nullptr },
        { "close_jaws", reinterpret_cast<PyCFunction>(ClaimedSlipPrinter_CloseJaws), METH_VARARGS, nullptr },
        { "create_job", reinterpret_cast<PyCFunction>(ClaimedSlipPrinter_CreateJob), METH_VARARGS, nullptr },
        { "insert_slip_async", reinterpret_cast<PyCFunction>(ClaimedSlipPrinter_InsertSlipAsync), METH_VARARGS, nullptr },
        { "open_jaws", reinterpret_cast<PyCFunction>(ClaimedSlipPrinter_OpenJaws), METH_VARARGS, nullptr },
        { "remove_slip_async", reinterpret_cast<PyCFunction>(ClaimedSlipPrinter_RemoveSlipAsync), METH_VARARGS, nullptr },
        { "validate_data", reinterpret_cast<PyCFunction>(ClaimedSlipPrinter_ValidateData), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ClaimedSlipPrinter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ClaimedSlipPrinter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClaimedSlipPrinter[] = {
        { "lines_near_end_to_end", reinterpret_cast<getter>(ClaimedSlipPrinter_get_LinesNearEndToEnd), nullptr, nullptr, nullptr },
        { "max_lines", reinterpret_cast<getter>(ClaimedSlipPrinter_get_MaxLines), nullptr, nullptr, nullptr },
        { "page_size", reinterpret_cast<getter>(ClaimedSlipPrinter_get_PageSize), nullptr, nullptr, nullptr },
        { "print_area", reinterpret_cast<getter>(ClaimedSlipPrinter_get_PrintArea), nullptr, nullptr, nullptr },
        { "print_side", reinterpret_cast<getter>(ClaimedSlipPrinter_get_PrintSide), nullptr, nullptr, nullptr },
        { "sideways_max_chars", reinterpret_cast<getter>(ClaimedSlipPrinter_get_SidewaysMaxChars), nullptr, nullptr, nullptr },
        { "sideways_max_lines", reinterpret_cast<getter>(ClaimedSlipPrinter_get_SidewaysMaxLines), nullptr, nullptr, nullptr },
        { "line_spacing", reinterpret_cast<getter>(ClaimedSlipPrinter_get_LineSpacing), reinterpret_cast<setter>(ClaimedSlipPrinter_put_LineSpacing), nullptr, nullptr },
        { "line_height", reinterpret_cast<getter>(ClaimedSlipPrinter_get_LineHeight), reinterpret_cast<setter>(ClaimedSlipPrinter_put_LineHeight), nullptr, nullptr },
        { "is_letter_quality", reinterpret_cast<getter>(ClaimedSlipPrinter_get_IsLetterQuality), reinterpret_cast<setter>(ClaimedSlipPrinter_put_IsLetterQuality), nullptr, nullptr },
        { "color_cartridge", reinterpret_cast<getter>(ClaimedSlipPrinter_get_ColorCartridge), reinterpret_cast<setter>(ClaimedSlipPrinter_put_ColorCartridge), nullptr, nullptr },
        { "characters_per_line", reinterpret_cast<getter>(ClaimedSlipPrinter_get_CharactersPerLine), reinterpret_cast<setter>(ClaimedSlipPrinter_put_CharactersPerLine), nullptr, nullptr },
        { "is_cartridge_empty", reinterpret_cast<getter>(ClaimedSlipPrinter_get_IsCartridgeEmpty), nullptr, nullptr, nullptr },
        { "is_cartridge_removed", reinterpret_cast<getter>(ClaimedSlipPrinter_get_IsCartridgeRemoved), nullptr, nullptr, nullptr },
        { "is_cover_open", reinterpret_cast<getter>(ClaimedSlipPrinter_get_IsCoverOpen), nullptr, nullptr, nullptr },
        { "is_head_cleaning", reinterpret_cast<getter>(ClaimedSlipPrinter_get_IsHeadCleaning), nullptr, nullptr, nullptr },
        { "is_paper_empty", reinterpret_cast<getter>(ClaimedSlipPrinter_get_IsPaperEmpty), nullptr, nullptr, nullptr },
        { "is_paper_near_end", reinterpret_cast<getter>(ClaimedSlipPrinter_get_IsPaperNearEnd), nullptr, nullptr, nullptr },
        { "is_ready_to_print", reinterpret_cast<getter>(ClaimedSlipPrinter_get_IsReadyToPrint), nullptr, nullptr, nullptr },
        { "line_width", reinterpret_cast<getter>(ClaimedSlipPrinter_get_LineWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ClaimedSlipPrinter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ClaimedSlipPrinter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ClaimedSlipPrinter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ClaimedSlipPrinter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ClaimedSlipPrinter) },
        { }
    };

    static PyType_Spec type_spec_ClaimedSlipPrinter = {
        "winrt._winrt_windows_devices_pointofservice.ClaimedSlipPrinter",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ClaimedSlipPrinter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClaimedSlipPrinter};

    // ----- JournalPrintJob class --------------------

    static PyObject* _new_JournalPrintJob(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::JournalPrintJob>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::JournalPrintJob>::type_name);
        return nullptr;
    }

    static void _dealloc_JournalPrintJob(py::wrapper::Windows::Devices::PointOfService::JournalPrintJob* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* JournalPrintJob_ExecuteAsync(py::wrapper::Windows::Devices::PointOfService::JournalPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.JournalPrintJob", L"ExecuteAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ExecuteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* JournalPrintJob_FeedPaperByLine(py::wrapper::Windows::Devices::PointOfService::JournalPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.JournalPrintJob", L"FeedPaperByLine", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.FeedPaperByLine(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* JournalPrintJob_FeedPaperByMapModeUnit(py::wrapper::Windows::Devices::PointOfService::JournalPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.JournalPrintJob", L"FeedPaperByMapModeUnit", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.FeedPaperByMapModeUnit(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* JournalPrintJob_Print(py::wrapper::Windows::Devices::PointOfService::JournalPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.JournalPrintJob", L"Print", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Print(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.JournalPrintJob", L"Print", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterPrintOptions>(args, 1);

                self->obj.Print(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* JournalPrintJob_PrintLine(py::wrapper::Windows::Devices::PointOfService::JournalPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.JournalPrintJob", L"PrintLine", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.PrintLine();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.JournalPrintJob", L"PrintLine", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.PrintLine(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_JournalPrintJob(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::JournalPrintJob>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_JournalPrintJob(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::JournalPrintJob>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_JournalPrintJob[] = {
        { "execute_async", reinterpret_cast<PyCFunction>(JournalPrintJob_ExecuteAsync), METH_VARARGS, nullptr },
        { "feed_paper_by_line", reinterpret_cast<PyCFunction>(JournalPrintJob_FeedPaperByLine), METH_VARARGS, nullptr },
        { "feed_paper_by_map_mode_unit", reinterpret_cast<PyCFunction>(JournalPrintJob_FeedPaperByMapModeUnit), METH_VARARGS, nullptr },
        { "print", reinterpret_cast<PyCFunction>(JournalPrintJob_Print), METH_VARARGS, nullptr },
        { "print_line", reinterpret_cast<PyCFunction>(JournalPrintJob_PrintLine), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_JournalPrintJob, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_JournalPrintJob), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_JournalPrintJob[] = {
        { }
    };

    static PyType_Slot _type_slots_JournalPrintJob[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_JournalPrintJob) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_JournalPrintJob) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_JournalPrintJob) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_JournalPrintJob) },
        { }
    };

    static PyType_Spec type_spec_JournalPrintJob = {
        "winrt._winrt_windows_devices_pointofservice.JournalPrintJob",
        sizeof(py::wrapper::Windows::Devices::PointOfService::JournalPrintJob),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_JournalPrintJob};

    // ----- JournalPrinterCapabilities class --------------------

    static PyObject* _new_JournalPrinterCapabilities(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::JournalPrinterCapabilities>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::JournalPrinterCapabilities>::type_name);
        return nullptr;
    }

    static void _dealloc_JournalPrinterCapabilities(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* JournalPrinterCapabilities_get_CartridgeSensors(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.JournalPrinterCapabilities", L"CartridgeSensors"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CartridgeSensors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_ColorCartridgeCapabilities(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.JournalPrinterCapabilities", L"ColorCartridgeCapabilities"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ColorCartridgeCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsBoldSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.JournalPrinterCapabilities", L"IsBoldSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsBoldSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsDoubleHighDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.JournalPrinterCapabilities", L"IsDoubleHighDoubleWidePrintSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDoubleHighDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsDoubleHighPrintSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.JournalPrinterCapabilities", L"IsDoubleHighPrintSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDoubleHighPrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.JournalPrinterCapabilities", L"IsDoubleWidePrintSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsDualColorSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.JournalPrinterCapabilities", L"IsDualColorSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDualColorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsItalicSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.JournalPrinterCapabilities", L"IsItalicSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsItalicSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsPaperEmptySensorSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.JournalPrinterCapabilities", L"IsPaperEmptySensorSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPaperEmptySensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsPaperNearEndSensorSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.JournalPrinterCapabilities", L"IsPaperNearEndSensorSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPaperNearEndSensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsPrinterPresent(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.JournalPrinterCapabilities", L"IsPrinterPresent"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPrinterPresent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsUnderlineSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.JournalPrinterCapabilities", L"IsUnderlineSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsUnderlineSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_SupportedCharactersPerLine(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.JournalPrinterCapabilities", L"SupportedCharactersPerLine"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedCharactersPerLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsReversePaperFeedByLineSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.JournalPrinterCapabilities", L"IsReversePaperFeedByLineSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsReversePaperFeedByLineSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsReversePaperFeedByMapModeUnitSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.JournalPrinterCapabilities", L"IsReversePaperFeedByMapModeUnitSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsReversePaperFeedByMapModeUnitSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsReverseVideoSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.JournalPrinterCapabilities", L"IsReverseVideoSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsReverseVideoSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsStrikethroughSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.JournalPrinterCapabilities", L"IsStrikethroughSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsStrikethroughSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsSubscriptSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.JournalPrinterCapabilities", L"IsSubscriptSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSubscriptSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* JournalPrinterCapabilities_get_IsSuperscriptSupported(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.JournalPrinterCapabilities", L"IsSuperscriptSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSuperscriptSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_JournalPrinterCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::JournalPrinterCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_JournalPrinterCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::JournalPrinterCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_JournalPrinterCapabilities[] = {
        { "_assign_array_", _assign_array_JournalPrinterCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_JournalPrinterCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_JournalPrinterCapabilities[] = {
        { "cartridge_sensors", reinterpret_cast<getter>(JournalPrinterCapabilities_get_CartridgeSensors), nullptr, nullptr, nullptr },
        { "color_cartridge_capabilities", reinterpret_cast<getter>(JournalPrinterCapabilities_get_ColorCartridgeCapabilities), nullptr, nullptr, nullptr },
        { "is_bold_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsBoldSupported), nullptr, nullptr, nullptr },
        { "is_double_high_double_wide_print_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsDoubleHighDoubleWidePrintSupported), nullptr, nullptr, nullptr },
        { "is_double_high_print_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsDoubleHighPrintSupported), nullptr, nullptr, nullptr },
        { "is_double_wide_print_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsDoubleWidePrintSupported), nullptr, nullptr, nullptr },
        { "is_dual_color_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsDualColorSupported), nullptr, nullptr, nullptr },
        { "is_italic_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsItalicSupported), nullptr, nullptr, nullptr },
        { "is_paper_empty_sensor_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsPaperEmptySensorSupported), nullptr, nullptr, nullptr },
        { "is_paper_near_end_sensor_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsPaperNearEndSensorSupported), nullptr, nullptr, nullptr },
        { "is_printer_present", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsPrinterPresent), nullptr, nullptr, nullptr },
        { "is_underline_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsUnderlineSupported), nullptr, nullptr, nullptr },
        { "supported_characters_per_line", reinterpret_cast<getter>(JournalPrinterCapabilities_get_SupportedCharactersPerLine), nullptr, nullptr, nullptr },
        { "is_reverse_paper_feed_by_line_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsReversePaperFeedByLineSupported), nullptr, nullptr, nullptr },
        { "is_reverse_paper_feed_by_map_mode_unit_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsReversePaperFeedByMapModeUnitSupported), nullptr, nullptr, nullptr },
        { "is_reverse_video_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsReverseVideoSupported), nullptr, nullptr, nullptr },
        { "is_strikethrough_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsStrikethroughSupported), nullptr, nullptr, nullptr },
        { "is_subscript_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsSubscriptSupported), nullptr, nullptr, nullptr },
        { "is_superscript_supported", reinterpret_cast<getter>(JournalPrinterCapabilities_get_IsSuperscriptSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_JournalPrinterCapabilities[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_JournalPrinterCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_JournalPrinterCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_JournalPrinterCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_JournalPrinterCapabilities) },
        { }
    };

    static PyType_Spec type_spec_JournalPrinterCapabilities = {
        "winrt._winrt_windows_devices_pointofservice.JournalPrinterCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::JournalPrinterCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_JournalPrinterCapabilities};

    // ----- LineDisplay class --------------------

    static PyObject* _new_LineDisplay(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::LineDisplay>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::LineDisplay>::type_name);
        return nullptr;
    }

    static void _dealloc_LineDisplay(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LineDisplay_CheckPowerStatusAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplay", L"CheckPowerStatusAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CheckPowerStatusAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplay_ClaimAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplay", L"ClaimAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ClaimAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplay_Close(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplay", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplay_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplay", L"FromIdAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::LineDisplay::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplay_GetDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplay", L"GetDefaultAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::PointOfService::LineDisplay::GetDefaultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplay_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplay", L"GetDeviceSelector", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::PointOfService::LineDisplay::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplay", L"GetDeviceSelector", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosConnectionTypes>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::LineDisplay::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplay_get_Capabilities(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplay", L"Capabilities"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Capabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplay_get_DeviceControlDescription(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplay", L"DeviceControlDescription"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceControlDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplay_get_DeviceControlVersion(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplay", L"DeviceControlVersion"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceControlVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplay_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplay", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplay_get_DeviceServiceVersion(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplay", L"DeviceServiceVersion"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceServiceVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplay_get_PhysicalDeviceDescription(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplay", L"PhysicalDeviceDescription"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PhysicalDeviceDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplay_get_PhysicalDeviceName(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplay", L"PhysicalDeviceName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PhysicalDeviceName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplay_get_StatisticsCategorySelector(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplay", L"StatisticsCategorySelector"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::LineDisplay::StatisticsCategorySelector());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LineDisplay(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::LineDisplay>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LineDisplay(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplay>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_LineDisplay(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_LineDisplay(py::wrapper::Windows::Devices::PointOfService::LineDisplay* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplay[] = {
        { "check_power_status_async", reinterpret_cast<PyCFunction>(LineDisplay_CheckPowerStatusAsync), METH_VARARGS, nullptr },
        { "claim_async", reinterpret_cast<PyCFunction>(LineDisplay_ClaimAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(LineDisplay_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LineDisplay, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LineDisplay), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_LineDisplay), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_LineDisplay), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_LineDisplay[] = {
        { "capabilities", reinterpret_cast<getter>(LineDisplay_get_Capabilities), nullptr, nullptr, nullptr },
        { "device_control_description", reinterpret_cast<getter>(LineDisplay_get_DeviceControlDescription), nullptr, nullptr, nullptr },
        { "device_control_version", reinterpret_cast<getter>(LineDisplay_get_DeviceControlVersion), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(LineDisplay_get_DeviceId), nullptr, nullptr, nullptr },
        { "device_service_version", reinterpret_cast<getter>(LineDisplay_get_DeviceServiceVersion), nullptr, nullptr, nullptr },
        { "physical_device_description", reinterpret_cast<getter>(LineDisplay_get_PhysicalDeviceDescription), nullptr, nullptr, nullptr },
        { "physical_device_name", reinterpret_cast<getter>(LineDisplay_get_PhysicalDeviceName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LineDisplay[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LineDisplay) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LineDisplay) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LineDisplay) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LineDisplay) },
        { }
    };

    static PyType_Spec type_spec_LineDisplay = {
        "winrt._winrt_windows_devices_pointofservice.LineDisplay",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplay),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplay};

    static PyGetSetDef getset_LineDisplay_Static[] = {
        { "statistics_category_selector", reinterpret_cast<getter>(LineDisplay_get_StatisticsCategorySelector), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_LineDisplay_Static[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(LineDisplay_FromIdAsync), METH_VARARGS, nullptr },
        { "get_default_async", reinterpret_cast<PyCFunction>(LineDisplay_GetDefaultAsync), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(LineDisplay_GetDeviceSelector), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_LineDisplay_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_LineDisplay_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_LineDisplay_Static) },
        { }
    };

    static PyType_Spec type_spec_LineDisplay_Static =
    {
        "winrt._winrt_windows_devices_pointofservice.LineDisplay_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_LineDisplay_Static
    };

    // ----- LineDisplayAttributes class --------------------

    static PyObject* _new_LineDisplayAttributes(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::LineDisplayAttributes>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::LineDisplayAttributes>::type_name);
        return nullptr;
    }

    static void _dealloc_LineDisplayAttributes(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LineDisplayAttributes_get_ScreenSizeInCharacters(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayAttributes", L"ScreenSizeInCharacters"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ScreenSizeInCharacters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayAttributes_put_ScreenSizeInCharacters(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayAttributes", L"ScreenSizeInCharacters"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(arg);

            self->obj.ScreenSizeInCharacters(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayAttributes_get_IsPowerNotifyEnabled(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayAttributes", L"IsPowerNotifyEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPowerNotifyEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayAttributes_put_IsPowerNotifyEnabled(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayAttributes", L"IsPowerNotifyEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsPowerNotifyEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayAttributes_get_IsCharacterSetMappingEnabled(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayAttributes", L"IsCharacterSetMappingEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsCharacterSetMappingEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayAttributes_put_IsCharacterSetMappingEnabled(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayAttributes", L"IsCharacterSetMappingEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCharacterSetMappingEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayAttributes_get_CurrentWindow(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayAttributes", L"CurrentWindow"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CurrentWindow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayAttributes_put_CurrentWindow(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayAttributes", L"CurrentWindow"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayWindow>(arg);

            self->obj.CurrentWindow(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayAttributes_get_CharacterSet(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayAttributes", L"CharacterSet"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CharacterSet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayAttributes_put_CharacterSet(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayAttributes", L"CharacterSet"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.CharacterSet(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayAttributes_get_Brightness(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayAttributes", L"Brightness"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Brightness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayAttributes_put_Brightness(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayAttributes", L"Brightness"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Brightness(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayAttributes_get_BlinkRate(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayAttributes", L"BlinkRate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BlinkRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayAttributes_put_BlinkRate(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayAttributes", L"BlinkRate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.BlinkRate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_LineDisplayAttributes(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::LineDisplayAttributes>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LineDisplayAttributes(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayAttributes>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayAttributes[] = {
        { "_assign_array_", _assign_array_LineDisplayAttributes, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LineDisplayAttributes), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LineDisplayAttributes[] = {
        { "screen_size_in_characters", reinterpret_cast<getter>(LineDisplayAttributes_get_ScreenSizeInCharacters), reinterpret_cast<setter>(LineDisplayAttributes_put_ScreenSizeInCharacters), nullptr, nullptr },
        { "is_power_notify_enabled", reinterpret_cast<getter>(LineDisplayAttributes_get_IsPowerNotifyEnabled), reinterpret_cast<setter>(LineDisplayAttributes_put_IsPowerNotifyEnabled), nullptr, nullptr },
        { "is_character_set_mapping_enabled", reinterpret_cast<getter>(LineDisplayAttributes_get_IsCharacterSetMappingEnabled), reinterpret_cast<setter>(LineDisplayAttributes_put_IsCharacterSetMappingEnabled), nullptr, nullptr },
        { "current_window", reinterpret_cast<getter>(LineDisplayAttributes_get_CurrentWindow), reinterpret_cast<setter>(LineDisplayAttributes_put_CurrentWindow), nullptr, nullptr },
        { "character_set", reinterpret_cast<getter>(LineDisplayAttributes_get_CharacterSet), reinterpret_cast<setter>(LineDisplayAttributes_put_CharacterSet), nullptr, nullptr },
        { "brightness", reinterpret_cast<getter>(LineDisplayAttributes_get_Brightness), reinterpret_cast<setter>(LineDisplayAttributes_put_Brightness), nullptr, nullptr },
        { "blink_rate", reinterpret_cast<getter>(LineDisplayAttributes_get_BlinkRate), reinterpret_cast<setter>(LineDisplayAttributes_put_BlinkRate), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LineDisplayAttributes[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LineDisplayAttributes) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LineDisplayAttributes) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LineDisplayAttributes) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LineDisplayAttributes) },
        { }
    };

    static PyType_Spec type_spec_LineDisplayAttributes = {
        "winrt._winrt_windows_devices_pointofservice.LineDisplayAttributes",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayAttributes),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayAttributes};

    // ----- LineDisplayCapabilities class --------------------

    static PyObject* _new_LineDisplayCapabilities(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::LineDisplayCapabilities>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::LineDisplayCapabilities>::type_name);
        return nullptr;
    }

    static void _dealloc_LineDisplayCapabilities(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LineDisplayCapabilities_get_CanBlink(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCapabilities", L"CanBlink"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanBlink());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_CanChangeBlinkRate(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCapabilities", L"CanChangeBlinkRate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanChangeBlinkRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_CanChangeScreenSize(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCapabilities", L"CanChangeScreenSize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanChangeScreenSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_CanDisplayBitmaps(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCapabilities", L"CanDisplayBitmaps"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanDisplayBitmaps());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_CanDisplayCustomGlyphs(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCapabilities", L"CanDisplayCustomGlyphs"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanDisplayCustomGlyphs());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_CanMapCharacterSets(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCapabilities", L"CanMapCharacterSets"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanMapCharacterSets());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_CanReadCharacterAtCursor(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCapabilities", L"CanReadCharacterAtCursor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanReadCharacterAtCursor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_CanReverse(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCapabilities", L"CanReverse"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanReverse());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_IsBrightnessSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCapabilities", L"IsBrightnessSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsBrightnessSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_IsCursorSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCapabilities", L"IsCursorSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsCursorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_IsHorizontalMarqueeSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCapabilities", L"IsHorizontalMarqueeSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsHorizontalMarqueeSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_IsInterCharacterWaitSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCapabilities", L"IsInterCharacterWaitSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsInterCharacterWaitSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_IsStatisticsReportingSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCapabilities", L"IsStatisticsReportingSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsStatisticsReportingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_IsStatisticsUpdatingSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCapabilities", L"IsStatisticsUpdatingSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsStatisticsUpdatingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_IsVerticalMarqueeSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCapabilities", L"IsVerticalMarqueeSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsVerticalMarqueeSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_PowerReportingType(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCapabilities", L"PowerReportingType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PowerReportingType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_SupportedDescriptors(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCapabilities", L"SupportedDescriptors"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedDescriptors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCapabilities_get_SupportedWindows(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCapabilities", L"SupportedWindows"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedWindows());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LineDisplayCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::LineDisplayCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LineDisplayCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayCapabilities[] = {
        { "_assign_array_", _assign_array_LineDisplayCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LineDisplayCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LineDisplayCapabilities[] = {
        { "can_blink", reinterpret_cast<getter>(LineDisplayCapabilities_get_CanBlink), nullptr, nullptr, nullptr },
        { "can_change_blink_rate", reinterpret_cast<getter>(LineDisplayCapabilities_get_CanChangeBlinkRate), nullptr, nullptr, nullptr },
        { "can_change_screen_size", reinterpret_cast<getter>(LineDisplayCapabilities_get_CanChangeScreenSize), nullptr, nullptr, nullptr },
        { "can_display_bitmaps", reinterpret_cast<getter>(LineDisplayCapabilities_get_CanDisplayBitmaps), nullptr, nullptr, nullptr },
        { "can_display_custom_glyphs", reinterpret_cast<getter>(LineDisplayCapabilities_get_CanDisplayCustomGlyphs), nullptr, nullptr, nullptr },
        { "can_map_character_sets", reinterpret_cast<getter>(LineDisplayCapabilities_get_CanMapCharacterSets), nullptr, nullptr, nullptr },
        { "can_read_character_at_cursor", reinterpret_cast<getter>(LineDisplayCapabilities_get_CanReadCharacterAtCursor), nullptr, nullptr, nullptr },
        { "can_reverse", reinterpret_cast<getter>(LineDisplayCapabilities_get_CanReverse), nullptr, nullptr, nullptr },
        { "is_brightness_supported", reinterpret_cast<getter>(LineDisplayCapabilities_get_IsBrightnessSupported), nullptr, nullptr, nullptr },
        { "is_cursor_supported", reinterpret_cast<getter>(LineDisplayCapabilities_get_IsCursorSupported), nullptr, nullptr, nullptr },
        { "is_horizontal_marquee_supported", reinterpret_cast<getter>(LineDisplayCapabilities_get_IsHorizontalMarqueeSupported), nullptr, nullptr, nullptr },
        { "is_inter_character_wait_supported", reinterpret_cast<getter>(LineDisplayCapabilities_get_IsInterCharacterWaitSupported), nullptr, nullptr, nullptr },
        { "is_statistics_reporting_supported", reinterpret_cast<getter>(LineDisplayCapabilities_get_IsStatisticsReportingSupported), nullptr, nullptr, nullptr },
        { "is_statistics_updating_supported", reinterpret_cast<getter>(LineDisplayCapabilities_get_IsStatisticsUpdatingSupported), nullptr, nullptr, nullptr },
        { "is_vertical_marquee_supported", reinterpret_cast<getter>(LineDisplayCapabilities_get_IsVerticalMarqueeSupported), nullptr, nullptr, nullptr },
        { "power_reporting_type", reinterpret_cast<getter>(LineDisplayCapabilities_get_PowerReportingType), nullptr, nullptr, nullptr },
        { "supported_descriptors", reinterpret_cast<getter>(LineDisplayCapabilities_get_SupportedDescriptors), nullptr, nullptr, nullptr },
        { "supported_windows", reinterpret_cast<getter>(LineDisplayCapabilities_get_SupportedWindows), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LineDisplayCapabilities[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LineDisplayCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LineDisplayCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LineDisplayCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LineDisplayCapabilities) },
        { }
    };

    static PyType_Spec type_spec_LineDisplayCapabilities = {
        "winrt._winrt_windows_devices_pointofservice.LineDisplayCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayCapabilities};

    // ----- LineDisplayCursor class --------------------

    static PyObject* _new_LineDisplayCursor(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::LineDisplayCursor>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::LineDisplayCursor>::type_name);
        return nullptr;
    }

    static void _dealloc_LineDisplayCursor(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LineDisplayCursor_GetAttributes(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayCursor", L"GetAttributes", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetAttributes());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayCursor_TryUpdateAttributesAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayCursor", L"TryUpdateAttributesAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayCursorAttributes>(args, 0);

                return py::convert(self->obj.TryUpdateAttributesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayCursor_get_CanCustomize(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCursor", L"CanCustomize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanCustomize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCursor_get_IsBlinkSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCursor", L"IsBlinkSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsBlinkSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCursor_get_IsBlockSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCursor", L"IsBlockSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsBlockSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCursor_get_IsHalfBlockSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCursor", L"IsHalfBlockSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsHalfBlockSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCursor_get_IsOtherSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCursor", L"IsOtherSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsOtherSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCursor_get_IsReverseSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCursor", L"IsReverseSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsReverseSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCursor_get_IsUnderlineSupported(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCursor", L"IsUnderlineSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsUnderlineSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LineDisplayCursor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::LineDisplayCursor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LineDisplayCursor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayCursor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayCursor[] = {
        { "get_attributes", reinterpret_cast<PyCFunction>(LineDisplayCursor_GetAttributes), METH_VARARGS, nullptr },
        { "try_update_attributes_async", reinterpret_cast<PyCFunction>(LineDisplayCursor_TryUpdateAttributesAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LineDisplayCursor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LineDisplayCursor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LineDisplayCursor[] = {
        { "can_customize", reinterpret_cast<getter>(LineDisplayCursor_get_CanCustomize), nullptr, nullptr, nullptr },
        { "is_blink_supported", reinterpret_cast<getter>(LineDisplayCursor_get_IsBlinkSupported), nullptr, nullptr, nullptr },
        { "is_block_supported", reinterpret_cast<getter>(LineDisplayCursor_get_IsBlockSupported), nullptr, nullptr, nullptr },
        { "is_half_block_supported", reinterpret_cast<getter>(LineDisplayCursor_get_IsHalfBlockSupported), nullptr, nullptr, nullptr },
        { "is_other_supported", reinterpret_cast<getter>(LineDisplayCursor_get_IsOtherSupported), nullptr, nullptr, nullptr },
        { "is_reverse_supported", reinterpret_cast<getter>(LineDisplayCursor_get_IsReverseSupported), nullptr, nullptr, nullptr },
        { "is_underline_supported", reinterpret_cast<getter>(LineDisplayCursor_get_IsUnderlineSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LineDisplayCursor[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LineDisplayCursor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LineDisplayCursor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LineDisplayCursor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LineDisplayCursor) },
        { }
    };

    static PyType_Spec type_spec_LineDisplayCursor = {
        "winrt._winrt_windows_devices_pointofservice.LineDisplayCursor",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayCursor};

    // ----- LineDisplayCursorAttributes class --------------------

    static PyObject* _new_LineDisplayCursorAttributes(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::LineDisplayCursorAttributes>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::LineDisplayCursorAttributes>::type_name);
        return nullptr;
    }

    static void _dealloc_LineDisplayCursorAttributes(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LineDisplayCursorAttributes_get_Position(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCursorAttributes", L"Position"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayCursorAttributes_put_Position(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCursorAttributes", L"Position"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayCursorAttributes_get_IsBlinkEnabled(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCursorAttributes", L"IsBlinkEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsBlinkEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayCursorAttributes_put_IsBlinkEnabled(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCursorAttributes", L"IsBlinkEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsBlinkEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayCursorAttributes_get_IsAutoAdvanceEnabled(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCursorAttributes", L"IsAutoAdvanceEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsAutoAdvanceEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayCursorAttributes_put_IsAutoAdvanceEnabled(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCursorAttributes", L"IsAutoAdvanceEnabled"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsAutoAdvanceEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayCursorAttributes_get_CursorType(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCursorAttributes", L"CursorType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CursorType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayCursorAttributes_put_CursorType(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCursorAttributes", L"CursorType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayCursorType>(arg);

            self->obj.CursorType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_LineDisplayCursorAttributes(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::LineDisplayCursorAttributes>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LineDisplayCursorAttributes(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayCursorAttributes>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayCursorAttributes[] = {
        { "_assign_array_", _assign_array_LineDisplayCursorAttributes, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LineDisplayCursorAttributes), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LineDisplayCursorAttributes[] = {
        { "position", reinterpret_cast<getter>(LineDisplayCursorAttributes_get_Position), reinterpret_cast<setter>(LineDisplayCursorAttributes_put_Position), nullptr, nullptr },
        { "is_blink_enabled", reinterpret_cast<getter>(LineDisplayCursorAttributes_get_IsBlinkEnabled), reinterpret_cast<setter>(LineDisplayCursorAttributes_put_IsBlinkEnabled), nullptr, nullptr },
        { "is_auto_advance_enabled", reinterpret_cast<getter>(LineDisplayCursorAttributes_get_IsAutoAdvanceEnabled), reinterpret_cast<setter>(LineDisplayCursorAttributes_put_IsAutoAdvanceEnabled), nullptr, nullptr },
        { "cursor_type", reinterpret_cast<getter>(LineDisplayCursorAttributes_get_CursorType), reinterpret_cast<setter>(LineDisplayCursorAttributes_put_CursorType), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LineDisplayCursorAttributes[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LineDisplayCursorAttributes) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LineDisplayCursorAttributes) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LineDisplayCursorAttributes) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LineDisplayCursorAttributes) },
        { }
    };

    static PyType_Spec type_spec_LineDisplayCursorAttributes = {
        "winrt._winrt_windows_devices_pointofservice.LineDisplayCursorAttributes",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayCursorAttributes),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayCursorAttributes};

    // ----- LineDisplayCustomGlyphs class --------------------

    static PyObject* _new_LineDisplayCustomGlyphs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::LineDisplayCustomGlyphs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::LineDisplayCustomGlyphs>::type_name);
        return nullptr;
    }

    static void _dealloc_LineDisplayCustomGlyphs(py::wrapper::Windows::Devices::PointOfService::LineDisplayCustomGlyphs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LineDisplayCustomGlyphs_TryRedefineAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayCustomGlyphs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayCustomGlyphs", L"TryRedefineAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(self->obj.TryRedefineAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayCustomGlyphs_get_SizeInPixels(py::wrapper::Windows::Devices::PointOfService::LineDisplayCustomGlyphs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCustomGlyphs", L"SizeInPixels"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SizeInPixels());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayCustomGlyphs_get_SupportedGlyphCodes(py::wrapper::Windows::Devices::PointOfService::LineDisplayCustomGlyphs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayCustomGlyphs", L"SupportedGlyphCodes"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedGlyphCodes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LineDisplayCustomGlyphs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::LineDisplayCustomGlyphs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LineDisplayCustomGlyphs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayCustomGlyphs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayCustomGlyphs[] = {
        { "try_redefine_async", reinterpret_cast<PyCFunction>(LineDisplayCustomGlyphs_TryRedefineAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LineDisplayCustomGlyphs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LineDisplayCustomGlyphs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LineDisplayCustomGlyphs[] = {
        { "size_in_pixels", reinterpret_cast<getter>(LineDisplayCustomGlyphs_get_SizeInPixels), nullptr, nullptr, nullptr },
        { "supported_glyph_codes", reinterpret_cast<getter>(LineDisplayCustomGlyphs_get_SupportedGlyphCodes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LineDisplayCustomGlyphs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LineDisplayCustomGlyphs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LineDisplayCustomGlyphs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LineDisplayCustomGlyphs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LineDisplayCustomGlyphs) },
        { }
    };

    static PyType_Spec type_spec_LineDisplayCustomGlyphs = {
        "winrt._winrt_windows_devices_pointofservice.LineDisplayCustomGlyphs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayCustomGlyphs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayCustomGlyphs};

    // ----- LineDisplayMarquee class --------------------

    static PyObject* _new_LineDisplayMarquee(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::LineDisplayMarquee>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::LineDisplayMarquee>::type_name);
        return nullptr;
    }

    static void _dealloc_LineDisplayMarquee(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LineDisplayMarquee_TryStartScrollingAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayMarquee", L"TryStartScrollingAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayScrollDirection>(args, 0);

                return py::convert(self->obj.TryStartScrollingAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayMarquee_TryStopScrollingAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayMarquee", L"TryStopScrollingAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TryStopScrollingAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayMarquee_get_ScrollWaitInterval(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayMarquee", L"ScrollWaitInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ScrollWaitInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayMarquee_put_ScrollWaitInterval(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayMarquee", L"ScrollWaitInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.ScrollWaitInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayMarquee_get_RepeatWaitInterval(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayMarquee", L"RepeatWaitInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RepeatWaitInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayMarquee_put_RepeatWaitInterval(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayMarquee", L"RepeatWaitInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.RepeatWaitInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayMarquee_get_Format(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayMarquee", L"Format"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Format());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayMarquee_put_Format(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayMarquee", L"Format"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayMarqueeFormat>(arg);

            self->obj.Format(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_LineDisplayMarquee(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::LineDisplayMarquee>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LineDisplayMarquee(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayMarquee>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayMarquee[] = {
        { "try_start_scrolling_async", reinterpret_cast<PyCFunction>(LineDisplayMarquee_TryStartScrollingAsync), METH_VARARGS, nullptr },
        { "try_stop_scrolling_async", reinterpret_cast<PyCFunction>(LineDisplayMarquee_TryStopScrollingAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LineDisplayMarquee, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LineDisplayMarquee), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LineDisplayMarquee[] = {
        { "scroll_wait_interval", reinterpret_cast<getter>(LineDisplayMarquee_get_ScrollWaitInterval), reinterpret_cast<setter>(LineDisplayMarquee_put_ScrollWaitInterval), nullptr, nullptr },
        { "repeat_wait_interval", reinterpret_cast<getter>(LineDisplayMarquee_get_RepeatWaitInterval), reinterpret_cast<setter>(LineDisplayMarquee_put_RepeatWaitInterval), nullptr, nullptr },
        { "format", reinterpret_cast<getter>(LineDisplayMarquee_get_Format), reinterpret_cast<setter>(LineDisplayMarquee_put_Format), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LineDisplayMarquee[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LineDisplayMarquee) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LineDisplayMarquee) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LineDisplayMarquee) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LineDisplayMarquee) },
        { }
    };

    static PyType_Spec type_spec_LineDisplayMarquee = {
        "winrt._winrt_windows_devices_pointofservice.LineDisplayMarquee",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayMarquee),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayMarquee};

    // ----- LineDisplayStatisticsCategorySelector class --------------------

    static PyObject* _new_LineDisplayStatisticsCategorySelector(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::LineDisplayStatisticsCategorySelector>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::LineDisplayStatisticsCategorySelector>::type_name);
        return nullptr;
    }

    static void _dealloc_LineDisplayStatisticsCategorySelector(py::wrapper::Windows::Devices::PointOfService::LineDisplayStatisticsCategorySelector* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LineDisplayStatisticsCategorySelector_get_AllStatistics(py::wrapper::Windows::Devices::PointOfService::LineDisplayStatisticsCategorySelector* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayStatisticsCategorySelector", L"AllStatistics"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AllStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayStatisticsCategorySelector_get_ManufacturerStatistics(py::wrapper::Windows::Devices::PointOfService::LineDisplayStatisticsCategorySelector* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayStatisticsCategorySelector", L"ManufacturerStatistics"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ManufacturerStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayStatisticsCategorySelector_get_UnifiedPosStatistics(py::wrapper::Windows::Devices::PointOfService::LineDisplayStatisticsCategorySelector* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayStatisticsCategorySelector", L"UnifiedPosStatistics"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.UnifiedPosStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LineDisplayStatisticsCategorySelector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::LineDisplayStatisticsCategorySelector>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LineDisplayStatisticsCategorySelector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayStatisticsCategorySelector>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayStatisticsCategorySelector[] = {
        { "_assign_array_", _assign_array_LineDisplayStatisticsCategorySelector, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LineDisplayStatisticsCategorySelector), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LineDisplayStatisticsCategorySelector[] = {
        { "all_statistics", reinterpret_cast<getter>(LineDisplayStatisticsCategorySelector_get_AllStatistics), nullptr, nullptr, nullptr },
        { "manufacturer_statistics", reinterpret_cast<getter>(LineDisplayStatisticsCategorySelector_get_ManufacturerStatistics), nullptr, nullptr, nullptr },
        { "unified_pos_statistics", reinterpret_cast<getter>(LineDisplayStatisticsCategorySelector_get_UnifiedPosStatistics), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LineDisplayStatisticsCategorySelector[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LineDisplayStatisticsCategorySelector) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LineDisplayStatisticsCategorySelector) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LineDisplayStatisticsCategorySelector) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LineDisplayStatisticsCategorySelector) },
        { }
    };

    static PyType_Spec type_spec_LineDisplayStatisticsCategorySelector = {
        "winrt._winrt_windows_devices_pointofservice.LineDisplayStatisticsCategorySelector",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayStatisticsCategorySelector),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayStatisticsCategorySelector};

    // ----- LineDisplayStatusUpdatedEventArgs class --------------------

    static PyObject* _new_LineDisplayStatusUpdatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::LineDisplayStatusUpdatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::LineDisplayStatusUpdatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_LineDisplayStatusUpdatedEventArgs(py::wrapper::Windows::Devices::PointOfService::LineDisplayStatusUpdatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LineDisplayStatusUpdatedEventArgs_get_Status(py::wrapper::Windows::Devices::PointOfService::LineDisplayStatusUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayStatusUpdatedEventArgs", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LineDisplayStatusUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::LineDisplayStatusUpdatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LineDisplayStatusUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayStatusUpdatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayStatusUpdatedEventArgs[] = {
        { "_assign_array_", _assign_array_LineDisplayStatusUpdatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LineDisplayStatusUpdatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LineDisplayStatusUpdatedEventArgs[] = {
        { "status", reinterpret_cast<getter>(LineDisplayStatusUpdatedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LineDisplayStatusUpdatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LineDisplayStatusUpdatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LineDisplayStatusUpdatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LineDisplayStatusUpdatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LineDisplayStatusUpdatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_LineDisplayStatusUpdatedEventArgs = {
        "winrt._winrt_windows_devices_pointofservice.LineDisplayStatusUpdatedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayStatusUpdatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayStatusUpdatedEventArgs};

    // ----- LineDisplayStoredBitmap class --------------------

    static PyObject* _new_LineDisplayStoredBitmap(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::LineDisplayStoredBitmap>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::LineDisplayStoredBitmap>::type_name);
        return nullptr;
    }

    static void _dealloc_LineDisplayStoredBitmap(py::wrapper::Windows::Devices::PointOfService::LineDisplayStoredBitmap* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LineDisplayStoredBitmap_TryDeleteAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayStoredBitmap* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayStoredBitmap", L"TryDeleteAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TryDeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayStoredBitmap_get_EscapeSequence(py::wrapper::Windows::Devices::PointOfService::LineDisplayStoredBitmap* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayStoredBitmap", L"EscapeSequence"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EscapeSequence());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LineDisplayStoredBitmap(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::LineDisplayStoredBitmap>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LineDisplayStoredBitmap(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayStoredBitmap>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayStoredBitmap[] = {
        { "try_delete_async", reinterpret_cast<PyCFunction>(LineDisplayStoredBitmap_TryDeleteAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LineDisplayStoredBitmap, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LineDisplayStoredBitmap), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LineDisplayStoredBitmap[] = {
        { "escape_sequence", reinterpret_cast<getter>(LineDisplayStoredBitmap_get_EscapeSequence), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LineDisplayStoredBitmap[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LineDisplayStoredBitmap) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LineDisplayStoredBitmap) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LineDisplayStoredBitmap) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LineDisplayStoredBitmap) },
        { }
    };

    static PyType_Spec type_spec_LineDisplayStoredBitmap = {
        "winrt._winrt_windows_devices_pointofservice.LineDisplayStoredBitmap",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayStoredBitmap),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayStoredBitmap};

    // ----- LineDisplayWindow class --------------------

    static PyObject* _new_LineDisplayWindow(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::LineDisplayWindow>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::LineDisplayWindow>::type_name);
        return nullptr;
    }

    static void _dealloc_LineDisplayWindow(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LineDisplayWindow_Close(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayWindow", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_ReadCharacterAtCursorAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayWindow", L"ReadCharacterAtCursorAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ReadCharacterAtCursorAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_TryClearTextAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayWindow", L"TryClearTextAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TryClearTextAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_TryDisplayStorageFileBitmapAtCursorAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayWindow", L"TryDisplayStorageFileBitmapAtCursorAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);

                return py::convert(self->obj.TryDisplayStorageFileBitmapAtCursorAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayWindow", L"TryDisplayStorageFileBitmapAtCursorAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayHorizontalAlignment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayVerticalAlignment>(args, 2);

                return py::convert(self->obj.TryDisplayStorageFileBitmapAtCursorAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayWindow", L"TryDisplayStorageFileBitmapAtCursorAsync", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayHorizontalAlignment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayVerticalAlignment>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                return py::convert(self->obj.TryDisplayStorageFileBitmapAtCursorAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_TryDisplayStorageFileBitmapAtPointAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayWindow", L"TryDisplayStorageFileBitmapAtPointAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);

                return py::convert(self->obj.TryDisplayStorageFileBitmapAtPointAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayWindow", L"TryDisplayStorageFileBitmapAtPointAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);

                return py::convert(self->obj.TryDisplayStorageFileBitmapAtPointAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_TryDisplayStoredBitmapAtCursorAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayWindow", L"TryDisplayStoredBitmapAtCursorAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayStoredBitmap>(args, 0);

                return py::convert(self->obj.TryDisplayStoredBitmapAtCursorAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_TryDisplayTextAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayWindow", L"TryDisplayTextAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryDisplayTextAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayWindow", L"TryDisplayTextAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayTextAttribute>(args, 1);

                return py::convert(self->obj.TryDisplayTextAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayWindow", L"TryDisplayTextAsync", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayTextAttribute>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Point>(args, 2);

                return py::convert(self->obj.TryDisplayTextAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_TryRefreshAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayWindow", L"TryRefreshAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TryRefreshAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_TryScrollTextAsync(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.LineDisplayWindow", L"TryScrollTextAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::LineDisplayScrollDirection>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.TryScrollTextAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_get_InterCharacterWaitInterval(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayWindow", L"InterCharacterWaitInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InterCharacterWaitInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LineDisplayWindow_put_InterCharacterWaitInterval(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayWindow", L"InterCharacterWaitInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.InterCharacterWaitInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LineDisplayWindow_get_SizeInCharacters(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayWindow", L"SizeInCharacters"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SizeInCharacters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_get_Cursor(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayWindow", L"Cursor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Cursor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LineDisplayWindow_get_Marquee(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.LineDisplayWindow", L"Marquee"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Marquee());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LineDisplayWindow(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::LineDisplayWindow>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LineDisplayWindow(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::LineDisplayWindow>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_LineDisplayWindow(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_LineDisplayWindow(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LineDisplayWindow[] = {
        { "close", reinterpret_cast<PyCFunction>(LineDisplayWindow_Close), METH_VARARGS, nullptr },
        { "read_character_at_cursor_async", reinterpret_cast<PyCFunction>(LineDisplayWindow_ReadCharacterAtCursorAsync), METH_VARARGS, nullptr },
        { "try_clear_text_async", reinterpret_cast<PyCFunction>(LineDisplayWindow_TryClearTextAsync), METH_VARARGS, nullptr },
        { "try_display_storage_file_bitmap_at_cursor_async", reinterpret_cast<PyCFunction>(LineDisplayWindow_TryDisplayStorageFileBitmapAtCursorAsync), METH_VARARGS, nullptr },
        { "try_display_storage_file_bitmap_at_point_async", reinterpret_cast<PyCFunction>(LineDisplayWindow_TryDisplayStorageFileBitmapAtPointAsync), METH_VARARGS, nullptr },
        { "try_display_stored_bitmap_at_cursor_async", reinterpret_cast<PyCFunction>(LineDisplayWindow_TryDisplayStoredBitmapAtCursorAsync), METH_VARARGS, nullptr },
        { "try_display_text_async", reinterpret_cast<PyCFunction>(LineDisplayWindow_TryDisplayTextAsync), METH_VARARGS, nullptr },
        { "try_refresh_async", reinterpret_cast<PyCFunction>(LineDisplayWindow_TryRefreshAsync), METH_VARARGS, nullptr },
        { "try_scroll_text_async", reinterpret_cast<PyCFunction>(LineDisplayWindow_TryScrollTextAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LineDisplayWindow, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LineDisplayWindow), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_LineDisplayWindow), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_LineDisplayWindow), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_LineDisplayWindow[] = {
        { "inter_character_wait_interval", reinterpret_cast<getter>(LineDisplayWindow_get_InterCharacterWaitInterval), reinterpret_cast<setter>(LineDisplayWindow_put_InterCharacterWaitInterval), nullptr, nullptr },
        { "size_in_characters", reinterpret_cast<getter>(LineDisplayWindow_get_SizeInCharacters), nullptr, nullptr, nullptr },
        { "cursor", reinterpret_cast<getter>(LineDisplayWindow_get_Cursor), nullptr, nullptr, nullptr },
        { "marquee", reinterpret_cast<getter>(LineDisplayWindow_get_Marquee), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LineDisplayWindow[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LineDisplayWindow) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LineDisplayWindow) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LineDisplayWindow) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LineDisplayWindow) },
        { }
    };

    static PyType_Spec type_spec_LineDisplayWindow = {
        "winrt._winrt_windows_devices_pointofservice.LineDisplayWindow",
        sizeof(py::wrapper::Windows::Devices::PointOfService::LineDisplayWindow),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LineDisplayWindow};

    // ----- MagneticStripeReader class --------------------

    static PyObject* _new_MagneticStripeReader(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::MagneticStripeReader>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::MagneticStripeReader>::type_name);
        return nullptr;
    }

    static void _dealloc_MagneticStripeReader(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MagneticStripeReader_CheckHealthAsync(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.MagneticStripeReader", L"CheckHealthAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::UnifiedPosHealthCheckLevel>(args, 0);

                return py::convert(self->obj.CheckHealthAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_ClaimReaderAsync(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.MagneticStripeReader", L"ClaimReaderAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ClaimReaderAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_Close(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.MagneticStripeReader", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.MagneticStripeReader", L"FromIdAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReader::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_GetDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.MagneticStripeReader", L"GetDefaultAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReader::GetDefaultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.MagneticStripeReader", L"GetDeviceSelector", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReader::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.MagneticStripeReader", L"GetDeviceSelector", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosConnectionTypes>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReader::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_GetErrorReportingType(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.MagneticStripeReader", L"GetErrorReportingType", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetErrorReportingType());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_RetrieveStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.MagneticStripeReader", L"RetrieveStatisticsAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.RetrieveStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_get_Capabilities(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReader", L"Capabilities"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Capabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_get_DeviceAuthenticationProtocol(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReader", L"DeviceAuthenticationProtocol"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceAuthenticationProtocol());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReader", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_get_SupportedCardTypes(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReader", L"SupportedCardTypes"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedCardTypes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_add_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.MagneticStripeReader", L"StatusUpdated"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::MagneticStripeReader, winrt::Windows::Devices::PointOfService::MagneticStripeReaderStatusUpdatedEventArgs>>(arg);

            return py::convert(self->obj.StatusUpdated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReader_remove_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.MagneticStripeReader", L"StatusUpdated"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StatusUpdated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MagneticStripeReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::MagneticStripeReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MagneticStripeReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::MagneticStripeReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MagneticStripeReader(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_MagneticStripeReader(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReader[] = {
        { "check_health_async", reinterpret_cast<PyCFunction>(MagneticStripeReader_CheckHealthAsync), METH_VARARGS, nullptr },
        { "claim_reader_async", reinterpret_cast<PyCFunction>(MagneticStripeReader_ClaimReaderAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(MagneticStripeReader_Close), METH_VARARGS, nullptr },
        { "get_error_reporting_type", reinterpret_cast<PyCFunction>(MagneticStripeReader_GetErrorReportingType), METH_VARARGS, nullptr },
        { "retrieve_statistics_async", reinterpret_cast<PyCFunction>(MagneticStripeReader_RetrieveStatisticsAsync), METH_VARARGS, nullptr },
        { "add_status_updated", reinterpret_cast<PyCFunction>(MagneticStripeReader_add_StatusUpdated), METH_O, nullptr },
        { "remove_status_updated", reinterpret_cast<PyCFunction>(MagneticStripeReader_remove_StatusUpdated), METH_O, nullptr },
        { "_assign_array_", _assign_array_MagneticStripeReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MagneticStripeReader), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MagneticStripeReader), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_MagneticStripeReader), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MagneticStripeReader[] = {
        { "capabilities", reinterpret_cast<getter>(MagneticStripeReader_get_Capabilities), nullptr, nullptr, nullptr },
        { "device_authentication_protocol", reinterpret_cast<getter>(MagneticStripeReader_get_DeviceAuthenticationProtocol), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(MagneticStripeReader_get_DeviceId), nullptr, nullptr, nullptr },
        { "supported_card_types", reinterpret_cast<getter>(MagneticStripeReader_get_SupportedCardTypes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MagneticStripeReader[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MagneticStripeReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MagneticStripeReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MagneticStripeReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MagneticStripeReader) },
        { }
    };

    static PyType_Spec type_spec_MagneticStripeReader = {
        "winrt._winrt_windows_devices_pointofservice.MagneticStripeReader",
        sizeof(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReader};

    static PyGetSetDef getset_MagneticStripeReader_Static[] = {
        { }
    };

    static PyMethodDef methods_MagneticStripeReader_Static[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(MagneticStripeReader_FromIdAsync), METH_VARARGS, nullptr },
        { "get_default_async", reinterpret_cast<PyCFunction>(MagneticStripeReader_GetDefaultAsync), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(MagneticStripeReader_GetDeviceSelector), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_MagneticStripeReader_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MagneticStripeReader_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MagneticStripeReader_Static) },
        { }
    };

    static PyType_Spec type_spec_MagneticStripeReader_Static =
    {
        "winrt._winrt_windows_devices_pointofservice.MagneticStripeReader_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MagneticStripeReader_Static
    };

    // ----- MagneticStripeReaderAamvaCardDataReceivedEventArgs class --------------------

    static PyObject* _new_MagneticStripeReaderAamvaCardDataReceivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MagneticStripeReaderAamvaCardDataReceivedEventArgs(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Address(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs", L"Address"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Address());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_BirthDate(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs", L"BirthDate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BirthDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_City(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs", L"City"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.City());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Class(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs", L"Class"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Class());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Endorsements(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs", L"Endorsements"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Endorsements());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_ExpirationDate(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs", L"ExpirationDate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpirationDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_EyeColor(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs", L"EyeColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EyeColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_FirstName(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs", L"FirstName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FirstName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Gender(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs", L"Gender"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Gender());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_HairColor(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs", L"HairColor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HairColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Height(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs", L"Height"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_LicenseNumber(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs", L"LicenseNumber"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LicenseNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_PostalCode(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs", L"PostalCode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PostalCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Report(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs", L"Report"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Report());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Restrictions(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs", L"Restrictions"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Restrictions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_State(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs", L"State"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Suffix(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs", L"Suffix"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Suffix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Surname(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs", L"Surname"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Surname());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Weight(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderAamvaCardDataReceivedEventArgs", L"Weight"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Weight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MagneticStripeReaderAamvaCardDataReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MagneticStripeReaderAamvaCardDataReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderAamvaCardDataReceivedEventArgs[] = {
        { "_assign_array_", _assign_array_MagneticStripeReaderAamvaCardDataReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MagneticStripeReaderAamvaCardDataReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MagneticStripeReaderAamvaCardDataReceivedEventArgs[] = {
        { "address", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Address), nullptr, nullptr, nullptr },
        { "birth_date", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_BirthDate), nullptr, nullptr, nullptr },
        { "city", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_City), nullptr, nullptr, nullptr },
        { "class_", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Class), nullptr, nullptr, nullptr },
        { "endorsements", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Endorsements), nullptr, nullptr, nullptr },
        { "expiration_date", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_ExpirationDate), nullptr, nullptr, nullptr },
        { "eye_color", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_EyeColor), nullptr, nullptr, nullptr },
        { "first_name", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_FirstName), nullptr, nullptr, nullptr },
        { "gender", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Gender), nullptr, nullptr, nullptr },
        { "hair_color", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_HairColor), nullptr, nullptr, nullptr },
        { "height", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Height), nullptr, nullptr, nullptr },
        { "license_number", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_LicenseNumber), nullptr, nullptr, nullptr },
        { "postal_code", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_PostalCode), nullptr, nullptr, nullptr },
        { "report", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Report), nullptr, nullptr, nullptr },
        { "restrictions", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Restrictions), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_State), nullptr, nullptr, nullptr },
        { "suffix", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Suffix), nullptr, nullptr, nullptr },
        { "surname", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Surname), nullptr, nullptr, nullptr },
        { "weight", reinterpret_cast<getter>(MagneticStripeReaderAamvaCardDataReceivedEventArgs_get_Weight), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderAamvaCardDataReceivedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MagneticStripeReaderAamvaCardDataReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MagneticStripeReaderAamvaCardDataReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MagneticStripeReaderAamvaCardDataReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MagneticStripeReaderAamvaCardDataReceivedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MagneticStripeReaderAamvaCardDataReceivedEventArgs = {
        "winrt._winrt_windows_devices_pointofservice.MagneticStripeReaderAamvaCardDataReceivedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderAamvaCardDataReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderAamvaCardDataReceivedEventArgs};

    // ----- MagneticStripeReaderBankCardDataReceivedEventArgs class --------------------

    static PyObject* _new_MagneticStripeReaderBankCardDataReceivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MagneticStripeReaderBankCardDataReceivedEventArgs(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MagneticStripeReaderBankCardDataReceivedEventArgs_get_AccountNumber(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderBankCardDataReceivedEventArgs", L"AccountNumber"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AccountNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderBankCardDataReceivedEventArgs_get_ExpirationDate(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderBankCardDataReceivedEventArgs", L"ExpirationDate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpirationDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderBankCardDataReceivedEventArgs_get_FirstName(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderBankCardDataReceivedEventArgs", L"FirstName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FirstName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderBankCardDataReceivedEventArgs_get_MiddleInitial(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderBankCardDataReceivedEventArgs", L"MiddleInitial"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MiddleInitial());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderBankCardDataReceivedEventArgs_get_Report(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderBankCardDataReceivedEventArgs", L"Report"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Report());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderBankCardDataReceivedEventArgs_get_ServiceCode(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderBankCardDataReceivedEventArgs", L"ServiceCode"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServiceCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderBankCardDataReceivedEventArgs_get_Suffix(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderBankCardDataReceivedEventArgs", L"Suffix"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Suffix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderBankCardDataReceivedEventArgs_get_Surname(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderBankCardDataReceivedEventArgs", L"Surname"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Surname());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderBankCardDataReceivedEventArgs_get_Title(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderBankCardDataReceivedEventArgs", L"Title"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MagneticStripeReaderBankCardDataReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MagneticStripeReaderBankCardDataReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderBankCardDataReceivedEventArgs[] = {
        { "_assign_array_", _assign_array_MagneticStripeReaderBankCardDataReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MagneticStripeReaderBankCardDataReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MagneticStripeReaderBankCardDataReceivedEventArgs[] = {
        { "account_number", reinterpret_cast<getter>(MagneticStripeReaderBankCardDataReceivedEventArgs_get_AccountNumber), nullptr, nullptr, nullptr },
        { "expiration_date", reinterpret_cast<getter>(MagneticStripeReaderBankCardDataReceivedEventArgs_get_ExpirationDate), nullptr, nullptr, nullptr },
        { "first_name", reinterpret_cast<getter>(MagneticStripeReaderBankCardDataReceivedEventArgs_get_FirstName), nullptr, nullptr, nullptr },
        { "middle_initial", reinterpret_cast<getter>(MagneticStripeReaderBankCardDataReceivedEventArgs_get_MiddleInitial), nullptr, nullptr, nullptr },
        { "report", reinterpret_cast<getter>(MagneticStripeReaderBankCardDataReceivedEventArgs_get_Report), nullptr, nullptr, nullptr },
        { "service_code", reinterpret_cast<getter>(MagneticStripeReaderBankCardDataReceivedEventArgs_get_ServiceCode), nullptr, nullptr, nullptr },
        { "suffix", reinterpret_cast<getter>(MagneticStripeReaderBankCardDataReceivedEventArgs_get_Suffix), nullptr, nullptr, nullptr },
        { "surname", reinterpret_cast<getter>(MagneticStripeReaderBankCardDataReceivedEventArgs_get_Surname), nullptr, nullptr, nullptr },
        { "title", reinterpret_cast<getter>(MagneticStripeReaderBankCardDataReceivedEventArgs_get_Title), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderBankCardDataReceivedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MagneticStripeReaderBankCardDataReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MagneticStripeReaderBankCardDataReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MagneticStripeReaderBankCardDataReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MagneticStripeReaderBankCardDataReceivedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MagneticStripeReaderBankCardDataReceivedEventArgs = {
        "winrt._winrt_windows_devices_pointofservice.MagneticStripeReaderBankCardDataReceivedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderBankCardDataReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderBankCardDataReceivedEventArgs};

    // ----- MagneticStripeReaderCapabilities class --------------------

    static PyObject* _new_MagneticStripeReaderCapabilities(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities>::type_name);
        return nullptr;
    }

    static void _dealloc_MagneticStripeReaderCapabilities(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MagneticStripeReaderCapabilities_get_AuthenticationLevel(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderCapabilities", L"AuthenticationLevel"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AuthenticationLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_CardAuthentication(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderCapabilities", L"CardAuthentication"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CardAuthentication());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_IsIsoSupported(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderCapabilities", L"IsIsoSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsIsoSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_IsJisOneSupported(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderCapabilities", L"IsJisOneSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsJisOneSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_IsJisTwoSupported(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderCapabilities", L"IsJisTwoSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsJisTwoSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_IsStatisticsReportingSupported(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderCapabilities", L"IsStatisticsReportingSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsStatisticsReportingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_IsStatisticsUpdatingSupported(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderCapabilities", L"IsStatisticsUpdatingSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsStatisticsUpdatingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_IsTrackDataMaskingSupported(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderCapabilities", L"IsTrackDataMaskingSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsTrackDataMaskingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_IsTransmitSentinelsSupported(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderCapabilities", L"IsTransmitSentinelsSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsTransmitSentinelsSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_PowerReportingType(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderCapabilities", L"PowerReportingType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PowerReportingType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCapabilities_get_SupportedEncryptionAlgorithms(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderCapabilities", L"SupportedEncryptionAlgorithms"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedEncryptionAlgorithms());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MagneticStripeReaderCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MagneticStripeReaderCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderCapabilities[] = {
        { "_assign_array_", _assign_array_MagneticStripeReaderCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MagneticStripeReaderCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MagneticStripeReaderCapabilities[] = {
        { "authentication_level", reinterpret_cast<getter>(MagneticStripeReaderCapabilities_get_AuthenticationLevel), nullptr, nullptr, nullptr },
        { "card_authentication", reinterpret_cast<getter>(MagneticStripeReaderCapabilities_get_CardAuthentication), nullptr, nullptr, nullptr },
        { "is_iso_supported", reinterpret_cast<getter>(MagneticStripeReaderCapabilities_get_IsIsoSupported), nullptr, nullptr, nullptr },
        { "is_jis_one_supported", reinterpret_cast<getter>(MagneticStripeReaderCapabilities_get_IsJisOneSupported), nullptr, nullptr, nullptr },
        { "is_jis_two_supported", reinterpret_cast<getter>(MagneticStripeReaderCapabilities_get_IsJisTwoSupported), nullptr, nullptr, nullptr },
        { "is_statistics_reporting_supported", reinterpret_cast<getter>(MagneticStripeReaderCapabilities_get_IsStatisticsReportingSupported), nullptr, nullptr, nullptr },
        { "is_statistics_updating_supported", reinterpret_cast<getter>(MagneticStripeReaderCapabilities_get_IsStatisticsUpdatingSupported), nullptr, nullptr, nullptr },
        { "is_track_data_masking_supported", reinterpret_cast<getter>(MagneticStripeReaderCapabilities_get_IsTrackDataMaskingSupported), nullptr, nullptr, nullptr },
        { "is_transmit_sentinels_supported", reinterpret_cast<getter>(MagneticStripeReaderCapabilities_get_IsTransmitSentinelsSupported), nullptr, nullptr, nullptr },
        { "power_reporting_type", reinterpret_cast<getter>(MagneticStripeReaderCapabilities_get_PowerReportingType), nullptr, nullptr, nullptr },
        { "supported_encryption_algorithms", reinterpret_cast<getter>(MagneticStripeReaderCapabilities_get_SupportedEncryptionAlgorithms), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderCapabilities[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MagneticStripeReaderCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MagneticStripeReaderCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MagneticStripeReaderCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MagneticStripeReaderCapabilities) },
        { }
    };

    static PyType_Spec type_spec_MagneticStripeReaderCapabilities = {
        "winrt._winrt_windows_devices_pointofservice.MagneticStripeReaderCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderCapabilities};

    // ----- MagneticStripeReaderCardTypes class --------------------

    static PyObject* _new_MagneticStripeReaderCardTypes(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderCardTypes>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderCardTypes>::type_name);
        return nullptr;
    }

    static PyObject* MagneticStripeReaderCardTypes_get_Aamva(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderCardTypes", L"Aamva"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReaderCardTypes::Aamva());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCardTypes_get_Bank(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderCardTypes", L"Bank"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReaderCardTypes::Bank());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCardTypes_get_ExtendedBase(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderCardTypes", L"ExtendedBase"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReaderCardTypes::ExtendedBase());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderCardTypes_get_Unknown(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderCardTypes", L"Unknown"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReaderCardTypes::Unknown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderCardTypes[] = {
        { }
    };

    static PyGetSetDef _getset_MagneticStripeReaderCardTypes[] = {
        { }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderCardTypes[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MagneticStripeReaderCardTypes) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MagneticStripeReaderCardTypes) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MagneticStripeReaderCardTypes) },
        { }
    };

    static PyType_Spec type_spec_MagneticStripeReaderCardTypes = {
        "winrt._winrt_windows_devices_pointofservice.MagneticStripeReaderCardTypes",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderCardTypes};

    static PyGetSetDef getset_MagneticStripeReaderCardTypes_Static[] = {
        { "aamva", reinterpret_cast<getter>(MagneticStripeReaderCardTypes_get_Aamva), nullptr, nullptr, nullptr },
        { "bank", reinterpret_cast<getter>(MagneticStripeReaderCardTypes_get_Bank), nullptr, nullptr, nullptr },
        { "extended_base", reinterpret_cast<getter>(MagneticStripeReaderCardTypes_get_ExtendedBase), nullptr, nullptr, nullptr },
        { "unknown", reinterpret_cast<getter>(MagneticStripeReaderCardTypes_get_Unknown), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_MagneticStripeReaderCardTypes_Static[] = {
        { }
    };

    static PyType_Slot type_slots_MagneticStripeReaderCardTypes_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MagneticStripeReaderCardTypes_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MagneticStripeReaderCardTypes_Static) },
        { }
    };

    static PyType_Spec type_spec_MagneticStripeReaderCardTypes_Static =
    {
        "winrt._winrt_windows_devices_pointofservice.MagneticStripeReaderCardTypes_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MagneticStripeReaderCardTypes_Static
    };

    // ----- MagneticStripeReaderEncryptionAlgorithms class --------------------

    static PyObject* _new_MagneticStripeReaderEncryptionAlgorithms(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderEncryptionAlgorithms>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderEncryptionAlgorithms>::type_name);
        return nullptr;
    }

    static PyObject* MagneticStripeReaderEncryptionAlgorithms_get_ExtendedBase(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderEncryptionAlgorithms", L"ExtendedBase"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReaderEncryptionAlgorithms::ExtendedBase());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderEncryptionAlgorithms_get_None(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderEncryptionAlgorithms", L"None"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReaderEncryptionAlgorithms::None());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderEncryptionAlgorithms_get_TripleDesDukpt(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderEncryptionAlgorithms", L"TripleDesDukpt"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::MagneticStripeReaderEncryptionAlgorithms::TripleDesDukpt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderEncryptionAlgorithms[] = {
        { }
    };

    static PyGetSetDef _getset_MagneticStripeReaderEncryptionAlgorithms[] = {
        { }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderEncryptionAlgorithms[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MagneticStripeReaderEncryptionAlgorithms) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MagneticStripeReaderEncryptionAlgorithms) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MagneticStripeReaderEncryptionAlgorithms) },
        { }
    };

    static PyType_Spec type_spec_MagneticStripeReaderEncryptionAlgorithms = {
        "winrt._winrt_windows_devices_pointofservice.MagneticStripeReaderEncryptionAlgorithms",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderEncryptionAlgorithms};

    static PyGetSetDef getset_MagneticStripeReaderEncryptionAlgorithms_Static[] = {
        { "extended_base", reinterpret_cast<getter>(MagneticStripeReaderEncryptionAlgorithms_get_ExtendedBase), nullptr, nullptr, nullptr },
        { "none", reinterpret_cast<getter>(MagneticStripeReaderEncryptionAlgorithms_get_None), nullptr, nullptr, nullptr },
        { "triple_des_dukpt", reinterpret_cast<getter>(MagneticStripeReaderEncryptionAlgorithms_get_TripleDesDukpt), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_MagneticStripeReaderEncryptionAlgorithms_Static[] = {
        { }
    };

    static PyType_Slot type_slots_MagneticStripeReaderEncryptionAlgorithms_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MagneticStripeReaderEncryptionAlgorithms_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MagneticStripeReaderEncryptionAlgorithms_Static) },
        { }
    };

    static PyType_Spec type_spec_MagneticStripeReaderEncryptionAlgorithms_Static =
    {
        "winrt._winrt_windows_devices_pointofservice.MagneticStripeReaderEncryptionAlgorithms_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MagneticStripeReaderEncryptionAlgorithms_Static
    };

    // ----- MagneticStripeReaderErrorOccurredEventArgs class --------------------

    static PyObject* _new_MagneticStripeReaderErrorOccurredEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MagneticStripeReaderErrorOccurredEventArgs(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MagneticStripeReaderErrorOccurredEventArgs_get_ErrorData(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderErrorOccurredEventArgs", L"ErrorData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ErrorData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderErrorOccurredEventArgs_get_PartialInputData(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderErrorOccurredEventArgs", L"PartialInputData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PartialInputData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderErrorOccurredEventArgs_get_Track1Status(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderErrorOccurredEventArgs", L"Track1Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Track1Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderErrorOccurredEventArgs_get_Track2Status(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderErrorOccurredEventArgs", L"Track2Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Track2Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderErrorOccurredEventArgs_get_Track3Status(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderErrorOccurredEventArgs", L"Track3Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Track3Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderErrorOccurredEventArgs_get_Track4Status(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderErrorOccurredEventArgs", L"Track4Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Track4Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MagneticStripeReaderErrorOccurredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MagneticStripeReaderErrorOccurredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderErrorOccurredEventArgs[] = {
        { "_assign_array_", _assign_array_MagneticStripeReaderErrorOccurredEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MagneticStripeReaderErrorOccurredEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MagneticStripeReaderErrorOccurredEventArgs[] = {
        { "error_data", reinterpret_cast<getter>(MagneticStripeReaderErrorOccurredEventArgs_get_ErrorData), nullptr, nullptr, nullptr },
        { "partial_input_data", reinterpret_cast<getter>(MagneticStripeReaderErrorOccurredEventArgs_get_PartialInputData), nullptr, nullptr, nullptr },
        { "track1_status", reinterpret_cast<getter>(MagneticStripeReaderErrorOccurredEventArgs_get_Track1Status), nullptr, nullptr, nullptr },
        { "track2_status", reinterpret_cast<getter>(MagneticStripeReaderErrorOccurredEventArgs_get_Track2Status), nullptr, nullptr, nullptr },
        { "track3_status", reinterpret_cast<getter>(MagneticStripeReaderErrorOccurredEventArgs_get_Track3Status), nullptr, nullptr, nullptr },
        { "track4_status", reinterpret_cast<getter>(MagneticStripeReaderErrorOccurredEventArgs_get_Track4Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderErrorOccurredEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MagneticStripeReaderErrorOccurredEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MagneticStripeReaderErrorOccurredEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MagneticStripeReaderErrorOccurredEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MagneticStripeReaderErrorOccurredEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MagneticStripeReaderErrorOccurredEventArgs = {
        "winrt._winrt_windows_devices_pointofservice.MagneticStripeReaderErrorOccurredEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderErrorOccurredEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderErrorOccurredEventArgs};

    // ----- MagneticStripeReaderReport class --------------------

    static PyObject* _new_MagneticStripeReaderReport(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderReport>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderReport>::type_name);
        return nullptr;
    }

    static void _dealloc_MagneticStripeReaderReport(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MagneticStripeReaderReport_get_AdditionalSecurityInformation(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderReport", L"AdditionalSecurityInformation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AdditionalSecurityInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderReport_get_CardAuthenticationData(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderReport", L"CardAuthenticationData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CardAuthenticationData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderReport_get_CardAuthenticationDataLength(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderReport", L"CardAuthenticationDataLength"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CardAuthenticationDataLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderReport_get_CardType(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderReport", L"CardType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CardType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderReport_get_Properties(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderReport", L"Properties"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderReport_get_Track1(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderReport", L"Track1"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Track1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderReport_get_Track2(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderReport", L"Track2"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Track2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderReport_get_Track3(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderReport", L"Track3"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Track3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderReport_get_Track4(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderReport", L"Track4"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Track4());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MagneticStripeReaderReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::MagneticStripeReaderReport>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MagneticStripeReaderReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::MagneticStripeReaderReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderReport[] = {
        { "_assign_array_", _assign_array_MagneticStripeReaderReport, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MagneticStripeReaderReport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MagneticStripeReaderReport[] = {
        { "additional_security_information", reinterpret_cast<getter>(MagneticStripeReaderReport_get_AdditionalSecurityInformation), nullptr, nullptr, nullptr },
        { "card_authentication_data", reinterpret_cast<getter>(MagneticStripeReaderReport_get_CardAuthenticationData), nullptr, nullptr, nullptr },
        { "card_authentication_data_length", reinterpret_cast<getter>(MagneticStripeReaderReport_get_CardAuthenticationDataLength), nullptr, nullptr, nullptr },
        { "card_type", reinterpret_cast<getter>(MagneticStripeReaderReport_get_CardType), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(MagneticStripeReaderReport_get_Properties), nullptr, nullptr, nullptr },
        { "track1", reinterpret_cast<getter>(MagneticStripeReaderReport_get_Track1), nullptr, nullptr, nullptr },
        { "track2", reinterpret_cast<getter>(MagneticStripeReaderReport_get_Track2), nullptr, nullptr, nullptr },
        { "track3", reinterpret_cast<getter>(MagneticStripeReaderReport_get_Track3), nullptr, nullptr, nullptr },
        { "track4", reinterpret_cast<getter>(MagneticStripeReaderReport_get_Track4), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderReport[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MagneticStripeReaderReport) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MagneticStripeReaderReport) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MagneticStripeReaderReport) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MagneticStripeReaderReport) },
        { }
    };

    static PyType_Spec type_spec_MagneticStripeReaderReport = {
        "winrt._winrt_windows_devices_pointofservice.MagneticStripeReaderReport",
        sizeof(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderReport};

    // ----- MagneticStripeReaderStatusUpdatedEventArgs class --------------------

    static PyObject* _new_MagneticStripeReaderStatusUpdatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderStatusUpdatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderStatusUpdatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MagneticStripeReaderStatusUpdatedEventArgs(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderStatusUpdatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MagneticStripeReaderStatusUpdatedEventArgs_get_ExtendedStatus(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderStatusUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderStatusUpdatedEventArgs", L"ExtendedStatus"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderStatusUpdatedEventArgs_get_Status(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderStatusUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderStatusUpdatedEventArgs", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MagneticStripeReaderStatusUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::MagneticStripeReaderStatusUpdatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MagneticStripeReaderStatusUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::MagneticStripeReaderStatusUpdatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderStatusUpdatedEventArgs[] = {
        { "_assign_array_", _assign_array_MagneticStripeReaderStatusUpdatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MagneticStripeReaderStatusUpdatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MagneticStripeReaderStatusUpdatedEventArgs[] = {
        { "extended_status", reinterpret_cast<getter>(MagneticStripeReaderStatusUpdatedEventArgs_get_ExtendedStatus), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(MagneticStripeReaderStatusUpdatedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderStatusUpdatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MagneticStripeReaderStatusUpdatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MagneticStripeReaderStatusUpdatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MagneticStripeReaderStatusUpdatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MagneticStripeReaderStatusUpdatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MagneticStripeReaderStatusUpdatedEventArgs = {
        "winrt._winrt_windows_devices_pointofservice.MagneticStripeReaderStatusUpdatedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderStatusUpdatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderStatusUpdatedEventArgs};

    // ----- MagneticStripeReaderTrackData class --------------------

    static PyObject* _new_MagneticStripeReaderTrackData(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderTrackData>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderTrackData>::type_name);
        return nullptr;
    }

    static void _dealloc_MagneticStripeReaderTrackData(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderTrackData* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MagneticStripeReaderTrackData_get_Data(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderTrackData* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderTrackData", L"Data"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderTrackData_get_DiscretionaryData(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderTrackData* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderTrackData", L"DiscretionaryData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DiscretionaryData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MagneticStripeReaderTrackData_get_EncryptedData(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderTrackData* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderTrackData", L"EncryptedData"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EncryptedData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MagneticStripeReaderTrackData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::MagneticStripeReaderTrackData>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MagneticStripeReaderTrackData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::MagneticStripeReaderTrackData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderTrackData[] = {
        { "_assign_array_", _assign_array_MagneticStripeReaderTrackData, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MagneticStripeReaderTrackData), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MagneticStripeReaderTrackData[] = {
        { "data", reinterpret_cast<getter>(MagneticStripeReaderTrackData_get_Data), nullptr, nullptr, nullptr },
        { "discretionary_data", reinterpret_cast<getter>(MagneticStripeReaderTrackData_get_DiscretionaryData), nullptr, nullptr, nullptr },
        { "encrypted_data", reinterpret_cast<getter>(MagneticStripeReaderTrackData_get_EncryptedData), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderTrackData[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MagneticStripeReaderTrackData) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MagneticStripeReaderTrackData) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MagneticStripeReaderTrackData) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MagneticStripeReaderTrackData) },
        { }
    };

    static PyType_Spec type_spec_MagneticStripeReaderTrackData = {
        "winrt._winrt_windows_devices_pointofservice.MagneticStripeReaderTrackData",
        sizeof(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderTrackData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderTrackData};

    // ----- MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs class --------------------

    static PyObject* _new_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs_get_Report(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs", L"Report"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Report());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs[] = {
        { "_assign_array_", _assign_array_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs[] = {
        { "report", reinterpret_cast<getter>(MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs_get_Report), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs = {
        "winrt._winrt_windows_devices_pointofservice.MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs};

    // ----- PosPrinter class --------------------

    static PyObject* _new_PosPrinter(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::PosPrinter>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::PosPrinter>::type_name);
        return nullptr;
    }

    static void _dealloc_PosPrinter(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PosPrinter_CheckHealthAsync(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.PosPrinter", L"CheckHealthAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::UnifiedPosHealthCheckLevel>(args, 0);

                return py::convert(self->obj.CheckHealthAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PosPrinter_ClaimPrinterAsync(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.PosPrinter", L"ClaimPrinterAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ClaimPrinterAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PosPrinter_Close(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.PosPrinter", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PosPrinter_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.PosPrinter", L"FromIdAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::PosPrinter::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PosPrinter_GetDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.PosPrinter", L"GetDefaultAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::PointOfService::PosPrinter::GetDefaultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PosPrinter_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.PosPrinter", L"GetDeviceSelector", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::PointOfService::PosPrinter::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.PosPrinter", L"GetDeviceSelector", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosConnectionTypes>(args, 0);

                return py::convert(winrt::Windows::Devices::PointOfService::PosPrinter::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PosPrinter_GetFontProperty(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.PosPrinter", L"GetFontProperty", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetFontProperty(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PosPrinter_GetStatisticsAsync(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.PosPrinter", L"GetStatisticsAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetStatisticsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PosPrinter_get_Capabilities(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinter", L"Capabilities"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Capabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinter_get_DeviceId(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinter", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinter_get_Status(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinter", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinter_get_SupportedCharacterSets(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinter", L"SupportedCharacterSets"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedCharacterSets());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinter_get_SupportedTypeFaces(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinter", L"SupportedTypeFaces"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedTypeFaces());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinter_get_SupportedBarcodeSymbologies(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinter", L"SupportedBarcodeSymbologies"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedBarcodeSymbologies());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinter_add_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.PosPrinter", L"StatusUpdated"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::PointOfService::PosPrinter, winrt::Windows::Devices::PointOfService::PosPrinterStatusUpdatedEventArgs>>(arg);

            return py::convert(self->obj.StatusUpdated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinter_remove_StatusUpdated(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.PointOfService.PosPrinter", L"StatusUpdated"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StatusUpdated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PosPrinter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::PosPrinter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PosPrinter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::PosPrinter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_PosPrinter(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_PosPrinter(py::wrapper::Windows::Devices::PointOfService::PosPrinter* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PosPrinter[] = {
        { "check_health_async", reinterpret_cast<PyCFunction>(PosPrinter_CheckHealthAsync), METH_VARARGS, nullptr },
        { "claim_printer_async", reinterpret_cast<PyCFunction>(PosPrinter_ClaimPrinterAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(PosPrinter_Close), METH_VARARGS, nullptr },
        { "get_font_property", reinterpret_cast<PyCFunction>(PosPrinter_GetFontProperty), METH_VARARGS, nullptr },
        { "get_statistics_async", reinterpret_cast<PyCFunction>(PosPrinter_GetStatisticsAsync), METH_VARARGS, nullptr },
        { "add_status_updated", reinterpret_cast<PyCFunction>(PosPrinter_add_StatusUpdated), METH_O, nullptr },
        { "remove_status_updated", reinterpret_cast<PyCFunction>(PosPrinter_remove_StatusUpdated), METH_O, nullptr },
        { "_assign_array_", _assign_array_PosPrinter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PosPrinter), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_PosPrinter), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_PosPrinter), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_PosPrinter[] = {
        { "capabilities", reinterpret_cast<getter>(PosPrinter_get_Capabilities), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(PosPrinter_get_DeviceId), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(PosPrinter_get_Status), nullptr, nullptr, nullptr },
        { "supported_character_sets", reinterpret_cast<getter>(PosPrinter_get_SupportedCharacterSets), nullptr, nullptr, nullptr },
        { "supported_type_faces", reinterpret_cast<getter>(PosPrinter_get_SupportedTypeFaces), nullptr, nullptr, nullptr },
        { "supported_barcode_symbologies", reinterpret_cast<getter>(PosPrinter_get_SupportedBarcodeSymbologies), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PosPrinter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PosPrinter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PosPrinter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PosPrinter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PosPrinter) },
        { }
    };

    static PyType_Spec type_spec_PosPrinter = {
        "winrt._winrt_windows_devices_pointofservice.PosPrinter",
        sizeof(py::wrapper::Windows::Devices::PointOfService::PosPrinter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PosPrinter};

    static PyGetSetDef getset_PosPrinter_Static[] = {
        { }
    };

    static PyMethodDef methods_PosPrinter_Static[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(PosPrinter_FromIdAsync), METH_VARARGS, nullptr },
        { "get_default_async", reinterpret_cast<PyCFunction>(PosPrinter_GetDefaultAsync), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(PosPrinter_GetDeviceSelector), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_PosPrinter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PosPrinter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PosPrinter_Static) },
        { }
    };

    static PyType_Spec type_spec_PosPrinter_Static =
    {
        "winrt._winrt_windows_devices_pointofservice.PosPrinter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PosPrinter_Static
    };

    // ----- PosPrinterCapabilities class --------------------

    static PyObject* _new_PosPrinterCapabilities(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::PosPrinterCapabilities>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::PosPrinterCapabilities>::type_name);
        return nullptr;
    }

    static void _dealloc_PosPrinterCapabilities(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PosPrinterCapabilities_get_CanMapCharacterSet(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterCapabilities", L"CanMapCharacterSet"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanMapCharacterSet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCapabilities_get_DefaultCharacterSet(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterCapabilities", L"DefaultCharacterSet"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DefaultCharacterSet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCapabilities_get_HasCoverSensor(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterCapabilities", L"HasCoverSensor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HasCoverSensor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCapabilities_get_IsStatisticsReportingSupported(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterCapabilities", L"IsStatisticsReportingSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsStatisticsReportingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCapabilities_get_IsStatisticsUpdatingSupported(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterCapabilities", L"IsStatisticsUpdatingSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsStatisticsUpdatingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCapabilities_get_IsTransactionSupported(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterCapabilities", L"IsTransactionSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsTransactionSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCapabilities_get_Journal(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterCapabilities", L"Journal"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Journal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCapabilities_get_PowerReportingType(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterCapabilities", L"PowerReportingType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PowerReportingType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCapabilities_get_Receipt(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterCapabilities", L"Receipt"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Receipt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCapabilities_get_Slip(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterCapabilities", L"Slip"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Slip());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PosPrinterCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::PosPrinterCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PosPrinterCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::PosPrinterCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PosPrinterCapabilities[] = {
        { "_assign_array_", _assign_array_PosPrinterCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PosPrinterCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PosPrinterCapabilities[] = {
        { "can_map_character_set", reinterpret_cast<getter>(PosPrinterCapabilities_get_CanMapCharacterSet), nullptr, nullptr, nullptr },
        { "default_character_set", reinterpret_cast<getter>(PosPrinterCapabilities_get_DefaultCharacterSet), nullptr, nullptr, nullptr },
        { "has_cover_sensor", reinterpret_cast<getter>(PosPrinterCapabilities_get_HasCoverSensor), nullptr, nullptr, nullptr },
        { "is_statistics_reporting_supported", reinterpret_cast<getter>(PosPrinterCapabilities_get_IsStatisticsReportingSupported), nullptr, nullptr, nullptr },
        { "is_statistics_updating_supported", reinterpret_cast<getter>(PosPrinterCapabilities_get_IsStatisticsUpdatingSupported), nullptr, nullptr, nullptr },
        { "is_transaction_supported", reinterpret_cast<getter>(PosPrinterCapabilities_get_IsTransactionSupported), nullptr, nullptr, nullptr },
        { "journal", reinterpret_cast<getter>(PosPrinterCapabilities_get_Journal), nullptr, nullptr, nullptr },
        { "power_reporting_type", reinterpret_cast<getter>(PosPrinterCapabilities_get_PowerReportingType), nullptr, nullptr, nullptr },
        { "receipt", reinterpret_cast<getter>(PosPrinterCapabilities_get_Receipt), nullptr, nullptr, nullptr },
        { "slip", reinterpret_cast<getter>(PosPrinterCapabilities_get_Slip), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PosPrinterCapabilities[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PosPrinterCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PosPrinterCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PosPrinterCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PosPrinterCapabilities) },
        { }
    };

    static PyType_Spec type_spec_PosPrinterCapabilities = {
        "winrt._winrt_windows_devices_pointofservice.PosPrinterCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::PosPrinterCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PosPrinterCapabilities};

    // ----- PosPrinterCharacterSetIds class --------------------

    static PyObject* _new_PosPrinterCharacterSetIds(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::PosPrinterCharacterSetIds>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::PosPrinterCharacterSetIds>::type_name);
        return nullptr;
    }

    static PyObject* PosPrinterCharacterSetIds_get_Ansi(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterCharacterSetIds", L"Ansi"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::PosPrinterCharacterSetIds::Ansi());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCharacterSetIds_get_Ascii(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterCharacterSetIds", L"Ascii"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::PosPrinterCharacterSetIds::Ascii());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterCharacterSetIds_get_Utf16LE(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterCharacterSetIds", L"Utf16LE"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::PointOfService::PosPrinterCharacterSetIds::Utf16LE());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PosPrinterCharacterSetIds[] = {
        { }
    };

    static PyGetSetDef _getset_PosPrinterCharacterSetIds[] = {
        { }
    };

    static PyType_Slot _type_slots_PosPrinterCharacterSetIds[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PosPrinterCharacterSetIds) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PosPrinterCharacterSetIds) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PosPrinterCharacterSetIds) },
        { }
    };

    static PyType_Spec type_spec_PosPrinterCharacterSetIds = {
        "winrt._winrt_windows_devices_pointofservice.PosPrinterCharacterSetIds",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PosPrinterCharacterSetIds};

    static PyGetSetDef getset_PosPrinterCharacterSetIds_Static[] = {
        { "ansi", reinterpret_cast<getter>(PosPrinterCharacterSetIds_get_Ansi), nullptr, nullptr, nullptr },
        { "ascii", reinterpret_cast<getter>(PosPrinterCharacterSetIds_get_Ascii), nullptr, nullptr, nullptr },
        { "utf16_l_e", reinterpret_cast<getter>(PosPrinterCharacterSetIds_get_Utf16LE), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_PosPrinterCharacterSetIds_Static[] = {
        { }
    };

    static PyType_Slot type_slots_PosPrinterCharacterSetIds_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PosPrinterCharacterSetIds_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PosPrinterCharacterSetIds_Static) },
        { }
    };

    static PyType_Spec type_spec_PosPrinterCharacterSetIds_Static =
    {
        "winrt._winrt_windows_devices_pointofservice.PosPrinterCharacterSetIds_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PosPrinterCharacterSetIds_Static
    };

    // ----- PosPrinterFontProperty class --------------------

    static PyObject* _new_PosPrinterFontProperty(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::PosPrinterFontProperty>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::PosPrinterFontProperty>::type_name);
        return nullptr;
    }

    static void _dealloc_PosPrinterFontProperty(py::wrapper::Windows::Devices::PointOfService::PosPrinterFontProperty* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PosPrinterFontProperty_get_CharacterSizes(py::wrapper::Windows::Devices::PointOfService::PosPrinterFontProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterFontProperty", L"CharacterSizes"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CharacterSizes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterFontProperty_get_IsScalableToAnySize(py::wrapper::Windows::Devices::PointOfService::PosPrinterFontProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterFontProperty", L"IsScalableToAnySize"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsScalableToAnySize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterFontProperty_get_TypeFace(py::wrapper::Windows::Devices::PointOfService::PosPrinterFontProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterFontProperty", L"TypeFace"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TypeFace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PosPrinterFontProperty(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::PosPrinterFontProperty>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PosPrinterFontProperty(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::PosPrinterFontProperty>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PosPrinterFontProperty[] = {
        { "_assign_array_", _assign_array_PosPrinterFontProperty, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PosPrinterFontProperty), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PosPrinterFontProperty[] = {
        { "character_sizes", reinterpret_cast<getter>(PosPrinterFontProperty_get_CharacterSizes), nullptr, nullptr, nullptr },
        { "is_scalable_to_any_size", reinterpret_cast<getter>(PosPrinterFontProperty_get_IsScalableToAnySize), nullptr, nullptr, nullptr },
        { "type_face", reinterpret_cast<getter>(PosPrinterFontProperty_get_TypeFace), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PosPrinterFontProperty[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PosPrinterFontProperty) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PosPrinterFontProperty) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PosPrinterFontProperty) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PosPrinterFontProperty) },
        { }
    };

    static PyType_Spec type_spec_PosPrinterFontProperty = {
        "winrt._winrt_windows_devices_pointofservice.PosPrinterFontProperty",
        sizeof(py::wrapper::Windows::Devices::PointOfService::PosPrinterFontProperty),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PosPrinterFontProperty};

    // ----- PosPrinterPrintOptions class --------------------

    static PyObject* _new_PosPrinterPrintOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::PointOfService::PosPrinterPrintOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PosPrinterPrintOptions(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PosPrinterPrintOptions_get_Underline(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"Underline"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Underline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_Underline(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"Underline"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Underline(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_TypeFace(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"TypeFace"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TypeFace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_TypeFace(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"TypeFace"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.TypeFace(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_Superscript(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"Superscript"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Superscript());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_Superscript(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"Superscript"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Superscript(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_Subscript(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"Subscript"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Subscript());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_Subscript(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"Subscript"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Subscript(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_Strikethrough(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"Strikethrough"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Strikethrough());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_Strikethrough(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"Strikethrough"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Strikethrough(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_ReverseVideo(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"ReverseVideo"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReverseVideo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_ReverseVideo(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"ReverseVideo"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.ReverseVideo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_Italic(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"Italic"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Italic());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_Italic(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"Italic"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Italic(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_DoubleWide(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"DoubleWide"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DoubleWide());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_DoubleWide(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"DoubleWide"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.DoubleWide(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_DoubleHigh(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"DoubleHigh"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DoubleHigh());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_DoubleHigh(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"DoubleHigh"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.DoubleHigh(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_CharacterSet(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"CharacterSet"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CharacterSet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_CharacterSet(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"CharacterSet"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CharacterSet(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_CharacterHeight(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"CharacterHeight"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CharacterHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_CharacterHeight(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"CharacterHeight"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CharacterHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_Bold(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"Bold"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Bold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_Bold(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"Bold"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.Bold(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PosPrinterPrintOptions_get_Alignment(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"Alignment"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Alignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PosPrinterPrintOptions_put_Alignment(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterPrintOptions", L"Alignment"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(arg);

            self->obj.Alignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PosPrinterPrintOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::PosPrinterPrintOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PosPrinterPrintOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::PosPrinterPrintOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PosPrinterPrintOptions[] = {
        { "_assign_array_", _assign_array_PosPrinterPrintOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PosPrinterPrintOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PosPrinterPrintOptions[] = {
        { "underline", reinterpret_cast<getter>(PosPrinterPrintOptions_get_Underline), reinterpret_cast<setter>(PosPrinterPrintOptions_put_Underline), nullptr, nullptr },
        { "type_face", reinterpret_cast<getter>(PosPrinterPrintOptions_get_TypeFace), reinterpret_cast<setter>(PosPrinterPrintOptions_put_TypeFace), nullptr, nullptr },
        { "superscript", reinterpret_cast<getter>(PosPrinterPrintOptions_get_Superscript), reinterpret_cast<setter>(PosPrinterPrintOptions_put_Superscript), nullptr, nullptr },
        { "subscript", reinterpret_cast<getter>(PosPrinterPrintOptions_get_Subscript), reinterpret_cast<setter>(PosPrinterPrintOptions_put_Subscript), nullptr, nullptr },
        { "strikethrough", reinterpret_cast<getter>(PosPrinterPrintOptions_get_Strikethrough), reinterpret_cast<setter>(PosPrinterPrintOptions_put_Strikethrough), nullptr, nullptr },
        { "reverse_video", reinterpret_cast<getter>(PosPrinterPrintOptions_get_ReverseVideo), reinterpret_cast<setter>(PosPrinterPrintOptions_put_ReverseVideo), nullptr, nullptr },
        { "italic", reinterpret_cast<getter>(PosPrinterPrintOptions_get_Italic), reinterpret_cast<setter>(PosPrinterPrintOptions_put_Italic), nullptr, nullptr },
        { "double_wide", reinterpret_cast<getter>(PosPrinterPrintOptions_get_DoubleWide), reinterpret_cast<setter>(PosPrinterPrintOptions_put_DoubleWide), nullptr, nullptr },
        { "double_high", reinterpret_cast<getter>(PosPrinterPrintOptions_get_DoubleHigh), reinterpret_cast<setter>(PosPrinterPrintOptions_put_DoubleHigh), nullptr, nullptr },
        { "character_set", reinterpret_cast<getter>(PosPrinterPrintOptions_get_CharacterSet), reinterpret_cast<setter>(PosPrinterPrintOptions_put_CharacterSet), nullptr, nullptr },
        { "character_height", reinterpret_cast<getter>(PosPrinterPrintOptions_get_CharacterHeight), reinterpret_cast<setter>(PosPrinterPrintOptions_put_CharacterHeight), nullptr, nullptr },
        { "bold", reinterpret_cast<getter>(PosPrinterPrintOptions_get_Bold), reinterpret_cast<setter>(PosPrinterPrintOptions_put_Bold), nullptr, nullptr },
        { "alignment", reinterpret_cast<getter>(PosPrinterPrintOptions_get_Alignment), reinterpret_cast<setter>(PosPrinterPrintOptions_put_Alignment), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PosPrinterPrintOptions[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PosPrinterPrintOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PosPrinterPrintOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PosPrinterPrintOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PosPrinterPrintOptions) },
        { }
    };

    static PyType_Spec type_spec_PosPrinterPrintOptions = {
        "winrt._winrt_windows_devices_pointofservice.PosPrinterPrintOptions",
        sizeof(py::wrapper::Windows::Devices::PointOfService::PosPrinterPrintOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PosPrinterPrintOptions};

    // ----- PosPrinterReleaseDeviceRequestedEventArgs class --------------------

    static PyObject* _new_PosPrinterReleaseDeviceRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::PosPrinterReleaseDeviceRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::PosPrinterReleaseDeviceRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PosPrinterReleaseDeviceRequestedEventArgs(py::wrapper::Windows::Devices::PointOfService::PosPrinterReleaseDeviceRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PosPrinterReleaseDeviceRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::PosPrinterReleaseDeviceRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PosPrinterReleaseDeviceRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::PosPrinterReleaseDeviceRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PosPrinterReleaseDeviceRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_PosPrinterReleaseDeviceRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PosPrinterReleaseDeviceRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PosPrinterReleaseDeviceRequestedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_PosPrinterReleaseDeviceRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PosPrinterReleaseDeviceRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PosPrinterReleaseDeviceRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PosPrinterReleaseDeviceRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PosPrinterReleaseDeviceRequestedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_PosPrinterReleaseDeviceRequestedEventArgs = {
        "winrt._winrt_windows_devices_pointofservice.PosPrinterReleaseDeviceRequestedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::PosPrinterReleaseDeviceRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PosPrinterReleaseDeviceRequestedEventArgs};

    // ----- PosPrinterStatus class --------------------

    static PyObject* _new_PosPrinterStatus(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::PosPrinterStatus>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::PosPrinterStatus>::type_name);
        return nullptr;
    }

    static void _dealloc_PosPrinterStatus(py::wrapper::Windows::Devices::PointOfService::PosPrinterStatus* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PosPrinterStatus_get_ExtendedStatus(py::wrapper::Windows::Devices::PointOfService::PosPrinterStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterStatus", L"ExtendedStatus"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PosPrinterStatus_get_StatusKind(py::wrapper::Windows::Devices::PointOfService::PosPrinterStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterStatus", L"StatusKind"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StatusKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PosPrinterStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::PosPrinterStatus>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PosPrinterStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::PosPrinterStatus>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PosPrinterStatus[] = {
        { "_assign_array_", _assign_array_PosPrinterStatus, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PosPrinterStatus), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PosPrinterStatus[] = {
        { "extended_status", reinterpret_cast<getter>(PosPrinterStatus_get_ExtendedStatus), nullptr, nullptr, nullptr },
        { "status_kind", reinterpret_cast<getter>(PosPrinterStatus_get_StatusKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PosPrinterStatus[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PosPrinterStatus) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PosPrinterStatus) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PosPrinterStatus) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PosPrinterStatus) },
        { }
    };

    static PyType_Spec type_spec_PosPrinterStatus = {
        "winrt._winrt_windows_devices_pointofservice.PosPrinterStatus",
        sizeof(py::wrapper::Windows::Devices::PointOfService::PosPrinterStatus),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PosPrinterStatus};

    // ----- PosPrinterStatusUpdatedEventArgs class --------------------

    static PyObject* _new_PosPrinterStatusUpdatedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::PosPrinterStatusUpdatedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::PosPrinterStatusUpdatedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PosPrinterStatusUpdatedEventArgs(py::wrapper::Windows::Devices::PointOfService::PosPrinterStatusUpdatedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PosPrinterStatusUpdatedEventArgs_get_Status(py::wrapper::Windows::Devices::PointOfService::PosPrinterStatusUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.PosPrinterStatusUpdatedEventArgs", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PosPrinterStatusUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::PosPrinterStatusUpdatedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PosPrinterStatusUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::PosPrinterStatusUpdatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PosPrinterStatusUpdatedEventArgs[] = {
        { "_assign_array_", _assign_array_PosPrinterStatusUpdatedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PosPrinterStatusUpdatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PosPrinterStatusUpdatedEventArgs[] = {
        { "status", reinterpret_cast<getter>(PosPrinterStatusUpdatedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PosPrinterStatusUpdatedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PosPrinterStatusUpdatedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PosPrinterStatusUpdatedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PosPrinterStatusUpdatedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PosPrinterStatusUpdatedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_PosPrinterStatusUpdatedEventArgs = {
        "winrt._winrt_windows_devices_pointofservice.PosPrinterStatusUpdatedEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::PosPrinterStatusUpdatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PosPrinterStatusUpdatedEventArgs};

    // ----- ReceiptPrintJob class --------------------

    static PyObject* _new_ReceiptPrintJob(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::ReceiptPrintJob>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::ReceiptPrintJob>::type_name);
        return nullptr;
    }

    static void _dealloc_ReceiptPrintJob(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ReceiptPrintJob_CutPaper(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"CutPaper", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.CutPaper();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"CutPaper", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                self->obj.CutPaper(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_DrawRuledLine(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"DrawRuledLine", 5))
                {
                    py::set_arg_count_version_error(5);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterLineDirection>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterLineStyle>(args, 3);
                auto param4 = py::convert_to<uint32_t>(args, 4);

                self->obj.DrawRuledLine(param0, param1, param2, param3, param4);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_ExecuteAsync(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"ExecuteAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ExecuteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_FeedPaperByLine(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"FeedPaperByLine", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.FeedPaperByLine(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_FeedPaperByMapModeUnit(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"FeedPaperByMapModeUnit", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.FeedPaperByMapModeUnit(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_MarkFeed(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"MarkFeed", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterMarkFeedKind>(args, 0);

                self->obj.MarkFeed(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_Print(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"Print", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Print(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"Print", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterPrintOptions>(args, 1);

                self->obj.Print(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_PrintBarcode(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"PrintBarcode", 6))
                {
                    py::set_arg_count_version_error(6);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterBarcodeTextPosition>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 5);

                self->obj.PrintBarcode(param0, param1, param2, param3, param4, param5);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_PrintBarcodeCustomAlign(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"PrintBarcodeCustomAlign", 6))
                {
                    py::set_arg_count_version_error(6);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterBarcodeTextPosition>(args, 4);
                auto param5 = py::convert_to<uint32_t>(args, 5);

                self->obj.PrintBarcodeCustomAlign(param0, param1, param2, param3, param4, param5);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_PrintBitmap(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"PrintBitmap", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 1);

                self->obj.PrintBitmap(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"PrintBitmap", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.PrintBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_PrintCustomAlignedBitmap(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"PrintCustomAlignedBitmap", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                self->obj.PrintCustomAlignedBitmap(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"PrintCustomAlignedBitmap", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.PrintCustomAlignedBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_PrintLine(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"PrintLine", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.PrintLine();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"PrintLine", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.PrintLine(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_PrintSavedBitmap(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"PrintSavedBitmap", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.PrintSavedBitmap(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_SetBarcodeRotation(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"SetBarcodeRotation", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterRotation>(args, 0);

                self->obj.SetBarcodeRotation(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_SetBitmap(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"SetBitmap", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 2);

                self->obj.SetBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"SetBitmap", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);

                self->obj.SetBitmap(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_SetCustomAlignedBitmap(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"SetCustomAlignedBitmap", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.SetCustomAlignedBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"SetCustomAlignedBitmap", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);

                self->obj.SetCustomAlignedBitmap(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_SetPrintArea(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"SetPrintArea", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                self->obj.SetPrintArea(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_SetPrintRotation(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"SetPrintRotation", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterRotation>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                self->obj.SetPrintRotation(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ReceiptPrintJob_StampPaper(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ReceiptPrintJob", L"StampPaper", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.StampPaper();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ReceiptPrintJob(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::ReceiptPrintJob>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ReceiptPrintJob(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ReceiptPrintJob>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ReceiptPrintJob[] = {
        { "cut_paper", reinterpret_cast<PyCFunction>(ReceiptPrintJob_CutPaper), METH_VARARGS, nullptr },
        { "draw_ruled_line", reinterpret_cast<PyCFunction>(ReceiptPrintJob_DrawRuledLine), METH_VARARGS, nullptr },
        { "execute_async", reinterpret_cast<PyCFunction>(ReceiptPrintJob_ExecuteAsync), METH_VARARGS, nullptr },
        { "feed_paper_by_line", reinterpret_cast<PyCFunction>(ReceiptPrintJob_FeedPaperByLine), METH_VARARGS, nullptr },
        { "feed_paper_by_map_mode_unit", reinterpret_cast<PyCFunction>(ReceiptPrintJob_FeedPaperByMapModeUnit), METH_VARARGS, nullptr },
        { "mark_feed", reinterpret_cast<PyCFunction>(ReceiptPrintJob_MarkFeed), METH_VARARGS, nullptr },
        { "print", reinterpret_cast<PyCFunction>(ReceiptPrintJob_Print), METH_VARARGS, nullptr },
        { "print_barcode", reinterpret_cast<PyCFunction>(ReceiptPrintJob_PrintBarcode), METH_VARARGS, nullptr },
        { "print_barcode_custom_align", reinterpret_cast<PyCFunction>(ReceiptPrintJob_PrintBarcodeCustomAlign), METH_VARARGS, nullptr },
        { "print_bitmap", reinterpret_cast<PyCFunction>(ReceiptPrintJob_PrintBitmap), METH_VARARGS, nullptr },
        { "print_custom_aligned_bitmap", reinterpret_cast<PyCFunction>(ReceiptPrintJob_PrintCustomAlignedBitmap), METH_VARARGS, nullptr },
        { "print_line", reinterpret_cast<PyCFunction>(ReceiptPrintJob_PrintLine), METH_VARARGS, nullptr },
        { "print_saved_bitmap", reinterpret_cast<PyCFunction>(ReceiptPrintJob_PrintSavedBitmap), METH_VARARGS, nullptr },
        { "set_barcode_rotation", reinterpret_cast<PyCFunction>(ReceiptPrintJob_SetBarcodeRotation), METH_VARARGS, nullptr },
        { "set_bitmap", reinterpret_cast<PyCFunction>(ReceiptPrintJob_SetBitmap), METH_VARARGS, nullptr },
        { "set_custom_aligned_bitmap", reinterpret_cast<PyCFunction>(ReceiptPrintJob_SetCustomAlignedBitmap), METH_VARARGS, nullptr },
        { "set_print_area", reinterpret_cast<PyCFunction>(ReceiptPrintJob_SetPrintArea), METH_VARARGS, nullptr },
        { "set_print_rotation", reinterpret_cast<PyCFunction>(ReceiptPrintJob_SetPrintRotation), METH_VARARGS, nullptr },
        { "stamp_paper", reinterpret_cast<PyCFunction>(ReceiptPrintJob_StampPaper), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ReceiptPrintJob, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ReceiptPrintJob), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ReceiptPrintJob[] = {
        { }
    };

    static PyType_Slot _type_slots_ReceiptPrintJob[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ReceiptPrintJob) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ReceiptPrintJob) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ReceiptPrintJob) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ReceiptPrintJob) },
        { }
    };

    static PyType_Spec type_spec_ReceiptPrintJob = {
        "winrt._winrt_windows_devices_pointofservice.ReceiptPrintJob",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ReceiptPrintJob),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ReceiptPrintJob};

    // ----- ReceiptPrinterCapabilities class --------------------

    static PyObject* _new_ReceiptPrinterCapabilities(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::ReceiptPrinterCapabilities>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::ReceiptPrinterCapabilities>::type_name);
        return nullptr;
    }

    static void _dealloc_ReceiptPrinterCapabilities(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ReceiptPrinterCapabilities_get_CartridgeSensors(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"CartridgeSensors"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CartridgeSensors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_ColorCartridgeCapabilities(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"ColorCartridgeCapabilities"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ColorCartridgeCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsBoldSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsBoldSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsBoldSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsDoubleHighDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsDoubleHighDoubleWidePrintSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDoubleHighDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsDoubleHighPrintSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsDoubleHighPrintSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDoubleHighPrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsDoubleWidePrintSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsDualColorSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsDualColorSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDualColorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsItalicSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsItalicSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsItalicSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsPaperEmptySensorSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsPaperEmptySensorSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPaperEmptySensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsPaperNearEndSensorSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsPaperNearEndSensorSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPaperNearEndSensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsPrinterPresent(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsPrinterPresent"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPrinterPresent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsUnderlineSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsUnderlineSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsUnderlineSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_SupportedCharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"SupportedCharactersPerLine"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedCharactersPerLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_Is180RotationSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"Is180RotationSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Is180RotationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsBarcodeSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsBarcodeSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsBarcodeSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsBitmapSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsBitmapSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsBitmapSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsLeft90RotationSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsLeft90RotationSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsLeft90RotationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsPrintAreaSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsPrintAreaSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPrintAreaSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsRight90RotationSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsRight90RotationSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsRight90RotationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_RuledLineCapabilities(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"RuledLineCapabilities"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RuledLineCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_SupportedBarcodeRotations(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"SupportedBarcodeRotations"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedBarcodeRotations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_SupportedBitmapRotations(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"SupportedBitmapRotations"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedBitmapRotations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_CanCutPaper(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"CanCutPaper"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanCutPaper());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsStampSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsStampSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsStampSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_MarkFeedCapabilities(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"MarkFeedCapabilities"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MarkFeedCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsReversePaperFeedByLineSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsReversePaperFeedByLineSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsReversePaperFeedByLineSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsReversePaperFeedByMapModeUnitSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsReversePaperFeedByMapModeUnitSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsReversePaperFeedByMapModeUnitSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsReverseVideoSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsReverseVideoSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsReverseVideoSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsStrikethroughSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsStrikethroughSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsStrikethroughSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsSubscriptSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsSubscriptSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSubscriptSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReceiptPrinterCapabilities_get_IsSuperscriptSupported(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ReceiptPrinterCapabilities", L"IsSuperscriptSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSuperscriptSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ReceiptPrinterCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::ReceiptPrinterCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ReceiptPrinterCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ReceiptPrinterCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ReceiptPrinterCapabilities[] = {
        { "_assign_array_", _assign_array_ReceiptPrinterCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ReceiptPrinterCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ReceiptPrinterCapabilities[] = {
        { "cartridge_sensors", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_CartridgeSensors), nullptr, nullptr, nullptr },
        { "color_cartridge_capabilities", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_ColorCartridgeCapabilities), nullptr, nullptr, nullptr },
        { "is_bold_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsBoldSupported), nullptr, nullptr, nullptr },
        { "is_double_high_double_wide_print_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsDoubleHighDoubleWidePrintSupported), nullptr, nullptr, nullptr },
        { "is_double_high_print_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsDoubleHighPrintSupported), nullptr, nullptr, nullptr },
        { "is_double_wide_print_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsDoubleWidePrintSupported), nullptr, nullptr, nullptr },
        { "is_dual_color_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsDualColorSupported), nullptr, nullptr, nullptr },
        { "is_italic_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsItalicSupported), nullptr, nullptr, nullptr },
        { "is_paper_empty_sensor_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsPaperEmptySensorSupported), nullptr, nullptr, nullptr },
        { "is_paper_near_end_sensor_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsPaperNearEndSensorSupported), nullptr, nullptr, nullptr },
        { "is_printer_present", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsPrinterPresent), nullptr, nullptr, nullptr },
        { "is_underline_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsUnderlineSupported), nullptr, nullptr, nullptr },
        { "supported_characters_per_line", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_SupportedCharactersPerLine), nullptr, nullptr, nullptr },
        { "is180_rotation_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_Is180RotationSupported), nullptr, nullptr, nullptr },
        { "is_barcode_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsBarcodeSupported), nullptr, nullptr, nullptr },
        { "is_bitmap_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsBitmapSupported), nullptr, nullptr, nullptr },
        { "is_left90_rotation_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsLeft90RotationSupported), nullptr, nullptr, nullptr },
        { "is_print_area_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsPrintAreaSupported), nullptr, nullptr, nullptr },
        { "is_right90_rotation_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsRight90RotationSupported), nullptr, nullptr, nullptr },
        { "ruled_line_capabilities", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_RuledLineCapabilities), nullptr, nullptr, nullptr },
        { "supported_barcode_rotations", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_SupportedBarcodeRotations), nullptr, nullptr, nullptr },
        { "supported_bitmap_rotations", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_SupportedBitmapRotations), nullptr, nullptr, nullptr },
        { "can_cut_paper", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_CanCutPaper), nullptr, nullptr, nullptr },
        { "is_stamp_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsStampSupported), nullptr, nullptr, nullptr },
        { "mark_feed_capabilities", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_MarkFeedCapabilities), nullptr, nullptr, nullptr },
        { "is_reverse_paper_feed_by_line_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsReversePaperFeedByLineSupported), nullptr, nullptr, nullptr },
        { "is_reverse_paper_feed_by_map_mode_unit_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsReversePaperFeedByMapModeUnitSupported), nullptr, nullptr, nullptr },
        { "is_reverse_video_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsReverseVideoSupported), nullptr, nullptr, nullptr },
        { "is_strikethrough_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsStrikethroughSupported), nullptr, nullptr, nullptr },
        { "is_subscript_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsSubscriptSupported), nullptr, nullptr, nullptr },
        { "is_superscript_supported", reinterpret_cast<getter>(ReceiptPrinterCapabilities_get_IsSuperscriptSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ReceiptPrinterCapabilities[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ReceiptPrinterCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ReceiptPrinterCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ReceiptPrinterCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ReceiptPrinterCapabilities) },
        { }
    };

    static PyType_Spec type_spec_ReceiptPrinterCapabilities = {
        "winrt._winrt_windows_devices_pointofservice.ReceiptPrinterCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ReceiptPrinterCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ReceiptPrinterCapabilities};

    // ----- SlipPrintJob class --------------------

    static PyObject* _new_SlipPrintJob(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::SlipPrintJob>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::SlipPrintJob>::type_name);
        return nullptr;
    }

    static void _dealloc_SlipPrintJob(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SlipPrintJob_DrawRuledLine(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"DrawRuledLine", 5))
                {
                    py::set_arg_count_version_error(5);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterLineDirection>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterLineStyle>(args, 3);
                auto param4 = py::convert_to<uint32_t>(args, 4);

                self->obj.DrawRuledLine(param0, param1, param2, param3, param4);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_ExecuteAsync(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"ExecuteAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ExecuteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_FeedPaperByLine(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"FeedPaperByLine", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.FeedPaperByLine(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_FeedPaperByMapModeUnit(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"FeedPaperByMapModeUnit", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.FeedPaperByMapModeUnit(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_Print(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"Print", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Print(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"Print", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterPrintOptions>(args, 1);

                self->obj.Print(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_PrintBarcode(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"PrintBarcode", 6))
                {
                    py::set_arg_count_version_error(6);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterBarcodeTextPosition>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 5);

                self->obj.PrintBarcode(param0, param1, param2, param3, param4, param5);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_PrintBarcodeCustomAlign(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"PrintBarcodeCustomAlign", 6))
                {
                    py::set_arg_count_version_error(6);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterBarcodeTextPosition>(args, 4);
                auto param5 = py::convert_to<uint32_t>(args, 5);

                self->obj.PrintBarcodeCustomAlign(param0, param1, param2, param3, param4, param5);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_PrintBitmap(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"PrintBitmap", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 1);

                self->obj.PrintBitmap(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"PrintBitmap", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.PrintBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_PrintCustomAlignedBitmap(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"PrintCustomAlignedBitmap", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                self->obj.PrintCustomAlignedBitmap(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"PrintCustomAlignedBitmap", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.PrintCustomAlignedBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_PrintLine(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"PrintLine", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.PrintLine();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"PrintLine", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.PrintLine(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_PrintSavedBitmap(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"PrintSavedBitmap", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.PrintSavedBitmap(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_SetBarcodeRotation(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"SetBarcodeRotation", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterRotation>(args, 0);

                self->obj.SetBarcodeRotation(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_SetBitmap(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"SetBitmap", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 2);

                self->obj.SetBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"SetBitmap", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);

                self->obj.SetBitmap(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_SetCustomAlignedBitmap(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"SetCustomAlignedBitmap", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.SetCustomAlignedBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"SetCustomAlignedBitmap", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);

                self->obj.SetCustomAlignedBitmap(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_SetPrintArea(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"SetPrintArea", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                self->obj.SetPrintArea(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SlipPrintJob_SetPrintRotation(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.SlipPrintJob", L"SetPrintRotation", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterRotation>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                self->obj.SetPrintRotation(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_SlipPrintJob(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::SlipPrintJob>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SlipPrintJob(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::SlipPrintJob>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SlipPrintJob[] = {
        { "draw_ruled_line", reinterpret_cast<PyCFunction>(SlipPrintJob_DrawRuledLine), METH_VARARGS, nullptr },
        { "execute_async", reinterpret_cast<PyCFunction>(SlipPrintJob_ExecuteAsync), METH_VARARGS, nullptr },
        { "feed_paper_by_line", reinterpret_cast<PyCFunction>(SlipPrintJob_FeedPaperByLine), METH_VARARGS, nullptr },
        { "feed_paper_by_map_mode_unit", reinterpret_cast<PyCFunction>(SlipPrintJob_FeedPaperByMapModeUnit), METH_VARARGS, nullptr },
        { "print", reinterpret_cast<PyCFunction>(SlipPrintJob_Print), METH_VARARGS, nullptr },
        { "print_barcode", reinterpret_cast<PyCFunction>(SlipPrintJob_PrintBarcode), METH_VARARGS, nullptr },
        { "print_barcode_custom_align", reinterpret_cast<PyCFunction>(SlipPrintJob_PrintBarcodeCustomAlign), METH_VARARGS, nullptr },
        { "print_bitmap", reinterpret_cast<PyCFunction>(SlipPrintJob_PrintBitmap), METH_VARARGS, nullptr },
        { "print_custom_aligned_bitmap", reinterpret_cast<PyCFunction>(SlipPrintJob_PrintCustomAlignedBitmap), METH_VARARGS, nullptr },
        { "print_line", reinterpret_cast<PyCFunction>(SlipPrintJob_PrintLine), METH_VARARGS, nullptr },
        { "print_saved_bitmap", reinterpret_cast<PyCFunction>(SlipPrintJob_PrintSavedBitmap), METH_VARARGS, nullptr },
        { "set_barcode_rotation", reinterpret_cast<PyCFunction>(SlipPrintJob_SetBarcodeRotation), METH_VARARGS, nullptr },
        { "set_bitmap", reinterpret_cast<PyCFunction>(SlipPrintJob_SetBitmap), METH_VARARGS, nullptr },
        { "set_custom_aligned_bitmap", reinterpret_cast<PyCFunction>(SlipPrintJob_SetCustomAlignedBitmap), METH_VARARGS, nullptr },
        { "set_print_area", reinterpret_cast<PyCFunction>(SlipPrintJob_SetPrintArea), METH_VARARGS, nullptr },
        { "set_print_rotation", reinterpret_cast<PyCFunction>(SlipPrintJob_SetPrintRotation), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SlipPrintJob, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SlipPrintJob), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SlipPrintJob[] = {
        { }
    };

    static PyType_Slot _type_slots_SlipPrintJob[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SlipPrintJob) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SlipPrintJob) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SlipPrintJob) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SlipPrintJob) },
        { }
    };

    static PyType_Spec type_spec_SlipPrintJob = {
        "winrt._winrt_windows_devices_pointofservice.SlipPrintJob",
        sizeof(py::wrapper::Windows::Devices::PointOfService::SlipPrintJob),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SlipPrintJob};

    // ----- SlipPrinterCapabilities class --------------------

    static PyObject* _new_SlipPrinterCapabilities(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::SlipPrinterCapabilities>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::SlipPrinterCapabilities>::type_name);
        return nullptr;
    }

    static void _dealloc_SlipPrinterCapabilities(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SlipPrinterCapabilities_get_CartridgeSensors(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"CartridgeSensors"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CartridgeSensors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_ColorCartridgeCapabilities(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"ColorCartridgeCapabilities"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ColorCartridgeCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsBoldSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsBoldSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsBoldSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsDoubleHighDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsDoubleHighDoubleWidePrintSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDoubleHighDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsDoubleHighPrintSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsDoubleHighPrintSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDoubleHighPrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsDoubleWidePrintSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsDualColorSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsDualColorSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDualColorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsItalicSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsItalicSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsItalicSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsPaperEmptySensorSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsPaperEmptySensorSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPaperEmptySensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsPaperNearEndSensorSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsPaperNearEndSensorSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPaperNearEndSensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsPrinterPresent(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsPrinterPresent"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPrinterPresent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsUnderlineSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsUnderlineSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsUnderlineSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_SupportedCharactersPerLine(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"SupportedCharactersPerLine"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedCharactersPerLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_Is180RotationSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"Is180RotationSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Is180RotationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsBarcodeSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsBarcodeSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsBarcodeSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsBitmapSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsBitmapSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsBitmapSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsLeft90RotationSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsLeft90RotationSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsLeft90RotationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsPrintAreaSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsPrintAreaSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPrintAreaSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsRight90RotationSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsRight90RotationSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsRight90RotationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_RuledLineCapabilities(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"RuledLineCapabilities"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RuledLineCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_SupportedBarcodeRotations(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"SupportedBarcodeRotations"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedBarcodeRotations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_SupportedBitmapRotations(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"SupportedBitmapRotations"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedBitmapRotations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsBothSidesPrintingSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsBothSidesPrintingSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsBothSidesPrintingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsFullLengthSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsFullLengthSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsFullLengthSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsReversePaperFeedByLineSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsReversePaperFeedByLineSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsReversePaperFeedByLineSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsReversePaperFeedByMapModeUnitSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsReversePaperFeedByMapModeUnitSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsReversePaperFeedByMapModeUnitSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsReverseVideoSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsReverseVideoSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsReverseVideoSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsStrikethroughSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsStrikethroughSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsStrikethroughSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsSubscriptSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsSubscriptSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSubscriptSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SlipPrinterCapabilities_get_IsSuperscriptSupported(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.SlipPrinterCapabilities", L"IsSuperscriptSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSuperscriptSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SlipPrinterCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::SlipPrinterCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SlipPrinterCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::SlipPrinterCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SlipPrinterCapabilities[] = {
        { "_assign_array_", _assign_array_SlipPrinterCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SlipPrinterCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SlipPrinterCapabilities[] = {
        { "cartridge_sensors", reinterpret_cast<getter>(SlipPrinterCapabilities_get_CartridgeSensors), nullptr, nullptr, nullptr },
        { "color_cartridge_capabilities", reinterpret_cast<getter>(SlipPrinterCapabilities_get_ColorCartridgeCapabilities), nullptr, nullptr, nullptr },
        { "is_bold_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsBoldSupported), nullptr, nullptr, nullptr },
        { "is_double_high_double_wide_print_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsDoubleHighDoubleWidePrintSupported), nullptr, nullptr, nullptr },
        { "is_double_high_print_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsDoubleHighPrintSupported), nullptr, nullptr, nullptr },
        { "is_double_wide_print_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsDoubleWidePrintSupported), nullptr, nullptr, nullptr },
        { "is_dual_color_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsDualColorSupported), nullptr, nullptr, nullptr },
        { "is_italic_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsItalicSupported), nullptr, nullptr, nullptr },
        { "is_paper_empty_sensor_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsPaperEmptySensorSupported), nullptr, nullptr, nullptr },
        { "is_paper_near_end_sensor_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsPaperNearEndSensorSupported), nullptr, nullptr, nullptr },
        { "is_printer_present", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsPrinterPresent), nullptr, nullptr, nullptr },
        { "is_underline_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsUnderlineSupported), nullptr, nullptr, nullptr },
        { "supported_characters_per_line", reinterpret_cast<getter>(SlipPrinterCapabilities_get_SupportedCharactersPerLine), nullptr, nullptr, nullptr },
        { "is180_rotation_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_Is180RotationSupported), nullptr, nullptr, nullptr },
        { "is_barcode_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsBarcodeSupported), nullptr, nullptr, nullptr },
        { "is_bitmap_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsBitmapSupported), nullptr, nullptr, nullptr },
        { "is_left90_rotation_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsLeft90RotationSupported), nullptr, nullptr, nullptr },
        { "is_print_area_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsPrintAreaSupported), nullptr, nullptr, nullptr },
        { "is_right90_rotation_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsRight90RotationSupported), nullptr, nullptr, nullptr },
        { "ruled_line_capabilities", reinterpret_cast<getter>(SlipPrinterCapabilities_get_RuledLineCapabilities), nullptr, nullptr, nullptr },
        { "supported_barcode_rotations", reinterpret_cast<getter>(SlipPrinterCapabilities_get_SupportedBarcodeRotations), nullptr, nullptr, nullptr },
        { "supported_bitmap_rotations", reinterpret_cast<getter>(SlipPrinterCapabilities_get_SupportedBitmapRotations), nullptr, nullptr, nullptr },
        { "is_both_sides_printing_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsBothSidesPrintingSupported), nullptr, nullptr, nullptr },
        { "is_full_length_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsFullLengthSupported), nullptr, nullptr, nullptr },
        { "is_reverse_paper_feed_by_line_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsReversePaperFeedByLineSupported), nullptr, nullptr, nullptr },
        { "is_reverse_paper_feed_by_map_mode_unit_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsReversePaperFeedByMapModeUnitSupported), nullptr, nullptr, nullptr },
        { "is_reverse_video_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsReverseVideoSupported), nullptr, nullptr, nullptr },
        { "is_strikethrough_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsStrikethroughSupported), nullptr, nullptr, nullptr },
        { "is_subscript_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsSubscriptSupported), nullptr, nullptr, nullptr },
        { "is_superscript_supported", reinterpret_cast<getter>(SlipPrinterCapabilities_get_IsSuperscriptSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SlipPrinterCapabilities[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SlipPrinterCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SlipPrinterCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SlipPrinterCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SlipPrinterCapabilities) },
        { }
    };

    static PyType_Spec type_spec_SlipPrinterCapabilities = {
        "winrt._winrt_windows_devices_pointofservice.SlipPrinterCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::SlipPrinterCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SlipPrinterCapabilities};

    // ----- UnifiedPosErrorData class --------------------

    static PyObject* _new_UnifiedPosErrorData(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::UnifiedPosErrorSeverity>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::UnifiedPosErrorReason>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);

                winrt::Windows::Devices::PointOfService::UnifiedPosErrorData instance{ param0, param1, param2, param3 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_UnifiedPosErrorData(py::wrapper::Windows::Devices::PointOfService::UnifiedPosErrorData* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UnifiedPosErrorData_get_ExtendedReason(py::wrapper::Windows::Devices::PointOfService::UnifiedPosErrorData* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.UnifiedPosErrorData", L"ExtendedReason"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExtendedReason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UnifiedPosErrorData_get_Message(py::wrapper::Windows::Devices::PointOfService::UnifiedPosErrorData* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.UnifiedPosErrorData", L"Message"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UnifiedPosErrorData_get_Reason(py::wrapper::Windows::Devices::PointOfService::UnifiedPosErrorData* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.UnifiedPosErrorData", L"Reason"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UnifiedPosErrorData_get_Severity(py::wrapper::Windows::Devices::PointOfService::UnifiedPosErrorData* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.UnifiedPosErrorData", L"Severity"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Severity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_UnifiedPosErrorData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::UnifiedPosErrorData>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_UnifiedPosErrorData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::UnifiedPosErrorData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UnifiedPosErrorData[] = {
        { "_assign_array_", _assign_array_UnifiedPosErrorData, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UnifiedPosErrorData), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UnifiedPosErrorData[] = {
        { "extended_reason", reinterpret_cast<getter>(UnifiedPosErrorData_get_ExtendedReason), nullptr, nullptr, nullptr },
        { "message", reinterpret_cast<getter>(UnifiedPosErrorData_get_Message), nullptr, nullptr, nullptr },
        { "reason", reinterpret_cast<getter>(UnifiedPosErrorData_get_Reason), nullptr, nullptr, nullptr },
        { "severity", reinterpret_cast<getter>(UnifiedPosErrorData_get_Severity), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UnifiedPosErrorData[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_UnifiedPosErrorData) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_UnifiedPosErrorData) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_UnifiedPosErrorData) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_UnifiedPosErrorData) },
        { }
    };

    static PyType_Spec type_spec_UnifiedPosErrorData = {
        "winrt._winrt_windows_devices_pointofservice.UnifiedPosErrorData",
        sizeof(py::wrapper::Windows::Devices::PointOfService::UnifiedPosErrorData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UnifiedPosErrorData};

    // ----- ICashDrawerEventSourceEventArgs interface --------------------

    static PyObject* _new_ICashDrawerEventSourceEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::ICashDrawerEventSourceEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::ICashDrawerEventSourceEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ICashDrawerEventSourceEventArgs(py::wrapper::Windows::Devices::PointOfService::ICashDrawerEventSourceEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICashDrawerEventSourceEventArgs_get_CashDrawer(py::wrapper::Windows::Devices::PointOfService::ICashDrawerEventSourceEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICashDrawerEventSourceEventArgs", L"CashDrawer"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CashDrawer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ICashDrawerEventSourceEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::ICashDrawerEventSourceEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICashDrawerEventSourceEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ICashDrawerEventSourceEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICashDrawerEventSourceEventArgs[] = {
        { "_assign_array_", _assign_array_ICashDrawerEventSourceEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICashDrawerEventSourceEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICashDrawerEventSourceEventArgs[] = {
        { "cash_drawer", reinterpret_cast<getter>(ICashDrawerEventSourceEventArgs_get_CashDrawer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ICashDrawerEventSourceEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICashDrawerEventSourceEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICashDrawerEventSourceEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICashDrawerEventSourceEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICashDrawerEventSourceEventArgs) },
        { }
    };

    static PyType_Spec type_spec_ICashDrawerEventSourceEventArgs = {
        "winrt._winrt_windows_devices_pointofservice.ICashDrawerEventSourceEventArgs",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ICashDrawerEventSourceEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICashDrawerEventSourceEventArgs};

    // ----- ICommonClaimedPosPrinterStation interface --------------------

    static PyObject* _new_ICommonClaimedPosPrinterStation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation>::type_name);
        return nullptr;
    }

    static void _dealloc_ICommonClaimedPosPrinterStation(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICommonClaimedPosPrinterStation_ValidateData(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.ICommonClaimedPosPrinterStation", L"ValidateData", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ValidateData(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_CharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonClaimedPosPrinterStation", L"CharactersPerLine"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CharactersPerLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ICommonClaimedPosPrinterStation_put_CharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonClaimedPosPrinterStation", L"CharactersPerLine"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.CharactersPerLine(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_ColorCartridge(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonClaimedPosPrinterStation", L"ColorCartridge"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ColorCartridge());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ICommonClaimedPosPrinterStation_put_ColorCartridge(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonClaimedPosPrinterStation", L"ColorCartridge"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterColorCartridge>(arg);

            self->obj.ColorCartridge(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_IsCartridgeEmpty(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonClaimedPosPrinterStation", L"IsCartridgeEmpty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsCartridgeEmpty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_IsCartridgeRemoved(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonClaimedPosPrinterStation", L"IsCartridgeRemoved"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsCartridgeRemoved());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_IsCoverOpen(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonClaimedPosPrinterStation", L"IsCoverOpen"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsCoverOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_IsHeadCleaning(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonClaimedPosPrinterStation", L"IsHeadCleaning"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsHeadCleaning());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_IsLetterQuality(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonClaimedPosPrinterStation", L"IsLetterQuality"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsLetterQuality());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ICommonClaimedPosPrinterStation_put_IsLetterQuality(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonClaimedPosPrinterStation", L"IsLetterQuality"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsLetterQuality(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_IsPaperEmpty(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonClaimedPosPrinterStation", L"IsPaperEmpty"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPaperEmpty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_IsPaperNearEnd(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonClaimedPosPrinterStation", L"IsPaperNearEnd"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPaperNearEnd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_IsReadyToPrint(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonClaimedPosPrinterStation", L"IsReadyToPrint"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsReadyToPrint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_LineHeight(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonClaimedPosPrinterStation", L"LineHeight"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LineHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ICommonClaimedPosPrinterStation_put_LineHeight(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonClaimedPosPrinterStation", L"LineHeight"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.LineHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_LineSpacing(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonClaimedPosPrinterStation", L"LineSpacing"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LineSpacing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ICommonClaimedPosPrinterStation_put_LineSpacing(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonClaimedPosPrinterStation", L"LineSpacing"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.LineSpacing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ICommonClaimedPosPrinterStation_get_LineWidth(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonClaimedPosPrinterStation", L"LineWidth"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LineWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ICommonClaimedPosPrinterStation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICommonClaimedPosPrinterStation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICommonClaimedPosPrinterStation[] = {
        { "validate_data", reinterpret_cast<PyCFunction>(ICommonClaimedPosPrinterStation_ValidateData), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ICommonClaimedPosPrinterStation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICommonClaimedPosPrinterStation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICommonClaimedPosPrinterStation[] = {
        { "characters_per_line", reinterpret_cast<getter>(ICommonClaimedPosPrinterStation_get_CharactersPerLine), reinterpret_cast<setter>(ICommonClaimedPosPrinterStation_put_CharactersPerLine), nullptr, nullptr },
        { "color_cartridge", reinterpret_cast<getter>(ICommonClaimedPosPrinterStation_get_ColorCartridge), reinterpret_cast<setter>(ICommonClaimedPosPrinterStation_put_ColorCartridge), nullptr, nullptr },
        { "is_cartridge_empty", reinterpret_cast<getter>(ICommonClaimedPosPrinterStation_get_IsCartridgeEmpty), nullptr, nullptr, nullptr },
        { "is_cartridge_removed", reinterpret_cast<getter>(ICommonClaimedPosPrinterStation_get_IsCartridgeRemoved), nullptr, nullptr, nullptr },
        { "is_cover_open", reinterpret_cast<getter>(ICommonClaimedPosPrinterStation_get_IsCoverOpen), nullptr, nullptr, nullptr },
        { "is_head_cleaning", reinterpret_cast<getter>(ICommonClaimedPosPrinterStation_get_IsHeadCleaning), nullptr, nullptr, nullptr },
        { "is_letter_quality", reinterpret_cast<getter>(ICommonClaimedPosPrinterStation_get_IsLetterQuality), reinterpret_cast<setter>(ICommonClaimedPosPrinterStation_put_IsLetterQuality), nullptr, nullptr },
        { "is_paper_empty", reinterpret_cast<getter>(ICommonClaimedPosPrinterStation_get_IsPaperEmpty), nullptr, nullptr, nullptr },
        { "is_paper_near_end", reinterpret_cast<getter>(ICommonClaimedPosPrinterStation_get_IsPaperNearEnd), nullptr, nullptr, nullptr },
        { "is_ready_to_print", reinterpret_cast<getter>(ICommonClaimedPosPrinterStation_get_IsReadyToPrint), nullptr, nullptr, nullptr },
        { "line_height", reinterpret_cast<getter>(ICommonClaimedPosPrinterStation_get_LineHeight), reinterpret_cast<setter>(ICommonClaimedPosPrinterStation_put_LineHeight), nullptr, nullptr },
        { "line_spacing", reinterpret_cast<getter>(ICommonClaimedPosPrinterStation_get_LineSpacing), reinterpret_cast<setter>(ICommonClaimedPosPrinterStation_put_LineSpacing), nullptr, nullptr },
        { "line_width", reinterpret_cast<getter>(ICommonClaimedPosPrinterStation_get_LineWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ICommonClaimedPosPrinterStation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICommonClaimedPosPrinterStation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICommonClaimedPosPrinterStation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICommonClaimedPosPrinterStation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICommonClaimedPosPrinterStation) },
        { }
    };

    static PyType_Spec type_spec_ICommonClaimedPosPrinterStation = {
        "winrt._winrt_windows_devices_pointofservice.ICommonClaimedPosPrinterStation",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ICommonClaimedPosPrinterStation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICommonClaimedPosPrinterStation};

    // ----- ICommonPosPrintStationCapabilities interface --------------------

    static PyObject* _new_ICommonPosPrintStationCapabilities(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities>::type_name);
        return nullptr;
    }

    static void _dealloc_ICommonPosPrintStationCapabilities(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_CartridgeSensors(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"CartridgeSensors"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CartridgeSensors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_ColorCartridgeCapabilities(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"ColorCartridgeCapabilities"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ColorCartridgeCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsBoldSupported(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsBoldSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsBoldSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsDoubleHighDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsDoubleHighDoubleWidePrintSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDoubleHighDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsDoubleHighPrintSupported(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsDoubleHighPrintSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDoubleHighPrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsDoubleWidePrintSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsDualColorSupported(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsDualColorSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDualColorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsItalicSupported(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsItalicSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsItalicSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsPaperEmptySensorSupported(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsPaperEmptySensorSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPaperEmptySensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsPaperNearEndSensorSupported(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsPaperNearEndSensorSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPaperNearEndSensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsPrinterPresent(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsPrinterPresent"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPrinterPresent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_IsUnderlineSupported(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsUnderlineSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsUnderlineSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonPosPrintStationCapabilities_get_SupportedCharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"SupportedCharactersPerLine"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedCharactersPerLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ICommonPosPrintStationCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICommonPosPrintStationCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICommonPosPrintStationCapabilities[] = {
        { "_assign_array_", _assign_array_ICommonPosPrintStationCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICommonPosPrintStationCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICommonPosPrintStationCapabilities[] = {
        { "cartridge_sensors", reinterpret_cast<getter>(ICommonPosPrintStationCapabilities_get_CartridgeSensors), nullptr, nullptr, nullptr },
        { "color_cartridge_capabilities", reinterpret_cast<getter>(ICommonPosPrintStationCapabilities_get_ColorCartridgeCapabilities), nullptr, nullptr, nullptr },
        { "is_bold_supported", reinterpret_cast<getter>(ICommonPosPrintStationCapabilities_get_IsBoldSupported), nullptr, nullptr, nullptr },
        { "is_double_high_double_wide_print_supported", reinterpret_cast<getter>(ICommonPosPrintStationCapabilities_get_IsDoubleHighDoubleWidePrintSupported), nullptr, nullptr, nullptr },
        { "is_double_high_print_supported", reinterpret_cast<getter>(ICommonPosPrintStationCapabilities_get_IsDoubleHighPrintSupported), nullptr, nullptr, nullptr },
        { "is_double_wide_print_supported", reinterpret_cast<getter>(ICommonPosPrintStationCapabilities_get_IsDoubleWidePrintSupported), nullptr, nullptr, nullptr },
        { "is_dual_color_supported", reinterpret_cast<getter>(ICommonPosPrintStationCapabilities_get_IsDualColorSupported), nullptr, nullptr, nullptr },
        { "is_italic_supported", reinterpret_cast<getter>(ICommonPosPrintStationCapabilities_get_IsItalicSupported), nullptr, nullptr, nullptr },
        { "is_paper_empty_sensor_supported", reinterpret_cast<getter>(ICommonPosPrintStationCapabilities_get_IsPaperEmptySensorSupported), nullptr, nullptr, nullptr },
        { "is_paper_near_end_sensor_supported", reinterpret_cast<getter>(ICommonPosPrintStationCapabilities_get_IsPaperNearEndSensorSupported), nullptr, nullptr, nullptr },
        { "is_printer_present", reinterpret_cast<getter>(ICommonPosPrintStationCapabilities_get_IsPrinterPresent), nullptr, nullptr, nullptr },
        { "is_underline_supported", reinterpret_cast<getter>(ICommonPosPrintStationCapabilities_get_IsUnderlineSupported), nullptr, nullptr, nullptr },
        { "supported_characters_per_line", reinterpret_cast<getter>(ICommonPosPrintStationCapabilities_get_SupportedCharactersPerLine), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ICommonPosPrintStationCapabilities[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICommonPosPrintStationCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICommonPosPrintStationCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICommonPosPrintStationCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICommonPosPrintStationCapabilities) },
        { }
    };

    static PyType_Spec type_spec_ICommonPosPrintStationCapabilities = {
        "winrt._winrt_windows_devices_pointofservice.ICommonPosPrintStationCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ICommonPosPrintStationCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICommonPosPrintStationCapabilities};

    // ----- ICommonReceiptSlipCapabilities interface --------------------

    static PyObject* _new_ICommonReceiptSlipCapabilities(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities>::type_name);
        return nullptr;
    }

    static void _dealloc_ICommonReceiptSlipCapabilities(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_Is180RotationSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonReceiptSlipCapabilities", L"Is180RotationSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Is180RotationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsBarcodeSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonReceiptSlipCapabilities", L"IsBarcodeSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsBarcodeSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsBitmapSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonReceiptSlipCapabilities", L"IsBitmapSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsBitmapSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsLeft90RotationSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonReceiptSlipCapabilities", L"IsLeft90RotationSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsLeft90RotationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsPrintAreaSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonReceiptSlipCapabilities", L"IsPrintAreaSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPrintAreaSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsRight90RotationSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonReceiptSlipCapabilities", L"IsRight90RotationSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsRight90RotationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_RuledLineCapabilities(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonReceiptSlipCapabilities", L"RuledLineCapabilities"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RuledLineCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_SupportedBarcodeRotations(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonReceiptSlipCapabilities", L"SupportedBarcodeRotations"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedBarcodeRotations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_SupportedBitmapRotations(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonReceiptSlipCapabilities", L"SupportedBitmapRotations"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedBitmapRotations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_CartridgeSensors(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"CartridgeSensors"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CartridgeSensors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_ColorCartridgeCapabilities(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"ColorCartridgeCapabilities"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ColorCartridgeCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsBoldSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsBoldSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsBoldSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsDoubleHighDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsDoubleHighDoubleWidePrintSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDoubleHighDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsDoubleHighPrintSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsDoubleHighPrintSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDoubleHighPrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsDoubleWidePrintSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsDoubleWidePrintSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDoubleWidePrintSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsDualColorSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsDualColorSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsDualColorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsItalicSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsItalicSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsItalicSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsPaperEmptySensorSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsPaperEmptySensorSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPaperEmptySensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsPaperNearEndSensorSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsPaperNearEndSensorSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPaperNearEndSensorSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsPrinterPresent(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsPrinterPresent"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPrinterPresent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_IsUnderlineSupported(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"IsUnderlineSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsUnderlineSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommonReceiptSlipCapabilities_get_SupportedCharactersPerLine(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.PointOfService.ICommonPosPrintStationCapabilities", L"SupportedCharactersPerLine"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedCharactersPerLine());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ICommonReceiptSlipCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICommonReceiptSlipCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICommonReceiptSlipCapabilities[] = {
        { "_assign_array_", _assign_array_ICommonReceiptSlipCapabilities, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICommonReceiptSlipCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICommonReceiptSlipCapabilities[] = {
        { "is180_rotation_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_Is180RotationSupported), nullptr, nullptr, nullptr },
        { "is_barcode_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsBarcodeSupported), nullptr, nullptr, nullptr },
        { "is_bitmap_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsBitmapSupported), nullptr, nullptr, nullptr },
        { "is_left90_rotation_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsLeft90RotationSupported), nullptr, nullptr, nullptr },
        { "is_print_area_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsPrintAreaSupported), nullptr, nullptr, nullptr },
        { "is_right90_rotation_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsRight90RotationSupported), nullptr, nullptr, nullptr },
        { "ruled_line_capabilities", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_RuledLineCapabilities), nullptr, nullptr, nullptr },
        { "supported_barcode_rotations", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_SupportedBarcodeRotations), nullptr, nullptr, nullptr },
        { "supported_bitmap_rotations", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_SupportedBitmapRotations), nullptr, nullptr, nullptr },
        { "cartridge_sensors", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_CartridgeSensors), nullptr, nullptr, nullptr },
        { "color_cartridge_capabilities", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_ColorCartridgeCapabilities), nullptr, nullptr, nullptr },
        { "is_bold_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsBoldSupported), nullptr, nullptr, nullptr },
        { "is_double_high_double_wide_print_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsDoubleHighDoubleWidePrintSupported), nullptr, nullptr, nullptr },
        { "is_double_high_print_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsDoubleHighPrintSupported), nullptr, nullptr, nullptr },
        { "is_double_wide_print_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsDoubleWidePrintSupported), nullptr, nullptr, nullptr },
        { "is_dual_color_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsDualColorSupported), nullptr, nullptr, nullptr },
        { "is_italic_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsItalicSupported), nullptr, nullptr, nullptr },
        { "is_paper_empty_sensor_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsPaperEmptySensorSupported), nullptr, nullptr, nullptr },
        { "is_paper_near_end_sensor_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsPaperNearEndSensorSupported), nullptr, nullptr, nullptr },
        { "is_printer_present", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsPrinterPresent), nullptr, nullptr, nullptr },
        { "is_underline_supported", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_IsUnderlineSupported), nullptr, nullptr, nullptr },
        { "supported_characters_per_line", reinterpret_cast<getter>(ICommonReceiptSlipCapabilities_get_SupportedCharactersPerLine), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ICommonReceiptSlipCapabilities[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICommonReceiptSlipCapabilities) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICommonReceiptSlipCapabilities) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICommonReceiptSlipCapabilities) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICommonReceiptSlipCapabilities) },
        { }
    };

    static PyType_Spec type_spec_ICommonReceiptSlipCapabilities = {
        "winrt._winrt_windows_devices_pointofservice.ICommonReceiptSlipCapabilities",
        sizeof(py::wrapper::Windows::Devices::PointOfService::ICommonReceiptSlipCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICommonReceiptSlipCapabilities};

    // ----- IPosPrinterJob interface --------------------

    static PyObject* _new_IPosPrinterJob(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::IPosPrinterJob>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::IPosPrinterJob>::type_name);
        return nullptr;
    }

    static void _dealloc_IPosPrinterJob(py::wrapper::Windows::Devices::PointOfService::IPosPrinterJob* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPosPrinterJob_ExecuteAsync(py::wrapper::Windows::Devices::PointOfService::IPosPrinterJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IPosPrinterJob", L"ExecuteAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ExecuteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPosPrinterJob_Print(py::wrapper::Windows::Devices::PointOfService::IPosPrinterJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IPosPrinterJob", L"Print", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Print(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IPosPrinterJob_PrintLine(py::wrapper::Windows::Devices::PointOfService::IPosPrinterJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IPosPrinterJob", L"PrintLine", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.PrintLine();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IPosPrinterJob", L"PrintLine", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.PrintLine(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IPosPrinterJob(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::IPosPrinterJob>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IPosPrinterJob(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::IPosPrinterJob>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPosPrinterJob[] = {
        { "execute_async", reinterpret_cast<PyCFunction>(IPosPrinterJob_ExecuteAsync), METH_VARARGS, nullptr },
        { "print", reinterpret_cast<PyCFunction>(IPosPrinterJob_Print), METH_VARARGS, nullptr },
        { "print_line", reinterpret_cast<PyCFunction>(IPosPrinterJob_PrintLine), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IPosPrinterJob, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IPosPrinterJob), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IPosPrinterJob[] = {
        { }
    };

    static PyType_Slot _type_slots_IPosPrinterJob[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IPosPrinterJob) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IPosPrinterJob) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IPosPrinterJob) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IPosPrinterJob) },
        { }
    };

    static PyType_Spec type_spec_IPosPrinterJob = {
        "winrt._winrt_windows_devices_pointofservice.IPosPrinterJob",
        sizeof(py::wrapper::Windows::Devices::PointOfService::IPosPrinterJob),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPosPrinterJob};

    // ----- IReceiptOrSlipJob interface --------------------

    static PyObject* _new_IReceiptOrSlipJob(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::PointOfService::IReceiptOrSlipJob>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::PointOfService::IReceiptOrSlipJob>::type_name);
        return nullptr;
    }

    static void _dealloc_IReceiptOrSlipJob(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IReceiptOrSlipJob_DrawRuledLine(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IReceiptOrSlipJob", L"DrawRuledLine", 5))
                {
                    py::set_arg_count_version_error(5);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterLineDirection>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterLineStyle>(args, 3);
                auto param4 = py::convert_to<uint32_t>(args, 4);

                self->obj.DrawRuledLine(param0, param1, param2, param3, param4);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_ExecuteAsync(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IPosPrinterJob", L"ExecuteAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ExecuteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_Print(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IPosPrinterJob", L"Print", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Print(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_PrintBarcode(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IReceiptOrSlipJob", L"PrintBarcode", 6))
                {
                    py::set_arg_count_version_error(6);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterBarcodeTextPosition>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 5);

                self->obj.PrintBarcode(param0, param1, param2, param3, param4, param5);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_PrintBarcodeCustomAlign(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IReceiptOrSlipJob", L"PrintBarcodeCustomAlign", 6))
                {
                    py::set_arg_count_version_error(6);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterBarcodeTextPosition>(args, 4);
                auto param5 = py::convert_to<uint32_t>(args, 5);

                self->obj.PrintBarcodeCustomAlign(param0, param1, param2, param3, param4, param5);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_PrintBitmap(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IReceiptOrSlipJob", L"PrintBitmap", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 1);

                self->obj.PrintBitmap(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IReceiptOrSlipJob", L"PrintBitmap", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.PrintBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_PrintCustomAlignedBitmap(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IReceiptOrSlipJob", L"PrintCustomAlignedBitmap", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                self->obj.PrintCustomAlignedBitmap(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IReceiptOrSlipJob", L"PrintCustomAlignedBitmap", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.PrintCustomAlignedBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_PrintLine(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IPosPrinterJob", L"PrintLine", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.PrintLine();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IPosPrinterJob", L"PrintLine", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.PrintLine(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_PrintSavedBitmap(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IReceiptOrSlipJob", L"PrintSavedBitmap", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.PrintSavedBitmap(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_SetBarcodeRotation(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IReceiptOrSlipJob", L"SetBarcodeRotation", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterRotation>(args, 0);

                self->obj.SetBarcodeRotation(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_SetBitmap(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IReceiptOrSlipJob", L"SetBitmap", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 2);

                self->obj.SetBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IReceiptOrSlipJob", L"SetBitmap", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterAlignment>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);

                self->obj.SetBitmap(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_SetCustomAlignedBitmap(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IReceiptOrSlipJob", L"SetCustomAlignedBitmap", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                self->obj.SetCustomAlignedBitmap(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IReceiptOrSlipJob", L"SetCustomAlignedBitmap", 4))
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFrame>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);

                self->obj.SetCustomAlignedBitmap(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_SetPrintArea(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IReceiptOrSlipJob", L"SetPrintArea", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                self->obj.SetPrintArea(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IReceiptOrSlipJob_SetPrintRotation(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.PointOfService.IReceiptOrSlipJob", L"SetPrintRotation", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::PointOfService::PosPrinterRotation>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                self->obj.SetPrintRotation(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IReceiptOrSlipJob(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::IReceiptOrSlipJob>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IReceiptOrSlipJob(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::PointOfService::IReceiptOrSlipJob>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IReceiptOrSlipJob[] = {
        { "draw_ruled_line", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_DrawRuledLine), METH_VARARGS, nullptr },
        { "execute_async", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_ExecuteAsync), METH_VARARGS, nullptr },
        { "print", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_Print), METH_VARARGS, nullptr },
        { "print_barcode", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_PrintBarcode), METH_VARARGS, nullptr },
        { "print_barcode_custom_align", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_PrintBarcodeCustomAlign), METH_VARARGS, nullptr },
        { "print_bitmap", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_PrintBitmap), METH_VARARGS, nullptr },
        { "print_custom_aligned_bitmap", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_PrintCustomAlignedBitmap), METH_VARARGS, nullptr },
        { "print_line", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_PrintLine), METH_VARARGS, nullptr },
        { "print_saved_bitmap", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_PrintSavedBitmap), METH_VARARGS, nullptr },
        { "set_barcode_rotation", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_SetBarcodeRotation), METH_VARARGS, nullptr },
        { "set_bitmap", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_SetBitmap), METH_VARARGS, nullptr },
        { "set_custom_aligned_bitmap", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_SetCustomAlignedBitmap), METH_VARARGS, nullptr },
        { "set_print_area", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_SetPrintArea), METH_VARARGS, nullptr },
        { "set_print_rotation", reinterpret_cast<PyCFunction>(IReceiptOrSlipJob_SetPrintRotation), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IReceiptOrSlipJob, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IReceiptOrSlipJob), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IReceiptOrSlipJob[] = {
        { }
    };

    static PyType_Slot _type_slots_IReceiptOrSlipJob[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IReceiptOrSlipJob) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IReceiptOrSlipJob) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IReceiptOrSlipJob) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IReceiptOrSlipJob) },
        { }
    };

    static PyType_Spec type_spec_IReceiptOrSlipJob = {
        "winrt._winrt_windows_devices_pointofservice.IReceiptOrSlipJob",
        sizeof(py::wrapper::Windows::Devices::PointOfService::IReceiptOrSlipJob),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IReceiptOrSlipJob};

    // ----- SizeUInt32 struct --------------------

    winrt_struct_wrapper<winrt::Windows::Devices::PointOfService::SizeUInt32>* _new_SizeUInt32(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Devices::PointOfService::SizeUInt32>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_SizeUInt32(winrt_struct_wrapper<winrt::Windows::Devices::PointOfService::SizeUInt32>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        uint32_t _Width{};
        uint32_t _Height{};

        static const char* kwlist[] = {"width", "height", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "II", const_cast<char**>(kwlist), &_Width, &_Height))
        {
            return -1;
        }

        try
        {
            self->obj.Width = _Width;
            self->obj.Height = _Height;

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_SizeUInt32(py::wrapper::Windows::Devices::PointOfService::SizeUInt32* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SizeUInt32(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::PointOfService::SizeUInt32>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_SizeUInt32[] = {
        { "_assign_array_", _assign_array_SizeUInt32, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* SizeUInt32_get_Width(py::wrapper::Windows::Devices::PointOfService::SizeUInt32* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SizeUInt32_set_Width(py::wrapper::Windows::Devices::PointOfService::SizeUInt32* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Width = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SizeUInt32_get_Height(py::wrapper::Windows::Devices::PointOfService::SizeUInt32* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SizeUInt32_set_Height(py::wrapper::Windows::Devices::PointOfService::SizeUInt32* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Height = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_SizeUInt32[] = {
        { "width", reinterpret_cast<getter>(SizeUInt32_get_Width), reinterpret_cast<setter>(SizeUInt32_set_Width), nullptr, nullptr },
        { "height", reinterpret_cast<getter>(SizeUInt32_get_Height), reinterpret_cast<setter>(SizeUInt32_set_Height), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SizeUInt32[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SizeUInt32) },
        { Py_tp_init, reinterpret_cast<void*>(_init_SizeUInt32) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SizeUInt32) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SizeUInt32) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SizeUInt32) },
        { }
    };

    static PyType_Spec type_spec_SizeUInt32 = {
        "winrt._winrt_windows_devices_pointofservice.SizeUInt32",
        sizeof(py::wrapper::Windows::Devices::PointOfService::SizeUInt32),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SizeUInt32};

    // ----- Windows.Devices.PointOfService Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Devices.PointOfService");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_devices_pointofservice",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Devices::PointOfService

PyMODINIT_FUNC PyInit__winrt_windows_devices_pointofservice(void) noexcept
{
    using namespace py::cpp::Windows::Devices::PointOfService;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_BarcodeScanner_Static{PyType_FromSpec(&type_spec_BarcodeScanner_Static)};
    if (!type_BarcodeScanner_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BarcodeScanner, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BarcodeScanner_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BarcodeScannerCapabilities, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BarcodeScannerDataReceivedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BarcodeScannerErrorOccurredEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BarcodeScannerImagePreviewReceivedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BarcodeScannerReport, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BarcodeScannerStatusUpdatedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_BarcodeSymbologies_Static{PyType_FromSpec(&type_spec_BarcodeSymbologies_Static)};
    if (!type_BarcodeSymbologies_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BarcodeSymbologies, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BarcodeSymbologies_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BarcodeSymbologyAttributes, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_CashDrawer_Static{PyType_FromSpec(&type_spec_CashDrawer_Static)};
    if (!type_CashDrawer_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CashDrawer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CashDrawer_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CashDrawerCapabilities, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CashDrawerCloseAlarm, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CashDrawerClosedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CashDrawerEventSource, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CashDrawerOpenedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CashDrawerStatus, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CashDrawerStatusUpdatedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ClaimedBarcodeScanner, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ClaimedBarcodeScannerClosedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ClaimedCashDrawer, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ClaimedCashDrawerClosedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ClaimedJournalPrinter, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ClaimedLineDisplay_Static{PyType_FromSpec(&type_spec_ClaimedLineDisplay_Static)};
    if (!type_ClaimedLineDisplay_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ClaimedLineDisplay, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ClaimedLineDisplay_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ClaimedLineDisplayClosedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ClaimedMagneticStripeReader, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ClaimedMagneticStripeReaderClosedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ClaimedPosPrinter, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ClaimedPosPrinterClosedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ClaimedReceiptPrinter, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ClaimedSlipPrinter, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_JournalPrintJob, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_JournalPrinterCapabilities, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_LineDisplay_Static{PyType_FromSpec(&type_spec_LineDisplay_Static)};
    if (!type_LineDisplay_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LineDisplay, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_LineDisplay_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LineDisplayAttributes, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LineDisplayCapabilities, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LineDisplayCursor, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LineDisplayCursorAttributes, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LineDisplayCustomGlyphs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LineDisplayMarquee, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LineDisplayStatisticsCategorySelector, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LineDisplayStatusUpdatedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LineDisplayStoredBitmap, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LineDisplayWindow, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MagneticStripeReader_Static{PyType_FromSpec(&type_spec_MagneticStripeReader_Static)};
    if (!type_MagneticStripeReader_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MagneticStripeReader, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MagneticStripeReader_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MagneticStripeReaderAamvaCardDataReceivedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MagneticStripeReaderBankCardDataReceivedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MagneticStripeReaderCapabilities, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MagneticStripeReaderCardTypes_Static{PyType_FromSpec(&type_spec_MagneticStripeReaderCardTypes_Static)};
    if (!type_MagneticStripeReaderCardTypes_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MagneticStripeReaderCardTypes, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MagneticStripeReaderCardTypes_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_MagneticStripeReaderEncryptionAlgorithms_Static{PyType_FromSpec(&type_spec_MagneticStripeReaderEncryptionAlgorithms_Static)};
    if (!type_MagneticStripeReaderEncryptionAlgorithms_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MagneticStripeReaderEncryptionAlgorithms, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MagneticStripeReaderEncryptionAlgorithms_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MagneticStripeReaderErrorOccurredEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MagneticStripeReaderReport, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MagneticStripeReaderStatusUpdatedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MagneticStripeReaderTrackData, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MagneticStripeReaderVendorSpecificCardDataReceivedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_PosPrinter_Static{PyType_FromSpec(&type_spec_PosPrinter_Static)};
    if (!type_PosPrinter_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PosPrinter, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PosPrinter_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PosPrinterCapabilities, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_PosPrinterCharacterSetIds_Static{PyType_FromSpec(&type_spec_PosPrinterCharacterSetIds_Static)};
    if (!type_PosPrinterCharacterSetIds_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PosPrinterCharacterSetIds, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PosPrinterCharacterSetIds_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PosPrinterFontProperty, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PosPrinterPrintOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PosPrinterReleaseDeviceRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PosPrinterStatus, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PosPrinterStatusUpdatedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ReceiptPrintJob, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ReceiptPrinterCapabilities, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SlipPrintJob, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SlipPrinterCapabilities, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_UnifiedPosErrorData, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ICashDrawerEventSourceEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ICommonClaimedPosPrinterStation, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ICommonPosPrintStationCapabilities, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ICommonReceiptSlipCapabilities, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IPosPrinterJob, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IReceiptOrSlipJob, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SizeUInt32, nullptr, nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
