# WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

import datetime
import sys
import types
import typing
import uuid as _uuid
from builtins import property as _property

import winrt._winrt
import winrt.system
import winrt.windows.foundation
import winrt.windows.foundation.collections
import winrt.windows.networking.connectivity
import winrt.windows.security.credentials

from winrt.windows.devices.wifi import WiFiAccessStatus, WiFiConnectionMethod, WiFiConnectionStatus, WiFiNetworkKind, WiFiOnDemandHotspotAvailability, WiFiOnDemandHotspotCellularBars, WiFiOnDemandHotspotConnectStatus, WiFiPhyKind, WiFiReconnectionKind, WiFiWpsConfigurationStatus, WiFiWpsKind

Self = typing.TypeVar('Self')

@typing.final
class WiFiAdapter_Static(type):
    def find_all_adapters_async(cls) -> winrt.windows.foundation.IAsyncOperation[winrt.windows.foundation.collections.IVectorView[WiFiAdapter]]: ...
    def from_id_async(cls, device_id: str, /) -> winrt.windows.foundation.IAsyncOperation[WiFiAdapter]: ...
    def get_device_selector(cls) -> str: ...
    def request_access_async(cls) -> winrt.windows.foundation.IAsyncOperation[WiFiAccessStatus]: ...

@typing.final
class WiFiAdapter(winrt.system.Object, metaclass=WiFiAdapter_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WiFiAdapter: ...
    @typing.overload
    def connect_async(self, available_network: typing.Optional[WiFiAvailableNetwork], reconnection_kind: WiFiReconnectionKind, /) -> winrt.windows.foundation.IAsyncOperation[WiFiConnectionResult]: ...
    @typing.overload
    def connect_async(self, available_network: typing.Optional[WiFiAvailableNetwork], reconnection_kind: WiFiReconnectionKind, password_credential: typing.Optional[winrt.windows.security.credentials.PasswordCredential], /) -> winrt.windows.foundation.IAsyncOperation[WiFiConnectionResult]: ...
    @typing.overload
    def connect_async(self, available_network: typing.Optional[WiFiAvailableNetwork], reconnection_kind: WiFiReconnectionKind, password_credential: typing.Optional[winrt.windows.security.credentials.PasswordCredential], ssid: str, /) -> winrt.windows.foundation.IAsyncOperation[WiFiConnectionResult]: ...
    @typing.overload
    def connect_async(self, available_network: typing.Optional[WiFiAvailableNetwork], reconnection_kind: WiFiReconnectionKind, password_credential: typing.Optional[winrt.windows.security.credentials.PasswordCredential], ssid: str, connection_method: WiFiConnectionMethod, /) -> winrt.windows.foundation.IAsyncOperation[WiFiConnectionResult]: ...
    def disconnect(self) -> None: ...
    def get_wps_configuration_async(self, available_network: typing.Optional[WiFiAvailableNetwork], /) -> winrt.windows.foundation.IAsyncOperation[WiFiWpsConfigurationResult]: ...
    def scan_async(self) -> winrt.windows.foundation.IAsyncAction: ...
    def add_available_networks_changed(self, args: winrt.windows.foundation.TypedEventHandler[WiFiAdapter, winrt.system.Object], /) -> winrt.windows.foundation.EventRegistrationToken: ...
    def remove_available_networks_changed(self, event_cookie: winrt.windows.foundation.EventRegistrationToken, /) -> None: ...
    @_property
    def network_adapter(self) -> typing.Optional[winrt.windows.networking.connectivity.NetworkAdapter]: ...
    @_property
    def network_report(self) -> typing.Optional[WiFiNetworkReport]: ...

@typing.final
class WiFiAvailableNetwork(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WiFiAvailableNetwork: ...
    @_property
    def beacon_interval(self) -> datetime.timedelta: ...
    @_property
    def bssid(self) -> str: ...
    @_property
    def channel_center_frequency_in_kilohertz(self) -> winrt.system.Int32: ...
    @_property
    def is_wi_fi_direct(self) -> bool: ...
    @_property
    def network_kind(self) -> WiFiNetworkKind: ...
    @_property
    def network_rssi_in_decibel_milliwatts(self) -> winrt.system.Double: ...
    @_property
    def phy_kind(self) -> WiFiPhyKind: ...
    @_property
    def security_settings(self) -> typing.Optional[winrt.windows.networking.connectivity.NetworkSecuritySettings]: ...
    @_property
    def signal_bars(self) -> winrt.system.UInt8: ...
    @_property
    def ssid(self) -> str: ...
    @_property
    def uptime(self) -> datetime.timedelta: ...

@typing.final
class WiFiConnectionResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WiFiConnectionResult: ...
    @_property
    def connection_status(self) -> WiFiConnectionStatus: ...

@typing.final
class WiFiNetworkReport(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WiFiNetworkReport: ...
    @_property
    def available_networks(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[WiFiAvailableNetwork]]: ...
    @_property
    def timestamp(self) -> datetime.datetime: ...

@typing.final
class WiFiOnDemandHotspotConnectTriggerDetails(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WiFiOnDemandHotspotConnectTriggerDetails: ...
    def connect(self) -> typing.Optional[WiFiOnDemandHotspotConnectionResult]: ...
    def connect_async(self) -> winrt.windows.foundation.IAsyncOperation[WiFiOnDemandHotspotConnectionResult]: ...
    def report_error(self, status: WiFiOnDemandHotspotConnectStatus, /) -> None: ...
    @_property
    def requested_network(self) -> typing.Optional[WiFiOnDemandHotspotNetwork]: ...

@typing.final
class WiFiOnDemandHotspotConnectionResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WiFiOnDemandHotspotConnectionResult: ...
    @_property
    def status(self) -> WiFiOnDemandHotspotConnectStatus: ...

@typing.final
class WiFiOnDemandHotspotNetwork_Static(type):
    def get_or_create_by_id(cls, network_id: _uuid.UUID, /) -> typing.Optional[WiFiOnDemandHotspotNetwork]: ...

@typing.final
class WiFiOnDemandHotspotNetwork(winrt.system.Object, metaclass=WiFiOnDemandHotspotNetwork_Static):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WiFiOnDemandHotspotNetwork: ...
    def get_properties(self) -> typing.Optional[WiFiOnDemandHotspotNetworkProperties]: ...
    def update_properties(self, new_properties: typing.Optional[WiFiOnDemandHotspotNetworkProperties], /) -> None: ...
    @_property
    def id(self) -> _uuid.UUID: ...

@typing.final
class WiFiOnDemandHotspotNetworkProperties(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WiFiOnDemandHotspotNetworkProperties: ...
    @_property
    def ssid(self) -> str: ...
    @ssid.setter
    def ssid(self, value: str) -> None: ...
    @_property
    def remaining_battery_percent(self) -> typing.Optional[typing.Optional[winrt.system.UInt32]]: ...
    @remaining_battery_percent.setter
    def remaining_battery_percent(self, value: typing.Optional[typing.Optional[winrt.system.UInt32]]) -> None: ...
    @_property
    def password(self) -> typing.Optional[winrt.windows.security.credentials.PasswordCredential]: ...
    @password.setter
    def password(self, value: typing.Optional[winrt.windows.security.credentials.PasswordCredential]) -> None: ...
    @_property
    def is_metered(self) -> bool: ...
    @is_metered.setter
    def is_metered(self, value: bool) -> None: ...
    @_property
    def display_name(self) -> str: ...
    @display_name.setter
    def display_name(self, value: str) -> None: ...
    @_property
    def cellular_bars(self) -> typing.Optional[typing.Optional[WiFiOnDemandHotspotCellularBars]]: ...
    @cellular_bars.setter
    def cellular_bars(self, value: typing.Optional[typing.Optional[WiFiOnDemandHotspotCellularBars]]) -> None: ...
    @_property
    def availability(self) -> WiFiOnDemandHotspotAvailability: ...
    @availability.setter
    def availability(self, value: WiFiOnDemandHotspotAvailability) -> None: ...

@typing.final
class WiFiWpsConfigurationResult(winrt.system.Object):
    @staticmethod
    def _from(obj: winrt.system.Object, /) -> WiFiWpsConfigurationResult: ...
    @_property
    def status(self) -> WiFiWpsConfigurationStatus: ...
    @_property
    def supported_wps_kinds(self) -> typing.Optional[winrt.windows.foundation.collections.IVectorView[WiFiWpsKind]]: ...

