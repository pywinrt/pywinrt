// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "pybase.h"
#include "py.Windows.Graphics.Imaging.h"


namespace py::cpp::Windows::Graphics::Imaging
{
    // ----- BitmapBuffer class --------------------

    static PyObject* _new_BitmapBuffer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Imaging::BitmapBuffer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Imaging::BitmapBuffer>::type_name);
        return nullptr;
    }

    static void _dealloc_BitmapBuffer(py::wrapper::Windows::Graphics::Imaging::BitmapBuffer* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BitmapBuffer_Close(py::wrapper::Windows::Graphics::Imaging::BitmapBuffer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapBuffer", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapBuffer_CreateReference(py::wrapper::Windows::Graphics::Imaging::BitmapBuffer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapBuffer", L"CreateReference", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapBuffer_GetPlaneCount(py::wrapper::Windows::Graphics::Imaging::BitmapBuffer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapBuffer", L"GetPlaneCount", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetPlaneCount());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapBuffer_GetPlaneDescription(py::wrapper::Windows::Graphics::Imaging::BitmapBuffer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapBuffer", L"GetPlaneDescription", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.GetPlaneDescription(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_BitmapBuffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Imaging::BitmapBuffer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BitmapBuffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::BitmapBuffer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_BitmapBuffer(py::wrapper::Windows::Graphics::Imaging::BitmapBuffer* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_BitmapBuffer(py::wrapper::Windows::Graphics::Imaging::BitmapBuffer* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BitmapBuffer[] = {
        { "close", reinterpret_cast<PyCFunction>(BitmapBuffer_Close), METH_VARARGS, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(BitmapBuffer_CreateReference), METH_VARARGS, nullptr },
        { "get_plane_count", reinterpret_cast<PyCFunction>(BitmapBuffer_GetPlaneCount), METH_VARARGS, nullptr },
        { "get_plane_description", reinterpret_cast<PyCFunction>(BitmapBuffer_GetPlaneDescription), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BitmapBuffer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BitmapBuffer), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_BitmapBuffer), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_BitmapBuffer), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_BitmapBuffer[] = {
        { }
    };

    static PyType_Slot _type_slots_BitmapBuffer[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BitmapBuffer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BitmapBuffer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BitmapBuffer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BitmapBuffer) },
        { },
    };

    static PyType_Spec type_spec_BitmapBuffer =
    {
        "_winrt_windows_graphics_imaging.BitmapBuffer",
        sizeof(py::wrapper::Windows::Graphics::Imaging::BitmapBuffer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapBuffer
    };

    // ----- BitmapCodecInformation class --------------------

    static PyObject* _new_BitmapCodecInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Imaging::BitmapCodecInformation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Imaging::BitmapCodecInformation>::type_name);
        return nullptr;
    }

    static void _dealloc_BitmapCodecInformation(py::wrapper::Windows::Graphics::Imaging::BitmapCodecInformation* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BitmapCodecInformation_get_CodecId(py::wrapper::Windows::Graphics::Imaging::BitmapCodecInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapCodecInformation", L"CodecId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CodecId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapCodecInformation_get_FileExtensions(py::wrapper::Windows::Graphics::Imaging::BitmapCodecInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapCodecInformation", L"FileExtensions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FileExtensions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapCodecInformation_get_FriendlyName(py::wrapper::Windows::Graphics::Imaging::BitmapCodecInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapCodecInformation", L"FriendlyName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapCodecInformation_get_MimeTypes(py::wrapper::Windows::Graphics::Imaging::BitmapCodecInformation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapCodecInformation", L"MimeTypes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MimeTypes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BitmapCodecInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Imaging::BitmapCodecInformation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BitmapCodecInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::BitmapCodecInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BitmapCodecInformation[] = {
        { "_assign_array_", _assign_array_BitmapCodecInformation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BitmapCodecInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BitmapCodecInformation[] = {
        { "codec_id", reinterpret_cast<getter>(BitmapCodecInformation_get_CodecId), nullptr, nullptr, nullptr },
        { "file_extensions", reinterpret_cast<getter>(BitmapCodecInformation_get_FileExtensions), nullptr, nullptr, nullptr },
        { "friendly_name", reinterpret_cast<getter>(BitmapCodecInformation_get_FriendlyName), nullptr, nullptr, nullptr },
        { "mime_types", reinterpret_cast<getter>(BitmapCodecInformation_get_MimeTypes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BitmapCodecInformation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BitmapCodecInformation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BitmapCodecInformation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BitmapCodecInformation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BitmapCodecInformation) },
        { },
    };

    static PyType_Spec type_spec_BitmapCodecInformation =
    {
        "_winrt_windows_graphics_imaging.BitmapCodecInformation",
        sizeof(py::wrapper::Windows::Graphics::Imaging::BitmapCodecInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapCodecInformation
    };

    // ----- BitmapDecoder class --------------------

    static PyObject* _new_BitmapDecoder(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Imaging::BitmapDecoder>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Imaging::BitmapDecoder>::type_name);
        return nullptr;
    }

    static void _dealloc_BitmapDecoder(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BitmapDecoder_CreateAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapDecoder", L"CreateAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);

                return py::convert(winrt::Windows::Graphics::Imaging::BitmapDecoder::CreateAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapDecoder", L"CreateAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                return py::convert(winrt::Windows::Graphics::Imaging::BitmapDecoder::CreateAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_GetDecoderInformationEnumerator(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapDecoder", L"GetDecoderInformationEnumerator", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Graphics::Imaging::BitmapDecoder::GetDecoderInformationEnumerator());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_GetFrameAsync(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapDecoder", L"GetFrameAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetFrameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_GetPixelDataAsync(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapDecoder", L"GetPixelDataAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetPixelDataAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapDecoder", L"GetPixelDataAsync", 5))
            {
                py::set_arg_count_version_error(5);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTransform>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::ExifOrientationMode>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::ColorManagementMode>(args, 4);

                return py::convert(self->obj.GetPixelDataAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_GetPreviewAsync(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapDecoder", L"GetPreviewAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetPreviewAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_GetSoftwareBitmapAsync(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapDecoder", L"GetSoftwareBitmapAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetSoftwareBitmapAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapDecoder", L"GetSoftwareBitmapAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);

                return py::convert(self->obj.GetSoftwareBitmapAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapDecoder", L"GetSoftwareBitmapAsync", 5))
            {
                py::set_arg_count_version_error(5);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTransform>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::ExifOrientationMode>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::ColorManagementMode>(args, 4);

                return py::convert(self->obj.GetSoftwareBitmapAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_GetThumbnailAsync(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapDecoder", L"GetThumbnailAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetThumbnailAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_BitmapContainerProperties(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapDecoder", L"BitmapContainerProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BitmapContainerProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_DecoderInformation(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapDecoder", L"DecoderInformation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DecoderInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_FrameCount(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapDecoder", L"FrameCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FrameCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_BitmapAlphaMode(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapDecoder", L"BitmapAlphaMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BitmapAlphaMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_BitmapPixelFormat(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapDecoder", L"BitmapPixelFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BitmapPixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_BitmapProperties(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapDecoder", L"BitmapProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BitmapProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_DpiX(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapDecoder", L"DpiX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DpiX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_DpiY(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapDecoder", L"DpiY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DpiY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_OrientedPixelHeight(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapDecoder", L"OrientedPixelHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OrientedPixelHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_OrientedPixelWidth(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapDecoder", L"OrientedPixelWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OrientedPixelWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_PixelHeight(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapDecoder", L"PixelHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PixelHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_PixelWidth(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapDecoder", L"PixelWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PixelWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_BmpDecoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapDecoder", L"BmpDecoderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapDecoder::BmpDecoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_GifDecoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapDecoder", L"GifDecoderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapDecoder::GifDecoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_IcoDecoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapDecoder", L"IcoDecoderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapDecoder::IcoDecoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_JpegDecoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapDecoder", L"JpegDecoderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapDecoder::JpegDecoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_JpegXRDecoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapDecoder", L"JpegXRDecoderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapDecoder::JpegXRDecoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_PngDecoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapDecoder", L"PngDecoderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapDecoder::PngDecoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_TiffDecoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapDecoder", L"TiffDecoderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapDecoder::TiffDecoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_HeifDecoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapDecoder", L"HeifDecoderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapDecoder::HeifDecoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_WebpDecoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapDecoder", L"WebpDecoderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapDecoder::WebpDecoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BitmapDecoder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Imaging::BitmapDecoder>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BitmapDecoder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::BitmapDecoder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BitmapDecoder[] = {
        { "create_async", reinterpret_cast<PyCFunction>(BitmapDecoder_CreateAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_decoder_information_enumerator", reinterpret_cast<PyCFunction>(BitmapDecoder_GetDecoderInformationEnumerator), METH_VARARGS | METH_STATIC, nullptr },
        { "get_frame_async", reinterpret_cast<PyCFunction>(BitmapDecoder_GetFrameAsync), METH_VARARGS, nullptr },
        { "get_pixel_data_async", reinterpret_cast<PyCFunction>(BitmapDecoder_GetPixelDataAsync), METH_VARARGS, nullptr },
        { "get_preview_async", reinterpret_cast<PyCFunction>(BitmapDecoder_GetPreviewAsync), METH_VARARGS, nullptr },
        { "get_software_bitmap_async", reinterpret_cast<PyCFunction>(BitmapDecoder_GetSoftwareBitmapAsync), METH_VARARGS, nullptr },
        { "get_thumbnail_async", reinterpret_cast<PyCFunction>(BitmapDecoder_GetThumbnailAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BitmapDecoder, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BitmapDecoder), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BitmapDecoder[] = {
        { "bitmap_container_properties", reinterpret_cast<getter>(BitmapDecoder_get_BitmapContainerProperties), nullptr, nullptr, nullptr },
        { "decoder_information", reinterpret_cast<getter>(BitmapDecoder_get_DecoderInformation), nullptr, nullptr, nullptr },
        { "frame_count", reinterpret_cast<getter>(BitmapDecoder_get_FrameCount), nullptr, nullptr, nullptr },
        { "bitmap_alpha_mode", reinterpret_cast<getter>(BitmapDecoder_get_BitmapAlphaMode), nullptr, nullptr, nullptr },
        { "bitmap_pixel_format", reinterpret_cast<getter>(BitmapDecoder_get_BitmapPixelFormat), nullptr, nullptr, nullptr },
        { "bitmap_properties", reinterpret_cast<getter>(BitmapDecoder_get_BitmapProperties), nullptr, nullptr, nullptr },
        { "dpi_x", reinterpret_cast<getter>(BitmapDecoder_get_DpiX), nullptr, nullptr, nullptr },
        { "dpi_y", reinterpret_cast<getter>(BitmapDecoder_get_DpiY), nullptr, nullptr, nullptr },
        { "oriented_pixel_height", reinterpret_cast<getter>(BitmapDecoder_get_OrientedPixelHeight), nullptr, nullptr, nullptr },
        { "oriented_pixel_width", reinterpret_cast<getter>(BitmapDecoder_get_OrientedPixelWidth), nullptr, nullptr, nullptr },
        { "pixel_height", reinterpret_cast<getter>(BitmapDecoder_get_PixelHeight), nullptr, nullptr, nullptr },
        { "pixel_width", reinterpret_cast<getter>(BitmapDecoder_get_PixelWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BitmapDecoder[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BitmapDecoder) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BitmapDecoder) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BitmapDecoder) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BitmapDecoder) },
        { },
    };

    static PyType_Spec type_spec_BitmapDecoder =
    {
        "_winrt_windows_graphics_imaging.BitmapDecoder",
        sizeof(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapDecoder
    };

    static PyGetSetDef getset_BitmapDecoder_Meta[] = {
        { "bmp_decoder_id", reinterpret_cast<getter>(BitmapDecoder_get_BmpDecoderId), nullptr, nullptr, nullptr },
        { "gif_decoder_id", reinterpret_cast<getter>(BitmapDecoder_get_GifDecoderId), nullptr, nullptr, nullptr },
        { "ico_decoder_id", reinterpret_cast<getter>(BitmapDecoder_get_IcoDecoderId), nullptr, nullptr, nullptr },
        { "jpeg_decoder_id", reinterpret_cast<getter>(BitmapDecoder_get_JpegDecoderId), nullptr, nullptr, nullptr },
        { "jpeg_x_r_decoder_id", reinterpret_cast<getter>(BitmapDecoder_get_JpegXRDecoderId), nullptr, nullptr, nullptr },
        { "png_decoder_id", reinterpret_cast<getter>(BitmapDecoder_get_PngDecoderId), nullptr, nullptr, nullptr },
        { "tiff_decoder_id", reinterpret_cast<getter>(BitmapDecoder_get_TiffDecoderId), nullptr, nullptr, nullptr },
        { "heif_decoder_id", reinterpret_cast<getter>(BitmapDecoder_get_HeifDecoderId), nullptr, nullptr, nullptr },
        { "webp_decoder_id", reinterpret_cast<getter>(BitmapDecoder_get_WebpDecoderId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_BitmapDecoder_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BitmapDecoder_Meta) },
        { }
    };

    static PyType_Spec type_spec_BitmapDecoder_Meta =
    {
        "_winrt_windows_graphics_imaging.BitmapDecoder_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BitmapDecoder_Meta
    };

    // ----- BitmapEncoder class --------------------

    static PyObject* _new_BitmapEncoder(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Imaging::BitmapEncoder>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Imaging::BitmapEncoder>::type_name);
        return nullptr;
    }

    static void _dealloc_BitmapEncoder(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BitmapEncoder_CreateAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapEncoder", L"CreateAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                return py::convert(winrt::Windows::Graphics::Imaging::BitmapEncoder::CreateAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapEncoder", L"CreateAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Graphics::Imaging::BitmapTypedValue>>>(args, 2);

                return py::convert(winrt::Windows::Graphics::Imaging::BitmapEncoder::CreateAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_CreateForInPlacePropertyEncodingAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapEncoder", L"CreateForInPlacePropertyEncodingAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapDecoder>(args, 0);

                return py::convert(winrt::Windows::Graphics::Imaging::BitmapEncoder::CreateForInPlacePropertyEncodingAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_CreateForTranscodingAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapEncoder", L"CreateForTranscodingAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapDecoder>(args, 1);

                return py::convert(winrt::Windows::Graphics::Imaging::BitmapEncoder::CreateForTranscodingAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_FlushAsync(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapEncoder", L"FlushAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.FlushAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_GetEncoderInformationEnumerator(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapEncoder", L"GetEncoderInformationEnumerator", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Graphics::Imaging::BitmapEncoder::GetEncoderInformationEnumerator());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_GoToNextFrameAsync(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapEncoder", L"GoToNextFrameAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GoToNextFrameAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapEncoder", L"GoToNextFrameAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Graphics::Imaging::BitmapTypedValue>>>(args, 0);

                return py::convert(self->obj.GoToNextFrameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_SetPixelData(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 7)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapEncoder", L"SetPixelData", 7))
            {
                py::set_arg_count_version_error(7);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);
                auto param4 = py::convert_to<double>(args, 4);
                auto param5 = py::convert_to<double>(args, 5);
                auto param6 = py::convert_to<py::pybuf_view<uint8_t, false>>(args, 6);

                self->obj.SetPixelData(param0, param1, param2, param3, param4, param5, param6);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_SetSoftwareBitmap(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapEncoder", L"SetSoftwareBitmap", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(args, 0);

                self->obj.SetSoftwareBitmap(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_get_IsThumbnailGenerated(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapEncoder", L"IsThumbnailGenerated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsThumbnailGenerated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapEncoder_put_IsThumbnailGenerated(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapEncoder", L"IsThumbnailGenerated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsThumbnailGenerated(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapEncoder_get_GeneratedThumbnailWidth(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapEncoder", L"GeneratedThumbnailWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.GeneratedThumbnailWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapEncoder_put_GeneratedThumbnailWidth(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapEncoder", L"GeneratedThumbnailWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.GeneratedThumbnailWidth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapEncoder_get_GeneratedThumbnailHeight(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapEncoder", L"GeneratedThumbnailHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.GeneratedThumbnailHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapEncoder_put_GeneratedThumbnailHeight(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapEncoder", L"GeneratedThumbnailHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.GeneratedThumbnailHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapEncoder_get_BitmapContainerProperties(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapEncoder", L"BitmapContainerProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BitmapContainerProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_get_BitmapProperties(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapEncoder", L"BitmapProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BitmapProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_get_BitmapTransform(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapEncoder", L"BitmapTransform"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BitmapTransform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_get_EncoderInformation(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapEncoder", L"EncoderInformation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EncoderInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_get_BmpEncoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapEncoder", L"BmpEncoderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapEncoder::BmpEncoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_get_GifEncoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapEncoder", L"GifEncoderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapEncoder::GifEncoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_get_JpegEncoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapEncoder", L"JpegEncoderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapEncoder::JpegEncoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_get_JpegXREncoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapEncoder", L"JpegXREncoderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapEncoder::JpegXREncoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_get_PngEncoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapEncoder", L"PngEncoderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapEncoder::PngEncoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_get_TiffEncoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapEncoder", L"TiffEncoderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapEncoder::TiffEncoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_get_HeifEncoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapEncoder", L"HeifEncoderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapEncoder::HeifEncoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BitmapEncoder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Imaging::BitmapEncoder>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BitmapEncoder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::BitmapEncoder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BitmapEncoder[] = {
        { "create_async", reinterpret_cast<PyCFunction>(BitmapEncoder_CreateAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "create_for_in_place_property_encoding_async", reinterpret_cast<PyCFunction>(BitmapEncoder_CreateForInPlacePropertyEncodingAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "create_for_transcoding_async", reinterpret_cast<PyCFunction>(BitmapEncoder_CreateForTranscodingAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "flush_async", reinterpret_cast<PyCFunction>(BitmapEncoder_FlushAsync), METH_VARARGS, nullptr },
        { "get_encoder_information_enumerator", reinterpret_cast<PyCFunction>(BitmapEncoder_GetEncoderInformationEnumerator), METH_VARARGS | METH_STATIC, nullptr },
        { "go_to_next_frame_async", reinterpret_cast<PyCFunction>(BitmapEncoder_GoToNextFrameAsync), METH_VARARGS, nullptr },
        { "set_pixel_data", reinterpret_cast<PyCFunction>(BitmapEncoder_SetPixelData), METH_VARARGS, nullptr },
        { "set_software_bitmap", reinterpret_cast<PyCFunction>(BitmapEncoder_SetSoftwareBitmap), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BitmapEncoder, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BitmapEncoder), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BitmapEncoder[] = {
        { "is_thumbnail_generated", reinterpret_cast<getter>(BitmapEncoder_get_IsThumbnailGenerated), reinterpret_cast<setter>(BitmapEncoder_put_IsThumbnailGenerated), nullptr, nullptr },
        { "generated_thumbnail_width", reinterpret_cast<getter>(BitmapEncoder_get_GeneratedThumbnailWidth), reinterpret_cast<setter>(BitmapEncoder_put_GeneratedThumbnailWidth), nullptr, nullptr },
        { "generated_thumbnail_height", reinterpret_cast<getter>(BitmapEncoder_get_GeneratedThumbnailHeight), reinterpret_cast<setter>(BitmapEncoder_put_GeneratedThumbnailHeight), nullptr, nullptr },
        { "bitmap_container_properties", reinterpret_cast<getter>(BitmapEncoder_get_BitmapContainerProperties), nullptr, nullptr, nullptr },
        { "bitmap_properties", reinterpret_cast<getter>(BitmapEncoder_get_BitmapProperties), nullptr, nullptr, nullptr },
        { "bitmap_transform", reinterpret_cast<getter>(BitmapEncoder_get_BitmapTransform), nullptr, nullptr, nullptr },
        { "encoder_information", reinterpret_cast<getter>(BitmapEncoder_get_EncoderInformation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BitmapEncoder[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BitmapEncoder) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BitmapEncoder) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BitmapEncoder) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BitmapEncoder) },
        { },
    };

    static PyType_Spec type_spec_BitmapEncoder =
    {
        "_winrt_windows_graphics_imaging.BitmapEncoder",
        sizeof(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapEncoder
    };

    static PyGetSetDef getset_BitmapEncoder_Meta[] = {
        { "bmp_encoder_id", reinterpret_cast<getter>(BitmapEncoder_get_BmpEncoderId), nullptr, nullptr, nullptr },
        { "gif_encoder_id", reinterpret_cast<getter>(BitmapEncoder_get_GifEncoderId), nullptr, nullptr, nullptr },
        { "jpeg_encoder_id", reinterpret_cast<getter>(BitmapEncoder_get_JpegEncoderId), nullptr, nullptr, nullptr },
        { "jpeg_x_r_encoder_id", reinterpret_cast<getter>(BitmapEncoder_get_JpegXREncoderId), nullptr, nullptr, nullptr },
        { "png_encoder_id", reinterpret_cast<getter>(BitmapEncoder_get_PngEncoderId), nullptr, nullptr, nullptr },
        { "tiff_encoder_id", reinterpret_cast<getter>(BitmapEncoder_get_TiffEncoderId), nullptr, nullptr, nullptr },
        { "heif_encoder_id", reinterpret_cast<getter>(BitmapEncoder_get_HeifEncoderId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot type_slots_BitmapEncoder_Meta[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BitmapEncoder_Meta) },
        { }
    };

    static PyType_Spec type_spec_BitmapEncoder_Meta =
    {
        "_winrt_windows_graphics_imaging.BitmapEncoder_Meta",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BitmapEncoder_Meta
    };

    // ----- BitmapFrame class --------------------

    static PyObject* _new_BitmapFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Imaging::BitmapFrame>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Imaging::BitmapFrame>::type_name);
        return nullptr;
    }

    static void _dealloc_BitmapFrame(py::wrapper::Windows::Graphics::Imaging::BitmapFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BitmapFrame_GetPixelDataAsync(py::wrapper::Windows::Graphics::Imaging::BitmapFrame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapFrame", L"GetPixelDataAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetPixelDataAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapFrame", L"GetPixelDataAsync", 5))
            {
                py::set_arg_count_version_error(5);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTransform>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::ExifOrientationMode>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::ColorManagementMode>(args, 4);

                return py::convert(self->obj.GetPixelDataAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapFrame_GetSoftwareBitmapAsync(py::wrapper::Windows::Graphics::Imaging::BitmapFrame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapFrame", L"GetSoftwareBitmapAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetSoftwareBitmapAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapFrame", L"GetSoftwareBitmapAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);

                return py::convert(self->obj.GetSoftwareBitmapAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapFrame", L"GetSoftwareBitmapAsync", 5))
            {
                py::set_arg_count_version_error(5);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTransform>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::ExifOrientationMode>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::ColorManagementMode>(args, 4);

                return py::convert(self->obj.GetSoftwareBitmapAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapFrame_GetThumbnailAsync(py::wrapper::Windows::Graphics::Imaging::BitmapFrame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapFrame", L"GetThumbnailAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetThumbnailAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapFrame_get_BitmapAlphaMode(py::wrapper::Windows::Graphics::Imaging::BitmapFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapFrame", L"BitmapAlphaMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BitmapAlphaMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapFrame_get_BitmapPixelFormat(py::wrapper::Windows::Graphics::Imaging::BitmapFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapFrame", L"BitmapPixelFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BitmapPixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapFrame_get_BitmapProperties(py::wrapper::Windows::Graphics::Imaging::BitmapFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapFrame", L"BitmapProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BitmapProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapFrame_get_DpiX(py::wrapper::Windows::Graphics::Imaging::BitmapFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapFrame", L"DpiX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DpiX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapFrame_get_DpiY(py::wrapper::Windows::Graphics::Imaging::BitmapFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapFrame", L"DpiY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DpiY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapFrame_get_OrientedPixelHeight(py::wrapper::Windows::Graphics::Imaging::BitmapFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapFrame", L"OrientedPixelHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OrientedPixelHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapFrame_get_OrientedPixelWidth(py::wrapper::Windows::Graphics::Imaging::BitmapFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapFrame", L"OrientedPixelWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OrientedPixelWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapFrame_get_PixelHeight(py::wrapper::Windows::Graphics::Imaging::BitmapFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapFrame", L"PixelHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PixelHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapFrame_get_PixelWidth(py::wrapper::Windows::Graphics::Imaging::BitmapFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapFrame", L"PixelWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PixelWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BitmapFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Imaging::BitmapFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BitmapFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::BitmapFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BitmapFrame[] = {
        { "get_pixel_data_async", reinterpret_cast<PyCFunction>(BitmapFrame_GetPixelDataAsync), METH_VARARGS, nullptr },
        { "get_software_bitmap_async", reinterpret_cast<PyCFunction>(BitmapFrame_GetSoftwareBitmapAsync), METH_VARARGS, nullptr },
        { "get_thumbnail_async", reinterpret_cast<PyCFunction>(BitmapFrame_GetThumbnailAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BitmapFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BitmapFrame), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BitmapFrame[] = {
        { "bitmap_alpha_mode", reinterpret_cast<getter>(BitmapFrame_get_BitmapAlphaMode), nullptr, nullptr, nullptr },
        { "bitmap_pixel_format", reinterpret_cast<getter>(BitmapFrame_get_BitmapPixelFormat), nullptr, nullptr, nullptr },
        { "bitmap_properties", reinterpret_cast<getter>(BitmapFrame_get_BitmapProperties), nullptr, nullptr, nullptr },
        { "dpi_x", reinterpret_cast<getter>(BitmapFrame_get_DpiX), nullptr, nullptr, nullptr },
        { "dpi_y", reinterpret_cast<getter>(BitmapFrame_get_DpiY), nullptr, nullptr, nullptr },
        { "oriented_pixel_height", reinterpret_cast<getter>(BitmapFrame_get_OrientedPixelHeight), nullptr, nullptr, nullptr },
        { "oriented_pixel_width", reinterpret_cast<getter>(BitmapFrame_get_OrientedPixelWidth), nullptr, nullptr, nullptr },
        { "pixel_height", reinterpret_cast<getter>(BitmapFrame_get_PixelHeight), nullptr, nullptr, nullptr },
        { "pixel_width", reinterpret_cast<getter>(BitmapFrame_get_PixelWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BitmapFrame[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BitmapFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BitmapFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BitmapFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BitmapFrame) },
        { },
    };

    static PyType_Spec type_spec_BitmapFrame =
    {
        "_winrt_windows_graphics_imaging.BitmapFrame",
        sizeof(py::wrapper::Windows::Graphics::Imaging::BitmapFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapFrame
    };

    // ----- BitmapProperties class --------------------

    static PyObject* _new_BitmapProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Imaging::BitmapProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Imaging::BitmapProperties>::type_name);
        return nullptr;
    }

    static void _dealloc_BitmapProperties(py::wrapper::Windows::Graphics::Imaging::BitmapProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BitmapProperties_GetPropertiesAsync(py::wrapper::Windows::Graphics::Imaging::BitmapProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapProperties", L"GetPropertiesAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetPropertiesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapProperties_SetPropertiesAsync(py::wrapper::Windows::Graphics::Imaging::BitmapProperties* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapProperties", L"SetPropertiesAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Graphics::Imaging::BitmapTypedValue>>>(args, 0);

                return py::convert(self->obj.SetPropertiesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_BitmapProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Imaging::BitmapProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BitmapProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::BitmapProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BitmapProperties[] = {
        { "get_properties_async", reinterpret_cast<PyCFunction>(BitmapProperties_GetPropertiesAsync), METH_VARARGS, nullptr },
        { "set_properties_async", reinterpret_cast<PyCFunction>(BitmapProperties_SetPropertiesAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BitmapProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BitmapProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BitmapProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_BitmapProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BitmapProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BitmapProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BitmapProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BitmapProperties) },
        { },
    };

    static PyType_Spec type_spec_BitmapProperties =
    {
        "_winrt_windows_graphics_imaging.BitmapProperties",
        sizeof(py::wrapper::Windows::Graphics::Imaging::BitmapProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapProperties
    };

    // ----- BitmapPropertiesView class --------------------

    static PyObject* _new_BitmapPropertiesView(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Imaging::BitmapPropertiesView>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Imaging::BitmapPropertiesView>::type_name);
        return nullptr;
    }

    static void _dealloc_BitmapPropertiesView(py::wrapper::Windows::Graphics::Imaging::BitmapPropertiesView* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BitmapPropertiesView_GetPropertiesAsync(py::wrapper::Windows::Graphics::Imaging::BitmapPropertiesView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapPropertiesView", L"GetPropertiesAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetPropertiesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_BitmapPropertiesView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Imaging::BitmapPropertiesView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BitmapPropertiesView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::BitmapPropertiesView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BitmapPropertiesView[] = {
        { "get_properties_async", reinterpret_cast<PyCFunction>(BitmapPropertiesView_GetPropertiesAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BitmapPropertiesView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BitmapPropertiesView), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BitmapPropertiesView[] = {
        { }
    };

    static PyType_Slot _type_slots_BitmapPropertiesView[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BitmapPropertiesView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BitmapPropertiesView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BitmapPropertiesView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BitmapPropertiesView) },
        { },
    };

    static PyType_Spec type_spec_BitmapPropertiesView =
    {
        "_winrt_windows_graphics_imaging.BitmapPropertiesView",
        sizeof(py::wrapper::Windows::Graphics::Imaging::BitmapPropertiesView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapPropertiesView
    };

    // ----- BitmapPropertySet class --------------------

    static PyObject* _new_BitmapPropertySet(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Graphics::Imaging::BitmapPropertySet instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BitmapPropertySet(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BitmapPropertySet_Clear(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapPropertySet", L"Clear", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapPropertySet_First(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapPropertySet", L"First", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapPropertySet_GetView(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapPropertySet", L"GetView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapPropertySet_HasKey(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapPropertySet", L"HasKey", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.HasKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapPropertySet_Insert(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapPropertySet", L"Insert", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTypedValue>(args, 1);

                return py::convert(self->obj.Insert(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapPropertySet_Lookup(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapPropertySet", L"Lookup", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.Lookup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapPropertySet_Remove(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.BitmapPropertySet", L"Remove", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapPropertySet_get_Size(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapPropertySet", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BitmapPropertySet(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Imaging::BitmapPropertySet>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BitmapPropertySet(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::BitmapPropertySet>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_BitmapPropertySet(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self) noexcept
    {
        try
        {
            py::pyobj_handle iter{py::convert(self->obj.First())};

            if (!iter)
            {
                return nullptr;
            }

            return py::wrap_mapping_iter(iter.get());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_contains_BitmapPropertySet(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self, PyObject* key) noexcept
    {
        try
        {
            return static_cast<int>(self->obj.HasKey(py::convert_to<winrt::hstring>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static Py_ssize_t _map_length_BitmapPropertySet(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_BitmapPropertySet(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self, PyObject* key) noexcept
    {
        try
        {
            auto value = self->obj.TryLookup(py::convert_to<winrt::hstring>(key));

            if (!value) {
                PyErr_SetObject(PyExc_KeyError, key);
                return nullptr;
            }

            return py::convert(value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_assign_BitmapPropertySet(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self, PyObject* key, PyObject* value) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);

            if (value == nullptr) {
                if (!self->obj.TryRemove(_key)) {
                    PyErr_SetObject(PyExc_KeyError, key);
                    return -1;
                }

                return 0;
            }

            self->obj.Insert(_key, py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTypedValue>(value));

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_BitmapPropertySet[] = {
        { "clear", reinterpret_cast<PyCFunction>(BitmapPropertySet_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(BitmapPropertySet_First), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(BitmapPropertySet_GetView), METH_VARARGS, nullptr },
        { "has_key", reinterpret_cast<PyCFunction>(BitmapPropertySet_HasKey), METH_VARARGS, nullptr },
        { "insert", reinterpret_cast<PyCFunction>(BitmapPropertySet_Insert), METH_VARARGS, nullptr },
        { "lookup", reinterpret_cast<PyCFunction>(BitmapPropertySet_Lookup), METH_VARARGS, nullptr },
        { "remove", reinterpret_cast<PyCFunction>(BitmapPropertySet_Remove), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BitmapPropertySet, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BitmapPropertySet), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BitmapPropertySet[] = {
        { "size", reinterpret_cast<getter>(BitmapPropertySet_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BitmapPropertySet[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BitmapPropertySet) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BitmapPropertySet) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BitmapPropertySet) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BitmapPropertySet) },
        { Py_tp_iter, reinterpret_cast<void*>(_iterator_BitmapPropertySet) },
        { Py_sq_contains, reinterpret_cast<void*>(_map_contains_BitmapPropertySet) },
        { Py_mp_length, reinterpret_cast<void*>(_map_length_BitmapPropertySet) },
        { Py_mp_subscript, reinterpret_cast<void*>(_map_subscript_BitmapPropertySet) },
        { Py_mp_ass_subscript, reinterpret_cast<void*>(_map_assign_BitmapPropertySet) },
        { },
    };

    static PyType_Spec type_spec_BitmapPropertySet =
    {
        "_winrt_windows_graphics_imaging.BitmapPropertySet",
        sizeof(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapPropertySet
    };

    // ----- BitmapTransform class --------------------

    static PyObject* _new_BitmapTransform(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Graphics::Imaging::BitmapTransform instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BitmapTransform(py::wrapper::Windows::Graphics::Imaging::BitmapTransform* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BitmapTransform_get_ScaledWidth(py::wrapper::Windows::Graphics::Imaging::BitmapTransform* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapTransform", L"ScaledWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ScaledWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapTransform_put_ScaledWidth(py::wrapper::Windows::Graphics::Imaging::BitmapTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapTransform", L"ScaledWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ScaledWidth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapTransform_get_ScaledHeight(py::wrapper::Windows::Graphics::Imaging::BitmapTransform* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapTransform", L"ScaledHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ScaledHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapTransform_put_ScaledHeight(py::wrapper::Windows::Graphics::Imaging::BitmapTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapTransform", L"ScaledHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ScaledHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapTransform_get_Rotation(py::wrapper::Windows::Graphics::Imaging::BitmapTransform* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapTransform", L"Rotation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Rotation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapTransform_put_Rotation(py::wrapper::Windows::Graphics::Imaging::BitmapTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapTransform", L"Rotation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapRotation>(arg);

            self->obj.Rotation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapTransform_get_InterpolationMode(py::wrapper::Windows::Graphics::Imaging::BitmapTransform* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapTransform", L"InterpolationMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InterpolationMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapTransform_put_InterpolationMode(py::wrapper::Windows::Graphics::Imaging::BitmapTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapTransform", L"InterpolationMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapInterpolationMode>(arg);

            self->obj.InterpolationMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapTransform_get_Flip(py::wrapper::Windows::Graphics::Imaging::BitmapTransform* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapTransform", L"Flip"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Flip());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapTransform_put_Flip(py::wrapper::Windows::Graphics::Imaging::BitmapTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapTransform", L"Flip"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFlip>(arg);

            self->obj.Flip(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapTransform_get_Bounds(py::wrapper::Windows::Graphics::Imaging::BitmapTransform* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapTransform", L"Bounds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Bounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapTransform_put_Bounds(py::wrapper::Windows::Graphics::Imaging::BitmapTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapTransform", L"Bounds"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapBounds>(arg);

            self->obj.Bounds(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_BitmapTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Imaging::BitmapTransform>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BitmapTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::BitmapTransform>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BitmapTransform[] = {
        { "_assign_array_", _assign_array_BitmapTransform, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BitmapTransform), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BitmapTransform[] = {
        { "scaled_width", reinterpret_cast<getter>(BitmapTransform_get_ScaledWidth), reinterpret_cast<setter>(BitmapTransform_put_ScaledWidth), nullptr, nullptr },
        { "scaled_height", reinterpret_cast<getter>(BitmapTransform_get_ScaledHeight), reinterpret_cast<setter>(BitmapTransform_put_ScaledHeight), nullptr, nullptr },
        { "rotation", reinterpret_cast<getter>(BitmapTransform_get_Rotation), reinterpret_cast<setter>(BitmapTransform_put_Rotation), nullptr, nullptr },
        { "interpolation_mode", reinterpret_cast<getter>(BitmapTransform_get_InterpolationMode), reinterpret_cast<setter>(BitmapTransform_put_InterpolationMode), nullptr, nullptr },
        { "flip", reinterpret_cast<getter>(BitmapTransform_get_Flip), reinterpret_cast<setter>(BitmapTransform_put_Flip), nullptr, nullptr },
        { "bounds", reinterpret_cast<getter>(BitmapTransform_get_Bounds), reinterpret_cast<setter>(BitmapTransform_put_Bounds), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BitmapTransform[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BitmapTransform) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BitmapTransform) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BitmapTransform) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BitmapTransform) },
        { },
    };

    static PyType_Spec type_spec_BitmapTransform =
    {
        "_winrt_windows_graphics_imaging.BitmapTransform",
        sizeof(py::wrapper::Windows::Graphics::Imaging::BitmapTransform),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapTransform
    };

    // ----- BitmapTypedValue class --------------------

    static PyObject* _new_BitmapTypedValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::PropertyType>(args, 1);

                winrt::Windows::Graphics::Imaging::BitmapTypedValue instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BitmapTypedValue(py::wrapper::Windows::Graphics::Imaging::BitmapTypedValue* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BitmapTypedValue_get_Type(py::wrapper::Windows::Graphics::Imaging::BitmapTypedValue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapTypedValue", L"Type"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapTypedValue_get_Value(py::wrapper::Windows::Graphics::Imaging::BitmapTypedValue* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.BitmapTypedValue", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BitmapTypedValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Imaging::BitmapTypedValue>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BitmapTypedValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::BitmapTypedValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BitmapTypedValue[] = {
        { "_assign_array_", _assign_array_BitmapTypedValue, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BitmapTypedValue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BitmapTypedValue[] = {
        { "type", reinterpret_cast<getter>(BitmapTypedValue_get_Type), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(BitmapTypedValue_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BitmapTypedValue[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BitmapTypedValue) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BitmapTypedValue) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BitmapTypedValue) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BitmapTypedValue) },
        { },
    };

    static PyType_Spec type_spec_BitmapTypedValue =
    {
        "_winrt_windows_graphics_imaging.BitmapTypedValue",
        sizeof(py::wrapper::Windows::Graphics::Imaging::BitmapTypedValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapTypedValue
    };

    // ----- ImageStream class --------------------

    static PyObject* _new_ImageStream(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Imaging::ImageStream>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Imaging::ImageStream>::type_name);
        return nullptr;
    }

    static void _dealloc_ImageStream(py::wrapper::Windows::Graphics::Imaging::ImageStream* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ImageStream_CloneStream(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.ImageStream", L"CloneStream", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CloneStream());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageStream_Close(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.ImageStream", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageStream_FlushAsync(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.ImageStream", L"FlushAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.FlushAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageStream_GetInputStreamAt(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.ImageStream", L"GetInputStreamAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetInputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageStream_GetOutputStreamAt(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.ImageStream", L"GetOutputStreamAt", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetOutputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageStream_ReadAsync(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.ImageStream", L"ReadAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);

                return py::convert(self->obj.ReadAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageStream_Seek(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.ImageStream", L"Seek", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.Seek(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageStream_WriteAsync(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.ImageStream", L"WriteAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.WriteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageStream_get_ContentType(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.ImageStream", L"ContentType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageStream_get_Size(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.ImageStream", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageStream_put_Size(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.ImageStream", L"Size"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint64_t>(arg);

            self->obj.Size(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageStream_get_CanRead(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.ImageStream", L"CanRead"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanRead());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageStream_get_CanWrite(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.ImageStream", L"CanWrite"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanWrite());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageStream_get_Position(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.ImageStream", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ImageStream(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Imaging::ImageStream>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ImageStream(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::ImageStream>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ImageStream(py::wrapper::Windows::Graphics::Imaging::ImageStream* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_ImageStream(py::wrapper::Windows::Graphics::Imaging::ImageStream* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageStream[] = {
        { "clone_stream", reinterpret_cast<PyCFunction>(ImageStream_CloneStream), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(ImageStream_Close), METH_VARARGS, nullptr },
        { "flush_async", reinterpret_cast<PyCFunction>(ImageStream_FlushAsync), METH_VARARGS, nullptr },
        { "get_input_stream_at", reinterpret_cast<PyCFunction>(ImageStream_GetInputStreamAt), METH_VARARGS, nullptr },
        { "get_output_stream_at", reinterpret_cast<PyCFunction>(ImageStream_GetOutputStreamAt), METH_VARARGS, nullptr },
        { "read_async", reinterpret_cast<PyCFunction>(ImageStream_ReadAsync), METH_VARARGS, nullptr },
        { "seek", reinterpret_cast<PyCFunction>(ImageStream_Seek), METH_VARARGS, nullptr },
        { "write_async", reinterpret_cast<PyCFunction>(ImageStream_WriteAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ImageStream, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ImageStream), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ImageStream), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_ImageStream), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ImageStream[] = {
        { "content_type", reinterpret_cast<getter>(ImageStream_get_ContentType), nullptr, nullptr, nullptr },
        { "size", reinterpret_cast<getter>(ImageStream_get_Size), reinterpret_cast<setter>(ImageStream_put_Size), nullptr, nullptr },
        { "can_read", reinterpret_cast<getter>(ImageStream_get_CanRead), nullptr, nullptr, nullptr },
        { "can_write", reinterpret_cast<getter>(ImageStream_get_CanWrite), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(ImageStream_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ImageStream[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ImageStream) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ImageStream) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ImageStream) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ImageStream) },
        { },
    };

    static PyType_Spec type_spec_ImageStream =
    {
        "_winrt_windows_graphics_imaging.ImageStream",
        sizeof(py::wrapper::Windows::Graphics::Imaging::ImageStream),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageStream
    };

    // ----- PixelDataProvider class --------------------

    static PyObject* _new_PixelDataProvider(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Imaging::PixelDataProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Imaging::PixelDataProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_PixelDataProvider(py::wrapper::Windows::Graphics::Imaging::PixelDataProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PixelDataProvider_DetachPixelData(py::wrapper::Windows::Graphics::Imaging::PixelDataProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.PixelDataProvider", L"DetachPixelData", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.DetachPixelData());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PixelDataProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Imaging::PixelDataProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PixelDataProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::PixelDataProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PixelDataProvider[] = {
        { "detach_pixel_data", reinterpret_cast<PyCFunction>(PixelDataProvider_DetachPixelData), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PixelDataProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PixelDataProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PixelDataProvider[] = {
        { }
    };

    static PyType_Slot _type_slots_PixelDataProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PixelDataProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PixelDataProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PixelDataProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PixelDataProvider) },
        { },
    };

    static PyType_Spec type_spec_PixelDataProvider =
    {
        "_winrt_windows_graphics_imaging.PixelDataProvider",
        sizeof(py::wrapper::Windows::Graphics::Imaging::PixelDataProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PixelDataProvider
    };

    // ----- SoftwareBitmap class --------------------

    static PyObject* _new_SoftwareBitmap(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);

                winrt::Windows::Graphics::Imaging::SoftwareBitmap instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 3);

                winrt::Windows::Graphics::Imaging::SoftwareBitmap instance{ param0, param1, param2, param3 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SoftwareBitmap(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SoftwareBitmap_Close(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.SoftwareBitmap", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_Convert(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.SoftwareBitmap", L"Convert", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 1);

                return py::convert(winrt::Windows::Graphics::Imaging::SoftwareBitmap::Convert(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.SoftwareBitmap", L"Convert", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 2);

                return py::convert(winrt::Windows::Graphics::Imaging::SoftwareBitmap::Convert(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_Copy(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.SoftwareBitmap", L"Copy", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(args, 0);

                return py::convert(winrt::Windows::Graphics::Imaging::SoftwareBitmap::Copy(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_CopyFromBuffer(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.SoftwareBitmap", L"CopyFromBuffer", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                self->obj.CopyFromBuffer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_CopyTo(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.SoftwareBitmap", L"CopyTo", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(args, 0);

                self->obj.CopyTo(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_CopyToBuffer(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.SoftwareBitmap", L"CopyToBuffer", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                self->obj.CopyToBuffer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_CreateCopyFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.SoftwareBitmap", L"CreateCopyFromBuffer", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                return py::convert(winrt::Windows::Graphics::Imaging::SoftwareBitmap::CreateCopyFromBuffer(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.SoftwareBitmap", L"CreateCopyFromBuffer", 5))
            {
                py::set_arg_count_version_error(5);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 4);

                return py::convert(winrt::Windows::Graphics::Imaging::SoftwareBitmap::CreateCopyFromBuffer(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_CreateCopyFromSurfaceAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.SoftwareBitmap", L"CreateCopyFromSurfaceAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface>(args, 0);

                return py::convert(winrt::Windows::Graphics::Imaging::SoftwareBitmap::CreateCopyFromSurfaceAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.SoftwareBitmap", L"CreateCopyFromSurfaceAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);

                return py::convert(winrt::Windows::Graphics::Imaging::SoftwareBitmap::CreateCopyFromSurfaceAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_GetReadOnlyView(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.SoftwareBitmap", L"GetReadOnlyView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetReadOnlyView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_LockBuffer(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.SoftwareBitmap", L"LockBuffer", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapBufferAccessMode>(args, 0);

                return py::convert(self->obj.LockBuffer(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_get_DpiY(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.SoftwareBitmap", L"DpiY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DpiY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SoftwareBitmap_put_DpiY(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.SoftwareBitmap", L"DpiY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.DpiY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SoftwareBitmap_get_DpiX(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.SoftwareBitmap", L"DpiX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DpiX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SoftwareBitmap_put_DpiX(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.SoftwareBitmap", L"DpiX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.DpiX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SoftwareBitmap_get_BitmapAlphaMode(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.SoftwareBitmap", L"BitmapAlphaMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BitmapAlphaMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_get_BitmapPixelFormat(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.SoftwareBitmap", L"BitmapPixelFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BitmapPixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_get_IsReadOnly(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.SoftwareBitmap", L"IsReadOnly"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_get_PixelHeight(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.SoftwareBitmap", L"PixelHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PixelHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_get_PixelWidth(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.SoftwareBitmap", L"PixelWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PixelWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SoftwareBitmap(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Imaging::SoftwareBitmap>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SoftwareBitmap(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::SoftwareBitmap>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_SoftwareBitmap(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_SoftwareBitmap(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SoftwareBitmap[] = {
        { "close", reinterpret_cast<PyCFunction>(SoftwareBitmap_Close), METH_VARARGS, nullptr },
        { "convert", reinterpret_cast<PyCFunction>(SoftwareBitmap_Convert), METH_VARARGS | METH_STATIC, nullptr },
        { "copy", reinterpret_cast<PyCFunction>(SoftwareBitmap_Copy), METH_VARARGS | METH_STATIC, nullptr },
        { "copy_from_buffer", reinterpret_cast<PyCFunction>(SoftwareBitmap_CopyFromBuffer), METH_VARARGS, nullptr },
        { "copy_to", reinterpret_cast<PyCFunction>(SoftwareBitmap_CopyTo), METH_VARARGS, nullptr },
        { "copy_to_buffer", reinterpret_cast<PyCFunction>(SoftwareBitmap_CopyToBuffer), METH_VARARGS, nullptr },
        { "create_copy_from_buffer", reinterpret_cast<PyCFunction>(SoftwareBitmap_CreateCopyFromBuffer), METH_VARARGS | METH_STATIC, nullptr },
        { "create_copy_from_surface_async", reinterpret_cast<PyCFunction>(SoftwareBitmap_CreateCopyFromSurfaceAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_read_only_view", reinterpret_cast<PyCFunction>(SoftwareBitmap_GetReadOnlyView), METH_VARARGS, nullptr },
        { "lock_buffer", reinterpret_cast<PyCFunction>(SoftwareBitmap_LockBuffer), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SoftwareBitmap, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SoftwareBitmap), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_SoftwareBitmap), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_SoftwareBitmap), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_SoftwareBitmap[] = {
        { "dpi_y", reinterpret_cast<getter>(SoftwareBitmap_get_DpiY), reinterpret_cast<setter>(SoftwareBitmap_put_DpiY), nullptr, nullptr },
        { "dpi_x", reinterpret_cast<getter>(SoftwareBitmap_get_DpiX), reinterpret_cast<setter>(SoftwareBitmap_put_DpiX), nullptr, nullptr },
        { "bitmap_alpha_mode", reinterpret_cast<getter>(SoftwareBitmap_get_BitmapAlphaMode), nullptr, nullptr, nullptr },
        { "bitmap_pixel_format", reinterpret_cast<getter>(SoftwareBitmap_get_BitmapPixelFormat), nullptr, nullptr, nullptr },
        { "is_read_only", reinterpret_cast<getter>(SoftwareBitmap_get_IsReadOnly), nullptr, nullptr, nullptr },
        { "pixel_height", reinterpret_cast<getter>(SoftwareBitmap_get_PixelHeight), nullptr, nullptr, nullptr },
        { "pixel_width", reinterpret_cast<getter>(SoftwareBitmap_get_PixelWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SoftwareBitmap[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SoftwareBitmap) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SoftwareBitmap) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SoftwareBitmap) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SoftwareBitmap) },
        { },
    };

    static PyType_Spec type_spec_SoftwareBitmap =
    {
        "_winrt_windows_graphics_imaging.SoftwareBitmap",
        sizeof(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SoftwareBitmap
    };

    // ----- IBitmapFrame interface --------------------

    static PyObject* _new_IBitmapFrame(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Imaging::IBitmapFrame>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Imaging::IBitmapFrame>::type_name);
        return nullptr;
    }

    static void _dealloc_IBitmapFrame(py::wrapper::Windows::Graphics::Imaging::IBitmapFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBitmapFrame_GetPixelDataAsync(py::wrapper::Windows::Graphics::Imaging::IBitmapFrame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.IBitmapFrame", L"GetPixelDataAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetPixelDataAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.IBitmapFrame", L"GetPixelDataAsync", 5))
            {
                py::set_arg_count_version_error(5);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTransform>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::ExifOrientationMode>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::ColorManagementMode>(args, 4);

                return py::convert(self->obj.GetPixelDataAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBitmapFrame_GetThumbnailAsync(py::wrapper::Windows::Graphics::Imaging::IBitmapFrame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.IBitmapFrame", L"GetThumbnailAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetThumbnailAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBitmapFrame_get_BitmapAlphaMode(py::wrapper::Windows::Graphics::Imaging::IBitmapFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.IBitmapFrame", L"BitmapAlphaMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BitmapAlphaMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrame_get_BitmapPixelFormat(py::wrapper::Windows::Graphics::Imaging::IBitmapFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.IBitmapFrame", L"BitmapPixelFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BitmapPixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrame_get_BitmapProperties(py::wrapper::Windows::Graphics::Imaging::IBitmapFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.IBitmapFrame", L"BitmapProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BitmapProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrame_get_DpiX(py::wrapper::Windows::Graphics::Imaging::IBitmapFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.IBitmapFrame", L"DpiX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DpiX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrame_get_DpiY(py::wrapper::Windows::Graphics::Imaging::IBitmapFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.IBitmapFrame", L"DpiY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DpiY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrame_get_OrientedPixelHeight(py::wrapper::Windows::Graphics::Imaging::IBitmapFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.IBitmapFrame", L"OrientedPixelHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OrientedPixelHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrame_get_OrientedPixelWidth(py::wrapper::Windows::Graphics::Imaging::IBitmapFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.IBitmapFrame", L"OrientedPixelWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OrientedPixelWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrame_get_PixelHeight(py::wrapper::Windows::Graphics::Imaging::IBitmapFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.IBitmapFrame", L"PixelHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PixelHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrame_get_PixelWidth(py::wrapper::Windows::Graphics::Imaging::IBitmapFrame* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.IBitmapFrame", L"PixelWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PixelWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IBitmapFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Imaging::IBitmapFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBitmapFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::IBitmapFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBitmapFrame[] = {
        { "get_pixel_data_async", reinterpret_cast<PyCFunction>(IBitmapFrame_GetPixelDataAsync), METH_VARARGS, nullptr },
        { "get_thumbnail_async", reinterpret_cast<PyCFunction>(IBitmapFrame_GetThumbnailAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IBitmapFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBitmapFrame), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBitmapFrame[] = {
        { "bitmap_alpha_mode", reinterpret_cast<getter>(IBitmapFrame_get_BitmapAlphaMode), nullptr, nullptr, nullptr },
        { "bitmap_pixel_format", reinterpret_cast<getter>(IBitmapFrame_get_BitmapPixelFormat), nullptr, nullptr, nullptr },
        { "bitmap_properties", reinterpret_cast<getter>(IBitmapFrame_get_BitmapProperties), nullptr, nullptr, nullptr },
        { "dpi_x", reinterpret_cast<getter>(IBitmapFrame_get_DpiX), nullptr, nullptr, nullptr },
        { "dpi_y", reinterpret_cast<getter>(IBitmapFrame_get_DpiY), nullptr, nullptr, nullptr },
        { "oriented_pixel_height", reinterpret_cast<getter>(IBitmapFrame_get_OrientedPixelHeight), nullptr, nullptr, nullptr },
        { "oriented_pixel_width", reinterpret_cast<getter>(IBitmapFrame_get_OrientedPixelWidth), nullptr, nullptr, nullptr },
        { "pixel_height", reinterpret_cast<getter>(IBitmapFrame_get_PixelHeight), nullptr, nullptr, nullptr },
        { "pixel_width", reinterpret_cast<getter>(IBitmapFrame_get_PixelWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBitmapFrame[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBitmapFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBitmapFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBitmapFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBitmapFrame) },
        { },
    };

    static PyType_Spec type_spec_IBitmapFrame =
    {
        "_winrt_windows_graphics_imaging.IBitmapFrame",
        sizeof(py::wrapper::Windows::Graphics::Imaging::IBitmapFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBitmapFrame
    };

    // ----- IBitmapFrameWithSoftwareBitmap interface --------------------

    static PyObject* _new_IBitmapFrameWithSoftwareBitmap(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>::type_name);
        return nullptr;
    }

    static void _dealloc_IBitmapFrameWithSoftwareBitmap(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBitmapFrameWithSoftwareBitmap_GetPixelDataAsync(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.IBitmapFrame", L"GetPixelDataAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetPixelDataAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.IBitmapFrame", L"GetPixelDataAsync", 5))
            {
                py::set_arg_count_version_error(5);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTransform>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::ExifOrientationMode>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::ColorManagementMode>(args, 4);

                return py::convert(self->obj.GetPixelDataAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBitmapFrameWithSoftwareBitmap_GetSoftwareBitmapAsync(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.IBitmapFrameWithSoftwareBitmap", L"GetSoftwareBitmapAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetSoftwareBitmapAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.IBitmapFrameWithSoftwareBitmap", L"GetSoftwareBitmapAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);

                return py::convert(self->obj.GetSoftwareBitmapAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.IBitmapFrameWithSoftwareBitmap", L"GetSoftwareBitmapAsync", 5))
            {
                py::set_arg_count_version_error(5);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTransform>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::ExifOrientationMode>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::ColorManagementMode>(args, 4);

                return py::convert(self->obj.GetSoftwareBitmapAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBitmapFrameWithSoftwareBitmap_GetThumbnailAsync(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.IBitmapFrame", L"GetThumbnailAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetThumbnailAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBitmapFrameWithSoftwareBitmap_get_BitmapAlphaMode(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.IBitmapFrame", L"BitmapAlphaMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BitmapAlphaMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrameWithSoftwareBitmap_get_BitmapPixelFormat(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.IBitmapFrame", L"BitmapPixelFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BitmapPixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrameWithSoftwareBitmap_get_BitmapProperties(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.IBitmapFrame", L"BitmapProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.BitmapProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrameWithSoftwareBitmap_get_DpiX(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.IBitmapFrame", L"DpiX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DpiX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrameWithSoftwareBitmap_get_DpiY(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.IBitmapFrame", L"DpiY"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DpiY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrameWithSoftwareBitmap_get_OrientedPixelHeight(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.IBitmapFrame", L"OrientedPixelHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OrientedPixelHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrameWithSoftwareBitmap_get_OrientedPixelWidth(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.IBitmapFrame", L"OrientedPixelWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OrientedPixelWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrameWithSoftwareBitmap_get_PixelHeight(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.IBitmapFrame", L"PixelHeight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PixelHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrameWithSoftwareBitmap_get_PixelWidth(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Graphics.Imaging.IBitmapFrame", L"PixelWidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PixelWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IBitmapFrameWithSoftwareBitmap(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBitmapFrameWithSoftwareBitmap(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBitmapFrameWithSoftwareBitmap[] = {
        { "get_pixel_data_async", reinterpret_cast<PyCFunction>(IBitmapFrameWithSoftwareBitmap_GetPixelDataAsync), METH_VARARGS, nullptr },
        { "get_software_bitmap_async", reinterpret_cast<PyCFunction>(IBitmapFrameWithSoftwareBitmap_GetSoftwareBitmapAsync), METH_VARARGS, nullptr },
        { "get_thumbnail_async", reinterpret_cast<PyCFunction>(IBitmapFrameWithSoftwareBitmap_GetThumbnailAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IBitmapFrameWithSoftwareBitmap, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBitmapFrameWithSoftwareBitmap), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBitmapFrameWithSoftwareBitmap[] = {
        { "bitmap_alpha_mode", reinterpret_cast<getter>(IBitmapFrameWithSoftwareBitmap_get_BitmapAlphaMode), nullptr, nullptr, nullptr },
        { "bitmap_pixel_format", reinterpret_cast<getter>(IBitmapFrameWithSoftwareBitmap_get_BitmapPixelFormat), nullptr, nullptr, nullptr },
        { "bitmap_properties", reinterpret_cast<getter>(IBitmapFrameWithSoftwareBitmap_get_BitmapProperties), nullptr, nullptr, nullptr },
        { "dpi_x", reinterpret_cast<getter>(IBitmapFrameWithSoftwareBitmap_get_DpiX), nullptr, nullptr, nullptr },
        { "dpi_y", reinterpret_cast<getter>(IBitmapFrameWithSoftwareBitmap_get_DpiY), nullptr, nullptr, nullptr },
        { "oriented_pixel_height", reinterpret_cast<getter>(IBitmapFrameWithSoftwareBitmap_get_OrientedPixelHeight), nullptr, nullptr, nullptr },
        { "oriented_pixel_width", reinterpret_cast<getter>(IBitmapFrameWithSoftwareBitmap_get_OrientedPixelWidth), nullptr, nullptr, nullptr },
        { "pixel_height", reinterpret_cast<getter>(IBitmapFrameWithSoftwareBitmap_get_PixelHeight), nullptr, nullptr, nullptr },
        { "pixel_width", reinterpret_cast<getter>(IBitmapFrameWithSoftwareBitmap_get_PixelWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBitmapFrameWithSoftwareBitmap[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBitmapFrameWithSoftwareBitmap) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBitmapFrameWithSoftwareBitmap) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBitmapFrameWithSoftwareBitmap) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBitmapFrameWithSoftwareBitmap) },
        { },
    };

    static PyType_Spec type_spec_IBitmapFrameWithSoftwareBitmap =
    {
        "_winrt_windows_graphics_imaging.IBitmapFrameWithSoftwareBitmap",
        sizeof(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBitmapFrameWithSoftwareBitmap
    };

    // ----- IBitmapPropertiesView interface --------------------

    static PyObject* _new_IBitmapPropertiesView(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Graphics::Imaging::IBitmapPropertiesView>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Graphics::Imaging::IBitmapPropertiesView>::type_name);
        return nullptr;
    }

    static void _dealloc_IBitmapPropertiesView(py::wrapper::Windows::Graphics::Imaging::IBitmapPropertiesView* self) noexcept
    {
        auto tp = Py_TYPE(self);

        if (PyType_IS_GC(tp))
        {
            PyObject_GC_UnTrack(self);
        }

        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBitmapPropertiesView_GetPropertiesAsync(py::wrapper::Windows::Graphics::Imaging::IBitmapPropertiesView* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Graphics.Imaging.IBitmapPropertiesView", L"GetPropertiesAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetPropertiesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IBitmapPropertiesView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Graphics::Imaging::IBitmapPropertiesView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IBitmapPropertiesView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::IBitmapPropertiesView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBitmapPropertiesView[] = {
        { "get_properties_async", reinterpret_cast<PyCFunction>(IBitmapPropertiesView_GetPropertiesAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IBitmapPropertiesView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBitmapPropertiesView), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBitmapPropertiesView[] = {
        { }
    };

    static PyType_Slot _type_slots_IBitmapPropertiesView[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IBitmapPropertiesView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IBitmapPropertiesView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IBitmapPropertiesView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IBitmapPropertiesView) },
        { },
    };

    static PyType_Spec type_spec_IBitmapPropertiesView =
    {
        "_winrt_windows_graphics_imaging.IBitmapPropertiesView",
        sizeof(py::wrapper::Windows::Graphics::Imaging::IBitmapPropertiesView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBitmapPropertiesView
    };

    // ----- BitmapBounds struct --------------------

    PyObject* _new_BitmapBounds(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Graphics::Imaging::BitmapBounds return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        uint32_t _X{};
        uint32_t _Y{};
        uint32_t _Width{};
        uint32_t _Height{};

        static const char* kwlist[] = {"x", "y", "width", "height", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "IIII", const_cast<char**>(kwlist), &_X, &_Y, &_Width, &_Height))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Graphics::Imaging::BitmapBounds return_value{ _X, _Y, _Width, _Height };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_BitmapBounds(py::wrapper::Windows::Graphics::Imaging::BitmapBounds* self) noexcept
    {
    }

    static PyObject* BitmapBounds_get_X(py::wrapper::Windows::Graphics::Imaging::BitmapBounds* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.X);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapBounds_set_X(py::wrapper::Windows::Graphics::Imaging::BitmapBounds* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.X = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapBounds_get_Y(py::wrapper::Windows::Graphics::Imaging::BitmapBounds* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Y);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapBounds_set_Y(py::wrapper::Windows::Graphics::Imaging::BitmapBounds* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Y = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapBounds_get_Width(py::wrapper::Windows::Graphics::Imaging::BitmapBounds* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapBounds_set_Width(py::wrapper::Windows::Graphics::Imaging::BitmapBounds* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Width = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapBounds_get_Height(py::wrapper::Windows::Graphics::Imaging::BitmapBounds* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapBounds_set_Height(py::wrapper::Windows::Graphics::Imaging::BitmapBounds* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Height = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_BitmapBounds[] = {
        { "x", reinterpret_cast<getter>(BitmapBounds_get_X), reinterpret_cast<setter>(BitmapBounds_set_X), nullptr, nullptr },
        { "y", reinterpret_cast<getter>(BitmapBounds_get_Y), reinterpret_cast<setter>(BitmapBounds_set_Y), nullptr, nullptr },
        { "width", reinterpret_cast<getter>(BitmapBounds_get_Width), reinterpret_cast<setter>(BitmapBounds_set_Width), nullptr, nullptr },
        { "height", reinterpret_cast<getter>(BitmapBounds_get_Height), reinterpret_cast<setter>(BitmapBounds_set_Height), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BitmapBounds[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BitmapBounds) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BitmapBounds) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BitmapBounds) },
        { },
    };

    static PyType_Spec type_spec_BitmapBounds =
    {
        "_winrt_windows_graphics_imaging.BitmapBounds",
        sizeof(py::wrapper::Windows::Graphics::Imaging::BitmapBounds),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapBounds
    };

    // ----- BitmapPlaneDescription struct --------------------

    PyObject* _new_BitmapPlaneDescription(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Graphics::Imaging::BitmapPlaneDescription return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        int32_t _StartIndex{};
        int32_t _Width{};
        int32_t _Height{};
        int32_t _Stride{};

        static const char* kwlist[] = {"start_index", "width", "height", "stride", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "iiii", const_cast<char**>(kwlist), &_StartIndex, &_Width, &_Height, &_Stride))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Graphics::Imaging::BitmapPlaneDescription return_value{ _StartIndex, _Width, _Height, _Stride };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_BitmapPlaneDescription(py::wrapper::Windows::Graphics::Imaging::BitmapPlaneDescription* self) noexcept
    {
    }

    static PyObject* BitmapPlaneDescription_get_StartIndex(py::wrapper::Windows::Graphics::Imaging::BitmapPlaneDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartIndex);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapPlaneDescription_set_StartIndex(py::wrapper::Windows::Graphics::Imaging::BitmapPlaneDescription* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.StartIndex = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapPlaneDescription_get_Width(py::wrapper::Windows::Graphics::Imaging::BitmapPlaneDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapPlaneDescription_set_Width(py::wrapper::Windows::Graphics::Imaging::BitmapPlaneDescription* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Width = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapPlaneDescription_get_Height(py::wrapper::Windows::Graphics::Imaging::BitmapPlaneDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapPlaneDescription_set_Height(py::wrapper::Windows::Graphics::Imaging::BitmapPlaneDescription* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Height = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapPlaneDescription_get_Stride(py::wrapper::Windows::Graphics::Imaging::BitmapPlaneDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Stride);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapPlaneDescription_set_Stride(py::wrapper::Windows::Graphics::Imaging::BitmapPlaneDescription* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Stride = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_BitmapPlaneDescription[] = {
        { "start_index", reinterpret_cast<getter>(BitmapPlaneDescription_get_StartIndex), reinterpret_cast<setter>(BitmapPlaneDescription_set_StartIndex), nullptr, nullptr },
        { "width", reinterpret_cast<getter>(BitmapPlaneDescription_get_Width), reinterpret_cast<setter>(BitmapPlaneDescription_set_Width), nullptr, nullptr },
        { "height", reinterpret_cast<getter>(BitmapPlaneDescription_get_Height), reinterpret_cast<setter>(BitmapPlaneDescription_set_Height), nullptr, nullptr },
        { "stride", reinterpret_cast<getter>(BitmapPlaneDescription_get_Stride), reinterpret_cast<setter>(BitmapPlaneDescription_set_Stride), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BitmapPlaneDescription[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BitmapPlaneDescription) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BitmapPlaneDescription) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BitmapPlaneDescription) },
        { },
    };

    static PyType_Spec type_spec_BitmapPlaneDescription =
    {
        "_winrt_windows_graphics_imaging.BitmapPlaneDescription",
        sizeof(py::wrapper::Windows::Graphics::Imaging::BitmapPlaneDescription),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapPlaneDescription
    };

    // ----- BitmapSize struct --------------------

    PyObject* _new_BitmapSize(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Graphics::Imaging::BitmapSize return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        uint32_t _Width{};
        uint32_t _Height{};

        static const char* kwlist[] = {"width", "height", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "II", const_cast<char**>(kwlist), &_Width, &_Height))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Graphics::Imaging::BitmapSize return_value{ _Width, _Height };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_BitmapSize(py::wrapper::Windows::Graphics::Imaging::BitmapSize* self) noexcept
    {
    }

    static PyObject* BitmapSize_get_Width(py::wrapper::Windows::Graphics::Imaging::BitmapSize* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapSize_set_Width(py::wrapper::Windows::Graphics::Imaging::BitmapSize* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Width = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapSize_get_Height(py::wrapper::Windows::Graphics::Imaging::BitmapSize* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapSize_set_Height(py::wrapper::Windows::Graphics::Imaging::BitmapSize* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Height = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_BitmapSize[] = {
        { "width", reinterpret_cast<getter>(BitmapSize_get_Width), reinterpret_cast<setter>(BitmapSize_set_Width), nullptr, nullptr },
        { "height", reinterpret_cast<getter>(BitmapSize_get_Height), reinterpret_cast<setter>(BitmapSize_set_Height), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BitmapSize[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BitmapSize) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BitmapSize) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BitmapSize) },
        { },
    };

    static PyType_Spec type_spec_BitmapSize =
    {
        "_winrt_windows_graphics_imaging.BitmapSize",
        sizeof(py::wrapper::Windows::Graphics::Imaging::BitmapSize),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapSize
    };

    // ----- Windows.Graphics.Imaging Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Graphics::Imaging");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_graphics_imaging",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::Graphics::Imaging

PyMODINIT_FUNC PyInit__winrt_windows_graphics_imaging(void) noexcept
{
    using namespace py::cpp::Windows::Graphics::Imaging;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_BitmapBuffer, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_BitmapBuffer, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_BitmapCodecInformation, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_BitmapCodecInformation, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_BitmapDecoder_Meta{PyType_FromSpec(&type_spec_BitmapDecoder_Meta)};
    if (!type_BitmapDecoder_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_BitmapDecoder, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BitmapDecoder_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_BitmapDecoder, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BitmapDecoder_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    py::pyobj_handle type_BitmapEncoder_Meta{PyType_FromSpec(&type_spec_BitmapEncoder_Meta)};
    if (!type_BitmapEncoder_Meta)
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_BitmapEncoder, nullptr, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BitmapEncoder_Meta.get())) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_BitmapEncoder, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BitmapEncoder_Meta.get())) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_BitmapFrame, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_BitmapFrame, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_BitmapProperties, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_BitmapProperties, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_BitmapPropertiesView, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_BitmapPropertiesView, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_BitmapPropertySet, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_BitmapPropertySet, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_BitmapTransform, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_BitmapTransform, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_BitmapTypedValue, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_BitmapTypedValue, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_ImageStream, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_ImageStream, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_PixelDataProvider, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_PixelDataProvider, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_SoftwareBitmap, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_SoftwareBitmap, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_IBitmapFrame, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_IBitmapFrame, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_IBitmapFrameWithSoftwareBitmap, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_IBitmapFrameWithSoftwareBitmap, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_IBitmapPropertiesView, nullptr, object_bases.get(), nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_IBitmapPropertiesView, object_bases.get(), nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_BitmapBounds, nullptr, nullptr, nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_BitmapBounds, nullptr, nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_BitmapPlaneDescription, nullptr, nullptr, nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_BitmapPlaneDescription, nullptr, nullptr) == -1)
    #endif
    {
        return nullptr;
    }

    #if PY_VERSION_HEX < 0x03090000
    if (py::register_python_type(module.get(), &type_spec_BitmapSize, nullptr, nullptr, nullptr) == -1)
    #else
    if (py::register_python_type(module.get(), &type_spec_BitmapSize, nullptr, nullptr) == -1)
    #endif
    {
        return nullptr;
    }


    return module.detach();
}
