// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Microsoft.UI.Content.h"

namespace py::cpp::Microsoft::UI::Content
{
    // ----- ContentCoordinateConverter class --------------------

    static PyObject* _new_ContentCoordinateConverter(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Content::ContentCoordinateConverter>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Content::ContentCoordinateConverter>::type_name);
        return nullptr;
    }

    static void _dealloc_ContentCoordinateConverter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContentCoordinateConverter_ConvertLocalToScreenWithPoint(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.ContentCoordinateConverter", L"ConvertLocalToScreen", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Content::ContentCoordinateConverter>().ConvertLocalToScreen(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContentCoordinateConverter_ConvertLocalToScreenWithPoints(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.ContentCoordinateConverter", L"ConvertLocalToScreen", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, false>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Content::ContentCoordinateConverter>().ConvertLocalToScreen(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContentCoordinateConverter_ConvertLocalToScreenWithPointsAndRoundingMode(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.ContentCoordinateConverter", L"ConvertLocalToScreen", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Content::ContentCoordinateRoundingMode>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Content::ContentCoordinateConverter>().ConvertLocalToScreen(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContentCoordinateConverter_ConvertLocalToScreenWithRect(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.ContentCoordinateConverter", L"ConvertLocalToScreen", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Content::ContentCoordinateConverter>().ConvertLocalToScreen(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContentCoordinateConverter_ConvertScreenToLocalWithPoint(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.ContentCoordinateConverter", L"ConvertScreenToLocal", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::PointInt32>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Content::ContentCoordinateConverter>().ConvertScreenToLocal(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContentCoordinateConverter_ConvertScreenToLocalWithPoints(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.ContentCoordinateConverter", L"ConvertScreenToLocal", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Graphics::PointInt32, false>>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Content::ContentCoordinateConverter>().ConvertScreenToLocal(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContentCoordinateConverter_ConvertScreenToLocalWithRect(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.ContentCoordinateConverter", L"ConvertScreenToLocal", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::RectInt32>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Content::ContentCoordinateConverter>().ConvertScreenToLocal(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContentCoordinateConverter_CreateForWindowId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.ContentCoordinateConverter", L"CreateForWindowId", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::WindowId>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Content::ContentCoordinateConverter::CreateForWindowId(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContentCoordinateConverter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Content::ContentCoordinateConverter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContentCoordinateConverter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Content::ContentCoordinateConverter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContentCoordinateConverter[] = {
        { "convert_local_to_screen_with_point", reinterpret_cast<PyCFunction>(ContentCoordinateConverter_ConvertLocalToScreenWithPoint), METH_VARARGS, nullptr },
        { "convert_local_to_screen_with_points", reinterpret_cast<PyCFunction>(ContentCoordinateConverter_ConvertLocalToScreenWithPoints), METH_VARARGS, nullptr },
        { "convert_local_to_screen_with_points_and_rounding_mode", reinterpret_cast<PyCFunction>(ContentCoordinateConverter_ConvertLocalToScreenWithPointsAndRoundingMode), METH_VARARGS, nullptr },
        { "convert_local_to_screen_with_rect", reinterpret_cast<PyCFunction>(ContentCoordinateConverter_ConvertLocalToScreenWithRect), METH_VARARGS, nullptr },
        { "convert_screen_to_local_with_point", reinterpret_cast<PyCFunction>(ContentCoordinateConverter_ConvertScreenToLocalWithPoint), METH_VARARGS, nullptr },
        { "convert_screen_to_local_with_points", reinterpret_cast<PyCFunction>(ContentCoordinateConverter_ConvertScreenToLocalWithPoints), METH_VARARGS, nullptr },
        { "convert_screen_to_local_with_rect", reinterpret_cast<PyCFunction>(ContentCoordinateConverter_ConvertScreenToLocalWithRect), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContentCoordinateConverter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContentCoordinateConverter), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ContentCoordinateConverter[] = {
        { }};

    static PyType_Slot _type_slots_ContentCoordinateConverter[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContentCoordinateConverter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContentCoordinateConverter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContentCoordinateConverter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContentCoordinateConverter) },
        { }};

    static PyType_Spec type_spec_ContentCoordinateConverter = {
        "winrt._winrt_microsoft_ui_content.ContentCoordinateConverter",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ContentCoordinateConverter};

    static PyGetSetDef getset_ContentCoordinateConverter_Static[] = {
        { }};

    static PyMethodDef methods_ContentCoordinateConverter_Static[] = {
        { "create_for_window_id", reinterpret_cast<PyCFunction>(ContentCoordinateConverter_CreateForWindowId), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_ContentCoordinateConverter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ContentCoordinateConverter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ContentCoordinateConverter_Static) },
        { }
    };

    static PyType_Spec type_spec_ContentCoordinateConverter_Static = {
        "winrt._winrt_microsoft_ui_content.ContentCoordinateConverter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ContentCoordinateConverter_Static};

    // ----- ContentDeferral class --------------------

    static PyObject* _new_ContentDeferral(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Content::ContentDeferral>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Content::ContentDeferral>::type_name);
        return nullptr;
    }

    static void _dealloc_ContentDeferral(py::wrapper::Microsoft::UI::Content::ContentDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContentDeferral_Complete(py::wrapper::Microsoft::UI::Content::ContentDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.ContentDeferral", L"Complete", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Complete();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContentDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Content::ContentDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContentDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Content::ContentDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContentDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(ContentDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContentDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContentDeferral), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ContentDeferral[] = {
        { }};

    static PyType_Slot _type_slots_ContentDeferral[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContentDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContentDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContentDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContentDeferral) },
        { }};

    static PyType_Spec type_spec_ContentDeferral = {
        "winrt._winrt_microsoft_ui_content.ContentDeferral",
        sizeof(py::wrapper::Microsoft::UI::Content::ContentDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContentDeferral};

    // ----- ContentEnvironmentSettingChangedEventArgs class --------------------

    static PyObject* _new_ContentEnvironmentSettingChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Content::ContentEnvironmentSettingChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Content::ContentEnvironmentSettingChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ContentEnvironmentSettingChangedEventArgs(py::wrapper::Microsoft::UI::Content::ContentEnvironmentSettingChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContentEnvironmentSettingChangedEventArgs_get_SettingName(py::wrapper::Microsoft::UI::Content::ContentEnvironmentSettingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentEnvironmentSettingChangedEventArgs", L"SettingName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SettingName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContentEnvironmentSettingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Content::ContentEnvironmentSettingChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContentEnvironmentSettingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Content::ContentEnvironmentSettingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContentEnvironmentSettingChangedEventArgs[] = {
        { "_assign_array_", _assign_array_ContentEnvironmentSettingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContentEnvironmentSettingChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ContentEnvironmentSettingChangedEventArgs[] = {
        { "setting_name", reinterpret_cast<getter>(ContentEnvironmentSettingChangedEventArgs_get_SettingName), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ContentEnvironmentSettingChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContentEnvironmentSettingChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContentEnvironmentSettingChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContentEnvironmentSettingChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContentEnvironmentSettingChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_ContentEnvironmentSettingChangedEventArgs = {
        "winrt._winrt_microsoft_ui_content.ContentEnvironmentSettingChangedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Content::ContentEnvironmentSettingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContentEnvironmentSettingChangedEventArgs};

    // ----- ContentEnvironmentStateChangedEventArgs class --------------------

    static PyObject* _new_ContentEnvironmentStateChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Content::ContentEnvironmentStateChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Content::ContentEnvironmentStateChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ContentEnvironmentStateChangedEventArgs(py::wrapper::Microsoft::UI::Content::ContentEnvironmentStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContentEnvironmentStateChangedEventArgs_get_DidAppWindowIdChange(py::wrapper::Microsoft::UI::Content::ContentEnvironmentStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentEnvironmentStateChangedEventArgs", L"DidAppWindowIdChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DidAppWindowIdChange();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentEnvironmentStateChangedEventArgs_get_DidDisplayIdChange(py::wrapper::Microsoft::UI::Content::ContentEnvironmentStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentEnvironmentStateChangedEventArgs", L"DidDisplayIdChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DidDisplayIdChange();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContentEnvironmentStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Content::ContentEnvironmentStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContentEnvironmentStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Content::ContentEnvironmentStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContentEnvironmentStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_ContentEnvironmentStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContentEnvironmentStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ContentEnvironmentStateChangedEventArgs[] = {
        { "did_app_window_id_change", reinterpret_cast<getter>(ContentEnvironmentStateChangedEventArgs_get_DidAppWindowIdChange), nullptr, nullptr, nullptr },
        { "did_display_id_change", reinterpret_cast<getter>(ContentEnvironmentStateChangedEventArgs_get_DidDisplayIdChange), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ContentEnvironmentStateChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContentEnvironmentStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContentEnvironmentStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContentEnvironmentStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContentEnvironmentStateChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_ContentEnvironmentStateChangedEventArgs = {
        "winrt._winrt_microsoft_ui_content.ContentEnvironmentStateChangedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Content::ContentEnvironmentStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContentEnvironmentStateChangedEventArgs};

    // ----- ContentIsland class --------------------

    static PyObject* _new_ContentIsland(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Content::ContentIsland>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Content::ContentIsland>::type_name);
        return nullptr;
    }

    static void _dealloc_ContentIsland(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContentIsland_Close(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.ContentIsland", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Content::ContentIsland>().Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContentIsland_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.ContentIsland", L"Create", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Visual>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Content::ContentIsland::Create(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContentIsland_FindAllForCompositor(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.ContentIsland", L"FindAllForCompositor", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Compositor>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Content::ContentIsland::FindAllForCompositor(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContentIsland_FindAllForCurrentThread(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.ContentIsland", L"FindAllForCurrentThread", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Content::ContentIsland::FindAllForCurrentThread();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContentIsland_GetAutomationHostProvider(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.ContentIsland", L"GetAutomationHostProvider", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Content::ContentIsland>().GetAutomationHostProvider();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContentIsland_GetByVisual(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.ContentIsland", L"GetByVisual", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Visual>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Content::ContentIsland::GetByVisual(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContentIsland_GetFromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.ContentIsland", L"GetFromId", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Content::ContentIsland::GetFromId(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContentIsland_GetStateChangeDeferral(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.ContentIsland", L"GetStateChangeDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Content::ContentIsland>().GetStateChangeDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContentIsland_RequestSize(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.ContentIsland", L"RequestSize", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Content::ContentIsland>().RequestSize(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContentIsland_get_SystemBackdrop(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"SystemBackdrop");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentIsland>().SystemBackdrop();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentIsland_put_SystemBackdrop(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"SystemBackdrop");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::UI::Composition::CompositionBrush>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Content::ContentIsland>().SystemBackdrop(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentIsland_get_IsIslandVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"IsIslandVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentIsland>().IsIslandVisible();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentIsland_put_IsIslandVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"IsIslandVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Content::ContentIsland>().IsIslandVisible(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentIsland_get_IsIslandEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"IsIslandEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentIsland>().IsIslandEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentIsland_put_IsIslandEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"IsIslandEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Content::ContentIsland>().IsIslandEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentIsland_get_IsHitTestVisibleWhenTransparent(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"IsHitTestVisibleWhenTransparent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentIsland>().IsHitTestVisibleWhenTransparent();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentIsland_put_IsHitTestVisibleWhenTransparent(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"IsHitTestVisibleWhenTransparent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Content::ContentIsland>().IsHitTestVisibleWhenTransparent(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentIsland_get_AppData(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"AppData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentIsland>().AppData();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentIsland_put_AppData(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"AppData");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Content::ContentIsland>().AppData(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentIsland_get_ActualSize(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"ActualSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentIsland>().ActualSize();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIsland_get_CoordinateConverter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"CoordinateConverter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentIsland>().CoordinateConverter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIsland_get_CustomProperties(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"CustomProperties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentIsland>().CustomProperties();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIsland_get_DispatcherQueue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"DispatcherQueue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentIsland>().DispatcherQueue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIsland_get_Environment(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"Environment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentIsland>().Environment();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIsland_get_Id(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentIsland>().Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIsland_get_IsConnected(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"IsConnected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentIsland>().IsConnected();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIsland_get_IsSiteEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"IsSiteEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentIsland>().IsSiteEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIsland_get_IsSiteVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"IsSiteVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentIsland>().IsSiteVisible();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIsland_get_LayoutDirection(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"LayoutDirection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentIsland>().LayoutDirection();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIsland_get_RasterizationScale(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"RasterizationScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentIsland>().RasterizationScale();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIsland_get_IsClosed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"IsClosed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentIsland>().IsClosed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIsland_add_AutomationProviderRequested(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.ContentIsland", L"AutomationProviderRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Content::ContentIsland, winrt::Microsoft::UI::Content::ContentIslandAutomationProviderRequestedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentIsland>().AutomationProviderRequested(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIsland_remove_AutomationProviderRequested(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.ContentIsland", L"AutomationProviderRequested");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Content::ContentIsland>().AutomationProviderRequested(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIsland_add_StateChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.ContentIsland", L"StateChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Content::ContentIsland, winrt::Microsoft::UI::Content::ContentIslandStateChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentIsland>().StateChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIsland_remove_StateChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.ContentIsland", L"StateChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Content::ContentIsland>().StateChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIsland_add_Closed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.ContentIsland", L"Closed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::ClosableNotifierHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentIsland>().Closed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIsland_remove_Closed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.ContentIsland", L"Closed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Content::ContentIsland>().Closed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIsland_add_FrameworkClosed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.ContentIsland", L"FrameworkClosed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::ClosableNotifierHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentIsland>().FrameworkClosed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIsland_remove_FrameworkClosed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.ContentIsland", L"FrameworkClosed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Content::ContentIsland>().FrameworkClosed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContentIsland(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Content::ContentIsland>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContentIsland(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Content::ContentIsland>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ContentIsland(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_ContentIsland(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Content::ContentIsland>().Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContentIsland[] = {
        { "close", reinterpret_cast<PyCFunction>(ContentIsland_Close), METH_VARARGS, nullptr },
        { "get_automation_host_provider", reinterpret_cast<PyCFunction>(ContentIsland_GetAutomationHostProvider), METH_VARARGS, nullptr },
        { "get_state_change_deferral", reinterpret_cast<PyCFunction>(ContentIsland_GetStateChangeDeferral), METH_VARARGS, nullptr },
        { "request_size", reinterpret_cast<PyCFunction>(ContentIsland_RequestSize), METH_VARARGS, nullptr },
        { "add_automation_provider_requested", reinterpret_cast<PyCFunction>(ContentIsland_add_AutomationProviderRequested), METH_O, nullptr },
        { "remove_automation_provider_requested", reinterpret_cast<PyCFunction>(ContentIsland_remove_AutomationProviderRequested), METH_O, nullptr },
        { "add_state_changed", reinterpret_cast<PyCFunction>(ContentIsland_add_StateChanged), METH_O, nullptr },
        { "remove_state_changed", reinterpret_cast<PyCFunction>(ContentIsland_remove_StateChanged), METH_O, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(ContentIsland_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(ContentIsland_remove_Closed), METH_O, nullptr },
        { "add_framework_closed", reinterpret_cast<PyCFunction>(ContentIsland_add_FrameworkClosed), METH_O, nullptr },
        { "remove_framework_closed", reinterpret_cast<PyCFunction>(ContentIsland_remove_FrameworkClosed), METH_O, nullptr },
        { "_assign_array_", _assign_array_ContentIsland, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContentIsland), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ContentIsland), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_ContentIsland), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_ContentIsland[] = {
        { "system_backdrop", reinterpret_cast<getter>(ContentIsland_get_SystemBackdrop), reinterpret_cast<setter>(ContentIsland_put_SystemBackdrop), nullptr, nullptr },
        { "is_island_visible", reinterpret_cast<getter>(ContentIsland_get_IsIslandVisible), reinterpret_cast<setter>(ContentIsland_put_IsIslandVisible), nullptr, nullptr },
        { "is_island_enabled", reinterpret_cast<getter>(ContentIsland_get_IsIslandEnabled), reinterpret_cast<setter>(ContentIsland_put_IsIslandEnabled), nullptr, nullptr },
        { "is_hit_test_visible_when_transparent", reinterpret_cast<getter>(ContentIsland_get_IsHitTestVisibleWhenTransparent), reinterpret_cast<setter>(ContentIsland_put_IsHitTestVisibleWhenTransparent), nullptr, nullptr },
        { "app_data", reinterpret_cast<getter>(ContentIsland_get_AppData), reinterpret_cast<setter>(ContentIsland_put_AppData), nullptr, nullptr },
        { "actual_size", reinterpret_cast<getter>(ContentIsland_get_ActualSize), nullptr, nullptr, nullptr },
        { "coordinate_converter", reinterpret_cast<getter>(ContentIsland_get_CoordinateConverter), nullptr, nullptr, nullptr },
        { "custom_properties", reinterpret_cast<getter>(ContentIsland_get_CustomProperties), nullptr, nullptr, nullptr },
        { "dispatcher_queue", reinterpret_cast<getter>(ContentIsland_get_DispatcherQueue), nullptr, nullptr, nullptr },
        { "environment", reinterpret_cast<getter>(ContentIsland_get_Environment), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ContentIsland_get_Id), nullptr, nullptr, nullptr },
        { "is_connected", reinterpret_cast<getter>(ContentIsland_get_IsConnected), nullptr, nullptr, nullptr },
        { "is_site_enabled", reinterpret_cast<getter>(ContentIsland_get_IsSiteEnabled), nullptr, nullptr, nullptr },
        { "is_site_visible", reinterpret_cast<getter>(ContentIsland_get_IsSiteVisible), nullptr, nullptr, nullptr },
        { "layout_direction", reinterpret_cast<getter>(ContentIsland_get_LayoutDirection), nullptr, nullptr, nullptr },
        { "rasterization_scale", reinterpret_cast<getter>(ContentIsland_get_RasterizationScale), nullptr, nullptr, nullptr },
        { "is_closed", reinterpret_cast<getter>(ContentIsland_get_IsClosed), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ContentIsland[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContentIsland) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContentIsland) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContentIsland) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContentIsland) },
        { }};

    static PyType_Spec type_spec_ContentIsland = {
        "winrt._winrt_microsoft_ui_content.ContentIsland",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ContentIsland};

    static PyGetSetDef getset_ContentIsland_Static[] = {
        { }};

    static PyMethodDef methods_ContentIsland_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(ContentIsland_Create), METH_VARARGS, nullptr },
        { "find_all_for_compositor", reinterpret_cast<PyCFunction>(ContentIsland_FindAllForCompositor), METH_VARARGS, nullptr },
        { "find_all_for_current_thread", reinterpret_cast<PyCFunction>(ContentIsland_FindAllForCurrentThread), METH_VARARGS, nullptr },
        { "get_by_visual", reinterpret_cast<PyCFunction>(ContentIsland_GetByVisual), METH_VARARGS, nullptr },
        { "get_from_id", reinterpret_cast<PyCFunction>(ContentIsland_GetFromId), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_ContentIsland_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ContentIsland_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ContentIsland_Static) },
        { }
    };

    static PyType_Spec type_spec_ContentIsland_Static = {
        "winrt._winrt_microsoft_ui_content.ContentIsland_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ContentIsland_Static};

    // ----- ContentIslandAutomationProviderRequestedEventArgs class --------------------

    static PyObject* _new_ContentIslandAutomationProviderRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Content::ContentIslandAutomationProviderRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Content::ContentIslandAutomationProviderRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ContentIslandAutomationProviderRequestedEventArgs(py::wrapper::Microsoft::UI::Content::ContentIslandAutomationProviderRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContentIslandAutomationProviderRequestedEventArgs_get_Handled(py::wrapper::Microsoft::UI::Content::ContentIslandAutomationProviderRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIslandAutomationProviderRequestedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Handled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentIslandAutomationProviderRequestedEventArgs_put_Handled(py::wrapper::Microsoft::UI::Content::ContentIslandAutomationProviderRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIslandAutomationProviderRequestedEventArgs", L"Handled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.Handled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentIslandAutomationProviderRequestedEventArgs_get_AutomationProvider(py::wrapper::Microsoft::UI::Content::ContentIslandAutomationProviderRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIslandAutomationProviderRequestedEventArgs", L"AutomationProvider");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AutomationProvider();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentIslandAutomationProviderRequestedEventArgs_put_AutomationProvider(py::wrapper::Microsoft::UI::Content::ContentIslandAutomationProviderRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIslandAutomationProviderRequestedEventArgs", L"AutomationProvider");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            {
                auto _gil = release_gil();
                self->obj.AutomationProvider(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ContentIslandAutomationProviderRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Content::ContentIslandAutomationProviderRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContentIslandAutomationProviderRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Content::ContentIslandAutomationProviderRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContentIslandAutomationProviderRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_ContentIslandAutomationProviderRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContentIslandAutomationProviderRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ContentIslandAutomationProviderRequestedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(ContentIslandAutomationProviderRequestedEventArgs_get_Handled), reinterpret_cast<setter>(ContentIslandAutomationProviderRequestedEventArgs_put_Handled), nullptr, nullptr },
        { "automation_provider", reinterpret_cast<getter>(ContentIslandAutomationProviderRequestedEventArgs_get_AutomationProvider), reinterpret_cast<setter>(ContentIslandAutomationProviderRequestedEventArgs_put_AutomationProvider), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ContentIslandAutomationProviderRequestedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContentIslandAutomationProviderRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContentIslandAutomationProviderRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContentIslandAutomationProviderRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContentIslandAutomationProviderRequestedEventArgs) },
        { }};

    static PyType_Spec type_spec_ContentIslandAutomationProviderRequestedEventArgs = {
        "winrt._winrt_microsoft_ui_content.ContentIslandAutomationProviderRequestedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Content::ContentIslandAutomationProviderRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContentIslandAutomationProviderRequestedEventArgs};

    // ----- ContentIslandEnvironment class --------------------

    static PyObject* _new_ContentIslandEnvironment(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Content::ContentIslandEnvironment>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Content::ContentIslandEnvironment>::type_name);
        return nullptr;
    }

    static void _dealloc_ContentIslandEnvironment(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContentIslandEnvironment_get_AppWindowId(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIslandEnvironment", L"AppWindowId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentIslandEnvironment>().AppWindowId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIslandEnvironment_get_DisplayId(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIslandEnvironment", L"DisplayId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentIslandEnvironment>().DisplayId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIslandEnvironment_add_SettingChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.ContentIslandEnvironment", L"SettingChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Content::ContentIslandEnvironment, winrt::Microsoft::UI::Content::ContentEnvironmentSettingChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentIslandEnvironment>().SettingChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIslandEnvironment_remove_SettingChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.ContentIslandEnvironment", L"SettingChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Content::ContentIslandEnvironment>().SettingChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIslandEnvironment_add_StateChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.ContentIslandEnvironment", L"StateChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Content::ContentIslandEnvironment, winrt::Microsoft::UI::Content::ContentEnvironmentStateChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentIslandEnvironment>().StateChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIslandEnvironment_remove_StateChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.ContentIslandEnvironment", L"StateChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Content::ContentIslandEnvironment>().StateChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContentIslandEnvironment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Content::ContentIslandEnvironment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContentIslandEnvironment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Content::ContentIslandEnvironment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContentIslandEnvironment[] = {
        { "add_setting_changed", reinterpret_cast<PyCFunction>(ContentIslandEnvironment_add_SettingChanged), METH_O, nullptr },
        { "remove_setting_changed", reinterpret_cast<PyCFunction>(ContentIslandEnvironment_remove_SettingChanged), METH_O, nullptr },
        { "add_state_changed", reinterpret_cast<PyCFunction>(ContentIslandEnvironment_add_StateChanged), METH_O, nullptr },
        { "remove_state_changed", reinterpret_cast<PyCFunction>(ContentIslandEnvironment_remove_StateChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ContentIslandEnvironment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContentIslandEnvironment), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ContentIslandEnvironment[] = {
        { "app_window_id", reinterpret_cast<getter>(ContentIslandEnvironment_get_AppWindowId), nullptr, nullptr, nullptr },
        { "display_id", reinterpret_cast<getter>(ContentIslandEnvironment_get_DisplayId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ContentIslandEnvironment[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContentIslandEnvironment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContentIslandEnvironment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContentIslandEnvironment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContentIslandEnvironment) },
        { }};

    static PyType_Spec type_spec_ContentIslandEnvironment = {
        "winrt._winrt_microsoft_ui_content.ContentIslandEnvironment",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ContentIslandEnvironment};

    static PyGetSetDef getset_ContentIslandEnvironment_Static[] = {
        { }};

    static PyMethodDef methods_ContentIslandEnvironment_Static[] = {
        { }};

    static PyType_Slot type_slots_ContentIslandEnvironment_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ContentIslandEnvironment_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ContentIslandEnvironment_Static) },
        { }
    };

    static PyType_Spec type_spec_ContentIslandEnvironment_Static = {
        "winrt._winrt_microsoft_ui_content.ContentIslandEnvironment_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ContentIslandEnvironment_Static};

    // ----- ContentIslandStateChangedEventArgs class --------------------

    static PyObject* _new_ContentIslandStateChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Content::ContentIslandStateChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Content::ContentIslandStateChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ContentIslandStateChangedEventArgs(py::wrapper::Microsoft::UI::Content::ContentIslandStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContentIslandStateChangedEventArgs_get_DidActualSizeChange(py::wrapper::Microsoft::UI::Content::ContentIslandStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIslandStateChangedEventArgs", L"DidActualSizeChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DidActualSizeChange();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIslandStateChangedEventArgs_get_DidLayoutDirectionChange(py::wrapper::Microsoft::UI::Content::ContentIslandStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIslandStateChangedEventArgs", L"DidLayoutDirectionChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DidLayoutDirectionChange();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIslandStateChangedEventArgs_get_DidRasterizationScaleChange(py::wrapper::Microsoft::UI::Content::ContentIslandStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIslandStateChangedEventArgs", L"DidRasterizationScaleChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DidRasterizationScaleChange();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIslandStateChangedEventArgs_get_DidSiteEnabledChange(py::wrapper::Microsoft::UI::Content::ContentIslandStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIslandStateChangedEventArgs", L"DidSiteEnabledChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DidSiteEnabledChange();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIslandStateChangedEventArgs_get_DidSiteVisibleChange(py::wrapper::Microsoft::UI::Content::ContentIslandStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIslandStateChangedEventArgs", L"DidSiteVisibleChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DidSiteVisibleChange();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContentIslandStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Content::ContentIslandStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContentIslandStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Content::ContentIslandStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContentIslandStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_ContentIslandStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContentIslandStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ContentIslandStateChangedEventArgs[] = {
        { "did_actual_size_change", reinterpret_cast<getter>(ContentIslandStateChangedEventArgs_get_DidActualSizeChange), nullptr, nullptr, nullptr },
        { "did_layout_direction_change", reinterpret_cast<getter>(ContentIslandStateChangedEventArgs_get_DidLayoutDirectionChange), nullptr, nullptr, nullptr },
        { "did_rasterization_scale_change", reinterpret_cast<getter>(ContentIslandStateChangedEventArgs_get_DidRasterizationScaleChange), nullptr, nullptr, nullptr },
        { "did_site_enabled_change", reinterpret_cast<getter>(ContentIslandStateChangedEventArgs_get_DidSiteEnabledChange), nullptr, nullptr, nullptr },
        { "did_site_visible_change", reinterpret_cast<getter>(ContentIslandStateChangedEventArgs_get_DidSiteVisibleChange), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ContentIslandStateChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContentIslandStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContentIslandStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContentIslandStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContentIslandStateChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_ContentIslandStateChangedEventArgs = {
        "winrt._winrt_microsoft_ui_content.ContentIslandStateChangedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Content::ContentIslandStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContentIslandStateChangedEventArgs};

    // ----- ContentSite class --------------------

    static PyObject* _new_ContentSite(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Content::ContentSite>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Content::ContentSite>::type_name);
        return nullptr;
    }

    static void _dealloc_ContentSite(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContentSite_Close(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.ContentSite", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Content::ContentSite>().Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContentSite_GetIslandStateChangeDeferral(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.ContentSite", L"GetIslandStateChangeDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Content::ContentSite>().GetIslandStateChangeDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContentSite_get_ShouldApplyRasterizationScale(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"ShouldApplyRasterizationScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentSite>().ShouldApplyRasterizationScale();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentSite_put_ShouldApplyRasterizationScale(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"ShouldApplyRasterizationScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Content::ContentSite>().ShouldApplyRasterizationScale(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentSite_get_ParentScale(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"ParentScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentSite>().ParentScale();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentSite_put_ParentScale(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"ParentScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Content::ContentSite>().ParentScale(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentSite_get_OverrideScale(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"OverrideScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentSite>().OverrideScale();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentSite_put_OverrideScale(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"OverrideScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Content::ContentSite>().OverrideScale(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentSite_get_LayoutDirection(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"LayoutDirection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentSite>().LayoutDirection();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentSite_put_LayoutDirection(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"LayoutDirection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Content::ContentLayoutDirection>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Content::ContentSite>().LayoutDirection(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentSite_get_IsSiteVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"IsSiteVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentSite>().IsSiteVisible();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentSite_put_IsSiteVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"IsSiteVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Content::ContentSite>().IsSiteVisible(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentSite_get_IsSiteEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"IsSiteEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentSite>().IsSiteEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentSite_put_IsSiteEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"IsSiteEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Content::ContentSite>().IsSiteEnabled(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentSite_get_ClientSize(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"ClientSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentSite>().ClientSize();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentSite_put_ClientSize(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"ClientSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Graphics::SizeInt32>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Content::ContentSite>().ClientSize(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentSite_get_ActualSize(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"ActualSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentSite>().ActualSize();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentSite_put_ActualSize(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"ActualSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Content::ContentSite>().ActualSize(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentSite_get_CoordinateConverter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"CoordinateConverter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentSite>().CoordinateConverter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSite_get_DispatcherQueue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"DispatcherQueue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentSite>().DispatcherQueue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSite_get_Environment(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"Environment");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentSite>().Environment();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSite_get_IsConnected(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"IsConnected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentSite>().IsConnected();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSite_get_RasterizationScale(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"RasterizationScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentSite>().RasterizationScale();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSite_get_RequestedSize(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"RequestedSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentSite>().RequestedSize();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSite_get_View(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"View");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentSite>().View();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSite_get_IsClosed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"IsClosed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentSite>().IsClosed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSite_add_RequestedStateChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.ContentSite", L"RequestedStateChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Content::ContentSite, winrt::Microsoft::UI::Content::ContentSiteRequestedStateChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentSite>().RequestedStateChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSite_remove_RequestedStateChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.ContentSite", L"RequestedStateChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Content::ContentSite>().RequestedStateChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSite_add_Closed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.ContentSite", L"Closed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::ClosableNotifierHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentSite>().Closed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSite_remove_Closed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.ContentSite", L"Closed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Content::ContentSite>().Closed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSite_add_FrameworkClosed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.ContentSite", L"FrameworkClosed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::ClosableNotifierHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentSite>().FrameworkClosed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSite_remove_FrameworkClosed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.ContentSite", L"FrameworkClosed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Content::ContentSite>().FrameworkClosed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContentSite(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Content::ContentSite>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContentSite(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Content::ContentSite>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ContentSite(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_ContentSite(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Content::ContentSite>().Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContentSite[] = {
        { "close", reinterpret_cast<PyCFunction>(ContentSite_Close), METH_VARARGS, nullptr },
        { "get_island_state_change_deferral", reinterpret_cast<PyCFunction>(ContentSite_GetIslandStateChangeDeferral), METH_VARARGS, nullptr },
        { "add_requested_state_changed", reinterpret_cast<PyCFunction>(ContentSite_add_RequestedStateChanged), METH_O, nullptr },
        { "remove_requested_state_changed", reinterpret_cast<PyCFunction>(ContentSite_remove_RequestedStateChanged), METH_O, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(ContentSite_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(ContentSite_remove_Closed), METH_O, nullptr },
        { "add_framework_closed", reinterpret_cast<PyCFunction>(ContentSite_add_FrameworkClosed), METH_O, nullptr },
        { "remove_framework_closed", reinterpret_cast<PyCFunction>(ContentSite_remove_FrameworkClosed), METH_O, nullptr },
        { "_assign_array_", _assign_array_ContentSite, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContentSite), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ContentSite), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_ContentSite), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_ContentSite[] = {
        { "should_apply_rasterization_scale", reinterpret_cast<getter>(ContentSite_get_ShouldApplyRasterizationScale), reinterpret_cast<setter>(ContentSite_put_ShouldApplyRasterizationScale), nullptr, nullptr },
        { "parent_scale", reinterpret_cast<getter>(ContentSite_get_ParentScale), reinterpret_cast<setter>(ContentSite_put_ParentScale), nullptr, nullptr },
        { "override_scale", reinterpret_cast<getter>(ContentSite_get_OverrideScale), reinterpret_cast<setter>(ContentSite_put_OverrideScale), nullptr, nullptr },
        { "layout_direction", reinterpret_cast<getter>(ContentSite_get_LayoutDirection), reinterpret_cast<setter>(ContentSite_put_LayoutDirection), nullptr, nullptr },
        { "is_site_visible", reinterpret_cast<getter>(ContentSite_get_IsSiteVisible), reinterpret_cast<setter>(ContentSite_put_IsSiteVisible), nullptr, nullptr },
        { "is_site_enabled", reinterpret_cast<getter>(ContentSite_get_IsSiteEnabled), reinterpret_cast<setter>(ContentSite_put_IsSiteEnabled), nullptr, nullptr },
        { "client_size", reinterpret_cast<getter>(ContentSite_get_ClientSize), reinterpret_cast<setter>(ContentSite_put_ClientSize), nullptr, nullptr },
        { "actual_size", reinterpret_cast<getter>(ContentSite_get_ActualSize), reinterpret_cast<setter>(ContentSite_put_ActualSize), nullptr, nullptr },
        { "coordinate_converter", reinterpret_cast<getter>(ContentSite_get_CoordinateConverter), nullptr, nullptr, nullptr },
        { "dispatcher_queue", reinterpret_cast<getter>(ContentSite_get_DispatcherQueue), nullptr, nullptr, nullptr },
        { "environment", reinterpret_cast<getter>(ContentSite_get_Environment), nullptr, nullptr, nullptr },
        { "is_connected", reinterpret_cast<getter>(ContentSite_get_IsConnected), nullptr, nullptr, nullptr },
        { "rasterization_scale", reinterpret_cast<getter>(ContentSite_get_RasterizationScale), nullptr, nullptr, nullptr },
        { "requested_size", reinterpret_cast<getter>(ContentSite_get_RequestedSize), nullptr, nullptr, nullptr },
        { "view", reinterpret_cast<getter>(ContentSite_get_View), nullptr, nullptr, nullptr },
        { "is_closed", reinterpret_cast<getter>(ContentSite_get_IsClosed), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ContentSite[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContentSite) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContentSite) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContentSite) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContentSite) },
        { }};

    static PyType_Spec type_spec_ContentSite = {
        "winrt._winrt_microsoft_ui_content.ContentSite",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ContentSite};

    static PyGetSetDef getset_ContentSite_Static[] = {
        { }};

    static PyMethodDef methods_ContentSite_Static[] = {
        { }};

    static PyType_Slot type_slots_ContentSite_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ContentSite_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ContentSite_Static) },
        { }
    };

    static PyType_Spec type_spec_ContentSite_Static = {
        "winrt._winrt_microsoft_ui_content.ContentSite_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ContentSite_Static};

    // ----- ContentSiteEnvironment class --------------------

    static PyObject* _new_ContentSiteEnvironment(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Content::ContentSiteEnvironment>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Content::ContentSiteEnvironment>::type_name);
        return nullptr;
    }

    static void _dealloc_ContentSiteEnvironment(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContentSiteEnvironment_NotifySettingChanged(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.ContentSiteEnvironment", L"NotifySettingChanged", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Content::ContentSiteEnvironment>().NotifySettingChanged(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContentSiteEnvironment_get_DisplayId(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteEnvironment", L"DisplayId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentSiteEnvironment>().DisplayId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentSiteEnvironment_put_DisplayId(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteEnvironment", L"DisplayId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::DisplayId>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Content::ContentSiteEnvironment>().DisplayId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentSiteEnvironment_get_AppWindowId(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteEnvironment", L"AppWindowId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentSiteEnvironment>().AppWindowId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentSiteEnvironment_put_AppWindowId(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteEnvironment", L"AppWindowId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::WindowId>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Content::ContentSiteEnvironment>().AppWindowId(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentSiteEnvironment_get_View(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteEnvironment", L"View");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentSiteEnvironment>().View();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContentSiteEnvironment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Content::ContentSiteEnvironment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContentSiteEnvironment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Content::ContentSiteEnvironment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContentSiteEnvironment[] = {
        { "notify_setting_changed", reinterpret_cast<PyCFunction>(ContentSiteEnvironment_NotifySettingChanged), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContentSiteEnvironment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContentSiteEnvironment), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ContentSiteEnvironment[] = {
        { "display_id", reinterpret_cast<getter>(ContentSiteEnvironment_get_DisplayId), reinterpret_cast<setter>(ContentSiteEnvironment_put_DisplayId), nullptr, nullptr },
        { "app_window_id", reinterpret_cast<getter>(ContentSiteEnvironment_get_AppWindowId), reinterpret_cast<setter>(ContentSiteEnvironment_put_AppWindowId), nullptr, nullptr },
        { "view", reinterpret_cast<getter>(ContentSiteEnvironment_get_View), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ContentSiteEnvironment[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContentSiteEnvironment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContentSiteEnvironment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContentSiteEnvironment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContentSiteEnvironment) },
        { }};

    static PyType_Spec type_spec_ContentSiteEnvironment = {
        "winrt._winrt_microsoft_ui_content.ContentSiteEnvironment",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ContentSiteEnvironment};

    static PyGetSetDef getset_ContentSiteEnvironment_Static[] = {
        { }};

    static PyMethodDef methods_ContentSiteEnvironment_Static[] = {
        { }};

    static PyType_Slot type_slots_ContentSiteEnvironment_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ContentSiteEnvironment_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ContentSiteEnvironment_Static) },
        { }
    };

    static PyType_Spec type_spec_ContentSiteEnvironment_Static = {
        "winrt._winrt_microsoft_ui_content.ContentSiteEnvironment_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ContentSiteEnvironment_Static};

    // ----- ContentSiteEnvironmentView class --------------------

    static PyObject* _new_ContentSiteEnvironmentView(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Content::ContentSiteEnvironmentView>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Content::ContentSiteEnvironmentView>::type_name);
        return nullptr;
    }

    static void _dealloc_ContentSiteEnvironmentView(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContentSiteEnvironmentView_get_AppWindowId(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteEnvironmentView", L"AppWindowId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentSiteEnvironmentView>().AppWindowId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSiteEnvironmentView_get_DisplayId(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteEnvironmentView", L"DisplayId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentSiteEnvironmentView>().DisplayId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContentSiteEnvironmentView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Content::ContentSiteEnvironmentView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContentSiteEnvironmentView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Content::ContentSiteEnvironmentView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContentSiteEnvironmentView[] = {
        { "_assign_array_", _assign_array_ContentSiteEnvironmentView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContentSiteEnvironmentView), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ContentSiteEnvironmentView[] = {
        { "app_window_id", reinterpret_cast<getter>(ContentSiteEnvironmentView_get_AppWindowId), nullptr, nullptr, nullptr },
        { "display_id", reinterpret_cast<getter>(ContentSiteEnvironmentView_get_DisplayId), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ContentSiteEnvironmentView[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContentSiteEnvironmentView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContentSiteEnvironmentView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContentSiteEnvironmentView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContentSiteEnvironmentView) },
        { }};

    static PyType_Spec type_spec_ContentSiteEnvironmentView = {
        "winrt._winrt_microsoft_ui_content.ContentSiteEnvironmentView",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ContentSiteEnvironmentView};

    static PyGetSetDef getset_ContentSiteEnvironmentView_Static[] = {
        { }};

    static PyMethodDef methods_ContentSiteEnvironmentView_Static[] = {
        { }};

    static PyType_Slot type_slots_ContentSiteEnvironmentView_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ContentSiteEnvironmentView_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ContentSiteEnvironmentView_Static) },
        { }
    };

    static PyType_Spec type_spec_ContentSiteEnvironmentView_Static = {
        "winrt._winrt_microsoft_ui_content.ContentSiteEnvironmentView_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ContentSiteEnvironmentView_Static};

    // ----- ContentSiteRequestedStateChangedEventArgs class --------------------

    static PyObject* _new_ContentSiteRequestedStateChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Content::ContentSiteRequestedStateChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Content::ContentSiteRequestedStateChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ContentSiteRequestedStateChangedEventArgs(py::wrapper::Microsoft::UI::Content::ContentSiteRequestedStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContentSiteRequestedStateChangedEventArgs_get_DidRequestedSizeChange(py::wrapper::Microsoft::UI::Content::ContentSiteRequestedStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteRequestedStateChangedEventArgs", L"DidRequestedSizeChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DidRequestedSizeChange();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContentSiteRequestedStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Content::ContentSiteRequestedStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContentSiteRequestedStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Content::ContentSiteRequestedStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContentSiteRequestedStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_ContentSiteRequestedStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContentSiteRequestedStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ContentSiteRequestedStateChangedEventArgs[] = {
        { "did_requested_size_change", reinterpret_cast<getter>(ContentSiteRequestedStateChangedEventArgs_get_DidRequestedSizeChange), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ContentSiteRequestedStateChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContentSiteRequestedStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContentSiteRequestedStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContentSiteRequestedStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContentSiteRequestedStateChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_ContentSiteRequestedStateChangedEventArgs = {
        "winrt._winrt_microsoft_ui_content.ContentSiteRequestedStateChangedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Content::ContentSiteRequestedStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContentSiteRequestedStateChangedEventArgs};

    // ----- ContentSiteView class --------------------

    static PyObject* _new_ContentSiteView(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Content::ContentSiteView>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Content::ContentSiteView>::type_name);
        return nullptr;
    }

    static void _dealloc_ContentSiteView(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContentSiteView_get_ActualSize(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteView", L"ActualSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentSiteView>().ActualSize();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSiteView_get_ClientSize(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteView", L"ClientSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentSiteView>().ClientSize();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSiteView_get_CoordinateConverter(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteView", L"CoordinateConverter");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentSiteView>().CoordinateConverter();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSiteView_get_DispatcherQueue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteView", L"DispatcherQueue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentSiteView>().DispatcherQueue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSiteView_get_EnvironmentView(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteView", L"EnvironmentView");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentSiteView>().EnvironmentView();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSiteView_get_IsConnected(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteView", L"IsConnected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentSiteView>().IsConnected();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSiteView_get_IsSiteEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteView", L"IsSiteEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentSiteView>().IsSiteEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSiteView_get_IsSiteVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteView", L"IsSiteVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentSiteView>().IsSiteVisible();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSiteView_get_LayoutDirection(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteView", L"LayoutDirection");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentSiteView>().LayoutDirection();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSiteView_get_OverrideScale(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteView", L"OverrideScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentSiteView>().OverrideScale();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSiteView_get_ParentScale(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteView", L"ParentScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentSiteView>().ParentScale();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSiteView_get_RasterizationScale(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteView", L"RasterizationScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentSiteView>().RasterizationScale();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSiteView_get_RequestedSize(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteView", L"RequestedSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentSiteView>().RequestedSize();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSiteView_get_ShouldApplyRasterizationScale(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteView", L"ShouldApplyRasterizationScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::ContentSiteView>().ShouldApplyRasterizationScale();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContentSiteView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Content::ContentSiteView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContentSiteView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Content::ContentSiteView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContentSiteView[] = {
        { "_assign_array_", _assign_array_ContentSiteView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContentSiteView), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_ContentSiteView[] = {
        { "actual_size", reinterpret_cast<getter>(ContentSiteView_get_ActualSize), nullptr, nullptr, nullptr },
        { "client_size", reinterpret_cast<getter>(ContentSiteView_get_ClientSize), nullptr, nullptr, nullptr },
        { "coordinate_converter", reinterpret_cast<getter>(ContentSiteView_get_CoordinateConverter), nullptr, nullptr, nullptr },
        { "dispatcher_queue", reinterpret_cast<getter>(ContentSiteView_get_DispatcherQueue), nullptr, nullptr, nullptr },
        { "environment_view", reinterpret_cast<getter>(ContentSiteView_get_EnvironmentView), nullptr, nullptr, nullptr },
        { "is_connected", reinterpret_cast<getter>(ContentSiteView_get_IsConnected), nullptr, nullptr, nullptr },
        { "is_site_enabled", reinterpret_cast<getter>(ContentSiteView_get_IsSiteEnabled), nullptr, nullptr, nullptr },
        { "is_site_visible", reinterpret_cast<getter>(ContentSiteView_get_IsSiteVisible), nullptr, nullptr, nullptr },
        { "layout_direction", reinterpret_cast<getter>(ContentSiteView_get_LayoutDirection), nullptr, nullptr, nullptr },
        { "override_scale", reinterpret_cast<getter>(ContentSiteView_get_OverrideScale), nullptr, nullptr, nullptr },
        { "parent_scale", reinterpret_cast<getter>(ContentSiteView_get_ParentScale), nullptr, nullptr, nullptr },
        { "rasterization_scale", reinterpret_cast<getter>(ContentSiteView_get_RasterizationScale), nullptr, nullptr, nullptr },
        { "requested_size", reinterpret_cast<getter>(ContentSiteView_get_RequestedSize), nullptr, nullptr, nullptr },
        { "should_apply_rasterization_scale", reinterpret_cast<getter>(ContentSiteView_get_ShouldApplyRasterizationScale), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_ContentSiteView[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContentSiteView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContentSiteView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContentSiteView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContentSiteView) },
        { }};

    static PyType_Spec type_spec_ContentSiteView = {
        "winrt._winrt_microsoft_ui_content.ContentSiteView",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_ContentSiteView};

    static PyGetSetDef getset_ContentSiteView_Static[] = {
        { }};

    static PyMethodDef methods_ContentSiteView_Static[] = {
        { }};

    static PyType_Slot type_slots_ContentSiteView_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ContentSiteView_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ContentSiteView_Static) },
        { }
    };

    static PyType_Spec type_spec_ContentSiteView_Static = {
        "winrt._winrt_microsoft_ui_content.ContentSiteView_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ContentSiteView_Static};

    // ----- DesktopChildSiteBridge class --------------------

    static PyObject* _new_DesktopChildSiteBridge(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Content::DesktopChildSiteBridge>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Content::DesktopChildSiteBridge>::type_name);
        return nullptr;
    }

    static void _dealloc_DesktopChildSiteBridge(py::wrapper::Microsoft::UI::Content::DesktopChildSiteBridge* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DesktopChildSiteBridge_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.DesktopChildSiteBridge", L"Create", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Compositor>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::WindowId>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Content::DesktopChildSiteBridge::Create(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DesktopChildSiteBridge_get_ResizePolicy(py::wrapper::Microsoft::UI::Content::DesktopChildSiteBridge* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.DesktopChildSiteBridge", L"ResizePolicy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ResizePolicy();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DesktopChildSiteBridge_put_ResizePolicy(py::wrapper::Microsoft::UI::Content::DesktopChildSiteBridge* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.DesktopChildSiteBridge", L"ResizePolicy");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Content::ContentSizePolicy>(arg);

            {
                auto _gil = release_gil();
                self->obj.ResizePolicy(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DesktopChildSiteBridge_get_SiteView(py::wrapper::Microsoft::UI::Content::DesktopChildSiteBridge* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.DesktopChildSiteBridge", L"SiteView");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SiteView();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DesktopChildSiteBridge(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Content::DesktopChildSiteBridge>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DesktopChildSiteBridge(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Content::DesktopChildSiteBridge>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DesktopChildSiteBridge[] = {
        { "_assign_array_", _assign_array_DesktopChildSiteBridge, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DesktopChildSiteBridge), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_DesktopChildSiteBridge[] = {
        { "resize_policy", reinterpret_cast<getter>(DesktopChildSiteBridge_get_ResizePolicy), reinterpret_cast<setter>(DesktopChildSiteBridge_put_ResizePolicy), nullptr, nullptr },
        { "site_view", reinterpret_cast<getter>(DesktopChildSiteBridge_get_SiteView), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_DesktopChildSiteBridge[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DesktopChildSiteBridge) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DesktopChildSiteBridge) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DesktopChildSiteBridge) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DesktopChildSiteBridge) },
        { }};

    static PyType_Spec type_spec_DesktopChildSiteBridge = {
        "winrt._winrt_microsoft_ui_content.DesktopChildSiteBridge",
        sizeof(py::wrapper::Microsoft::UI::Content::DesktopChildSiteBridge),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DesktopChildSiteBridge};

    static PyGetSetDef getset_DesktopChildSiteBridge_Static[] = {
        { }};

    static PyMethodDef methods_DesktopChildSiteBridge_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(DesktopChildSiteBridge_Create), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_DesktopChildSiteBridge_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DesktopChildSiteBridge_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_DesktopChildSiteBridge_Static) },
        { }
    };

    static PyType_Spec type_spec_DesktopChildSiteBridge_Static = {
        "winrt._winrt_microsoft_ui_content.DesktopChildSiteBridge_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DesktopChildSiteBridge_Static};

    // ----- DesktopSiteBridge class --------------------

    static PyObject* _new_DesktopSiteBridge(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Content::DesktopSiteBridge>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Content::DesktopSiteBridge>::type_name);
        return nullptr;
    }

    static void _dealloc_DesktopSiteBridge(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DesktopSiteBridge_Close(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Content::DesktopSiteBridge>().Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DesktopSiteBridge_Connect(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"Connect", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Content::ContentIsland>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Content::DesktopSiteBridge>().Connect(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DesktopSiteBridge_Disable(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"Disable", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Content::DesktopSiteBridge>().Disable();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DesktopSiteBridge_Enable(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"Enable", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Content::DesktopSiteBridge>().Enable();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DesktopSiteBridge_Hide(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"Hide", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Content::DesktopSiteBridge>().Hide();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DesktopSiteBridge_IsSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"IsSupported", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::UI::Content::DesktopSiteBridge::IsSupported();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DesktopSiteBridge_MoveAndResize(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"MoveAndResize", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::RectInt32>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Content::DesktopSiteBridge>().MoveAndResize(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DesktopSiteBridge_MoveInZOrderAtBottom(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"MoveInZOrderAtBottom", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Content::DesktopSiteBridge>().MoveInZOrderAtBottom();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DesktopSiteBridge_MoveInZOrderAtTop(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"MoveInZOrderAtTop", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Content::DesktopSiteBridge>().MoveInZOrderAtTop();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DesktopSiteBridge_MoveInZOrderBelow(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"MoveInZOrderBelow", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::WindowId>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Content::DesktopSiteBridge>().MoveInZOrderBelow(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DesktopSiteBridge_Show(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"Show", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Content::DesktopSiteBridge>().Show();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DesktopSiteBridge_get_OverrideScale(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"OverrideScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::DesktopSiteBridge>().OverrideScale();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DesktopSiteBridge_put_OverrideScale(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"OverrideScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Content::DesktopSiteBridge>().OverrideScale(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DesktopSiteBridge_get_LayoutDirectionOverride(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"LayoutDirectionOverride");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::DesktopSiteBridge>().LayoutDirectionOverride();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DesktopSiteBridge_put_LayoutDirectionOverride(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"LayoutDirectionOverride");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Microsoft::UI::Content::ContentLayoutDirection>>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Content::DesktopSiteBridge>().LayoutDirectionOverride(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DesktopSiteBridge_get_DispatcherQueue(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"DispatcherQueue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::DesktopSiteBridge>().DispatcherQueue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DesktopSiteBridge_get_IsEnabled(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"IsEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::DesktopSiteBridge>().IsEnabled();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DesktopSiteBridge_get_IsVisible(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"IsVisible");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::DesktopSiteBridge>().IsVisible();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DesktopSiteBridge_get_WindowId(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"WindowId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::DesktopSiteBridge>().WindowId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DesktopSiteBridge_get_IsClosed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"IsClosed");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::DesktopSiteBridge>().IsClosed();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DesktopSiteBridge_add_Closed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"Closed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::ClosableNotifierHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::DesktopSiteBridge>().Closed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DesktopSiteBridge_remove_Closed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"Closed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Content::DesktopSiteBridge>().Closed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DesktopSiteBridge_add_FrameworkClosed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"FrameworkClosed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::ClosableNotifierHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Content::DesktopSiteBridge>().FrameworkClosed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DesktopSiteBridge_remove_FrameworkClosed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"FrameworkClosed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Content::DesktopSiteBridge>().FrameworkClosed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DesktopSiteBridge(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Content::DesktopSiteBridge>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DesktopSiteBridge(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Content::DesktopSiteBridge>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_DesktopSiteBridge(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_DesktopSiteBridge(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Content::DesktopSiteBridge>().Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DesktopSiteBridge[] = {
        { "close", reinterpret_cast<PyCFunction>(DesktopSiteBridge_Close), METH_VARARGS, nullptr },
        { "connect", reinterpret_cast<PyCFunction>(DesktopSiteBridge_Connect), METH_VARARGS, nullptr },
        { "disable", reinterpret_cast<PyCFunction>(DesktopSiteBridge_Disable), METH_VARARGS, nullptr },
        { "enable", reinterpret_cast<PyCFunction>(DesktopSiteBridge_Enable), METH_VARARGS, nullptr },
        { "hide", reinterpret_cast<PyCFunction>(DesktopSiteBridge_Hide), METH_VARARGS, nullptr },
        { "move_and_resize", reinterpret_cast<PyCFunction>(DesktopSiteBridge_MoveAndResize), METH_VARARGS, nullptr },
        { "move_in_z_order_at_bottom", reinterpret_cast<PyCFunction>(DesktopSiteBridge_MoveInZOrderAtBottom), METH_VARARGS, nullptr },
        { "move_in_z_order_at_top", reinterpret_cast<PyCFunction>(DesktopSiteBridge_MoveInZOrderAtTop), METH_VARARGS, nullptr },
        { "move_in_z_order_below", reinterpret_cast<PyCFunction>(DesktopSiteBridge_MoveInZOrderBelow), METH_VARARGS, nullptr },
        { "show", reinterpret_cast<PyCFunction>(DesktopSiteBridge_Show), METH_VARARGS, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(DesktopSiteBridge_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(DesktopSiteBridge_remove_Closed), METH_O, nullptr },
        { "add_framework_closed", reinterpret_cast<PyCFunction>(DesktopSiteBridge_add_FrameworkClosed), METH_O, nullptr },
        { "remove_framework_closed", reinterpret_cast<PyCFunction>(DesktopSiteBridge_remove_FrameworkClosed), METH_O, nullptr },
        { "_assign_array_", _assign_array_DesktopSiteBridge, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DesktopSiteBridge), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_DesktopSiteBridge), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_DesktopSiteBridge), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_DesktopSiteBridge[] = {
        { "override_scale", reinterpret_cast<getter>(DesktopSiteBridge_get_OverrideScale), reinterpret_cast<setter>(DesktopSiteBridge_put_OverrideScale), nullptr, nullptr },
        { "layout_direction_override", reinterpret_cast<getter>(DesktopSiteBridge_get_LayoutDirectionOverride), reinterpret_cast<setter>(DesktopSiteBridge_put_LayoutDirectionOverride), nullptr, nullptr },
        { "dispatcher_queue", reinterpret_cast<getter>(DesktopSiteBridge_get_DispatcherQueue), nullptr, nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(DesktopSiteBridge_get_IsEnabled), nullptr, nullptr, nullptr },
        { "is_visible", reinterpret_cast<getter>(DesktopSiteBridge_get_IsVisible), nullptr, nullptr, nullptr },
        { "window_id", reinterpret_cast<getter>(DesktopSiteBridge_get_WindowId), nullptr, nullptr, nullptr },
        { "is_closed", reinterpret_cast<getter>(DesktopSiteBridge_get_IsClosed), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_DesktopSiteBridge[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DesktopSiteBridge) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DesktopSiteBridge) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DesktopSiteBridge) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DesktopSiteBridge) },
        { }};

    static PyType_Spec type_spec_DesktopSiteBridge = {
        "winrt._winrt_microsoft_ui_content.DesktopSiteBridge",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_DesktopSiteBridge};

    static PyGetSetDef getset_DesktopSiteBridge_Static[] = {
        { }};

    static PyMethodDef methods_DesktopSiteBridge_Static[] = {
        { "is_supported", reinterpret_cast<PyCFunction>(DesktopSiteBridge_IsSupported), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_DesktopSiteBridge_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DesktopSiteBridge_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_DesktopSiteBridge_Static) },
        { }
    };

    static PyType_Spec type_spec_DesktopSiteBridge_Static = {
        "winrt._winrt_microsoft_ui_content.DesktopSiteBridge_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_DesktopSiteBridge_Static};

    // ----- IContentSiteBridge interface --------------------

    static PyObject* _new_IContentSiteBridge(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Content::IContentSiteBridge>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Content::IContentSiteBridge>::type_name);
        return nullptr;
    }

    static void _dealloc_IContentSiteBridge(py::wrapper::Microsoft::UI::Content::IContentSiteBridge* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContentSiteBridge_Close(py::wrapper::Microsoft::UI::Content::IContentSiteBridge* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IContentSiteBridge_get_DispatcherQueue(py::wrapper::Microsoft::UI::Content::IContentSiteBridge* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.IContentSiteBridge", L"DispatcherQueue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DispatcherQueue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContentSiteBridge_get_LayoutDirectionOverride(py::wrapper::Microsoft::UI::Content::IContentSiteBridge* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.IContentSiteBridge", L"LayoutDirectionOverride");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LayoutDirectionOverride();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IContentSiteBridge_put_LayoutDirectionOverride(py::wrapper::Microsoft::UI::Content::IContentSiteBridge* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.IContentSiteBridge", L"LayoutDirectionOverride");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Microsoft::UI::Content::ContentLayoutDirection>>(arg);

            {
                auto _gil = release_gil();
                self->obj.LayoutDirectionOverride(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IContentSiteBridge_get_OverrideScale(py::wrapper::Microsoft::UI::Content::IContentSiteBridge* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.IContentSiteBridge", L"OverrideScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.OverrideScale();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IContentSiteBridge_put_OverrideScale(py::wrapper::Microsoft::UI::Content::IContentSiteBridge* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.IContentSiteBridge", L"OverrideScale");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<float>(arg);

            {
                auto _gil = release_gil();
                self->obj.OverrideScale(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IContentSiteBridge(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Content::IContentSiteBridge>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IContentSiteBridge(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Content::IContentSiteBridge>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IContentSiteBridge(py::wrapper::Microsoft::UI::Content::IContentSiteBridge* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_IContentSiteBridge(py::wrapper::Microsoft::UI::Content::IContentSiteBridge* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContentSiteBridge[] = {
        { "close", reinterpret_cast<PyCFunction>(IContentSiteBridge_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IContentSiteBridge, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IContentSiteBridge), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IContentSiteBridge), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_IContentSiteBridge), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IContentSiteBridge[] = {
        { "dispatcher_queue", reinterpret_cast<getter>(IContentSiteBridge_get_DispatcherQueue), nullptr, nullptr, nullptr },
        { "layout_direction_override", reinterpret_cast<getter>(IContentSiteBridge_get_LayoutDirectionOverride), reinterpret_cast<setter>(IContentSiteBridge_put_LayoutDirectionOverride), nullptr, nullptr },
        { "override_scale", reinterpret_cast<getter>(IContentSiteBridge_get_OverrideScale), reinterpret_cast<setter>(IContentSiteBridge_put_OverrideScale), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_IContentSiteBridge[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_IContentSiteBridge) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IContentSiteBridge) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IContentSiteBridge) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IContentSiteBridge) },
        { }};

    static PyType_Spec type_spec_IContentSiteBridge = {
        "winrt._winrt_microsoft_ui_content.IContentSiteBridge",
        sizeof(py::wrapper::Microsoft::UI::Content::IContentSiteBridge),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContentSiteBridge};

    struct ImplementsIContentSiteBridge : py::ImplementsInterfaceT<ImplementsIContentSiteBridge, winrt::Microsoft::UI::Content::IContentSiteBridge>
    {
        ImplementsIContentSiteBridge() = delete;
        ImplementsIContentSiteBridge(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIContentSiteBridge, winrt::Microsoft::UI::Content::IContentSiteBridge>(py_obj, runtime_class)
        {
        }

        auto Close()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "close")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto DispatcherQueue()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "dispatcher_queue")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Microsoft::UI::Dispatching::DispatcherQueue>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto LayoutDirectionOverride()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "layout_direction_override")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Windows::Foundation::IReference<winrt::Microsoft::UI::Content::ContentLayoutDirection>>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void LayoutDirectionOverride(winrt::Windows::Foundation::IReference<winrt::Microsoft::UI::Content::ContentLayoutDirection> const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "layout_direction_override", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto OverrideScale()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{PyObject_GetAttrString(self.get(), "override_scale")};
                if (!value)
                {
                    throw python_exception();
                }

                return py::convert_to<float>(value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        void OverrideScale(float param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle value{py::convert(param0)};
                if (!value)
                {
                    throw python_exception();
                }

                if (PyObject_SetAttrString(self.get(), "override_scale", value.get()) == -1)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _guid_ImplementsIContentSiteBridge(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Microsoft::UI::Content::IContentSiteBridge>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIContentSiteBridge(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIContentSiteBridge>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIContentSiteBridge[] = {
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIContentSiteBridge), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIContentSiteBridge), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIContentSiteBridge[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIContentSiteBridge) },
        { }};

    static PyType_Spec type_spec_ImplementsIContentSiteBridge = {
        "winrt._winrt_microsoft_ui_content.ImplementsIContentSiteBridge",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_ImplementsIContentSiteBridge};

    // ----- Microsoft.UI.Content Initialization --------------------

    PyDoc_STRVAR(module_doc, "Microsoft.UI.Content");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_microsoft_ui_content",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Microsoft::UI::Content

PyMODINIT_FUNC PyInit__winrt_microsoft_ui_content(void) noexcept
{
    using namespace py::cpp::Microsoft::UI::Content;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ContentCoordinateConverter_Static{PyType_FromSpec(&type_spec_ContentCoordinateConverter_Static)};
    if (!type_ContentCoordinateConverter_Static)
    {
        return nullptr;
    }

    py::pytype_handle ContentCoordinateConverter_type{py::register_python_type(module.get(), &type_spec_ContentCoordinateConverter, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ContentCoordinateConverter_Static.get()))};
    if (!ContentCoordinateConverter_type)
    {
        return nullptr;
    }

    py::pytype_handle ContentDeferral_type{py::register_python_type(module.get(), &type_spec_ContentDeferral, object_bases.get(), nullptr)};
    if (!ContentDeferral_type)
    {
        return nullptr;
    }

    py::pytype_handle ContentEnvironmentSettingChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_ContentEnvironmentSettingChangedEventArgs, object_bases.get(), nullptr)};
    if (!ContentEnvironmentSettingChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle ContentEnvironmentStateChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_ContentEnvironmentStateChangedEventArgs, object_bases.get(), nullptr)};
    if (!ContentEnvironmentStateChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ContentIsland_Static{PyType_FromSpec(&type_spec_ContentIsland_Static)};
    if (!type_ContentIsland_Static)
    {
        return nullptr;
    }

    py::pytype_handle ContentIsland_type{py::register_python_type(module.get(), &type_spec_ContentIsland, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ContentIsland_Static.get()))};
    if (!ContentIsland_type)
    {
        return nullptr;
    }

    py::pytype_handle ContentIslandAutomationProviderRequestedEventArgs_type{py::register_python_type(module.get(), &type_spec_ContentIslandAutomationProviderRequestedEventArgs, object_bases.get(), nullptr)};
    if (!ContentIslandAutomationProviderRequestedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ContentIslandEnvironment_Static{PyType_FromSpec(&type_spec_ContentIslandEnvironment_Static)};
    if (!type_ContentIslandEnvironment_Static)
    {
        return nullptr;
    }

    py::pytype_handle ContentIslandEnvironment_type{py::register_python_type(module.get(), &type_spec_ContentIslandEnvironment, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ContentIslandEnvironment_Static.get()))};
    if (!ContentIslandEnvironment_type)
    {
        return nullptr;
    }

    py::pytype_handle ContentIslandStateChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_ContentIslandStateChangedEventArgs, object_bases.get(), nullptr)};
    if (!ContentIslandStateChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ContentSite_Static{PyType_FromSpec(&type_spec_ContentSite_Static)};
    if (!type_ContentSite_Static)
    {
        return nullptr;
    }

    py::pytype_handle ContentSite_type{py::register_python_type(module.get(), &type_spec_ContentSite, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ContentSite_Static.get()))};
    if (!ContentSite_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ContentSiteEnvironment_Static{PyType_FromSpec(&type_spec_ContentSiteEnvironment_Static)};
    if (!type_ContentSiteEnvironment_Static)
    {
        return nullptr;
    }

    py::pytype_handle ContentSiteEnvironment_type{py::register_python_type(module.get(), &type_spec_ContentSiteEnvironment, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ContentSiteEnvironment_Static.get()))};
    if (!ContentSiteEnvironment_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ContentSiteEnvironmentView_Static{PyType_FromSpec(&type_spec_ContentSiteEnvironmentView_Static)};
    if (!type_ContentSiteEnvironmentView_Static)
    {
        return nullptr;
    }

    py::pytype_handle ContentSiteEnvironmentView_type{py::register_python_type(module.get(), &type_spec_ContentSiteEnvironmentView, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ContentSiteEnvironmentView_Static.get()))};
    if (!ContentSiteEnvironmentView_type)
    {
        return nullptr;
    }

    py::pytype_handle ContentSiteRequestedStateChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_ContentSiteRequestedStateChangedEventArgs, object_bases.get(), nullptr)};
    if (!ContentSiteRequestedStateChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ContentSiteView_Static{PyType_FromSpec(&type_spec_ContentSiteView_Static)};
    if (!type_ContentSiteView_Static)
    {
        return nullptr;
    }

    py::pytype_handle ContentSiteView_type{py::register_python_type(module.get(), &type_spec_ContentSiteView, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ContentSiteView_Static.get()))};
    if (!ContentSiteView_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_DesktopSiteBridge_Static{PyType_FromSpec(&type_spec_DesktopSiteBridge_Static)};
    if (!type_DesktopSiteBridge_Static)
    {
        return nullptr;
    }

    py::pytype_handle DesktopSiteBridge_type{py::register_python_type(module.get(), &type_spec_DesktopSiteBridge, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DesktopSiteBridge_Static.get()))};
    if (!DesktopSiteBridge_type)
    {
        return nullptr;
    }

    py::pyobj_handle DesktopChildSiteBridge_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(DesktopSiteBridge_type.get())))};
    if (!DesktopChildSiteBridge_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_DesktopChildSiteBridge_Static{PyType_FromSpecWithBases(&type_spec_DesktopChildSiteBridge_Static, DesktopChildSiteBridge_Static_bases.get())};
    if (!type_DesktopChildSiteBridge_Static)
    {
        return nullptr;
    }

    py::pyobj_handle DesktopChildSiteBridge_bases{PyTuple_Pack(1, DesktopSiteBridge_type.get())};
    if (!DesktopChildSiteBridge_bases)
    {
        return nullptr;
    }

    py::pytype_handle DesktopChildSiteBridge_type{py::register_python_type(module.get(), &type_spec_DesktopChildSiteBridge, DesktopChildSiteBridge_bases.get(), reinterpret_cast<PyTypeObject*>(type_DesktopChildSiteBridge_Static.get()))};
    if (!DesktopChildSiteBridge_type)
    {
        return nullptr;
    }

    py::pytype_handle IContentSiteBridge_type{py::register_python_type(module.get(), &type_spec_IContentSiteBridge, object_bases.get(), nullptr)};
    if (!IContentSiteBridge_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIContentSiteBridge_type{reinterpret_cast<PyTypeObject*>(PyType_FromModuleAndSpec(module.get(), &type_spec_ImplementsIContentSiteBridge, nullptr))};
    if (!ImplementsIContentSiteBridge_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIContentSiteBridge_type.get()) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
