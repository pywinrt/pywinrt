// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

#include "py.Microsoft.UI.Content.h"


namespace py::cpp::Microsoft::UI::Content
{
    // ----- ContentCoordinateConverter class --------------------

    static PyObject* _new_ContentCoordinateConverter(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Content::ContentCoordinateConverter>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Content::ContentCoordinateConverter>::type_name);
        return nullptr;
    }

    static void _dealloc_ContentCoordinateConverter(py::wrapper::Microsoft::UI::Content::ContentCoordinateConverter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContentCoordinateConverter_ConvertLocalToScreen(py::wrapper::Microsoft::UI::Content::ContentCoordinateConverter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.ContentCoordinateConverter", L"ConvertLocalToScreen", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.ConvertLocalToScreen(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.ContentCoordinateConverter", L"ConvertLocalToScreen", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Content::ContentCoordinateRoundingMode>(args, 1);

                return py::convert(self->obj.ConvertLocalToScreen(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContentCoordinateConverter_ConvertScreenToLocal(py::wrapper::Microsoft::UI::Content::ContentCoordinateConverter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.ContentCoordinateConverter", L"ConvertScreenToLocal", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::PointInt32>(args, 0);

                return py::convert(self->obj.ConvertScreenToLocal(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContentCoordinateConverter_CreateForWindowId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.ContentCoordinateConverter", L"CreateForWindowId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::WindowId>(args, 0);

                return py::convert(winrt::Microsoft::UI::Content::ContentCoordinateConverter::CreateForWindowId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContentCoordinateConverter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Content::ContentCoordinateConverter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContentCoordinateConverter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Content::ContentCoordinateConverter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContentCoordinateConverter[] = {
        { "convert_local_to_screen", reinterpret_cast<PyCFunction>(ContentCoordinateConverter_ConvertLocalToScreen), METH_VARARGS, nullptr },
        { "convert_screen_to_local", reinterpret_cast<PyCFunction>(ContentCoordinateConverter_ConvertScreenToLocal), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContentCoordinateConverter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContentCoordinateConverter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContentCoordinateConverter[] = {
        { }
    };

    static PyType_Slot _type_slots_ContentCoordinateConverter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContentCoordinateConverter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContentCoordinateConverter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContentCoordinateConverter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContentCoordinateConverter) },
        { },
    };

    static PyType_Spec type_spec_ContentCoordinateConverter =
    {
        "winrt._winrt_microsoft_ui_content.ContentCoordinateConverter",
        sizeof(py::wrapper::Microsoft::UI::Content::ContentCoordinateConverter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContentCoordinateConverter
    };

    static PyGetSetDef getset_ContentCoordinateConverter_Static[] = {
        { }
    };

    static PyMethodDef methods_ContentCoordinateConverter_Static[] = {
        { "create_for_window_id", reinterpret_cast<PyCFunction>(ContentCoordinateConverter_CreateForWindowId), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_ContentCoordinateConverter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ContentCoordinateConverter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ContentCoordinateConverter_Static) },
        { }
    };

    static PyType_Spec type_spec_ContentCoordinateConverter_Static =
    {
        "winrt._winrt_microsoft_ui_content.ContentCoordinateConverter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ContentCoordinateConverter_Static
    };

    // ----- ContentDeferral class --------------------

    static PyObject* _new_ContentDeferral(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Content::ContentDeferral>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Content::ContentDeferral>::type_name);
        return nullptr;
    }

    static void _dealloc_ContentDeferral(py::wrapper::Microsoft::UI::Content::ContentDeferral* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContentDeferral_Complete(py::wrapper::Microsoft::UI::Content::ContentDeferral* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.ContentDeferral", L"Complete", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContentDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Content::ContentDeferral>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContentDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Content::ContentDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContentDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(ContentDeferral_Complete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContentDeferral, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContentDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContentDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_ContentDeferral[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContentDeferral) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContentDeferral) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContentDeferral) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContentDeferral) },
        { },
    };

    static PyType_Spec type_spec_ContentDeferral =
    {
        "winrt._winrt_microsoft_ui_content.ContentDeferral",
        sizeof(py::wrapper::Microsoft::UI::Content::ContentDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContentDeferral
    };

    // ----- ContentEnvironmentSettingChangedEventArgs class --------------------

    static PyObject* _new_ContentEnvironmentSettingChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Content::ContentEnvironmentSettingChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Content::ContentEnvironmentSettingChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ContentEnvironmentSettingChangedEventArgs(py::wrapper::Microsoft::UI::Content::ContentEnvironmentSettingChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContentEnvironmentSettingChangedEventArgs_get_SettingName(py::wrapper::Microsoft::UI::Content::ContentEnvironmentSettingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentEnvironmentSettingChangedEventArgs", L"SettingName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SettingName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContentEnvironmentSettingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Content::ContentEnvironmentSettingChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContentEnvironmentSettingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Content::ContentEnvironmentSettingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContentEnvironmentSettingChangedEventArgs[] = {
        { "_assign_array_", _assign_array_ContentEnvironmentSettingChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContentEnvironmentSettingChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContentEnvironmentSettingChangedEventArgs[] = {
        { "setting_name", reinterpret_cast<getter>(ContentEnvironmentSettingChangedEventArgs_get_SettingName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContentEnvironmentSettingChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContentEnvironmentSettingChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContentEnvironmentSettingChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContentEnvironmentSettingChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContentEnvironmentSettingChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ContentEnvironmentSettingChangedEventArgs =
    {
        "winrt._winrt_microsoft_ui_content.ContentEnvironmentSettingChangedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Content::ContentEnvironmentSettingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContentEnvironmentSettingChangedEventArgs
    };

    // ----- ContentEnvironmentStateChangedEventArgs class --------------------

    static PyObject* _new_ContentEnvironmentStateChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Content::ContentEnvironmentStateChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Content::ContentEnvironmentStateChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ContentEnvironmentStateChangedEventArgs(py::wrapper::Microsoft::UI::Content::ContentEnvironmentStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContentEnvironmentStateChangedEventArgs_get_DidAppWindowIdChange(py::wrapper::Microsoft::UI::Content::ContentEnvironmentStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentEnvironmentStateChangedEventArgs", L"DidAppWindowIdChange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DidAppWindowIdChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentEnvironmentStateChangedEventArgs_get_DidDisplayIdChange(py::wrapper::Microsoft::UI::Content::ContentEnvironmentStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentEnvironmentStateChangedEventArgs", L"DidDisplayIdChange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DidDisplayIdChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContentEnvironmentStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Content::ContentEnvironmentStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContentEnvironmentStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Content::ContentEnvironmentStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContentEnvironmentStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_ContentEnvironmentStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContentEnvironmentStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContentEnvironmentStateChangedEventArgs[] = {
        { "did_app_window_id_change", reinterpret_cast<getter>(ContentEnvironmentStateChangedEventArgs_get_DidAppWindowIdChange), nullptr, nullptr, nullptr },
        { "did_display_id_change", reinterpret_cast<getter>(ContentEnvironmentStateChangedEventArgs_get_DidDisplayIdChange), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContentEnvironmentStateChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContentEnvironmentStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContentEnvironmentStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContentEnvironmentStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContentEnvironmentStateChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ContentEnvironmentStateChangedEventArgs =
    {
        "winrt._winrt_microsoft_ui_content.ContentEnvironmentStateChangedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Content::ContentEnvironmentStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContentEnvironmentStateChangedEventArgs
    };

    // ----- ContentIsland class --------------------

    static PyObject* _new_ContentIsland(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Content::ContentIsland>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Content::ContentIsland>::type_name);
        return nullptr;
    }

    static void _dealloc_ContentIsland(py::wrapper::Microsoft::UI::Content::ContentIsland* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContentIsland_Close(py::wrapper::Microsoft::UI::Content::ContentIsland* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.ContentIsland", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContentIsland_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.ContentIsland", L"Create", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Visual>(args, 0);

                return py::convert(winrt::Microsoft::UI::Content::ContentIsland::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContentIsland_FindAllForCompositor(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.ContentIsland", L"FindAllForCompositor", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Compositor>(args, 0);

                return py::convert(winrt::Microsoft::UI::Content::ContentIsland::FindAllForCompositor(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContentIsland_FindAllForCurrentThread(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.ContentIsland", L"FindAllForCurrentThread", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Microsoft::UI::Content::ContentIsland::FindAllForCurrentThread());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContentIsland_GetAutomationHostProvider(py::wrapper::Microsoft::UI::Content::ContentIsland* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.ContentIsland", L"GetAutomationHostProvider", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAutomationHostProvider());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContentIsland_GetByVisual(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.ContentIsland", L"GetByVisual", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Visual>(args, 0);

                return py::convert(winrt::Microsoft::UI::Content::ContentIsland::GetByVisual(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContentIsland_GetFromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.ContentIsland", L"GetFromId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(winrt::Microsoft::UI::Content::ContentIsland::GetFromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContentIsland_GetStateChangeDeferral(py::wrapper::Microsoft::UI::Content::ContentIsland* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.ContentIsland", L"GetStateChangeDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetStateChangeDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContentIsland_RequestSize(py::wrapper::Microsoft::UI::Content::ContentIsland* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.ContentIsland", L"RequestSize", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 0);

                self->obj.RequestSize(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContentIsland_get_SystemBackdrop(py::wrapper::Microsoft::UI::Content::ContentIsland* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"SystemBackdrop"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SystemBackdrop());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentIsland_put_SystemBackdrop(py::wrapper::Microsoft::UI::Content::ContentIsland* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"SystemBackdrop"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Composition::CompositionBrush>(arg);

            self->obj.SystemBackdrop(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentIsland_get_IsIslandVisible(py::wrapper::Microsoft::UI::Content::ContentIsland* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"IsIslandVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsIslandVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentIsland_put_IsIslandVisible(py::wrapper::Microsoft::UI::Content::ContentIsland* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"IsIslandVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsIslandVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentIsland_get_IsIslandEnabled(py::wrapper::Microsoft::UI::Content::ContentIsland* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"IsIslandEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsIslandEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentIsland_put_IsIslandEnabled(py::wrapper::Microsoft::UI::Content::ContentIsland* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"IsIslandEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsIslandEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentIsland_get_IsHitTestVisibleWhenTransparent(py::wrapper::Microsoft::UI::Content::ContentIsland* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"IsHitTestVisibleWhenTransparent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsHitTestVisibleWhenTransparent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentIsland_put_IsHitTestVisibleWhenTransparent(py::wrapper::Microsoft::UI::Content::ContentIsland* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"IsHitTestVisibleWhenTransparent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsHitTestVisibleWhenTransparent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentIsland_get_AppData(py::wrapper::Microsoft::UI::Content::ContentIsland* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"AppData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentIsland_put_AppData(py::wrapper::Microsoft::UI::Content::ContentIsland* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"AppData"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.AppData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentIsland_get_ActualSize(py::wrapper::Microsoft::UI::Content::ContentIsland* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"ActualSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActualSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIsland_get_CoordinateConverter(py::wrapper::Microsoft::UI::Content::ContentIsland* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"CoordinateConverter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CoordinateConverter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIsland_get_CustomProperties(py::wrapper::Microsoft::UI::Content::ContentIsland* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"CustomProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CustomProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIsland_get_DispatcherQueue(py::wrapper::Microsoft::UI::Content::ContentIsland* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"DispatcherQueue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DispatcherQueue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIsland_get_Environment(py::wrapper::Microsoft::UI::Content::ContentIsland* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"Environment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Environment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIsland_get_Id(py::wrapper::Microsoft::UI::Content::ContentIsland* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIsland_get_IsConnected(py::wrapper::Microsoft::UI::Content::ContentIsland* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"IsConnected"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsConnected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIsland_get_IsSiteEnabled(py::wrapper::Microsoft::UI::Content::ContentIsland* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"IsSiteEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSiteEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIsland_get_IsSiteVisible(py::wrapper::Microsoft::UI::Content::ContentIsland* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"IsSiteVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSiteVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIsland_get_LayoutDirection(py::wrapper::Microsoft::UI::Content::ContentIsland* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"LayoutDirection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LayoutDirection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIsland_get_RasterizationScale(py::wrapper::Microsoft::UI::Content::ContentIsland* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"RasterizationScale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RasterizationScale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIsland_get_IsClosed(py::wrapper::Microsoft::UI::Content::ContentIsland* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIsland", L"IsClosed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsClosed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIsland_add_AutomationProviderRequested(py::wrapper::Microsoft::UI::Content::ContentIsland* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.ContentIsland", L"AutomationProviderRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Content::ContentIsland, winrt::Microsoft::UI::Content::ContentIslandAutomationProviderRequestedEventArgs>>(arg);

            return py::convert(self->obj.AutomationProviderRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIsland_remove_AutomationProviderRequested(py::wrapper::Microsoft::UI::Content::ContentIsland* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.ContentIsland", L"AutomationProviderRequested"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AutomationProviderRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIsland_add_StateChanged(py::wrapper::Microsoft::UI::Content::ContentIsland* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.ContentIsland", L"StateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Content::ContentIsland, winrt::Microsoft::UI::Content::ContentIslandStateChangedEventArgs>>(arg);

            return py::convert(self->obj.StateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIsland_remove_StateChanged(py::wrapper::Microsoft::UI::Content::ContentIsland* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.ContentIsland", L"StateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIsland_add_Closed(py::wrapper::Microsoft::UI::Content::ContentIsland* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.ContentIsland", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::ClosableNotifierHandler>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIsland_remove_Closed(py::wrapper::Microsoft::UI::Content::ContentIsland* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.ContentIsland", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIsland_add_FrameworkClosed(py::wrapper::Microsoft::UI::Content::ContentIsland* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.ContentIsland", L"FrameworkClosed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::ClosableNotifierHandler>(arg);

            return py::convert(self->obj.FrameworkClosed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIsland_remove_FrameworkClosed(py::wrapper::Microsoft::UI::Content::ContentIsland* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.ContentIsland", L"FrameworkClosed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FrameworkClosed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContentIsland(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Content::ContentIsland>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContentIsland(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Content::ContentIsland>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ContentIsland(py::wrapper::Microsoft::UI::Content::ContentIsland* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_ContentIsland(py::wrapper::Microsoft::UI::Content::ContentIsland* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContentIsland[] = {
        { "close", reinterpret_cast<PyCFunction>(ContentIsland_Close), METH_VARARGS, nullptr },
        { "get_automation_host_provider", reinterpret_cast<PyCFunction>(ContentIsland_GetAutomationHostProvider), METH_VARARGS, nullptr },
        { "get_state_change_deferral", reinterpret_cast<PyCFunction>(ContentIsland_GetStateChangeDeferral), METH_VARARGS, nullptr },
        { "request_size", reinterpret_cast<PyCFunction>(ContentIsland_RequestSize), METH_VARARGS, nullptr },
        { "add_automation_provider_requested", reinterpret_cast<PyCFunction>(ContentIsland_add_AutomationProviderRequested), METH_O, nullptr },
        { "remove_automation_provider_requested", reinterpret_cast<PyCFunction>(ContentIsland_remove_AutomationProviderRequested), METH_O, nullptr },
        { "add_state_changed", reinterpret_cast<PyCFunction>(ContentIsland_add_StateChanged), METH_O, nullptr },
        { "remove_state_changed", reinterpret_cast<PyCFunction>(ContentIsland_remove_StateChanged), METH_O, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(ContentIsland_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(ContentIsland_remove_Closed), METH_O, nullptr },
        { "add_framework_closed", reinterpret_cast<PyCFunction>(ContentIsland_add_FrameworkClosed), METH_O, nullptr },
        { "remove_framework_closed", reinterpret_cast<PyCFunction>(ContentIsland_remove_FrameworkClosed), METH_O, nullptr },
        { "_assign_array_", _assign_array_ContentIsland, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContentIsland), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ContentIsland), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_ContentIsland), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContentIsland[] = {
        { "system_backdrop", reinterpret_cast<getter>(ContentIsland_get_SystemBackdrop), reinterpret_cast<setter>(ContentIsland_put_SystemBackdrop), nullptr, nullptr },
        { "is_island_visible", reinterpret_cast<getter>(ContentIsland_get_IsIslandVisible), reinterpret_cast<setter>(ContentIsland_put_IsIslandVisible), nullptr, nullptr },
        { "is_island_enabled", reinterpret_cast<getter>(ContentIsland_get_IsIslandEnabled), reinterpret_cast<setter>(ContentIsland_put_IsIslandEnabled), nullptr, nullptr },
        { "is_hit_test_visible_when_transparent", reinterpret_cast<getter>(ContentIsland_get_IsHitTestVisibleWhenTransparent), reinterpret_cast<setter>(ContentIsland_put_IsHitTestVisibleWhenTransparent), nullptr, nullptr },
        { "app_data", reinterpret_cast<getter>(ContentIsland_get_AppData), reinterpret_cast<setter>(ContentIsland_put_AppData), nullptr, nullptr },
        { "actual_size", reinterpret_cast<getter>(ContentIsland_get_ActualSize), nullptr, nullptr, nullptr },
        { "coordinate_converter", reinterpret_cast<getter>(ContentIsland_get_CoordinateConverter), nullptr, nullptr, nullptr },
        { "custom_properties", reinterpret_cast<getter>(ContentIsland_get_CustomProperties), nullptr, nullptr, nullptr },
        { "dispatcher_queue", reinterpret_cast<getter>(ContentIsland_get_DispatcherQueue), nullptr, nullptr, nullptr },
        { "environment", reinterpret_cast<getter>(ContentIsland_get_Environment), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ContentIsland_get_Id), nullptr, nullptr, nullptr },
        { "is_connected", reinterpret_cast<getter>(ContentIsland_get_IsConnected), nullptr, nullptr, nullptr },
        { "is_site_enabled", reinterpret_cast<getter>(ContentIsland_get_IsSiteEnabled), nullptr, nullptr, nullptr },
        { "is_site_visible", reinterpret_cast<getter>(ContentIsland_get_IsSiteVisible), nullptr, nullptr, nullptr },
        { "layout_direction", reinterpret_cast<getter>(ContentIsland_get_LayoutDirection), nullptr, nullptr, nullptr },
        { "rasterization_scale", reinterpret_cast<getter>(ContentIsland_get_RasterizationScale), nullptr, nullptr, nullptr },
        { "is_closed", reinterpret_cast<getter>(ContentIsland_get_IsClosed), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContentIsland[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContentIsland) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContentIsland) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContentIsland) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContentIsland) },
        { },
    };

    static PyType_Spec type_spec_ContentIsland =
    {
        "winrt._winrt_microsoft_ui_content.ContentIsland",
        sizeof(py::wrapper::Microsoft::UI::Content::ContentIsland),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContentIsland
    };

    static PyGetSetDef getset_ContentIsland_Static[] = {
        { }
    };

    static PyMethodDef methods_ContentIsland_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(ContentIsland_Create), METH_VARARGS, nullptr },
        { "find_all_for_compositor", reinterpret_cast<PyCFunction>(ContentIsland_FindAllForCompositor), METH_VARARGS, nullptr },
        { "find_all_for_current_thread", reinterpret_cast<PyCFunction>(ContentIsland_FindAllForCurrentThread), METH_VARARGS, nullptr },
        { "get_by_visual", reinterpret_cast<PyCFunction>(ContentIsland_GetByVisual), METH_VARARGS, nullptr },
        { "get_from_id", reinterpret_cast<PyCFunction>(ContentIsland_GetFromId), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_ContentIsland_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ContentIsland_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ContentIsland_Static) },
        { }
    };

    static PyType_Spec type_spec_ContentIsland_Static =
    {
        "winrt._winrt_microsoft_ui_content.ContentIsland_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ContentIsland_Static
    };

    // ----- ContentIslandAutomationProviderRequestedEventArgs class --------------------

    static PyObject* _new_ContentIslandAutomationProviderRequestedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Content::ContentIslandAutomationProviderRequestedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Content::ContentIslandAutomationProviderRequestedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ContentIslandAutomationProviderRequestedEventArgs(py::wrapper::Microsoft::UI::Content::ContentIslandAutomationProviderRequestedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContentIslandAutomationProviderRequestedEventArgs_get_Handled(py::wrapper::Microsoft::UI::Content::ContentIslandAutomationProviderRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIslandAutomationProviderRequestedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentIslandAutomationProviderRequestedEventArgs_put_Handled(py::wrapper::Microsoft::UI::Content::ContentIslandAutomationProviderRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIslandAutomationProviderRequestedEventArgs", L"Handled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentIslandAutomationProviderRequestedEventArgs_get_AutomationProvider(py::wrapper::Microsoft::UI::Content::ContentIslandAutomationProviderRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIslandAutomationProviderRequestedEventArgs", L"AutomationProvider"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AutomationProvider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentIslandAutomationProviderRequestedEventArgs_put_AutomationProvider(py::wrapper::Microsoft::UI::Content::ContentIslandAutomationProviderRequestedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIslandAutomationProviderRequestedEventArgs", L"AutomationProvider"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.AutomationProvider(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_ContentIslandAutomationProviderRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Content::ContentIslandAutomationProviderRequestedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContentIslandAutomationProviderRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Content::ContentIslandAutomationProviderRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContentIslandAutomationProviderRequestedEventArgs[] = {
        { "_assign_array_", _assign_array_ContentIslandAutomationProviderRequestedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContentIslandAutomationProviderRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContentIslandAutomationProviderRequestedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(ContentIslandAutomationProviderRequestedEventArgs_get_Handled), reinterpret_cast<setter>(ContentIslandAutomationProviderRequestedEventArgs_put_Handled), nullptr, nullptr },
        { "automation_provider", reinterpret_cast<getter>(ContentIslandAutomationProviderRequestedEventArgs_get_AutomationProvider), reinterpret_cast<setter>(ContentIslandAutomationProviderRequestedEventArgs_put_AutomationProvider), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContentIslandAutomationProviderRequestedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContentIslandAutomationProviderRequestedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContentIslandAutomationProviderRequestedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContentIslandAutomationProviderRequestedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContentIslandAutomationProviderRequestedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ContentIslandAutomationProviderRequestedEventArgs =
    {
        "winrt._winrt_microsoft_ui_content.ContentIslandAutomationProviderRequestedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Content::ContentIslandAutomationProviderRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContentIslandAutomationProviderRequestedEventArgs
    };

    // ----- ContentIslandEnvironment class --------------------

    static PyObject* _new_ContentIslandEnvironment(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Content::ContentIslandEnvironment>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Content::ContentIslandEnvironment>::type_name);
        return nullptr;
    }

    static void _dealloc_ContentIslandEnvironment(py::wrapper::Microsoft::UI::Content::ContentIslandEnvironment* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContentIslandEnvironment_get_AppWindowId(py::wrapper::Microsoft::UI::Content::ContentIslandEnvironment* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIslandEnvironment", L"AppWindowId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppWindowId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIslandEnvironment_get_DisplayId(py::wrapper::Microsoft::UI::Content::ContentIslandEnvironment* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIslandEnvironment", L"DisplayId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIslandEnvironment_add_SettingChanged(py::wrapper::Microsoft::UI::Content::ContentIslandEnvironment* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.ContentIslandEnvironment", L"SettingChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Content::ContentIslandEnvironment, winrt::Microsoft::UI::Content::ContentEnvironmentSettingChangedEventArgs>>(arg);

            return py::convert(self->obj.SettingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIslandEnvironment_remove_SettingChanged(py::wrapper::Microsoft::UI::Content::ContentIslandEnvironment* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.ContentIslandEnvironment", L"SettingChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SettingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIslandEnvironment_add_StateChanged(py::wrapper::Microsoft::UI::Content::ContentIslandEnvironment* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.ContentIslandEnvironment", L"StateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Content::ContentIslandEnvironment, winrt::Microsoft::UI::Content::ContentEnvironmentStateChangedEventArgs>>(arg);

            return py::convert(self->obj.StateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIslandEnvironment_remove_StateChanged(py::wrapper::Microsoft::UI::Content::ContentIslandEnvironment* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.ContentIslandEnvironment", L"StateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContentIslandEnvironment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Content::ContentIslandEnvironment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContentIslandEnvironment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Content::ContentIslandEnvironment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContentIslandEnvironment[] = {
        { "add_setting_changed", reinterpret_cast<PyCFunction>(ContentIslandEnvironment_add_SettingChanged), METH_O, nullptr },
        { "remove_setting_changed", reinterpret_cast<PyCFunction>(ContentIslandEnvironment_remove_SettingChanged), METH_O, nullptr },
        { "add_state_changed", reinterpret_cast<PyCFunction>(ContentIslandEnvironment_add_StateChanged), METH_O, nullptr },
        { "remove_state_changed", reinterpret_cast<PyCFunction>(ContentIslandEnvironment_remove_StateChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ContentIslandEnvironment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContentIslandEnvironment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContentIslandEnvironment[] = {
        { "app_window_id", reinterpret_cast<getter>(ContentIslandEnvironment_get_AppWindowId), nullptr, nullptr, nullptr },
        { "display_id", reinterpret_cast<getter>(ContentIslandEnvironment_get_DisplayId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContentIslandEnvironment[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContentIslandEnvironment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContentIslandEnvironment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContentIslandEnvironment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContentIslandEnvironment) },
        { },
    };

    static PyType_Spec type_spec_ContentIslandEnvironment =
    {
        "winrt._winrt_microsoft_ui_content.ContentIslandEnvironment",
        sizeof(py::wrapper::Microsoft::UI::Content::ContentIslandEnvironment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContentIslandEnvironment
    };

    // ----- ContentIslandStateChangedEventArgs class --------------------

    static PyObject* _new_ContentIslandStateChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Content::ContentIslandStateChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Content::ContentIslandStateChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ContentIslandStateChangedEventArgs(py::wrapper::Microsoft::UI::Content::ContentIslandStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContentIslandStateChangedEventArgs_get_DidActualSizeChange(py::wrapper::Microsoft::UI::Content::ContentIslandStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIslandStateChangedEventArgs", L"DidActualSizeChange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DidActualSizeChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIslandStateChangedEventArgs_get_DidLayoutDirectionChange(py::wrapper::Microsoft::UI::Content::ContentIslandStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIslandStateChangedEventArgs", L"DidLayoutDirectionChange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DidLayoutDirectionChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIslandStateChangedEventArgs_get_DidRasterizationScaleChange(py::wrapper::Microsoft::UI::Content::ContentIslandStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIslandStateChangedEventArgs", L"DidRasterizationScaleChange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DidRasterizationScaleChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIslandStateChangedEventArgs_get_DidSiteEnabledChange(py::wrapper::Microsoft::UI::Content::ContentIslandStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIslandStateChangedEventArgs", L"DidSiteEnabledChange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DidSiteEnabledChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentIslandStateChangedEventArgs_get_DidSiteVisibleChange(py::wrapper::Microsoft::UI::Content::ContentIslandStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentIslandStateChangedEventArgs", L"DidSiteVisibleChange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DidSiteVisibleChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContentIslandStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Content::ContentIslandStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContentIslandStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Content::ContentIslandStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContentIslandStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_ContentIslandStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContentIslandStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContentIslandStateChangedEventArgs[] = {
        { "did_actual_size_change", reinterpret_cast<getter>(ContentIslandStateChangedEventArgs_get_DidActualSizeChange), nullptr, nullptr, nullptr },
        { "did_layout_direction_change", reinterpret_cast<getter>(ContentIslandStateChangedEventArgs_get_DidLayoutDirectionChange), nullptr, nullptr, nullptr },
        { "did_rasterization_scale_change", reinterpret_cast<getter>(ContentIslandStateChangedEventArgs_get_DidRasterizationScaleChange), nullptr, nullptr, nullptr },
        { "did_site_enabled_change", reinterpret_cast<getter>(ContentIslandStateChangedEventArgs_get_DidSiteEnabledChange), nullptr, nullptr, nullptr },
        { "did_site_visible_change", reinterpret_cast<getter>(ContentIslandStateChangedEventArgs_get_DidSiteVisibleChange), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContentIslandStateChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContentIslandStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContentIslandStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContentIslandStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContentIslandStateChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ContentIslandStateChangedEventArgs =
    {
        "winrt._winrt_microsoft_ui_content.ContentIslandStateChangedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Content::ContentIslandStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContentIslandStateChangedEventArgs
    };

    // ----- ContentSite class --------------------

    static PyObject* _new_ContentSite(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Content::ContentSite>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Content::ContentSite>::type_name);
        return nullptr;
    }

    static void _dealloc_ContentSite(py::wrapper::Microsoft::UI::Content::ContentSite* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContentSite_Close(py::wrapper::Microsoft::UI::Content::ContentSite* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.ContentSite", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContentSite_GetIslandStateChangeDeferral(py::wrapper::Microsoft::UI::Content::ContentSite* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.ContentSite", L"GetIslandStateChangeDeferral", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetIslandStateChangeDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContentSite_get_ShouldApplyRasterizationScale(py::wrapper::Microsoft::UI::Content::ContentSite* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"ShouldApplyRasterizationScale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShouldApplyRasterizationScale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentSite_put_ShouldApplyRasterizationScale(py::wrapper::Microsoft::UI::Content::ContentSite* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"ShouldApplyRasterizationScale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShouldApplyRasterizationScale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentSite_get_ParentScale(py::wrapper::Microsoft::UI::Content::ContentSite* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"ParentScale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ParentScale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentSite_put_ParentScale(py::wrapper::Microsoft::UI::Content::ContentSite* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"ParentScale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.ParentScale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentSite_get_OverrideScale(py::wrapper::Microsoft::UI::Content::ContentSite* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"OverrideScale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OverrideScale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentSite_put_OverrideScale(py::wrapper::Microsoft::UI::Content::ContentSite* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"OverrideScale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.OverrideScale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentSite_get_LayoutDirection(py::wrapper::Microsoft::UI::Content::ContentSite* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"LayoutDirection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LayoutDirection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentSite_put_LayoutDirection(py::wrapper::Microsoft::UI::Content::ContentSite* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"LayoutDirection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Content::ContentLayoutDirection>(arg);

            self->obj.LayoutDirection(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentSite_get_IsSiteVisible(py::wrapper::Microsoft::UI::Content::ContentSite* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"IsSiteVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSiteVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentSite_put_IsSiteVisible(py::wrapper::Microsoft::UI::Content::ContentSite* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"IsSiteVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsSiteVisible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentSite_get_IsSiteEnabled(py::wrapper::Microsoft::UI::Content::ContentSite* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"IsSiteEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSiteEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentSite_put_IsSiteEnabled(py::wrapper::Microsoft::UI::Content::ContentSite* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"IsSiteEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsSiteEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentSite_get_ClientSize(py::wrapper::Microsoft::UI::Content::ContentSite* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"ClientSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ClientSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentSite_put_ClientSize(py::wrapper::Microsoft::UI::Content::ContentSite* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"ClientSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::SizeInt32>(arg);

            self->obj.ClientSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentSite_get_ActualSize(py::wrapper::Microsoft::UI::Content::ContentSite* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"ActualSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActualSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentSite_put_ActualSize(py::wrapper::Microsoft::UI::Content::ContentSite* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"ActualSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(arg);

            self->obj.ActualSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentSite_get_CoordinateConverter(py::wrapper::Microsoft::UI::Content::ContentSite* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"CoordinateConverter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CoordinateConverter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSite_get_DispatcherQueue(py::wrapper::Microsoft::UI::Content::ContentSite* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"DispatcherQueue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DispatcherQueue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSite_get_Environment(py::wrapper::Microsoft::UI::Content::ContentSite* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"Environment"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Environment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSite_get_IsConnected(py::wrapper::Microsoft::UI::Content::ContentSite* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"IsConnected"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsConnected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSite_get_RasterizationScale(py::wrapper::Microsoft::UI::Content::ContentSite* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"RasterizationScale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RasterizationScale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSite_get_RequestedSize(py::wrapper::Microsoft::UI::Content::ContentSite* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"RequestedSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RequestedSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSite_get_View(py::wrapper::Microsoft::UI::Content::ContentSite* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"View"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.View());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSite_get_IsClosed(py::wrapper::Microsoft::UI::Content::ContentSite* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSite", L"IsClosed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsClosed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSite_add_RequestedStateChanged(py::wrapper::Microsoft::UI::Content::ContentSite* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.ContentSite", L"RequestedStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Content::ContentSite, winrt::Microsoft::UI::Content::ContentSiteRequestedStateChangedEventArgs>>(arg);

            return py::convert(self->obj.RequestedStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSite_remove_RequestedStateChanged(py::wrapper::Microsoft::UI::Content::ContentSite* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.ContentSite", L"RequestedStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RequestedStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSite_add_Closed(py::wrapper::Microsoft::UI::Content::ContentSite* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.ContentSite", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::ClosableNotifierHandler>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSite_remove_Closed(py::wrapper::Microsoft::UI::Content::ContentSite* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.ContentSite", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSite_add_FrameworkClosed(py::wrapper::Microsoft::UI::Content::ContentSite* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.ContentSite", L"FrameworkClosed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::ClosableNotifierHandler>(arg);

            return py::convert(self->obj.FrameworkClosed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSite_remove_FrameworkClosed(py::wrapper::Microsoft::UI::Content::ContentSite* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.ContentSite", L"FrameworkClosed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FrameworkClosed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContentSite(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Content::ContentSite>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContentSite(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Content::ContentSite>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ContentSite(py::wrapper::Microsoft::UI::Content::ContentSite* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_ContentSite(py::wrapper::Microsoft::UI::Content::ContentSite* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContentSite[] = {
        { "close", reinterpret_cast<PyCFunction>(ContentSite_Close), METH_VARARGS, nullptr },
        { "get_island_state_change_deferral", reinterpret_cast<PyCFunction>(ContentSite_GetIslandStateChangeDeferral), METH_VARARGS, nullptr },
        { "add_requested_state_changed", reinterpret_cast<PyCFunction>(ContentSite_add_RequestedStateChanged), METH_O, nullptr },
        { "remove_requested_state_changed", reinterpret_cast<PyCFunction>(ContentSite_remove_RequestedStateChanged), METH_O, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(ContentSite_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(ContentSite_remove_Closed), METH_O, nullptr },
        { "add_framework_closed", reinterpret_cast<PyCFunction>(ContentSite_add_FrameworkClosed), METH_O, nullptr },
        { "remove_framework_closed", reinterpret_cast<PyCFunction>(ContentSite_remove_FrameworkClosed), METH_O, nullptr },
        { "_assign_array_", _assign_array_ContentSite, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContentSite), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ContentSite), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_ContentSite), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContentSite[] = {
        { "should_apply_rasterization_scale", reinterpret_cast<getter>(ContentSite_get_ShouldApplyRasterizationScale), reinterpret_cast<setter>(ContentSite_put_ShouldApplyRasterizationScale), nullptr, nullptr },
        { "parent_scale", reinterpret_cast<getter>(ContentSite_get_ParentScale), reinterpret_cast<setter>(ContentSite_put_ParentScale), nullptr, nullptr },
        { "override_scale", reinterpret_cast<getter>(ContentSite_get_OverrideScale), reinterpret_cast<setter>(ContentSite_put_OverrideScale), nullptr, nullptr },
        { "layout_direction", reinterpret_cast<getter>(ContentSite_get_LayoutDirection), reinterpret_cast<setter>(ContentSite_put_LayoutDirection), nullptr, nullptr },
        { "is_site_visible", reinterpret_cast<getter>(ContentSite_get_IsSiteVisible), reinterpret_cast<setter>(ContentSite_put_IsSiteVisible), nullptr, nullptr },
        { "is_site_enabled", reinterpret_cast<getter>(ContentSite_get_IsSiteEnabled), reinterpret_cast<setter>(ContentSite_put_IsSiteEnabled), nullptr, nullptr },
        { "client_size", reinterpret_cast<getter>(ContentSite_get_ClientSize), reinterpret_cast<setter>(ContentSite_put_ClientSize), nullptr, nullptr },
        { "actual_size", reinterpret_cast<getter>(ContentSite_get_ActualSize), reinterpret_cast<setter>(ContentSite_put_ActualSize), nullptr, nullptr },
        { "coordinate_converter", reinterpret_cast<getter>(ContentSite_get_CoordinateConverter), nullptr, nullptr, nullptr },
        { "dispatcher_queue", reinterpret_cast<getter>(ContentSite_get_DispatcherQueue), nullptr, nullptr, nullptr },
        { "environment", reinterpret_cast<getter>(ContentSite_get_Environment), nullptr, nullptr, nullptr },
        { "is_connected", reinterpret_cast<getter>(ContentSite_get_IsConnected), nullptr, nullptr, nullptr },
        { "rasterization_scale", reinterpret_cast<getter>(ContentSite_get_RasterizationScale), nullptr, nullptr, nullptr },
        { "requested_size", reinterpret_cast<getter>(ContentSite_get_RequestedSize), nullptr, nullptr, nullptr },
        { "view", reinterpret_cast<getter>(ContentSite_get_View), nullptr, nullptr, nullptr },
        { "is_closed", reinterpret_cast<getter>(ContentSite_get_IsClosed), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContentSite[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContentSite) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContentSite) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContentSite) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContentSite) },
        { },
    };

    static PyType_Spec type_spec_ContentSite =
    {
        "winrt._winrt_microsoft_ui_content.ContentSite",
        sizeof(py::wrapper::Microsoft::UI::Content::ContentSite),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContentSite
    };

    // ----- ContentSiteEnvironment class --------------------

    static PyObject* _new_ContentSiteEnvironment(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Content::ContentSiteEnvironment>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Content::ContentSiteEnvironment>::type_name);
        return nullptr;
    }

    static void _dealloc_ContentSiteEnvironment(py::wrapper::Microsoft::UI::Content::ContentSiteEnvironment* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContentSiteEnvironment_NotifySettingChanged(py::wrapper::Microsoft::UI::Content::ContentSiteEnvironment* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.ContentSiteEnvironment", L"NotifySettingChanged", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.NotifySettingChanged(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContentSiteEnvironment_get_DisplayId(py::wrapper::Microsoft::UI::Content::ContentSiteEnvironment* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteEnvironment", L"DisplayId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentSiteEnvironment_put_DisplayId(py::wrapper::Microsoft::UI::Content::ContentSiteEnvironment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteEnvironment", L"DisplayId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::DisplayId>(arg);

            self->obj.DisplayId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentSiteEnvironment_get_AppWindowId(py::wrapper::Microsoft::UI::Content::ContentSiteEnvironment* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteEnvironment", L"AppWindowId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppWindowId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContentSiteEnvironment_put_AppWindowId(py::wrapper::Microsoft::UI::Content::ContentSiteEnvironment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteEnvironment", L"AppWindowId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::WindowId>(arg);

            self->obj.AppWindowId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContentSiteEnvironment_get_View(py::wrapper::Microsoft::UI::Content::ContentSiteEnvironment* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteEnvironment", L"View"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.View());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContentSiteEnvironment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Content::ContentSiteEnvironment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContentSiteEnvironment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Content::ContentSiteEnvironment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContentSiteEnvironment[] = {
        { "notify_setting_changed", reinterpret_cast<PyCFunction>(ContentSiteEnvironment_NotifySettingChanged), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ContentSiteEnvironment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContentSiteEnvironment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContentSiteEnvironment[] = {
        { "display_id", reinterpret_cast<getter>(ContentSiteEnvironment_get_DisplayId), reinterpret_cast<setter>(ContentSiteEnvironment_put_DisplayId), nullptr, nullptr },
        { "app_window_id", reinterpret_cast<getter>(ContentSiteEnvironment_get_AppWindowId), reinterpret_cast<setter>(ContentSiteEnvironment_put_AppWindowId), nullptr, nullptr },
        { "view", reinterpret_cast<getter>(ContentSiteEnvironment_get_View), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContentSiteEnvironment[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContentSiteEnvironment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContentSiteEnvironment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContentSiteEnvironment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContentSiteEnvironment) },
        { },
    };

    static PyType_Spec type_spec_ContentSiteEnvironment =
    {
        "winrt._winrt_microsoft_ui_content.ContentSiteEnvironment",
        sizeof(py::wrapper::Microsoft::UI::Content::ContentSiteEnvironment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContentSiteEnvironment
    };

    // ----- ContentSiteEnvironmentView class --------------------

    static PyObject* _new_ContentSiteEnvironmentView(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Content::ContentSiteEnvironmentView>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Content::ContentSiteEnvironmentView>::type_name);
        return nullptr;
    }

    static void _dealloc_ContentSiteEnvironmentView(py::wrapper::Microsoft::UI::Content::ContentSiteEnvironmentView* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContentSiteEnvironmentView_get_AppWindowId(py::wrapper::Microsoft::UI::Content::ContentSiteEnvironmentView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteEnvironmentView", L"AppWindowId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AppWindowId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSiteEnvironmentView_get_DisplayId(py::wrapper::Microsoft::UI::Content::ContentSiteEnvironmentView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteEnvironmentView", L"DisplayId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContentSiteEnvironmentView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Content::ContentSiteEnvironmentView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContentSiteEnvironmentView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Content::ContentSiteEnvironmentView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContentSiteEnvironmentView[] = {
        { "_assign_array_", _assign_array_ContentSiteEnvironmentView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContentSiteEnvironmentView), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContentSiteEnvironmentView[] = {
        { "app_window_id", reinterpret_cast<getter>(ContentSiteEnvironmentView_get_AppWindowId), nullptr, nullptr, nullptr },
        { "display_id", reinterpret_cast<getter>(ContentSiteEnvironmentView_get_DisplayId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContentSiteEnvironmentView[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContentSiteEnvironmentView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContentSiteEnvironmentView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContentSiteEnvironmentView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContentSiteEnvironmentView) },
        { },
    };

    static PyType_Spec type_spec_ContentSiteEnvironmentView =
    {
        "winrt._winrt_microsoft_ui_content.ContentSiteEnvironmentView",
        sizeof(py::wrapper::Microsoft::UI::Content::ContentSiteEnvironmentView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContentSiteEnvironmentView
    };

    // ----- ContentSiteRequestedStateChangedEventArgs class --------------------

    static PyObject* _new_ContentSiteRequestedStateChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Content::ContentSiteRequestedStateChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Content::ContentSiteRequestedStateChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ContentSiteRequestedStateChangedEventArgs(py::wrapper::Microsoft::UI::Content::ContentSiteRequestedStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContentSiteRequestedStateChangedEventArgs_get_DidRequestedSizeChange(py::wrapper::Microsoft::UI::Content::ContentSiteRequestedStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteRequestedStateChangedEventArgs", L"DidRequestedSizeChange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DidRequestedSizeChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContentSiteRequestedStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Content::ContentSiteRequestedStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContentSiteRequestedStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Content::ContentSiteRequestedStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContentSiteRequestedStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_ContentSiteRequestedStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContentSiteRequestedStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContentSiteRequestedStateChangedEventArgs[] = {
        { "did_requested_size_change", reinterpret_cast<getter>(ContentSiteRequestedStateChangedEventArgs_get_DidRequestedSizeChange), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContentSiteRequestedStateChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContentSiteRequestedStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContentSiteRequestedStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContentSiteRequestedStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContentSiteRequestedStateChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ContentSiteRequestedStateChangedEventArgs =
    {
        "winrt._winrt_microsoft_ui_content.ContentSiteRequestedStateChangedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Content::ContentSiteRequestedStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContentSiteRequestedStateChangedEventArgs
    };

    // ----- ContentSiteView class --------------------

    static PyObject* _new_ContentSiteView(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Content::ContentSiteView>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Content::ContentSiteView>::type_name);
        return nullptr;
    }

    static void _dealloc_ContentSiteView(py::wrapper::Microsoft::UI::Content::ContentSiteView* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContentSiteView_get_ActualSize(py::wrapper::Microsoft::UI::Content::ContentSiteView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteView", L"ActualSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActualSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSiteView_get_ClientSize(py::wrapper::Microsoft::UI::Content::ContentSiteView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteView", L"ClientSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ClientSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSiteView_get_CoordinateConverter(py::wrapper::Microsoft::UI::Content::ContentSiteView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteView", L"CoordinateConverter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CoordinateConverter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSiteView_get_DispatcherQueue(py::wrapper::Microsoft::UI::Content::ContentSiteView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteView", L"DispatcherQueue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DispatcherQueue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSiteView_get_EnvironmentView(py::wrapper::Microsoft::UI::Content::ContentSiteView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteView", L"EnvironmentView"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EnvironmentView());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSiteView_get_IsConnected(py::wrapper::Microsoft::UI::Content::ContentSiteView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteView", L"IsConnected"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsConnected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSiteView_get_IsSiteEnabled(py::wrapper::Microsoft::UI::Content::ContentSiteView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteView", L"IsSiteEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSiteEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSiteView_get_IsSiteVisible(py::wrapper::Microsoft::UI::Content::ContentSiteView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteView", L"IsSiteVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSiteVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSiteView_get_LayoutDirection(py::wrapper::Microsoft::UI::Content::ContentSiteView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteView", L"LayoutDirection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LayoutDirection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSiteView_get_OverrideScale(py::wrapper::Microsoft::UI::Content::ContentSiteView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteView", L"OverrideScale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OverrideScale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSiteView_get_ParentScale(py::wrapper::Microsoft::UI::Content::ContentSiteView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteView", L"ParentScale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ParentScale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSiteView_get_RasterizationScale(py::wrapper::Microsoft::UI::Content::ContentSiteView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteView", L"RasterizationScale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RasterizationScale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSiteView_get_RequestedSize(py::wrapper::Microsoft::UI::Content::ContentSiteView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteView", L"RequestedSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RequestedSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentSiteView_get_ShouldApplyRasterizationScale(py::wrapper::Microsoft::UI::Content::ContentSiteView* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.ContentSiteView", L"ShouldApplyRasterizationScale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ShouldApplyRasterizationScale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ContentSiteView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Content::ContentSiteView>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ContentSiteView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Content::ContentSiteView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContentSiteView[] = {
        { "_assign_array_", _assign_array_ContentSiteView, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContentSiteView), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContentSiteView[] = {
        { "actual_size", reinterpret_cast<getter>(ContentSiteView_get_ActualSize), nullptr, nullptr, nullptr },
        { "client_size", reinterpret_cast<getter>(ContentSiteView_get_ClientSize), nullptr, nullptr, nullptr },
        { "coordinate_converter", reinterpret_cast<getter>(ContentSiteView_get_CoordinateConverter), nullptr, nullptr, nullptr },
        { "dispatcher_queue", reinterpret_cast<getter>(ContentSiteView_get_DispatcherQueue), nullptr, nullptr, nullptr },
        { "environment_view", reinterpret_cast<getter>(ContentSiteView_get_EnvironmentView), nullptr, nullptr, nullptr },
        { "is_connected", reinterpret_cast<getter>(ContentSiteView_get_IsConnected), nullptr, nullptr, nullptr },
        { "is_site_enabled", reinterpret_cast<getter>(ContentSiteView_get_IsSiteEnabled), nullptr, nullptr, nullptr },
        { "is_site_visible", reinterpret_cast<getter>(ContentSiteView_get_IsSiteVisible), nullptr, nullptr, nullptr },
        { "layout_direction", reinterpret_cast<getter>(ContentSiteView_get_LayoutDirection), nullptr, nullptr, nullptr },
        { "override_scale", reinterpret_cast<getter>(ContentSiteView_get_OverrideScale), nullptr, nullptr, nullptr },
        { "parent_scale", reinterpret_cast<getter>(ContentSiteView_get_ParentScale), nullptr, nullptr, nullptr },
        { "rasterization_scale", reinterpret_cast<getter>(ContentSiteView_get_RasterizationScale), nullptr, nullptr, nullptr },
        { "requested_size", reinterpret_cast<getter>(ContentSiteView_get_RequestedSize), nullptr, nullptr, nullptr },
        { "should_apply_rasterization_scale", reinterpret_cast<getter>(ContentSiteView_get_ShouldApplyRasterizationScale), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContentSiteView[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ContentSiteView) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ContentSiteView) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ContentSiteView) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ContentSiteView) },
        { },
    };

    static PyType_Spec type_spec_ContentSiteView =
    {
        "winrt._winrt_microsoft_ui_content.ContentSiteView",
        sizeof(py::wrapper::Microsoft::UI::Content::ContentSiteView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContentSiteView
    };

    // ----- DesktopChildSiteBridge class --------------------

    static PyObject* _new_DesktopChildSiteBridge(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Content::DesktopChildSiteBridge>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Content::DesktopChildSiteBridge>::type_name);
        return nullptr;
    }

    static void _dealloc_DesktopChildSiteBridge(py::wrapper::Microsoft::UI::Content::DesktopChildSiteBridge* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DesktopChildSiteBridge_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.DesktopChildSiteBridge", L"Create", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Composition::Compositor>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::WindowId>(args, 1);

                return py::convert(winrt::Microsoft::UI::Content::DesktopChildSiteBridge::Create(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DesktopChildSiteBridge_get_ResizePolicy(py::wrapper::Microsoft::UI::Content::DesktopChildSiteBridge* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.DesktopChildSiteBridge", L"ResizePolicy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ResizePolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DesktopChildSiteBridge_put_ResizePolicy(py::wrapper::Microsoft::UI::Content::DesktopChildSiteBridge* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.DesktopChildSiteBridge", L"ResizePolicy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::Content::ContentSizePolicy>(arg);

            self->obj.ResizePolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DesktopChildSiteBridge_get_SiteView(py::wrapper::Microsoft::UI::Content::DesktopChildSiteBridge* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.DesktopChildSiteBridge", L"SiteView"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SiteView());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DesktopChildSiteBridge(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Content::DesktopChildSiteBridge>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DesktopChildSiteBridge(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Content::DesktopChildSiteBridge>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DesktopChildSiteBridge[] = {
        { "_assign_array_", _assign_array_DesktopChildSiteBridge, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DesktopChildSiteBridge), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DesktopChildSiteBridge[] = {
        { "resize_policy", reinterpret_cast<getter>(DesktopChildSiteBridge_get_ResizePolicy), reinterpret_cast<setter>(DesktopChildSiteBridge_put_ResizePolicy), nullptr, nullptr },
        { "site_view", reinterpret_cast<getter>(DesktopChildSiteBridge_get_SiteView), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DesktopChildSiteBridge[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DesktopChildSiteBridge) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DesktopChildSiteBridge) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DesktopChildSiteBridge) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DesktopChildSiteBridge) },
        { },
    };

    static PyType_Spec type_spec_DesktopChildSiteBridge =
    {
        "winrt._winrt_microsoft_ui_content.DesktopChildSiteBridge",
        sizeof(py::wrapper::Microsoft::UI::Content::DesktopChildSiteBridge),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DesktopChildSiteBridge
    };

    static PyGetSetDef getset_DesktopChildSiteBridge_Static[] = {
        { }
    };

    static PyMethodDef methods_DesktopChildSiteBridge_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(DesktopChildSiteBridge_Create), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_DesktopChildSiteBridge_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DesktopChildSiteBridge_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_DesktopChildSiteBridge_Static) },
        { }
    };

    static PyType_Spec type_spec_DesktopChildSiteBridge_Static =
    {
        "winrt._winrt_microsoft_ui_content.DesktopChildSiteBridge_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DesktopChildSiteBridge_Static
    };

    // ----- DesktopSiteBridge class --------------------

    static PyObject* _new_DesktopSiteBridge(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Content::DesktopSiteBridge>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Content::DesktopSiteBridge>::type_name);
        return nullptr;
    }

    static void _dealloc_DesktopSiteBridge(py::wrapper::Microsoft::UI::Content::DesktopSiteBridge* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DesktopSiteBridge_Close(py::wrapper::Microsoft::UI::Content::DesktopSiteBridge* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DesktopSiteBridge_Connect(py::wrapper::Microsoft::UI::Content::DesktopSiteBridge* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"Connect", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Content::ContentIsland>(args, 0);

                self->obj.Connect(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DesktopSiteBridge_Disable(py::wrapper::Microsoft::UI::Content::DesktopSiteBridge* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"Disable", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Disable();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DesktopSiteBridge_Enable(py::wrapper::Microsoft::UI::Content::DesktopSiteBridge* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"Enable", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Enable();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DesktopSiteBridge_Hide(py::wrapper::Microsoft::UI::Content::DesktopSiteBridge* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"Hide", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Hide();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DesktopSiteBridge_IsSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"IsSupported", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Microsoft::UI::Content::DesktopSiteBridge::IsSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DesktopSiteBridge_MoveAndResize(py::wrapper::Microsoft::UI::Content::DesktopSiteBridge* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"MoveAndResize", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::RectInt32>(args, 0);

                self->obj.MoveAndResize(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DesktopSiteBridge_MoveInZOrderAtBottom(py::wrapper::Microsoft::UI::Content::DesktopSiteBridge* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"MoveInZOrderAtBottom", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.MoveInZOrderAtBottom();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DesktopSiteBridge_MoveInZOrderAtTop(py::wrapper::Microsoft::UI::Content::DesktopSiteBridge* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"MoveInZOrderAtTop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.MoveInZOrderAtTop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DesktopSiteBridge_MoveInZOrderBelow(py::wrapper::Microsoft::UI::Content::DesktopSiteBridge* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"MoveInZOrderBelow", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::WindowId>(args, 0);

                self->obj.MoveInZOrderBelow(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DesktopSiteBridge_Show(py::wrapper::Microsoft::UI::Content::DesktopSiteBridge* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"Show", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Show();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DesktopSiteBridge_get_OverrideScale(py::wrapper::Microsoft::UI::Content::DesktopSiteBridge* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"OverrideScale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OverrideScale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DesktopSiteBridge_put_OverrideScale(py::wrapper::Microsoft::UI::Content::DesktopSiteBridge* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"OverrideScale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.OverrideScale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DesktopSiteBridge_get_LayoutDirectionOverride(py::wrapper::Microsoft::UI::Content::DesktopSiteBridge* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"LayoutDirectionOverride"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LayoutDirectionOverride());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DesktopSiteBridge_put_LayoutDirectionOverride(py::wrapper::Microsoft::UI::Content::DesktopSiteBridge* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"LayoutDirectionOverride"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Microsoft::UI::Content::ContentLayoutDirection>>(arg);

            self->obj.LayoutDirectionOverride(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DesktopSiteBridge_get_DispatcherQueue(py::wrapper::Microsoft::UI::Content::DesktopSiteBridge* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"DispatcherQueue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DispatcherQueue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DesktopSiteBridge_get_IsEnabled(py::wrapper::Microsoft::UI::Content::DesktopSiteBridge* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DesktopSiteBridge_get_IsVisible(py::wrapper::Microsoft::UI::Content::DesktopSiteBridge* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"IsVisible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsVisible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DesktopSiteBridge_get_WindowId(py::wrapper::Microsoft::UI::Content::DesktopSiteBridge* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"WindowId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WindowId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DesktopSiteBridge_get_IsClosed(py::wrapper::Microsoft::UI::Content::DesktopSiteBridge* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"IsClosed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsClosed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DesktopSiteBridge_add_Closed(py::wrapper::Microsoft::UI::Content::DesktopSiteBridge* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::ClosableNotifierHandler>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DesktopSiteBridge_remove_Closed(py::wrapper::Microsoft::UI::Content::DesktopSiteBridge* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"Closed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DesktopSiteBridge_add_FrameworkClosed(py::wrapper::Microsoft::UI::Content::DesktopSiteBridge* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"FrameworkClosed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::UI::ClosableNotifierHandler>(arg);

            return py::convert(self->obj.FrameworkClosed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DesktopSiteBridge_remove_FrameworkClosed(py::wrapper::Microsoft::UI::Content::DesktopSiteBridge* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Content.DesktopSiteBridge", L"FrameworkClosed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FrameworkClosed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DesktopSiteBridge(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Content::DesktopSiteBridge>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DesktopSiteBridge(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Content::DesktopSiteBridge>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_DesktopSiteBridge(py::wrapper::Microsoft::UI::Content::DesktopSiteBridge* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_DesktopSiteBridge(py::wrapper::Microsoft::UI::Content::DesktopSiteBridge* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DesktopSiteBridge[] = {
        { "close", reinterpret_cast<PyCFunction>(DesktopSiteBridge_Close), METH_VARARGS, nullptr },
        { "connect", reinterpret_cast<PyCFunction>(DesktopSiteBridge_Connect), METH_VARARGS, nullptr },
        { "disable", reinterpret_cast<PyCFunction>(DesktopSiteBridge_Disable), METH_VARARGS, nullptr },
        { "enable", reinterpret_cast<PyCFunction>(DesktopSiteBridge_Enable), METH_VARARGS, nullptr },
        { "hide", reinterpret_cast<PyCFunction>(DesktopSiteBridge_Hide), METH_VARARGS, nullptr },
        { "move_and_resize", reinterpret_cast<PyCFunction>(DesktopSiteBridge_MoveAndResize), METH_VARARGS, nullptr },
        { "move_in_z_order_at_bottom", reinterpret_cast<PyCFunction>(DesktopSiteBridge_MoveInZOrderAtBottom), METH_VARARGS, nullptr },
        { "move_in_z_order_at_top", reinterpret_cast<PyCFunction>(DesktopSiteBridge_MoveInZOrderAtTop), METH_VARARGS, nullptr },
        { "move_in_z_order_below", reinterpret_cast<PyCFunction>(DesktopSiteBridge_MoveInZOrderBelow), METH_VARARGS, nullptr },
        { "show", reinterpret_cast<PyCFunction>(DesktopSiteBridge_Show), METH_VARARGS, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(DesktopSiteBridge_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(DesktopSiteBridge_remove_Closed), METH_O, nullptr },
        { "add_framework_closed", reinterpret_cast<PyCFunction>(DesktopSiteBridge_add_FrameworkClosed), METH_O, nullptr },
        { "remove_framework_closed", reinterpret_cast<PyCFunction>(DesktopSiteBridge_remove_FrameworkClosed), METH_O, nullptr },
        { "_assign_array_", _assign_array_DesktopSiteBridge, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DesktopSiteBridge), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_DesktopSiteBridge), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_DesktopSiteBridge), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_DesktopSiteBridge[] = {
        { "override_scale", reinterpret_cast<getter>(DesktopSiteBridge_get_OverrideScale), reinterpret_cast<setter>(DesktopSiteBridge_put_OverrideScale), nullptr, nullptr },
        { "layout_direction_override", reinterpret_cast<getter>(DesktopSiteBridge_get_LayoutDirectionOverride), reinterpret_cast<setter>(DesktopSiteBridge_put_LayoutDirectionOverride), nullptr, nullptr },
        { "dispatcher_queue", reinterpret_cast<getter>(DesktopSiteBridge_get_DispatcherQueue), nullptr, nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(DesktopSiteBridge_get_IsEnabled), nullptr, nullptr, nullptr },
        { "is_visible", reinterpret_cast<getter>(DesktopSiteBridge_get_IsVisible), nullptr, nullptr, nullptr },
        { "window_id", reinterpret_cast<getter>(DesktopSiteBridge_get_WindowId), nullptr, nullptr, nullptr },
        { "is_closed", reinterpret_cast<getter>(DesktopSiteBridge_get_IsClosed), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DesktopSiteBridge[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DesktopSiteBridge) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DesktopSiteBridge) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DesktopSiteBridge) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DesktopSiteBridge) },
        { },
    };

    static PyType_Spec type_spec_DesktopSiteBridge =
    {
        "winrt._winrt_microsoft_ui_content.DesktopSiteBridge",
        sizeof(py::wrapper::Microsoft::UI::Content::DesktopSiteBridge),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DesktopSiteBridge
    };

    static PyGetSetDef getset_DesktopSiteBridge_Static[] = {
        { }
    };

    static PyMethodDef methods_DesktopSiteBridge_Static[] = {
        { "is_supported", reinterpret_cast<PyCFunction>(DesktopSiteBridge_IsSupported), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_DesktopSiteBridge_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DesktopSiteBridge_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_DesktopSiteBridge_Static) },
        { }
    };

    static PyType_Spec type_spec_DesktopSiteBridge_Static =
    {
        "winrt._winrt_microsoft_ui_content.DesktopSiteBridge_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DesktopSiteBridge_Static
    };

    // ----- IContentSiteBridge interface --------------------

    static PyObject* _new_IContentSiteBridge(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Content::IContentSiteBridge>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Content::IContentSiteBridge>::type_name);
        return nullptr;
    }

    static void _dealloc_IContentSiteBridge(py::wrapper::Microsoft::UI::Content::IContentSiteBridge* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContentSiteBridge_Close(py::wrapper::Microsoft::UI::Content::IContentSiteBridge* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IContentSiteBridge_get_DispatcherQueue(py::wrapper::Microsoft::UI::Content::IContentSiteBridge* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.IContentSiteBridge", L"DispatcherQueue"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DispatcherQueue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContentSiteBridge_get_LayoutDirectionOverride(py::wrapper::Microsoft::UI::Content::IContentSiteBridge* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.IContentSiteBridge", L"LayoutDirectionOverride"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LayoutDirectionOverride());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IContentSiteBridge_put_LayoutDirectionOverride(py::wrapper::Microsoft::UI::Content::IContentSiteBridge* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.IContentSiteBridge", L"LayoutDirectionOverride"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Microsoft::UI::Content::ContentLayoutDirection>>(arg);

            self->obj.LayoutDirectionOverride(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IContentSiteBridge_get_OverrideScale(py::wrapper::Microsoft::UI::Content::IContentSiteBridge* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.IContentSiteBridge", L"OverrideScale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OverrideScale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IContentSiteBridge_put_OverrideScale(py::wrapper::Microsoft::UI::Content::IContentSiteBridge* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Content.IContentSiteBridge", L"OverrideScale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.OverrideScale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IContentSiteBridge(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Content::IContentSiteBridge>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IContentSiteBridge(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Content::IContentSiteBridge>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IContentSiteBridge(py::wrapper::Microsoft::UI::Content::IContentSiteBridge* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_IContentSiteBridge(py::wrapper::Microsoft::UI::Content::IContentSiteBridge* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContentSiteBridge[] = {
        { "close", reinterpret_cast<PyCFunction>(IContentSiteBridge_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IContentSiteBridge, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IContentSiteBridge), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IContentSiteBridge), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_IContentSiteBridge), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_IContentSiteBridge[] = {
        { "dispatcher_queue", reinterpret_cast<getter>(IContentSiteBridge_get_DispatcherQueue), nullptr, nullptr, nullptr },
        { "layout_direction_override", reinterpret_cast<getter>(IContentSiteBridge_get_LayoutDirectionOverride), reinterpret_cast<setter>(IContentSiteBridge_put_LayoutDirectionOverride), nullptr, nullptr },
        { "override_scale", reinterpret_cast<getter>(IContentSiteBridge_get_OverrideScale), reinterpret_cast<setter>(IContentSiteBridge_put_OverrideScale), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IContentSiteBridge[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IContentSiteBridge) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IContentSiteBridge) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IContentSiteBridge) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IContentSiteBridge) },
        { },
    };

    static PyType_Spec type_spec_IContentSiteBridge =
    {
        "winrt._winrt_microsoft_ui_content.IContentSiteBridge",
        sizeof(py::wrapper::Microsoft::UI::Content::IContentSiteBridge),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContentSiteBridge
    };

    // ----- Microsoft.UI.Content Initialization --------------------
    PyDoc_STRVAR(module_doc, "Microsoft::UI::Content");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_microsoft_ui_content",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Microsoft::UI::Content

PyMODINIT_FUNC PyInit__winrt_microsoft_ui_content(void) noexcept
{
    using namespace py::cpp::Microsoft::UI::Content;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_ContentCoordinateConverter_Static{PyType_FromSpec(&type_spec_ContentCoordinateConverter_Static)};
    if (!type_ContentCoordinateConverter_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContentCoordinateConverter, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ContentCoordinateConverter_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContentDeferral, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContentEnvironmentSettingChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContentEnvironmentStateChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ContentIsland_Static{PyType_FromSpec(&type_spec_ContentIsland_Static)};
    if (!type_ContentIsland_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContentIsland, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ContentIsland_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContentIslandAutomationProviderRequestedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContentIslandEnvironment, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContentIslandStateChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContentSite, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContentSiteEnvironment, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContentSiteEnvironmentView, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContentSiteRequestedStateChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ContentSiteView, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_DesktopChildSiteBridge_Static{PyType_FromSpec(&type_spec_DesktopChildSiteBridge_Static)};
    if (!type_DesktopChildSiteBridge_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DesktopChildSiteBridge, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DesktopChildSiteBridge_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_DesktopSiteBridge_Static{PyType_FromSpec(&type_spec_DesktopSiteBridge_Static)};
    if (!type_DesktopSiteBridge_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DesktopSiteBridge, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DesktopSiteBridge_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IContentSiteBridge, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
