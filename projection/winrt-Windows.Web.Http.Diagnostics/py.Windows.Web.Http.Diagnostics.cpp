// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

#include "py.Windows.Web.Http.Diagnostics.h"


namespace py::cpp::Windows::Web::Http::Diagnostics
{
    // ----- HttpDiagnosticProvider class --------------------

    static PyObject* _new_HttpDiagnosticProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_HttpDiagnosticProvider(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpDiagnosticProvider_CreateFromProcessDiagnosticInfo(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProvider", L"CreateFromProcessDiagnosticInfo", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::Diagnostics::ProcessDiagnosticInfo>(args, 0);

                return py::convert(winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProvider::CreateFromProcessDiagnosticInfo(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProvider_Start(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProvider", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProvider_Stop(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProvider", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProvider_add_RequestResponseCompleted(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProvider* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProvider", L"RequestResponseCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProvider, winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseCompletedEventArgs>>(arg);

            return py::convert(self->obj.RequestResponseCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProvider_remove_RequestResponseCompleted(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProvider* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProvider", L"RequestResponseCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RequestResponseCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProvider_add_RequestSent(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProvider* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProvider", L"RequestSent"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProvider, winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestSentEventArgs>>(arg);

            return py::convert(self->obj.RequestSent(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProvider_remove_RequestSent(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProvider* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProvider", L"RequestSent"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RequestSent(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProvider_add_ResponseReceived(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProvider* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProvider", L"ResponseReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProvider, winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderResponseReceivedEventArgs>>(arg);

            return py::convert(self->obj.ResponseReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProvider_remove_ResponseReceived(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProvider* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProvider", L"ResponseReceived"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ResponseReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpDiagnosticProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpDiagnosticProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpDiagnosticProvider[] = {
        { "start", reinterpret_cast<PyCFunction>(HttpDiagnosticProvider_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(HttpDiagnosticProvider_Stop), METH_VARARGS, nullptr },
        { "add_request_response_completed", reinterpret_cast<PyCFunction>(HttpDiagnosticProvider_add_RequestResponseCompleted), METH_O, nullptr },
        { "remove_request_response_completed", reinterpret_cast<PyCFunction>(HttpDiagnosticProvider_remove_RequestResponseCompleted), METH_O, nullptr },
        { "add_request_sent", reinterpret_cast<PyCFunction>(HttpDiagnosticProvider_add_RequestSent), METH_O, nullptr },
        { "remove_request_sent", reinterpret_cast<PyCFunction>(HttpDiagnosticProvider_remove_RequestSent), METH_O, nullptr },
        { "add_response_received", reinterpret_cast<PyCFunction>(HttpDiagnosticProvider_add_ResponseReceived), METH_O, nullptr },
        { "remove_response_received", reinterpret_cast<PyCFunction>(HttpDiagnosticProvider_remove_ResponseReceived), METH_O, nullptr },
        { "_assign_array_", _assign_array_HttpDiagnosticProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpDiagnosticProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpDiagnosticProvider[] = {
        { }
    };

    static PyType_Slot _type_slots_HttpDiagnosticProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpDiagnosticProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpDiagnosticProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpDiagnosticProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpDiagnosticProvider) },
        { },
    };

    static PyType_Spec type_spec_HttpDiagnosticProvider =
    {
        "winrt._winrt_windows_web_http_diagnostics.HttpDiagnosticProvider",
        sizeof(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpDiagnosticProvider
    };

    static PyGetSetDef getset_HttpDiagnosticProvider_Static[] = {
        { }
    };

    static PyMethodDef methods_HttpDiagnosticProvider_Static[] = {
        { "create_from_process_diagnostic_info", reinterpret_cast<PyCFunction>(HttpDiagnosticProvider_CreateFromProcessDiagnosticInfo), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_HttpDiagnosticProvider_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HttpDiagnosticProvider_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HttpDiagnosticProvider_Static) },
        { }
    };

    static PyType_Spec type_spec_HttpDiagnosticProvider_Static =
    {
        "winrt._winrt_windows_web_http_diagnostics.HttpDiagnosticProvider_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_HttpDiagnosticProvider_Static
    };

    // ----- HttpDiagnosticProviderRequestResponseCompletedEventArgs class --------------------

    static PyObject* _new_HttpDiagnosticProviderRequestResponseCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_HttpDiagnosticProviderRequestResponseCompletedEventArgs(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpDiagnosticProviderRequestResponseCompletedEventArgs_get_ActivityId(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseCompletedEventArgs", L"ActivityId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivityId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestResponseCompletedEventArgs_get_Initiator(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseCompletedEventArgs", L"Initiator"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Initiator());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestResponseCompletedEventArgs_get_ProcessId(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseCompletedEventArgs", L"ProcessId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProcessId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestResponseCompletedEventArgs_get_RequestedUri(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseCompletedEventArgs", L"RequestedUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RequestedUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestResponseCompletedEventArgs_get_SourceLocations(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseCompletedEventArgs", L"SourceLocations"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourceLocations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestResponseCompletedEventArgs_get_ThreadId(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseCompletedEventArgs", L"ThreadId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ThreadId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestResponseCompletedEventArgs_get_Timestamps(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseCompletedEventArgs", L"Timestamps"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamps());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpDiagnosticProviderRequestResponseCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpDiagnosticProviderRequestResponseCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpDiagnosticProviderRequestResponseCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_HttpDiagnosticProviderRequestResponseCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpDiagnosticProviderRequestResponseCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpDiagnosticProviderRequestResponseCompletedEventArgs[] = {
        { "activity_id", reinterpret_cast<getter>(HttpDiagnosticProviderRequestResponseCompletedEventArgs_get_ActivityId), nullptr, nullptr, nullptr },
        { "initiator", reinterpret_cast<getter>(HttpDiagnosticProviderRequestResponseCompletedEventArgs_get_Initiator), nullptr, nullptr, nullptr },
        { "process_id", reinterpret_cast<getter>(HttpDiagnosticProviderRequestResponseCompletedEventArgs_get_ProcessId), nullptr, nullptr, nullptr },
        { "requested_uri", reinterpret_cast<getter>(HttpDiagnosticProviderRequestResponseCompletedEventArgs_get_RequestedUri), nullptr, nullptr, nullptr },
        { "source_locations", reinterpret_cast<getter>(HttpDiagnosticProviderRequestResponseCompletedEventArgs_get_SourceLocations), nullptr, nullptr, nullptr },
        { "thread_id", reinterpret_cast<getter>(HttpDiagnosticProviderRequestResponseCompletedEventArgs_get_ThreadId), nullptr, nullptr, nullptr },
        { "timestamps", reinterpret_cast<getter>(HttpDiagnosticProviderRequestResponseCompletedEventArgs_get_Timestamps), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpDiagnosticProviderRequestResponseCompletedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpDiagnosticProviderRequestResponseCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpDiagnosticProviderRequestResponseCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpDiagnosticProviderRequestResponseCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpDiagnosticProviderRequestResponseCompletedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_HttpDiagnosticProviderRequestResponseCompletedEventArgs =
    {
        "winrt._winrt_windows_web_http_diagnostics.HttpDiagnosticProviderRequestResponseCompletedEventArgs",
        sizeof(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpDiagnosticProviderRequestResponseCompletedEventArgs
    };

    // ----- HttpDiagnosticProviderRequestResponseTimestamps class --------------------

    static PyObject* _new_HttpDiagnosticProviderRequestResponseTimestamps(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseTimestamps>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseTimestamps>::type_name);
        return nullptr;
    }

    static void _dealloc_HttpDiagnosticProviderRequestResponseTimestamps(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseTimestamps* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpDiagnosticProviderRequestResponseTimestamps_get_CacheCheckedTimestamp(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseTimestamps* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseTimestamps", L"CacheCheckedTimestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CacheCheckedTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestResponseTimestamps_get_ConnectionCompletedTimestamp(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseTimestamps* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseTimestamps", L"ConnectionCompletedTimestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConnectionCompletedTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestResponseTimestamps_get_ConnectionInitiatedTimestamp(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseTimestamps* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseTimestamps", L"ConnectionInitiatedTimestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConnectionInitiatedTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestResponseTimestamps_get_NameResolvedTimestamp(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseTimestamps* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseTimestamps", L"NameResolvedTimestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NameResolvedTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestResponseTimestamps_get_RequestCompletedTimestamp(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseTimestamps* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseTimestamps", L"RequestCompletedTimestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RequestCompletedTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestResponseTimestamps_get_RequestSentTimestamp(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseTimestamps* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseTimestamps", L"RequestSentTimestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RequestSentTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestResponseTimestamps_get_ResponseCompletedTimestamp(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseTimestamps* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseTimestamps", L"ResponseCompletedTimestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ResponseCompletedTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestResponseTimestamps_get_ResponseReceivedTimestamp(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseTimestamps* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseTimestamps", L"ResponseReceivedTimestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ResponseReceivedTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestResponseTimestamps_get_SslNegotiatedTimestamp(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseTimestamps* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestResponseTimestamps", L"SslNegotiatedTimestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SslNegotiatedTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpDiagnosticProviderRequestResponseTimestamps(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseTimestamps>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpDiagnosticProviderRequestResponseTimestamps(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseTimestamps>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpDiagnosticProviderRequestResponseTimestamps[] = {
        { "_assign_array_", _assign_array_HttpDiagnosticProviderRequestResponseTimestamps, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpDiagnosticProviderRequestResponseTimestamps), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpDiagnosticProviderRequestResponseTimestamps[] = {
        { "cache_checked_timestamp", reinterpret_cast<getter>(HttpDiagnosticProviderRequestResponseTimestamps_get_CacheCheckedTimestamp), nullptr, nullptr, nullptr },
        { "connection_completed_timestamp", reinterpret_cast<getter>(HttpDiagnosticProviderRequestResponseTimestamps_get_ConnectionCompletedTimestamp), nullptr, nullptr, nullptr },
        { "connection_initiated_timestamp", reinterpret_cast<getter>(HttpDiagnosticProviderRequestResponseTimestamps_get_ConnectionInitiatedTimestamp), nullptr, nullptr, nullptr },
        { "name_resolved_timestamp", reinterpret_cast<getter>(HttpDiagnosticProviderRequestResponseTimestamps_get_NameResolvedTimestamp), nullptr, nullptr, nullptr },
        { "request_completed_timestamp", reinterpret_cast<getter>(HttpDiagnosticProviderRequestResponseTimestamps_get_RequestCompletedTimestamp), nullptr, nullptr, nullptr },
        { "request_sent_timestamp", reinterpret_cast<getter>(HttpDiagnosticProviderRequestResponseTimestamps_get_RequestSentTimestamp), nullptr, nullptr, nullptr },
        { "response_completed_timestamp", reinterpret_cast<getter>(HttpDiagnosticProviderRequestResponseTimestamps_get_ResponseCompletedTimestamp), nullptr, nullptr, nullptr },
        { "response_received_timestamp", reinterpret_cast<getter>(HttpDiagnosticProviderRequestResponseTimestamps_get_ResponseReceivedTimestamp), nullptr, nullptr, nullptr },
        { "ssl_negotiated_timestamp", reinterpret_cast<getter>(HttpDiagnosticProviderRequestResponseTimestamps_get_SslNegotiatedTimestamp), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpDiagnosticProviderRequestResponseTimestamps[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpDiagnosticProviderRequestResponseTimestamps) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpDiagnosticProviderRequestResponseTimestamps) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpDiagnosticProviderRequestResponseTimestamps) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpDiagnosticProviderRequestResponseTimestamps) },
        { },
    };

    static PyType_Spec type_spec_HttpDiagnosticProviderRequestResponseTimestamps =
    {
        "winrt._winrt_windows_web_http_diagnostics.HttpDiagnosticProviderRequestResponseTimestamps",
        sizeof(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestResponseTimestamps),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpDiagnosticProviderRequestResponseTimestamps
    };

    // ----- HttpDiagnosticProviderRequestSentEventArgs class --------------------

    static PyObject* _new_HttpDiagnosticProviderRequestSentEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestSentEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestSentEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_HttpDiagnosticProviderRequestSentEventArgs(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestSentEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpDiagnosticProviderRequestSentEventArgs_get_ActivityId(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestSentEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestSentEventArgs", L"ActivityId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivityId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestSentEventArgs_get_Initiator(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestSentEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestSentEventArgs", L"Initiator"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Initiator());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestSentEventArgs_get_Message(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestSentEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestSentEventArgs", L"Message"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestSentEventArgs_get_ProcessId(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestSentEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestSentEventArgs", L"ProcessId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProcessId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestSentEventArgs_get_SourceLocations(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestSentEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestSentEventArgs", L"SourceLocations"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourceLocations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestSentEventArgs_get_ThreadId(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestSentEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestSentEventArgs", L"ThreadId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ThreadId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderRequestSentEventArgs_get_Timestamp(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestSentEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderRequestSentEventArgs", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpDiagnosticProviderRequestSentEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestSentEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpDiagnosticProviderRequestSentEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestSentEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpDiagnosticProviderRequestSentEventArgs[] = {
        { "_assign_array_", _assign_array_HttpDiagnosticProviderRequestSentEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpDiagnosticProviderRequestSentEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpDiagnosticProviderRequestSentEventArgs[] = {
        { "activity_id", reinterpret_cast<getter>(HttpDiagnosticProviderRequestSentEventArgs_get_ActivityId), nullptr, nullptr, nullptr },
        { "initiator", reinterpret_cast<getter>(HttpDiagnosticProviderRequestSentEventArgs_get_Initiator), nullptr, nullptr, nullptr },
        { "message", reinterpret_cast<getter>(HttpDiagnosticProviderRequestSentEventArgs_get_Message), nullptr, nullptr, nullptr },
        { "process_id", reinterpret_cast<getter>(HttpDiagnosticProviderRequestSentEventArgs_get_ProcessId), nullptr, nullptr, nullptr },
        { "source_locations", reinterpret_cast<getter>(HttpDiagnosticProviderRequestSentEventArgs_get_SourceLocations), nullptr, nullptr, nullptr },
        { "thread_id", reinterpret_cast<getter>(HttpDiagnosticProviderRequestSentEventArgs_get_ThreadId), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(HttpDiagnosticProviderRequestSentEventArgs_get_Timestamp), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpDiagnosticProviderRequestSentEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpDiagnosticProviderRequestSentEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpDiagnosticProviderRequestSentEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpDiagnosticProviderRequestSentEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpDiagnosticProviderRequestSentEventArgs) },
        { },
    };

    static PyType_Spec type_spec_HttpDiagnosticProviderRequestSentEventArgs =
    {
        "winrt._winrt_windows_web_http_diagnostics.HttpDiagnosticProviderRequestSentEventArgs",
        sizeof(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderRequestSentEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpDiagnosticProviderRequestSentEventArgs
    };

    // ----- HttpDiagnosticProviderResponseReceivedEventArgs class --------------------

    static PyObject* _new_HttpDiagnosticProviderResponseReceivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderResponseReceivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderResponseReceivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_HttpDiagnosticProviderResponseReceivedEventArgs(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderResponseReceivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpDiagnosticProviderResponseReceivedEventArgs_get_ActivityId(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderResponseReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderResponseReceivedEventArgs", L"ActivityId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivityId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderResponseReceivedEventArgs_get_Message(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderResponseReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderResponseReceivedEventArgs", L"Message"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticProviderResponseReceivedEventArgs_get_Timestamp(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderResponseReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticProviderResponseReceivedEventArgs", L"Timestamp"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpDiagnosticProviderResponseReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderResponseReceivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpDiagnosticProviderResponseReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderResponseReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpDiagnosticProviderResponseReceivedEventArgs[] = {
        { "_assign_array_", _assign_array_HttpDiagnosticProviderResponseReceivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpDiagnosticProviderResponseReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpDiagnosticProviderResponseReceivedEventArgs[] = {
        { "activity_id", reinterpret_cast<getter>(HttpDiagnosticProviderResponseReceivedEventArgs_get_ActivityId), nullptr, nullptr, nullptr },
        { "message", reinterpret_cast<getter>(HttpDiagnosticProviderResponseReceivedEventArgs_get_Message), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(HttpDiagnosticProviderResponseReceivedEventArgs_get_Timestamp), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpDiagnosticProviderResponseReceivedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpDiagnosticProviderResponseReceivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpDiagnosticProviderResponseReceivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpDiagnosticProviderResponseReceivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpDiagnosticProviderResponseReceivedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_HttpDiagnosticProviderResponseReceivedEventArgs =
    {
        "winrt._winrt_windows_web_http_diagnostics.HttpDiagnosticProviderResponseReceivedEventArgs",
        sizeof(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticProviderResponseReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpDiagnosticProviderResponseReceivedEventArgs
    };

    // ----- HttpDiagnosticSourceLocation class --------------------

    static PyObject* _new_HttpDiagnosticSourceLocation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticSourceLocation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticSourceLocation>::type_name);
        return nullptr;
    }

    static void _dealloc_HttpDiagnosticSourceLocation(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticSourceLocation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HttpDiagnosticSourceLocation_get_ColumnNumber(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticSourceLocation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticSourceLocation", L"ColumnNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ColumnNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticSourceLocation_get_LineNumber(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticSourceLocation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticSourceLocation", L"LineNumber"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LineNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HttpDiagnosticSourceLocation_get_SourceUri(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticSourceLocation* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Web.Http.Diagnostics.HttpDiagnosticSourceLocation", L"SourceUri"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourceUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_HttpDiagnosticSourceLocation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticSourceLocation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HttpDiagnosticSourceLocation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Web::Http::Diagnostics::HttpDiagnosticSourceLocation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HttpDiagnosticSourceLocation[] = {
        { "_assign_array_", _assign_array_HttpDiagnosticSourceLocation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HttpDiagnosticSourceLocation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HttpDiagnosticSourceLocation[] = {
        { "column_number", reinterpret_cast<getter>(HttpDiagnosticSourceLocation_get_ColumnNumber), nullptr, nullptr, nullptr },
        { "line_number", reinterpret_cast<getter>(HttpDiagnosticSourceLocation_get_LineNumber), nullptr, nullptr, nullptr },
        { "source_uri", reinterpret_cast<getter>(HttpDiagnosticSourceLocation_get_SourceUri), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HttpDiagnosticSourceLocation[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_HttpDiagnosticSourceLocation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HttpDiagnosticSourceLocation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HttpDiagnosticSourceLocation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HttpDiagnosticSourceLocation) },
        { },
    };

    static PyType_Spec type_spec_HttpDiagnosticSourceLocation =
    {
        "winrt._winrt_windows_web_http_diagnostics.HttpDiagnosticSourceLocation",
        sizeof(py::wrapper::Windows::Web::Http::Diagnostics::HttpDiagnosticSourceLocation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HttpDiagnosticSourceLocation
    };

    // ----- Windows.Web.Http.Diagnostics Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Web::Http::Diagnostics");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_web_http_diagnostics",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::Web::Http::Diagnostics

PyMODINIT_FUNC PyInit__winrt_windows_web_http_diagnostics(void) noexcept
{
    using namespace py::cpp::Windows::Web::Http::Diagnostics;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_HttpDiagnosticProvider_Static{PyType_FromSpec(&type_spec_HttpDiagnosticProvider_Static)};
    if (!type_HttpDiagnosticProvider_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpDiagnosticProvider, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_HttpDiagnosticProvider_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpDiagnosticProviderRequestResponseCompletedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpDiagnosticProviderRequestResponseTimestamps, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpDiagnosticProviderRequestSentEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpDiagnosticProviderResponseReceivedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_HttpDiagnosticSourceLocation, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
