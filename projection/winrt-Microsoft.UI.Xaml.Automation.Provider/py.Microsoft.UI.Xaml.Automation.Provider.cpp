// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Microsoft.UI.Xaml.Automation.Provider.h"


namespace py::cpp::Microsoft::UI::Xaml::Automation::Provider
{
    // ----- IRawElementProviderSimple class --------------------

    static PyObject* _new_IRawElementProviderSimple(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IRawElementProviderSimple>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IRawElementProviderSimple>::type_name);
        return nullptr;
    }

    static void _dealloc_IRawElementProviderSimple(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IRawElementProviderSimple* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_IRawElementProviderSimple(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Provider::IRawElementProviderSimple>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IRawElementProviderSimple(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Provider::IRawElementProviderSimple>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IRawElementProviderSimple[] = {
        { "_assign_array_", _assign_array_IRawElementProviderSimple, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IRawElementProviderSimple), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IRawElementProviderSimple[] = {
        { }
    };

    static PyType_Slot _type_slots_IRawElementProviderSimple[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IRawElementProviderSimple) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IRawElementProviderSimple) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IRawElementProviderSimple) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IRawElementProviderSimple) },
        { },
    };

    static PyType_Spec type_spec_IRawElementProviderSimple =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_provider.IRawElementProviderSimple",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IRawElementProviderSimple),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IRawElementProviderSimple
    };

    // ----- IAnnotationProvider interface --------------------

    static PyObject* _new_IAnnotationProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IAnnotationProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IAnnotationProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IAnnotationProvider(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IAnnotationProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAnnotationProvider_get_AnnotationTypeId(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IAnnotationProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IAnnotationProvider", L"AnnotationTypeId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AnnotationTypeId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAnnotationProvider_get_AnnotationTypeName(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IAnnotationProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IAnnotationProvider", L"AnnotationTypeName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AnnotationTypeName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAnnotationProvider_get_Author(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IAnnotationProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IAnnotationProvider", L"Author"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Author());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAnnotationProvider_get_DateTime(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IAnnotationProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IAnnotationProvider", L"DateTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DateTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAnnotationProvider_get_Target(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IAnnotationProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IAnnotationProvider", L"Target"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Target());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IAnnotationProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Provider::IAnnotationProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAnnotationProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Provider::IAnnotationProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAnnotationProvider[] = {
        { "_assign_array_", _assign_array_IAnnotationProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAnnotationProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAnnotationProvider[] = {
        { "annotation_type_id", reinterpret_cast<getter>(IAnnotationProvider_get_AnnotationTypeId), nullptr, nullptr, nullptr },
        { "annotation_type_name", reinterpret_cast<getter>(IAnnotationProvider_get_AnnotationTypeName), nullptr, nullptr, nullptr },
        { "author", reinterpret_cast<getter>(IAnnotationProvider_get_Author), nullptr, nullptr, nullptr },
        { "date_time", reinterpret_cast<getter>(IAnnotationProvider_get_DateTime), nullptr, nullptr, nullptr },
        { "target", reinterpret_cast<getter>(IAnnotationProvider_get_Target), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAnnotationProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IAnnotationProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAnnotationProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAnnotationProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAnnotationProvider) },
        { },
    };

    static PyType_Spec type_spec_IAnnotationProvider =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_provider.IAnnotationProvider",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IAnnotationProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAnnotationProvider
    };

    // ----- ICustomNavigationProvider interface --------------------

    static PyObject* _new_ICustomNavigationProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::ICustomNavigationProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::ICustomNavigationProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_ICustomNavigationProvider(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ICustomNavigationProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICustomNavigationProvider_NavigateCustom(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ICustomNavigationProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ICustomNavigationProvider", L"NavigateCustom", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Peers::AutomationNavigationDirection>(args, 0);

                return py::convert(self->obj.NavigateCustom(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ICustomNavigationProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Provider::ICustomNavigationProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ICustomNavigationProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Provider::ICustomNavigationProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICustomNavigationProvider[] = {
        { "navigate_custom", reinterpret_cast<PyCFunction>(ICustomNavigationProvider_NavigateCustom), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ICustomNavigationProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICustomNavigationProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICustomNavigationProvider[] = {
        { }
    };

    static PyType_Slot _type_slots_ICustomNavigationProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ICustomNavigationProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ICustomNavigationProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ICustomNavigationProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ICustomNavigationProvider) },
        { },
    };

    static PyType_Spec type_spec_ICustomNavigationProvider =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_provider.ICustomNavigationProvider",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ICustomNavigationProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICustomNavigationProvider
    };

    // ----- IDockProvider interface --------------------

    static PyObject* _new_IDockProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IDockProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IDockProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IDockProvider(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IDockProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IDockProvider_SetDockPosition(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IDockProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.IDockProvider", L"SetDockPosition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::DockPosition>(args, 0);

                self->obj.SetDockPosition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDockProvider_get_DockPosition(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IDockProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IDockProvider", L"DockPosition"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DockPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IDockProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Provider::IDockProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IDockProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Provider::IDockProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IDockProvider[] = {
        { "set_dock_position", reinterpret_cast<PyCFunction>(IDockProvider_SetDockPosition), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IDockProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IDockProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IDockProvider[] = {
        { "dock_position", reinterpret_cast<getter>(IDockProvider_get_DockPosition), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IDockProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IDockProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IDockProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IDockProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IDockProvider) },
        { },
    };

    static PyType_Spec type_spec_IDockProvider =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_provider.IDockProvider",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IDockProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IDockProvider
    };

    // ----- IDragProvider interface --------------------

    static PyObject* _new_IDragProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IDragProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IDragProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IDragProvider(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IDragProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IDragProvider_GetGrabbedItems(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IDragProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.IDragProvider", L"GetGrabbedItems", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetGrabbedItems());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IDragProvider_get_DropEffect(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IDragProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IDragProvider", L"DropEffect"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DropEffect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDragProvider_get_DropEffects(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IDragProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IDragProvider", L"DropEffects"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DropEffects());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDragProvider_get_IsGrabbed(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IDragProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IDragProvider", L"IsGrabbed"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsGrabbed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IDragProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Provider::IDragProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IDragProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Provider::IDragProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IDragProvider[] = {
        { "get_grabbed_items", reinterpret_cast<PyCFunction>(IDragProvider_GetGrabbedItems), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IDragProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IDragProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IDragProvider[] = {
        { "drop_effect", reinterpret_cast<getter>(IDragProvider_get_DropEffect), nullptr, nullptr, nullptr },
        { "drop_effects", reinterpret_cast<getter>(IDragProvider_get_DropEffects), nullptr, nullptr, nullptr },
        { "is_grabbed", reinterpret_cast<getter>(IDragProvider_get_IsGrabbed), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IDragProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IDragProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IDragProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IDragProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IDragProvider) },
        { },
    };

    static PyType_Spec type_spec_IDragProvider =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_provider.IDragProvider",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IDragProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IDragProvider
    };

    // ----- IDropTargetProvider interface --------------------

    static PyObject* _new_IDropTargetProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IDropTargetProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IDropTargetProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IDropTargetProvider(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IDropTargetProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IDropTargetProvider_get_DropEffect(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IDropTargetProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IDropTargetProvider", L"DropEffect"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DropEffect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDropTargetProvider_get_DropEffects(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IDropTargetProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IDropTargetProvider", L"DropEffects"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DropEffects());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IDropTargetProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Provider::IDropTargetProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IDropTargetProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Provider::IDropTargetProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IDropTargetProvider[] = {
        { "_assign_array_", _assign_array_IDropTargetProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IDropTargetProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IDropTargetProvider[] = {
        { "drop_effect", reinterpret_cast<getter>(IDropTargetProvider_get_DropEffect), nullptr, nullptr, nullptr },
        { "drop_effects", reinterpret_cast<getter>(IDropTargetProvider_get_DropEffects), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IDropTargetProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IDropTargetProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IDropTargetProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IDropTargetProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IDropTargetProvider) },
        { },
    };

    static PyType_Spec type_spec_IDropTargetProvider =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_provider.IDropTargetProvider",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IDropTargetProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IDropTargetProvider
    };

    // ----- IExpandCollapseProvider interface --------------------

    static PyObject* _new_IExpandCollapseProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IExpandCollapseProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IExpandCollapseProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IExpandCollapseProvider(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IExpandCollapseProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IExpandCollapseProvider_Collapse(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IExpandCollapseProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.IExpandCollapseProvider", L"Collapse", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Collapse();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IExpandCollapseProvider_Expand(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IExpandCollapseProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.IExpandCollapseProvider", L"Expand", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Expand();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IExpandCollapseProvider_get_ExpandCollapseState(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IExpandCollapseProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IExpandCollapseProvider", L"ExpandCollapseState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExpandCollapseState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IExpandCollapseProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Provider::IExpandCollapseProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IExpandCollapseProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Provider::IExpandCollapseProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IExpandCollapseProvider[] = {
        { "collapse", reinterpret_cast<PyCFunction>(IExpandCollapseProvider_Collapse), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(IExpandCollapseProvider_Expand), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IExpandCollapseProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IExpandCollapseProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IExpandCollapseProvider[] = {
        { "expand_collapse_state", reinterpret_cast<getter>(IExpandCollapseProvider_get_ExpandCollapseState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IExpandCollapseProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IExpandCollapseProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IExpandCollapseProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IExpandCollapseProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IExpandCollapseProvider) },
        { },
    };

    static PyType_Spec type_spec_IExpandCollapseProvider =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_provider.IExpandCollapseProvider",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IExpandCollapseProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IExpandCollapseProvider
    };

    // ----- IGridItemProvider interface --------------------

    static PyObject* _new_IGridItemProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IGridItemProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IGridItemProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IGridItemProvider(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IGridItemProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IGridItemProvider_get_Column(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IGridItemProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IGridItemProvider", L"Column"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Column());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGridItemProvider_get_ColumnSpan(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IGridItemProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IGridItemProvider", L"ColumnSpan"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ColumnSpan());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGridItemProvider_get_ContainingGrid(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IGridItemProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IGridItemProvider", L"ContainingGrid"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContainingGrid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGridItemProvider_get_Row(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IGridItemProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IGridItemProvider", L"Row"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Row());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGridItemProvider_get_RowSpan(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IGridItemProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IGridItemProvider", L"RowSpan"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RowSpan());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IGridItemProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Provider::IGridItemProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IGridItemProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Provider::IGridItemProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IGridItemProvider[] = {
        { "_assign_array_", _assign_array_IGridItemProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IGridItemProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IGridItemProvider[] = {
        { "column", reinterpret_cast<getter>(IGridItemProvider_get_Column), nullptr, nullptr, nullptr },
        { "column_span", reinterpret_cast<getter>(IGridItemProvider_get_ColumnSpan), nullptr, nullptr, nullptr },
        { "containing_grid", reinterpret_cast<getter>(IGridItemProvider_get_ContainingGrid), nullptr, nullptr, nullptr },
        { "row", reinterpret_cast<getter>(IGridItemProvider_get_Row), nullptr, nullptr, nullptr },
        { "row_span", reinterpret_cast<getter>(IGridItemProvider_get_RowSpan), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IGridItemProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IGridItemProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IGridItemProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IGridItemProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IGridItemProvider) },
        { },
    };

    static PyType_Spec type_spec_IGridItemProvider =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_provider.IGridItemProvider",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IGridItemProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IGridItemProvider
    };

    // ----- IGridProvider interface --------------------

    static PyObject* _new_IGridProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IGridProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IGridProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IGridProvider(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IGridProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IGridProvider_GetItem(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IGridProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.IGridProvider", L"GetItem", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.GetItem(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IGridProvider_get_ColumnCount(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IGridProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IGridProvider", L"ColumnCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ColumnCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGridProvider_get_RowCount(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IGridProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IGridProvider", L"RowCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RowCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IGridProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Provider::IGridProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IGridProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Provider::IGridProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IGridProvider[] = {
        { "get_item", reinterpret_cast<PyCFunction>(IGridProvider_GetItem), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IGridProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IGridProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IGridProvider[] = {
        { "column_count", reinterpret_cast<getter>(IGridProvider_get_ColumnCount), nullptr, nullptr, nullptr },
        { "row_count", reinterpret_cast<getter>(IGridProvider_get_RowCount), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IGridProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IGridProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IGridProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IGridProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IGridProvider) },
        { },
    };

    static PyType_Spec type_spec_IGridProvider =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_provider.IGridProvider",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IGridProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IGridProvider
    };

    // ----- IInvokeProvider interface --------------------

    static PyObject* _new_IInvokeProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IInvokeProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IInvokeProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IInvokeProvider(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IInvokeProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IInvokeProvider_Invoke(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IInvokeProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.IInvokeProvider", L"Invoke", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Invoke();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IInvokeProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Provider::IInvokeProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IInvokeProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Provider::IInvokeProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IInvokeProvider[] = {
        { "invoke", reinterpret_cast<PyCFunction>(IInvokeProvider_Invoke), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IInvokeProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IInvokeProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IInvokeProvider[] = {
        { }
    };

    static PyType_Slot _type_slots_IInvokeProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IInvokeProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IInvokeProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IInvokeProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IInvokeProvider) },
        { },
    };

    static PyType_Spec type_spec_IInvokeProvider =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_provider.IInvokeProvider",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IInvokeProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IInvokeProvider
    };

    // ----- IItemContainerProvider interface --------------------

    static PyObject* _new_IItemContainerProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IItemContainerProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IItemContainerProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IItemContainerProvider(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IItemContainerProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IItemContainerProvider_FindItemByProperty(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IItemContainerProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.IItemContainerProvider", L"FindItemByProperty", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Provider::IRawElementProviderSimple>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::AutomationProperty>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);

                return py::convert(self->obj.FindItemByProperty(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IItemContainerProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Provider::IItemContainerProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IItemContainerProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Provider::IItemContainerProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IItemContainerProvider[] = {
        { "find_item_by_property", reinterpret_cast<PyCFunction>(IItemContainerProvider_FindItemByProperty), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IItemContainerProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IItemContainerProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IItemContainerProvider[] = {
        { }
    };

    static PyType_Slot _type_slots_IItemContainerProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IItemContainerProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IItemContainerProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IItemContainerProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IItemContainerProvider) },
        { },
    };

    static PyType_Spec type_spec_IItemContainerProvider =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_provider.IItemContainerProvider",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IItemContainerProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IItemContainerProvider
    };

    // ----- IMultipleViewProvider interface --------------------

    static PyObject* _new_IMultipleViewProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IMultipleViewProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IMultipleViewProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IMultipleViewProvider(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IMultipleViewProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IMultipleViewProvider_GetSupportedViews(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IMultipleViewProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.IMultipleViewProvider", L"GetSupportedViews", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetSupportedViews());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IMultipleViewProvider_GetViewName(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IMultipleViewProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.IMultipleViewProvider", L"GetViewName", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.GetViewName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IMultipleViewProvider_SetCurrentView(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IMultipleViewProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.IMultipleViewProvider", L"SetCurrentView", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.SetCurrentView(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IMultipleViewProvider_get_CurrentView(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IMultipleViewProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IMultipleViewProvider", L"CurrentView"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CurrentView());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IMultipleViewProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Provider::IMultipleViewProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IMultipleViewProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Provider::IMultipleViewProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMultipleViewProvider[] = {
        { "get_supported_views", reinterpret_cast<PyCFunction>(IMultipleViewProvider_GetSupportedViews), METH_VARARGS, nullptr },
        { "get_view_name", reinterpret_cast<PyCFunction>(IMultipleViewProvider_GetViewName), METH_VARARGS, nullptr },
        { "set_current_view", reinterpret_cast<PyCFunction>(IMultipleViewProvider_SetCurrentView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IMultipleViewProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IMultipleViewProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMultipleViewProvider[] = {
        { "current_view", reinterpret_cast<getter>(IMultipleViewProvider_get_CurrentView), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IMultipleViewProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IMultipleViewProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IMultipleViewProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IMultipleViewProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IMultipleViewProvider) },
        { },
    };

    static PyType_Spec type_spec_IMultipleViewProvider =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_provider.IMultipleViewProvider",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IMultipleViewProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMultipleViewProvider
    };

    // ----- IObjectModelProvider interface --------------------

    static PyObject* _new_IObjectModelProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IObjectModelProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IObjectModelProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IObjectModelProvider(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IObjectModelProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IObjectModelProvider_GetUnderlyingObjectModel(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IObjectModelProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.IObjectModelProvider", L"GetUnderlyingObjectModel", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetUnderlyingObjectModel());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IObjectModelProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Provider::IObjectModelProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IObjectModelProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Provider::IObjectModelProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IObjectModelProvider[] = {
        { "get_underlying_object_model", reinterpret_cast<PyCFunction>(IObjectModelProvider_GetUnderlyingObjectModel), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IObjectModelProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IObjectModelProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IObjectModelProvider[] = {
        { }
    };

    static PyType_Slot _type_slots_IObjectModelProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IObjectModelProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IObjectModelProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IObjectModelProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IObjectModelProvider) },
        { },
    };

    static PyType_Spec type_spec_IObjectModelProvider =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_provider.IObjectModelProvider",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IObjectModelProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IObjectModelProvider
    };

    // ----- IRangeValueProvider interface --------------------

    static PyObject* _new_IRangeValueProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IRangeValueProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IRangeValueProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IRangeValueProvider(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IRangeValueProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IRangeValueProvider_SetValue(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IRangeValueProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.IRangeValueProvider", L"SetValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                self->obj.SetValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IRangeValueProvider_get_IsReadOnly(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IRangeValueProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IRangeValueProvider", L"IsReadOnly"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IRangeValueProvider_get_LargeChange(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IRangeValueProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IRangeValueProvider", L"LargeChange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LargeChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IRangeValueProvider_get_Maximum(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IRangeValueProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IRangeValueProvider", L"Maximum"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Maximum());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IRangeValueProvider_get_Minimum(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IRangeValueProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IRangeValueProvider", L"Minimum"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Minimum());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IRangeValueProvider_get_SmallChange(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IRangeValueProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IRangeValueProvider", L"SmallChange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SmallChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IRangeValueProvider_get_Value(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IRangeValueProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IRangeValueProvider", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IRangeValueProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Provider::IRangeValueProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IRangeValueProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Provider::IRangeValueProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IRangeValueProvider[] = {
        { "set_value", reinterpret_cast<PyCFunction>(IRangeValueProvider_SetValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IRangeValueProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IRangeValueProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IRangeValueProvider[] = {
        { "is_read_only", reinterpret_cast<getter>(IRangeValueProvider_get_IsReadOnly), nullptr, nullptr, nullptr },
        { "large_change", reinterpret_cast<getter>(IRangeValueProvider_get_LargeChange), nullptr, nullptr, nullptr },
        { "maximum", reinterpret_cast<getter>(IRangeValueProvider_get_Maximum), nullptr, nullptr, nullptr },
        { "minimum", reinterpret_cast<getter>(IRangeValueProvider_get_Minimum), nullptr, nullptr, nullptr },
        { "small_change", reinterpret_cast<getter>(IRangeValueProvider_get_SmallChange), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(IRangeValueProvider_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IRangeValueProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IRangeValueProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IRangeValueProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IRangeValueProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IRangeValueProvider) },
        { },
    };

    static PyType_Spec type_spec_IRangeValueProvider =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_provider.IRangeValueProvider",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IRangeValueProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IRangeValueProvider
    };

    // ----- IScrollItemProvider interface --------------------

    static PyObject* _new_IScrollItemProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IScrollItemProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IScrollItemProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IScrollItemProvider(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IScrollItemProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IScrollItemProvider_ScrollIntoView(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IScrollItemProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.IScrollItemProvider", L"ScrollIntoView", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ScrollIntoView();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IScrollItemProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Provider::IScrollItemProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IScrollItemProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Provider::IScrollItemProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IScrollItemProvider[] = {
        { "scroll_into_view", reinterpret_cast<PyCFunction>(IScrollItemProvider_ScrollIntoView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IScrollItemProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IScrollItemProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IScrollItemProvider[] = {
        { }
    };

    static PyType_Slot _type_slots_IScrollItemProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IScrollItemProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IScrollItemProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IScrollItemProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IScrollItemProvider) },
        { },
    };

    static PyType_Spec type_spec_IScrollItemProvider =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_provider.IScrollItemProvider",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IScrollItemProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IScrollItemProvider
    };

    // ----- IScrollProvider interface --------------------

    static PyObject* _new_IScrollProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IScrollProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IScrollProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IScrollProvider(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IScrollProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IScrollProvider_Scroll(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IScrollProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.IScrollProvider", L"Scroll", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::ScrollAmount>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::ScrollAmount>(args, 1);

                self->obj.Scroll(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IScrollProvider_SetScrollPercent(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IScrollProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.IScrollProvider", L"SetScrollPercent", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.SetScrollPercent(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IScrollProvider_get_HorizontalScrollPercent(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IScrollProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IScrollProvider", L"HorizontalScrollPercent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontalScrollPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollProvider_get_HorizontalViewSize(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IScrollProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IScrollProvider", L"HorizontalViewSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontalViewSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollProvider_get_HorizontallyScrollable(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IScrollProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IScrollProvider", L"HorizontallyScrollable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HorizontallyScrollable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollProvider_get_VerticalScrollPercent(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IScrollProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IScrollProvider", L"VerticalScrollPercent"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VerticalScrollPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollProvider_get_VerticalViewSize(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IScrollProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IScrollProvider", L"VerticalViewSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VerticalViewSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IScrollProvider_get_VerticallyScrollable(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IScrollProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IScrollProvider", L"VerticallyScrollable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VerticallyScrollable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IScrollProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Provider::IScrollProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IScrollProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Provider::IScrollProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IScrollProvider[] = {
        { "scroll", reinterpret_cast<PyCFunction>(IScrollProvider_Scroll), METH_VARARGS, nullptr },
        { "set_scroll_percent", reinterpret_cast<PyCFunction>(IScrollProvider_SetScrollPercent), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IScrollProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IScrollProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IScrollProvider[] = {
        { "horizontal_scroll_percent", reinterpret_cast<getter>(IScrollProvider_get_HorizontalScrollPercent), nullptr, nullptr, nullptr },
        { "horizontal_view_size", reinterpret_cast<getter>(IScrollProvider_get_HorizontalViewSize), nullptr, nullptr, nullptr },
        { "horizontally_scrollable", reinterpret_cast<getter>(IScrollProvider_get_HorizontallyScrollable), nullptr, nullptr, nullptr },
        { "vertical_scroll_percent", reinterpret_cast<getter>(IScrollProvider_get_VerticalScrollPercent), nullptr, nullptr, nullptr },
        { "vertical_view_size", reinterpret_cast<getter>(IScrollProvider_get_VerticalViewSize), nullptr, nullptr, nullptr },
        { "vertically_scrollable", reinterpret_cast<getter>(IScrollProvider_get_VerticallyScrollable), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IScrollProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IScrollProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IScrollProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IScrollProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IScrollProvider) },
        { },
    };

    static PyType_Spec type_spec_IScrollProvider =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_provider.IScrollProvider",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IScrollProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IScrollProvider
    };

    // ----- ISelectionItemProvider interface --------------------

    static PyObject* _new_ISelectionItemProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::ISelectionItemProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::ISelectionItemProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_ISelectionItemProvider(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ISelectionItemProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISelectionItemProvider_AddToSelection(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ISelectionItemProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ISelectionItemProvider", L"AddToSelection", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.AddToSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ISelectionItemProvider_RemoveFromSelection(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ISelectionItemProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ISelectionItemProvider", L"RemoveFromSelection", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RemoveFromSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ISelectionItemProvider_Select(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ISelectionItemProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ISelectionItemProvider", L"Select", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Select();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ISelectionItemProvider_get_IsSelected(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ISelectionItemProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.ISelectionItemProvider", L"IsSelected"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISelectionItemProvider_get_SelectionContainer(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ISelectionItemProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.ISelectionItemProvider", L"SelectionContainer"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SelectionContainer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ISelectionItemProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Provider::ISelectionItemProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISelectionItemProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Provider::ISelectionItemProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISelectionItemProvider[] = {
        { "add_to_selection", reinterpret_cast<PyCFunction>(ISelectionItemProvider_AddToSelection), METH_VARARGS, nullptr },
        { "remove_from_selection", reinterpret_cast<PyCFunction>(ISelectionItemProvider_RemoveFromSelection), METH_VARARGS, nullptr },
        { "select", reinterpret_cast<PyCFunction>(ISelectionItemProvider_Select), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ISelectionItemProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISelectionItemProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ISelectionItemProvider[] = {
        { "is_selected", reinterpret_cast<getter>(ISelectionItemProvider_get_IsSelected), nullptr, nullptr, nullptr },
        { "selection_container", reinterpret_cast<getter>(ISelectionItemProvider_get_SelectionContainer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ISelectionItemProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ISelectionItemProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISelectionItemProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISelectionItemProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISelectionItemProvider) },
        { },
    };

    static PyType_Spec type_spec_ISelectionItemProvider =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_provider.ISelectionItemProvider",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ISelectionItemProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISelectionItemProvider
    };

    // ----- ISelectionProvider interface --------------------

    static PyObject* _new_ISelectionProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::ISelectionProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::ISelectionProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_ISelectionProvider(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ISelectionProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISelectionProvider_GetSelection(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ISelectionProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ISelectionProvider", L"GetSelection", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetSelection());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ISelectionProvider_get_CanSelectMultiple(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ISelectionProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.ISelectionProvider", L"CanSelectMultiple"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanSelectMultiple());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISelectionProvider_get_IsSelectionRequired(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ISelectionProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.ISelectionProvider", L"IsSelectionRequired"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSelectionRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ISelectionProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Provider::ISelectionProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISelectionProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Provider::ISelectionProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISelectionProvider[] = {
        { "get_selection", reinterpret_cast<PyCFunction>(ISelectionProvider_GetSelection), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ISelectionProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISelectionProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ISelectionProvider[] = {
        { "can_select_multiple", reinterpret_cast<getter>(ISelectionProvider_get_CanSelectMultiple), nullptr, nullptr, nullptr },
        { "is_selection_required", reinterpret_cast<getter>(ISelectionProvider_get_IsSelectionRequired), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ISelectionProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ISelectionProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISelectionProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISelectionProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISelectionProvider) },
        { },
    };

    static PyType_Spec type_spec_ISelectionProvider =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_provider.ISelectionProvider",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ISelectionProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISelectionProvider
    };

    // ----- ISpreadsheetItemProvider interface --------------------

    static PyObject* _new_ISpreadsheetItemProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::ISpreadsheetItemProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::ISpreadsheetItemProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_ISpreadsheetItemProvider(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ISpreadsheetItemProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISpreadsheetItemProvider_GetAnnotationObjects(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ISpreadsheetItemProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ISpreadsheetItemProvider", L"GetAnnotationObjects", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAnnotationObjects());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ISpreadsheetItemProvider_GetAnnotationTypes(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ISpreadsheetItemProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ISpreadsheetItemProvider", L"GetAnnotationTypes", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAnnotationTypes());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ISpreadsheetItemProvider_get_Formula(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ISpreadsheetItemProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.ISpreadsheetItemProvider", L"Formula"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Formula());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ISpreadsheetItemProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Provider::ISpreadsheetItemProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISpreadsheetItemProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Provider::ISpreadsheetItemProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISpreadsheetItemProvider[] = {
        { "get_annotation_objects", reinterpret_cast<PyCFunction>(ISpreadsheetItemProvider_GetAnnotationObjects), METH_VARARGS, nullptr },
        { "get_annotation_types", reinterpret_cast<PyCFunction>(ISpreadsheetItemProvider_GetAnnotationTypes), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ISpreadsheetItemProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISpreadsheetItemProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ISpreadsheetItemProvider[] = {
        { "formula", reinterpret_cast<getter>(ISpreadsheetItemProvider_get_Formula), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ISpreadsheetItemProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ISpreadsheetItemProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISpreadsheetItemProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISpreadsheetItemProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISpreadsheetItemProvider) },
        { },
    };

    static PyType_Spec type_spec_ISpreadsheetItemProvider =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_provider.ISpreadsheetItemProvider",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ISpreadsheetItemProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISpreadsheetItemProvider
    };

    // ----- ISpreadsheetProvider interface --------------------

    static PyObject* _new_ISpreadsheetProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::ISpreadsheetProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::ISpreadsheetProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_ISpreadsheetProvider(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ISpreadsheetProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISpreadsheetProvider_GetItemByName(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ISpreadsheetProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ISpreadsheetProvider", L"GetItemByName", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetItemByName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ISpreadsheetProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Provider::ISpreadsheetProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISpreadsheetProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Provider::ISpreadsheetProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISpreadsheetProvider[] = {
        { "get_item_by_name", reinterpret_cast<PyCFunction>(ISpreadsheetProvider_GetItemByName), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ISpreadsheetProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISpreadsheetProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ISpreadsheetProvider[] = {
        { }
    };

    static PyType_Slot _type_slots_ISpreadsheetProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ISpreadsheetProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISpreadsheetProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISpreadsheetProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISpreadsheetProvider) },
        { },
    };

    static PyType_Spec type_spec_ISpreadsheetProvider =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_provider.ISpreadsheetProvider",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ISpreadsheetProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISpreadsheetProvider
    };

    // ----- IStylesProvider interface --------------------

    static PyObject* _new_IStylesProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IStylesProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IStylesProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IStylesProvider(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IStylesProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStylesProvider_get_ExtendedProperties(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IStylesProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IStylesProvider", L"ExtendedProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStylesProvider_get_FillColor(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IStylesProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IStylesProvider", L"FillColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FillColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStylesProvider_get_FillPatternColor(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IStylesProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IStylesProvider", L"FillPatternColor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FillPatternColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStylesProvider_get_FillPatternStyle(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IStylesProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IStylesProvider", L"FillPatternStyle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FillPatternStyle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStylesProvider_get_Shape(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IStylesProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IStylesProvider", L"Shape"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStylesProvider_get_StyleId(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IStylesProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IStylesProvider", L"StyleId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StyleId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStylesProvider_get_StyleName(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IStylesProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IStylesProvider", L"StyleName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StyleName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IStylesProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Provider::IStylesProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IStylesProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Provider::IStylesProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStylesProvider[] = {
        { "_assign_array_", _assign_array_IStylesProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStylesProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStylesProvider[] = {
        { "extended_properties", reinterpret_cast<getter>(IStylesProvider_get_ExtendedProperties), nullptr, nullptr, nullptr },
        { "fill_color", reinterpret_cast<getter>(IStylesProvider_get_FillColor), nullptr, nullptr, nullptr },
        { "fill_pattern_color", reinterpret_cast<getter>(IStylesProvider_get_FillPatternColor), nullptr, nullptr, nullptr },
        { "fill_pattern_style", reinterpret_cast<getter>(IStylesProvider_get_FillPatternStyle), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(IStylesProvider_get_Shape), nullptr, nullptr, nullptr },
        { "style_id", reinterpret_cast<getter>(IStylesProvider_get_StyleId), nullptr, nullptr, nullptr },
        { "style_name", reinterpret_cast<getter>(IStylesProvider_get_StyleName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IStylesProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IStylesProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IStylesProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IStylesProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IStylesProvider) },
        { },
    };

    static PyType_Spec type_spec_IStylesProvider =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_provider.IStylesProvider",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IStylesProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStylesProvider
    };

    // ----- ISynchronizedInputProvider interface --------------------

    static PyObject* _new_ISynchronizedInputProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::ISynchronizedInputProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::ISynchronizedInputProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_ISynchronizedInputProvider(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ISynchronizedInputProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISynchronizedInputProvider_Cancel(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ISynchronizedInputProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ISynchronizedInputProvider", L"Cancel", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Cancel();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ISynchronizedInputProvider_StartListening(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ISynchronizedInputProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ISynchronizedInputProvider", L"StartListening", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::SynchronizedInputType>(args, 0);

                self->obj.StartListening(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ISynchronizedInputProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Provider::ISynchronizedInputProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ISynchronizedInputProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Provider::ISynchronizedInputProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISynchronizedInputProvider[] = {
        { "cancel", reinterpret_cast<PyCFunction>(ISynchronizedInputProvider_Cancel), METH_VARARGS, nullptr },
        { "start_listening", reinterpret_cast<PyCFunction>(ISynchronizedInputProvider_StartListening), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ISynchronizedInputProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISynchronizedInputProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ISynchronizedInputProvider[] = {
        { }
    };

    static PyType_Slot _type_slots_ISynchronizedInputProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ISynchronizedInputProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ISynchronizedInputProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ISynchronizedInputProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ISynchronizedInputProvider) },
        { },
    };

    static PyType_Spec type_spec_ISynchronizedInputProvider =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_provider.ISynchronizedInputProvider",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ISynchronizedInputProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISynchronizedInputProvider
    };

    // ----- ITableItemProvider interface --------------------

    static PyObject* _new_ITableItemProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::ITableItemProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::ITableItemProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_ITableItemProvider(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITableItemProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ITableItemProvider_GetColumnHeaderItems(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITableItemProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITableItemProvider", L"GetColumnHeaderItems", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetColumnHeaderItems());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITableItemProvider_GetRowHeaderItems(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITableItemProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITableItemProvider", L"GetRowHeaderItems", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetRowHeaderItems());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ITableItemProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Provider::ITableItemProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ITableItemProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Provider::ITableItemProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITableItemProvider[] = {
        { "get_column_header_items", reinterpret_cast<PyCFunction>(ITableItemProvider_GetColumnHeaderItems), METH_VARARGS, nullptr },
        { "get_row_header_items", reinterpret_cast<PyCFunction>(ITableItemProvider_GetRowHeaderItems), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ITableItemProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ITableItemProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ITableItemProvider[] = {
        { }
    };

    static PyType_Slot _type_slots_ITableItemProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ITableItemProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ITableItemProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ITableItemProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ITableItemProvider) },
        { },
    };

    static PyType_Spec type_spec_ITableItemProvider =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_provider.ITableItemProvider",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITableItemProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITableItemProvider
    };

    // ----- ITableProvider interface --------------------

    static PyObject* _new_ITableProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::ITableProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::ITableProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_ITableProvider(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITableProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ITableProvider_GetColumnHeaders(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITableProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITableProvider", L"GetColumnHeaders", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetColumnHeaders());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITableProvider_GetRowHeaders(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITableProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITableProvider", L"GetRowHeaders", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetRowHeaders());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITableProvider_get_RowOrColumnMajor(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITableProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITableProvider", L"RowOrColumnMajor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RowOrColumnMajor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ITableProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Provider::ITableProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ITableProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Provider::ITableProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITableProvider[] = {
        { "get_column_headers", reinterpret_cast<PyCFunction>(ITableProvider_GetColumnHeaders), METH_VARARGS, nullptr },
        { "get_row_headers", reinterpret_cast<PyCFunction>(ITableProvider_GetRowHeaders), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ITableProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ITableProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ITableProvider[] = {
        { "row_or_column_major", reinterpret_cast<getter>(ITableProvider_get_RowOrColumnMajor), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ITableProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ITableProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ITableProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ITableProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ITableProvider) },
        { },
    };

    static PyType_Spec type_spec_ITableProvider =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_provider.ITableProvider",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITableProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITableProvider
    };

    // ----- ITextChildProvider interface --------------------

    static PyObject* _new_ITextChildProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::ITextChildProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::ITextChildProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_ITextChildProvider(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextChildProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ITextChildProvider_get_TextContainer(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextChildProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextChildProvider", L"TextContainer"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TextContainer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITextChildProvider_get_TextRange(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextChildProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextChildProvider", L"TextRange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TextRange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ITextChildProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Provider::ITextChildProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ITextChildProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Provider::ITextChildProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITextChildProvider[] = {
        { "_assign_array_", _assign_array_ITextChildProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ITextChildProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ITextChildProvider[] = {
        { "text_container", reinterpret_cast<getter>(ITextChildProvider_get_TextContainer), nullptr, nullptr, nullptr },
        { "text_range", reinterpret_cast<getter>(ITextChildProvider_get_TextRange), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ITextChildProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ITextChildProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ITextChildProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ITextChildProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ITextChildProvider) },
        { },
    };

    static PyType_Spec type_spec_ITextChildProvider =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_provider.ITextChildProvider",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextChildProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITextChildProvider
    };

    // ----- ITextEditProvider interface --------------------

    static PyObject* _new_ITextEditProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::ITextEditProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::ITextEditProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_ITextEditProvider(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextEditProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ITextEditProvider_GetActiveComposition(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextEditProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextEditProvider", L"GetActiveComposition", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetActiveComposition());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextEditProvider_GetConversionTarget(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextEditProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextEditProvider", L"GetConversionTarget", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetConversionTarget());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextEditProvider_GetSelection(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextEditProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextProvider", L"GetSelection", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetSelection());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextEditProvider_GetVisibleRanges(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextEditProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextProvider", L"GetVisibleRanges", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetVisibleRanges());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextEditProvider_RangeFromChild(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextEditProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextProvider", L"RangeFromChild", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Provider::IRawElementProviderSimple>(args, 0);

                return py::convert(self->obj.RangeFromChild(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextEditProvider_RangeFromPoint(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextEditProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextProvider", L"RangeFromPoint", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.RangeFromPoint(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextEditProvider_get_DocumentRange(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextEditProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextProvider", L"DocumentRange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DocumentRange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITextEditProvider_get_SupportedTextSelection(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextEditProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextProvider", L"SupportedTextSelection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedTextSelection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ITextEditProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Provider::ITextEditProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ITextEditProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Provider::ITextEditProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITextEditProvider[] = {
        { "get_active_composition", reinterpret_cast<PyCFunction>(ITextEditProvider_GetActiveComposition), METH_VARARGS, nullptr },
        { "get_conversion_target", reinterpret_cast<PyCFunction>(ITextEditProvider_GetConversionTarget), METH_VARARGS, nullptr },
        { "get_selection", reinterpret_cast<PyCFunction>(ITextEditProvider_GetSelection), METH_VARARGS, nullptr },
        { "get_visible_ranges", reinterpret_cast<PyCFunction>(ITextEditProvider_GetVisibleRanges), METH_VARARGS, nullptr },
        { "range_from_child", reinterpret_cast<PyCFunction>(ITextEditProvider_RangeFromChild), METH_VARARGS, nullptr },
        { "range_from_point", reinterpret_cast<PyCFunction>(ITextEditProvider_RangeFromPoint), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ITextEditProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ITextEditProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ITextEditProvider[] = {
        { "document_range", reinterpret_cast<getter>(ITextEditProvider_get_DocumentRange), nullptr, nullptr, nullptr },
        { "supported_text_selection", reinterpret_cast<getter>(ITextEditProvider_get_SupportedTextSelection), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ITextEditProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ITextEditProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ITextEditProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ITextEditProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ITextEditProvider) },
        { },
    };

    static PyType_Spec type_spec_ITextEditProvider =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_provider.ITextEditProvider",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextEditProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITextEditProvider
    };

    // ----- ITextProvider interface --------------------

    static PyObject* _new_ITextProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::ITextProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::ITextProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_ITextProvider(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ITextProvider_GetSelection(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextProvider", L"GetSelection", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetSelection());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextProvider_GetVisibleRanges(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextProvider", L"GetVisibleRanges", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetVisibleRanges());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextProvider_RangeFromChild(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextProvider", L"RangeFromChild", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Provider::IRawElementProviderSimple>(args, 0);

                return py::convert(self->obj.RangeFromChild(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextProvider_RangeFromPoint(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextProvider", L"RangeFromPoint", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.RangeFromPoint(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextProvider_get_DocumentRange(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextProvider", L"DocumentRange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DocumentRange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITextProvider_get_SupportedTextSelection(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextProvider", L"SupportedTextSelection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedTextSelection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ITextProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Provider::ITextProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ITextProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Provider::ITextProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITextProvider[] = {
        { "get_selection", reinterpret_cast<PyCFunction>(ITextProvider_GetSelection), METH_VARARGS, nullptr },
        { "get_visible_ranges", reinterpret_cast<PyCFunction>(ITextProvider_GetVisibleRanges), METH_VARARGS, nullptr },
        { "range_from_child", reinterpret_cast<PyCFunction>(ITextProvider_RangeFromChild), METH_VARARGS, nullptr },
        { "range_from_point", reinterpret_cast<PyCFunction>(ITextProvider_RangeFromPoint), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ITextProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ITextProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ITextProvider[] = {
        { "document_range", reinterpret_cast<getter>(ITextProvider_get_DocumentRange), nullptr, nullptr, nullptr },
        { "supported_text_selection", reinterpret_cast<getter>(ITextProvider_get_SupportedTextSelection), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ITextProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ITextProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ITextProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ITextProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ITextProvider) },
        { },
    };

    static PyType_Spec type_spec_ITextProvider =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_provider.ITextProvider",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITextProvider
    };

    // ----- ITextProvider2 interface --------------------

    static PyObject* _new_ITextProvider2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::ITextProvider2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::ITextProvider2>::type_name);
        return nullptr;
    }

    static void _dealloc_ITextProvider2(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextProvider2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ITextProvider2_GetCaretRange(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextProvider2", L"GetCaretRange", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                bool param0 {  };

                auto return_value = self->obj.GetCaretRange(param0);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out0.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextProvider2_GetSelection(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextProvider", L"GetSelection", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetSelection());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextProvider2_GetVisibleRanges(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextProvider", L"GetVisibleRanges", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetVisibleRanges());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextProvider2_RangeFromAnnotation(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextProvider2", L"RangeFromAnnotation", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Provider::IRawElementProviderSimple>(args, 0);

                return py::convert(self->obj.RangeFromAnnotation(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextProvider2_RangeFromChild(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextProvider", L"RangeFromChild", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Provider::IRawElementProviderSimple>(args, 0);

                return py::convert(self->obj.RangeFromChild(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextProvider2_RangeFromPoint(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextProvider", L"RangeFromPoint", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.RangeFromPoint(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextProvider2_get_DocumentRange(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextProvider2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextProvider", L"DocumentRange"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DocumentRange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITextProvider2_get_SupportedTextSelection(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextProvider2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextProvider", L"SupportedTextSelection"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedTextSelection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ITextProvider2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Provider::ITextProvider2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ITextProvider2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Provider::ITextProvider2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITextProvider2[] = {
        { "get_caret_range", reinterpret_cast<PyCFunction>(ITextProvider2_GetCaretRange), METH_VARARGS, nullptr },
        { "get_selection", reinterpret_cast<PyCFunction>(ITextProvider2_GetSelection), METH_VARARGS, nullptr },
        { "get_visible_ranges", reinterpret_cast<PyCFunction>(ITextProvider2_GetVisibleRanges), METH_VARARGS, nullptr },
        { "range_from_annotation", reinterpret_cast<PyCFunction>(ITextProvider2_RangeFromAnnotation), METH_VARARGS, nullptr },
        { "range_from_child", reinterpret_cast<PyCFunction>(ITextProvider2_RangeFromChild), METH_VARARGS, nullptr },
        { "range_from_point", reinterpret_cast<PyCFunction>(ITextProvider2_RangeFromPoint), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ITextProvider2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ITextProvider2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ITextProvider2[] = {
        { "document_range", reinterpret_cast<getter>(ITextProvider2_get_DocumentRange), nullptr, nullptr, nullptr },
        { "supported_text_selection", reinterpret_cast<getter>(ITextProvider2_get_SupportedTextSelection), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ITextProvider2[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ITextProvider2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ITextProvider2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ITextProvider2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ITextProvider2) },
        { },
    };

    static PyType_Spec type_spec_ITextProvider2 =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_provider.ITextProvider2",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextProvider2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITextProvider2
    };

    // ----- ITextRangeProvider interface --------------------

    static PyObject* _new_ITextRangeProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_ITextRangeProvider(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ITextRangeProvider_AddToSelection(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextRangeProvider", L"AddToSelection", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.AddToSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider_Clone(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextRangeProvider", L"Clone", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.Clone());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider_Compare(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextRangeProvider", L"Compare", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider>(args, 0);

                return py::convert(self->obj.Compare(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider_CompareEndpoints(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextRangeProvider", L"CompareEndpoints", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Text::TextPatternRangeEndpoint>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Text::TextPatternRangeEndpoint>(args, 2);

                return py::convert(self->obj.CompareEndpoints(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider_ExpandToEnclosingUnit(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextRangeProvider", L"ExpandToEnclosingUnit", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Text::TextUnit>(args, 0);

                self->obj.ExpandToEnclosingUnit(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider_FindAttribute(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextRangeProvider", L"FindAttribute", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                return py::convert(self->obj.FindAttribute(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider_FindText(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextRangeProvider", L"FindText", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                return py::convert(self->obj.FindText(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider_GetAttributeValue(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextRangeProvider", L"GetAttributeValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.GetAttributeValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider_GetBoundingRectangles(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextRangeProvider", L"GetBoundingRectangles", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::com_array<double> param0 { };

                self->obj.GetBoundingRectangles(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider_GetChildren(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextRangeProvider", L"GetChildren", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetChildren());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider_GetEnclosingElement(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextRangeProvider", L"GetEnclosingElement", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetEnclosingElement());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider_GetText(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextRangeProvider", L"GetText", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.GetText(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider_Move(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextRangeProvider", L"Move", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Text::TextUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.Move(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider_MoveEndpointByRange(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextRangeProvider", L"MoveEndpointByRange", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Text::TextPatternRangeEndpoint>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Text::TextPatternRangeEndpoint>(args, 2);

                self->obj.MoveEndpointByRange(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider_MoveEndpointByUnit(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextRangeProvider", L"MoveEndpointByUnit", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Text::TextPatternRangeEndpoint>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Text::TextUnit>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);

                return py::convert(self->obj.MoveEndpointByUnit(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider_RemoveFromSelection(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextRangeProvider", L"RemoveFromSelection", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RemoveFromSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider_ScrollIntoView(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextRangeProvider", L"ScrollIntoView", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.ScrollIntoView(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider_Select(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextRangeProvider", L"Select", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Select();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ITextRangeProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ITextRangeProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITextRangeProvider[] = {
        { "add_to_selection", reinterpret_cast<PyCFunction>(ITextRangeProvider_AddToSelection), METH_VARARGS, nullptr },
        { "clone", reinterpret_cast<PyCFunction>(ITextRangeProvider_Clone), METH_VARARGS, nullptr },
        { "compare", reinterpret_cast<PyCFunction>(ITextRangeProvider_Compare), METH_VARARGS, nullptr },
        { "compare_endpoints", reinterpret_cast<PyCFunction>(ITextRangeProvider_CompareEndpoints), METH_VARARGS, nullptr },
        { "expand_to_enclosing_unit", reinterpret_cast<PyCFunction>(ITextRangeProvider_ExpandToEnclosingUnit), METH_VARARGS, nullptr },
        { "find_attribute", reinterpret_cast<PyCFunction>(ITextRangeProvider_FindAttribute), METH_VARARGS, nullptr },
        { "find_text", reinterpret_cast<PyCFunction>(ITextRangeProvider_FindText), METH_VARARGS, nullptr },
        { "get_attribute_value", reinterpret_cast<PyCFunction>(ITextRangeProvider_GetAttributeValue), METH_VARARGS, nullptr },
        { "get_bounding_rectangles", reinterpret_cast<PyCFunction>(ITextRangeProvider_GetBoundingRectangles), METH_VARARGS, nullptr },
        { "get_children", reinterpret_cast<PyCFunction>(ITextRangeProvider_GetChildren), METH_VARARGS, nullptr },
        { "get_enclosing_element", reinterpret_cast<PyCFunction>(ITextRangeProvider_GetEnclosingElement), METH_VARARGS, nullptr },
        { "get_text", reinterpret_cast<PyCFunction>(ITextRangeProvider_GetText), METH_VARARGS, nullptr },
        { "move", reinterpret_cast<PyCFunction>(ITextRangeProvider_Move), METH_VARARGS, nullptr },
        { "move_endpoint_by_range", reinterpret_cast<PyCFunction>(ITextRangeProvider_MoveEndpointByRange), METH_VARARGS, nullptr },
        { "move_endpoint_by_unit", reinterpret_cast<PyCFunction>(ITextRangeProvider_MoveEndpointByUnit), METH_VARARGS, nullptr },
        { "remove_from_selection", reinterpret_cast<PyCFunction>(ITextRangeProvider_RemoveFromSelection), METH_VARARGS, nullptr },
        { "scroll_into_view", reinterpret_cast<PyCFunction>(ITextRangeProvider_ScrollIntoView), METH_VARARGS, nullptr },
        { "select", reinterpret_cast<PyCFunction>(ITextRangeProvider_Select), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ITextRangeProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ITextRangeProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ITextRangeProvider[] = {
        { }
    };

    static PyType_Slot _type_slots_ITextRangeProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ITextRangeProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ITextRangeProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ITextRangeProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ITextRangeProvider) },
        { },
    };

    static PyType_Spec type_spec_ITextRangeProvider =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_provider.ITextRangeProvider",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITextRangeProvider
    };

    // ----- ITextRangeProvider2 interface --------------------

    static PyObject* _new_ITextRangeProvider2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider2>::type_name);
        return nullptr;
    }

    static void _dealloc_ITextRangeProvider2(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ITextRangeProvider2_AddToSelection(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextRangeProvider", L"AddToSelection", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.AddToSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider2_Clone(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextRangeProvider", L"Clone", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.Clone());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider2_Compare(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextRangeProvider", L"Compare", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider>(args, 0);

                return py::convert(self->obj.Compare(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider2_CompareEndpoints(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextRangeProvider", L"CompareEndpoints", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Text::TextPatternRangeEndpoint>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Text::TextPatternRangeEndpoint>(args, 2);

                return py::convert(self->obj.CompareEndpoints(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider2_ExpandToEnclosingUnit(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextRangeProvider", L"ExpandToEnclosingUnit", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Text::TextUnit>(args, 0);

                self->obj.ExpandToEnclosingUnit(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider2_FindAttribute(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextRangeProvider", L"FindAttribute", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                return py::convert(self->obj.FindAttribute(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider2_FindText(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextRangeProvider", L"FindText", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                return py::convert(self->obj.FindText(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider2_GetAttributeValue(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextRangeProvider", L"GetAttributeValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.GetAttributeValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider2_GetBoundingRectangles(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextRangeProvider", L"GetBoundingRectangles", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                winrt::com_array<double> param0 { };

                self->obj.GetBoundingRectangles(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider2_GetChildren(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextRangeProvider", L"GetChildren", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetChildren());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider2_GetEnclosingElement(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextRangeProvider", L"GetEnclosingElement", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetEnclosingElement());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider2_GetText(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextRangeProvider", L"GetText", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.GetText(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider2_Move(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextRangeProvider", L"Move", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Text::TextUnit>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.Move(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider2_MoveEndpointByRange(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextRangeProvider", L"MoveEndpointByRange", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Text::TextPatternRangeEndpoint>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Text::TextPatternRangeEndpoint>(args, 2);

                self->obj.MoveEndpointByRange(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider2_MoveEndpointByUnit(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextRangeProvider", L"MoveEndpointByUnit", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Text::TextPatternRangeEndpoint>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Text::TextUnit>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);

                return py::convert(self->obj.MoveEndpointByUnit(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider2_RemoveFromSelection(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextRangeProvider", L"RemoveFromSelection", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.RemoveFromSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider2_ScrollIntoView(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextRangeProvider", L"ScrollIntoView", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.ScrollIntoView(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider2_Select(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextRangeProvider", L"Select", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Select();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITextRangeProvider2_ShowContextMenu(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITextRangeProvider2", L"ShowContextMenu", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ShowContextMenu();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ITextRangeProvider2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ITextRangeProvider2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITextRangeProvider2[] = {
        { "add_to_selection", reinterpret_cast<PyCFunction>(ITextRangeProvider2_AddToSelection), METH_VARARGS, nullptr },
        { "clone", reinterpret_cast<PyCFunction>(ITextRangeProvider2_Clone), METH_VARARGS, nullptr },
        { "compare", reinterpret_cast<PyCFunction>(ITextRangeProvider2_Compare), METH_VARARGS, nullptr },
        { "compare_endpoints", reinterpret_cast<PyCFunction>(ITextRangeProvider2_CompareEndpoints), METH_VARARGS, nullptr },
        { "expand_to_enclosing_unit", reinterpret_cast<PyCFunction>(ITextRangeProvider2_ExpandToEnclosingUnit), METH_VARARGS, nullptr },
        { "find_attribute", reinterpret_cast<PyCFunction>(ITextRangeProvider2_FindAttribute), METH_VARARGS, nullptr },
        { "find_text", reinterpret_cast<PyCFunction>(ITextRangeProvider2_FindText), METH_VARARGS, nullptr },
        { "get_attribute_value", reinterpret_cast<PyCFunction>(ITextRangeProvider2_GetAttributeValue), METH_VARARGS, nullptr },
        { "get_bounding_rectangles", reinterpret_cast<PyCFunction>(ITextRangeProvider2_GetBoundingRectangles), METH_VARARGS, nullptr },
        { "get_children", reinterpret_cast<PyCFunction>(ITextRangeProvider2_GetChildren), METH_VARARGS, nullptr },
        { "get_enclosing_element", reinterpret_cast<PyCFunction>(ITextRangeProvider2_GetEnclosingElement), METH_VARARGS, nullptr },
        { "get_text", reinterpret_cast<PyCFunction>(ITextRangeProvider2_GetText), METH_VARARGS, nullptr },
        { "move", reinterpret_cast<PyCFunction>(ITextRangeProvider2_Move), METH_VARARGS, nullptr },
        { "move_endpoint_by_range", reinterpret_cast<PyCFunction>(ITextRangeProvider2_MoveEndpointByRange), METH_VARARGS, nullptr },
        { "move_endpoint_by_unit", reinterpret_cast<PyCFunction>(ITextRangeProvider2_MoveEndpointByUnit), METH_VARARGS, nullptr },
        { "remove_from_selection", reinterpret_cast<PyCFunction>(ITextRangeProvider2_RemoveFromSelection), METH_VARARGS, nullptr },
        { "scroll_into_view", reinterpret_cast<PyCFunction>(ITextRangeProvider2_ScrollIntoView), METH_VARARGS, nullptr },
        { "select", reinterpret_cast<PyCFunction>(ITextRangeProvider2_Select), METH_VARARGS, nullptr },
        { "show_context_menu", reinterpret_cast<PyCFunction>(ITextRangeProvider2_ShowContextMenu), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ITextRangeProvider2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ITextRangeProvider2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ITextRangeProvider2[] = {
        { }
    };

    static PyType_Slot _type_slots_ITextRangeProvider2[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ITextRangeProvider2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ITextRangeProvider2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ITextRangeProvider2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ITextRangeProvider2) },
        { },
    };

    static PyType_Spec type_spec_ITextRangeProvider2 =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_provider.ITextRangeProvider2",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITextRangeProvider2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITextRangeProvider2
    };

    // ----- IToggleProvider interface --------------------

    static PyObject* _new_IToggleProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IToggleProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IToggleProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IToggleProvider(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IToggleProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IToggleProvider_Toggle(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IToggleProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.IToggleProvider", L"Toggle", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Toggle();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IToggleProvider_get_ToggleState(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IToggleProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IToggleProvider", L"ToggleState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ToggleState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IToggleProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Provider::IToggleProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IToggleProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Provider::IToggleProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IToggleProvider[] = {
        { "toggle", reinterpret_cast<PyCFunction>(IToggleProvider_Toggle), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IToggleProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IToggleProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IToggleProvider[] = {
        { "toggle_state", reinterpret_cast<getter>(IToggleProvider_get_ToggleState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IToggleProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IToggleProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IToggleProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IToggleProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IToggleProvider) },
        { },
    };

    static PyType_Spec type_spec_IToggleProvider =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_provider.IToggleProvider",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IToggleProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IToggleProvider
    };

    // ----- ITransformProvider interface --------------------

    static PyObject* _new_ITransformProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::ITransformProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::ITransformProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_ITransformProvider(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITransformProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ITransformProvider_Move(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITransformProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITransformProvider", L"Move", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.Move(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITransformProvider_Resize(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITransformProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITransformProvider", L"Resize", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.Resize(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITransformProvider_Rotate(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITransformProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITransformProvider", L"Rotate", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                self->obj.Rotate(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITransformProvider_get_CanMove(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITransformProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITransformProvider", L"CanMove"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanMove());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITransformProvider_get_CanResize(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITransformProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITransformProvider", L"CanResize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanResize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITransformProvider_get_CanRotate(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITransformProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITransformProvider", L"CanRotate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanRotate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ITransformProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Provider::ITransformProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ITransformProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Provider::ITransformProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITransformProvider[] = {
        { "move", reinterpret_cast<PyCFunction>(ITransformProvider_Move), METH_VARARGS, nullptr },
        { "resize", reinterpret_cast<PyCFunction>(ITransformProvider_Resize), METH_VARARGS, nullptr },
        { "rotate", reinterpret_cast<PyCFunction>(ITransformProvider_Rotate), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ITransformProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ITransformProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ITransformProvider[] = {
        { "can_move", reinterpret_cast<getter>(ITransformProvider_get_CanMove), nullptr, nullptr, nullptr },
        { "can_resize", reinterpret_cast<getter>(ITransformProvider_get_CanResize), nullptr, nullptr, nullptr },
        { "can_rotate", reinterpret_cast<getter>(ITransformProvider_get_CanRotate), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ITransformProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ITransformProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ITransformProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ITransformProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ITransformProvider) },
        { },
    };

    static PyType_Spec type_spec_ITransformProvider =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_provider.ITransformProvider",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITransformProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITransformProvider
    };

    // ----- ITransformProvider2 interface --------------------

    static PyObject* _new_ITransformProvider2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::ITransformProvider2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::ITransformProvider2>::type_name);
        return nullptr;
    }

    static void _dealloc_ITransformProvider2(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITransformProvider2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ITransformProvider2_Move(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITransformProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITransformProvider", L"Move", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.Move(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITransformProvider2_Resize(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITransformProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITransformProvider", L"Resize", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.Resize(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITransformProvider2_Rotate(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITransformProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITransformProvider", L"Rotate", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                self->obj.Rotate(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITransformProvider2_Zoom(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITransformProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITransformProvider2", L"Zoom", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                self->obj.Zoom(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITransformProvider2_ZoomByUnit(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITransformProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITransformProvider2", L"ZoomByUnit", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::ZoomUnit>(args, 0);

                self->obj.ZoomByUnit(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ITransformProvider2_get_CanZoom(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITransformProvider2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITransformProvider2", L"CanZoom"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanZoom());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITransformProvider2_get_MaxZoom(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITransformProvider2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITransformProvider2", L"MaxZoom"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxZoom());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITransformProvider2_get_MinZoom(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITransformProvider2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITransformProvider2", L"MinZoom"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinZoom());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITransformProvider2_get_ZoomLevel(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITransformProvider2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITransformProvider2", L"ZoomLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ZoomLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITransformProvider2_get_CanMove(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITransformProvider2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITransformProvider", L"CanMove"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanMove());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITransformProvider2_get_CanResize(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITransformProvider2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITransformProvider", L"CanResize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanResize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ITransformProvider2_get_CanRotate(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITransformProvider2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.ITransformProvider", L"CanRotate"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanRotate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ITransformProvider2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Provider::ITransformProvider2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ITransformProvider2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Provider::ITransformProvider2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITransformProvider2[] = {
        { "move", reinterpret_cast<PyCFunction>(ITransformProvider2_Move), METH_VARARGS, nullptr },
        { "resize", reinterpret_cast<PyCFunction>(ITransformProvider2_Resize), METH_VARARGS, nullptr },
        { "rotate", reinterpret_cast<PyCFunction>(ITransformProvider2_Rotate), METH_VARARGS, nullptr },
        { "zoom", reinterpret_cast<PyCFunction>(ITransformProvider2_Zoom), METH_VARARGS, nullptr },
        { "zoom_by_unit", reinterpret_cast<PyCFunction>(ITransformProvider2_ZoomByUnit), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ITransformProvider2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ITransformProvider2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ITransformProvider2[] = {
        { "can_zoom", reinterpret_cast<getter>(ITransformProvider2_get_CanZoom), nullptr, nullptr, nullptr },
        { "max_zoom", reinterpret_cast<getter>(ITransformProvider2_get_MaxZoom), nullptr, nullptr, nullptr },
        { "min_zoom", reinterpret_cast<getter>(ITransformProvider2_get_MinZoom), nullptr, nullptr, nullptr },
        { "zoom_level", reinterpret_cast<getter>(ITransformProvider2_get_ZoomLevel), nullptr, nullptr, nullptr },
        { "can_move", reinterpret_cast<getter>(ITransformProvider2_get_CanMove), nullptr, nullptr, nullptr },
        { "can_resize", reinterpret_cast<getter>(ITransformProvider2_get_CanResize), nullptr, nullptr, nullptr },
        { "can_rotate", reinterpret_cast<getter>(ITransformProvider2_get_CanRotate), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ITransformProvider2[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ITransformProvider2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ITransformProvider2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ITransformProvider2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ITransformProvider2) },
        { },
    };

    static PyType_Spec type_spec_ITransformProvider2 =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_provider.ITransformProvider2",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::ITransformProvider2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITransformProvider2
    };

    // ----- IValueProvider interface --------------------

    static PyObject* _new_IValueProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IValueProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IValueProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IValueProvider(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IValueProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IValueProvider_SetValue(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IValueProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.IValueProvider", L"SetValue", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.SetValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IValueProvider_get_IsReadOnly(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IValueProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IValueProvider", L"IsReadOnly"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IValueProvider_get_Value(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IValueProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IValueProvider", L"Value"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IValueProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Provider::IValueProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IValueProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Provider::IValueProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IValueProvider[] = {
        { "set_value", reinterpret_cast<PyCFunction>(IValueProvider_SetValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IValueProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IValueProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IValueProvider[] = {
        { "is_read_only", reinterpret_cast<getter>(IValueProvider_get_IsReadOnly), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(IValueProvider_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IValueProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IValueProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IValueProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IValueProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IValueProvider) },
        { },
    };

    static PyType_Spec type_spec_IValueProvider =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_provider.IValueProvider",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IValueProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IValueProvider
    };

    // ----- IVirtualizedItemProvider interface --------------------

    static PyObject* _new_IVirtualizedItemProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IVirtualizedItemProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IVirtualizedItemProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IVirtualizedItemProvider(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IVirtualizedItemProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IVirtualizedItemProvider_Realize(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IVirtualizedItemProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.IVirtualizedItemProvider", L"Realize", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Realize();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_IVirtualizedItemProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Provider::IVirtualizedItemProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IVirtualizedItemProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Provider::IVirtualizedItemProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVirtualizedItemProvider[] = {
        { "realize", reinterpret_cast<PyCFunction>(IVirtualizedItemProvider_Realize), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IVirtualizedItemProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IVirtualizedItemProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IVirtualizedItemProvider[] = {
        { }
    };

    static PyType_Slot _type_slots_IVirtualizedItemProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IVirtualizedItemProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IVirtualizedItemProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IVirtualizedItemProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IVirtualizedItemProvider) },
        { },
    };

    static PyType_Spec type_spec_IVirtualizedItemProvider =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_provider.IVirtualizedItemProvider",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IVirtualizedItemProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVirtualizedItemProvider
    };

    // ----- IWindowProvider interface --------------------

    static PyObject* _new_IWindowProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IWindowProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Provider::IWindowProvider>::type_name);
        return nullptr;
    }

    static void _dealloc_IWindowProvider(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IWindowProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWindowProvider_Close(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IWindowProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.IWindowProvider", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWindowProvider_SetVisualState(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IWindowProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.IWindowProvider", L"SetVisualState", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::WindowVisualState>(args, 0);

                self->obj.SetVisualState(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWindowProvider_WaitForInputIdle(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IWindowProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Provider.IWindowProvider", L"WaitForInputIdle", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.WaitForInputIdle(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWindowProvider_get_InteractionState(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IWindowProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IWindowProvider", L"InteractionState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InteractionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWindowProvider_get_IsModal(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IWindowProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IWindowProvider", L"IsModal"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsModal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWindowProvider_get_IsTopmost(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IWindowProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IWindowProvider", L"IsTopmost"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsTopmost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWindowProvider_get_Maximizable(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IWindowProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IWindowProvider", L"Maximizable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Maximizable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWindowProvider_get_Minimizable(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IWindowProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IWindowProvider", L"Minimizable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Minimizable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWindowProvider_get_VisualState(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IWindowProvider* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Provider.IWindowProvider", L"VisualState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VisualState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IWindowProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Provider::IWindowProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWindowProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Provider::IWindowProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWindowProvider[] = {
        { "close", reinterpret_cast<PyCFunction>(IWindowProvider_Close), METH_VARARGS, nullptr },
        { "set_visual_state", reinterpret_cast<PyCFunction>(IWindowProvider_SetVisualState), METH_VARARGS, nullptr },
        { "wait_for_input_idle", reinterpret_cast<PyCFunction>(IWindowProvider_WaitForInputIdle), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IWindowProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWindowProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IWindowProvider[] = {
        { "interaction_state", reinterpret_cast<getter>(IWindowProvider_get_InteractionState), nullptr, nullptr, nullptr },
        { "is_modal", reinterpret_cast<getter>(IWindowProvider_get_IsModal), nullptr, nullptr, nullptr },
        { "is_topmost", reinterpret_cast<getter>(IWindowProvider_get_IsTopmost), nullptr, nullptr, nullptr },
        { "maximizable", reinterpret_cast<getter>(IWindowProvider_get_Maximizable), nullptr, nullptr, nullptr },
        { "minimizable", reinterpret_cast<getter>(IWindowProvider_get_Minimizable), nullptr, nullptr, nullptr },
        { "visual_state", reinterpret_cast<getter>(IWindowProvider_get_VisualState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IWindowProvider[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IWindowProvider) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWindowProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWindowProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWindowProvider) },
        { },
    };

    static PyType_Spec type_spec_IWindowProvider =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_provider.IWindowProvider",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Provider::IWindowProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWindowProvider
    };

    // ----- Microsoft.UI.Xaml.Automation.Provider Initialization --------------------
    PyDoc_STRVAR(module_doc, "Microsoft::UI::Xaml::Automation::Provider");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_microsoft_ui_xaml_automation_provider",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Microsoft::UI::Xaml::Automation::Provider

PyMODINIT_FUNC PyInit__winrt_microsoft_ui_xaml_automation_provider(void) noexcept
{
    using namespace py::cpp::Microsoft::UI::Xaml::Automation::Provider;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IRawElementProviderSimple, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IAnnotationProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ICustomNavigationProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IDockProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IDragProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IDropTargetProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IExpandCollapseProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IGridItemProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IGridProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IInvokeProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IItemContainerProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IMultipleViewProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IObjectModelProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IRangeValueProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IScrollItemProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IScrollProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ISelectionItemProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ISelectionProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ISpreadsheetItemProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ISpreadsheetProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IStylesProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ISynchronizedInputProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ITableItemProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ITableProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ITextChildProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ITextEditProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ITextProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ITextProvider2, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ITextRangeProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ITextRangeProvider2, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IToggleProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ITransformProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ITransformProvider2, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IValueProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IVirtualizedItemProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IWindowProvider, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
