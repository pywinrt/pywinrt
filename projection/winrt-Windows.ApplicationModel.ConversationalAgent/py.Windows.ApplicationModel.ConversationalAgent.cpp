// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.1

#include "py.Windows.ApplicationModel.ConversationalAgent.h"


namespace py::cpp::Windows::ApplicationModel::ConversationalAgent
{
    // ----- ActivationSignalDetectionConfiguration class --------------------

    static PyObject* _new_ActivationSignalDetectionConfiguration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration>::type_name);
        return nullptr;
    }

    static void _dealloc_ActivationSignalDetectionConfiguration(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ActivationSignalDetectionConfiguration_ApplyTrainingData(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetectionConfiguration", L"ApplyTrainingData", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionTrainingDataFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 1);

                return py::convert(self->obj.ApplyTrainingData(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_ApplyTrainingDataAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetectionConfiguration", L"ApplyTrainingDataAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionTrainingDataFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 1);

                return py::convert(self->obj.ApplyTrainingDataAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_ClearModelData(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetectionConfiguration", L"ClearModelData", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ClearModelData();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_ClearModelDataAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetectionConfiguration", L"ClearModelDataAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ClearModelDataAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_ClearTrainingData(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetectionConfiguration", L"ClearTrainingData", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ClearTrainingData();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_ClearTrainingDataAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetectionConfiguration", L"ClearTrainingDataAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.ClearTrainingDataAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_Close(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetectionConfiguration", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_GetModelData(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetectionConfiguration", L"GetModelData", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetModelData());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_GetModelDataAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetectionConfiguration", L"GetModelDataAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetModelDataAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_GetModelDataType(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetectionConfiguration", L"GetModelDataType", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetModelDataType());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_GetModelDataTypeAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetectionConfiguration", L"GetModelDataTypeAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetModelDataTypeAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_SetEnabled(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetectionConfiguration", L"SetEnabled", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.SetEnabled(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_SetEnabledAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetectionConfiguration", L"SetEnabledAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.SetEnabledAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_SetEnabledWithResult(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetectionConfiguration", L"SetEnabledWithResult", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.SetEnabledWithResult(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_SetEnabledWithResultAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetectionConfiguration", L"SetEnabledWithResultAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.SetEnabledWithResultAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_SetModelData(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetectionConfiguration", L"SetModelData", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 1);

                self->obj.SetModelData(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_SetModelDataAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetectionConfiguration", L"SetModelDataAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 1);

                return py::convert(self->obj.SetModelDataAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_SetModelDataWithResult(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetectionConfiguration", L"SetModelDataWithResult", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 1);

                return py::convert(self->obj.SetModelDataWithResult(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_SetModelDataWithResultAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetectionConfiguration", L"SetModelDataWithResultAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 1);

                return py::convert(self->obj.SetModelDataWithResultAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_get_AvailabilityInfo(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetectionConfiguration", L"AvailabilityInfo"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AvailabilityInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_get_DisplayName(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetectionConfiguration", L"DisplayName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_get_IsActive(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetectionConfiguration", L"IsActive"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsActive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_get_ModelId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetectionConfiguration", L"ModelId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ModelId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_get_SignalId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetectionConfiguration", L"SignalId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SignalId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_get_TrainingDataFormat(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetectionConfiguration", L"TrainingDataFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TrainingDataFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_get_TrainingStepsCompleted(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetectionConfiguration", L"TrainingStepsCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TrainingStepsCompleted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_get_TrainingStepsRemaining(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetectionConfiguration", L"TrainingStepsRemaining"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TrainingStepsRemaining());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_get_TrainingStepCompletionMaxAllowedTime(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetectionConfiguration", L"TrainingStepCompletionMaxAllowedTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.TrainingStepCompletionMaxAllowedTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_add_AvailabilityChanged(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetectionConfiguration", L"AvailabilityChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration, winrt::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityChangedEventArgs>>(arg);

            return py::convert(self->obj.AvailabilityChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_remove_AvailabilityChanged(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetectionConfiguration", L"AvailabilityChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AvailabilityChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ActivationSignalDetectionConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ActivationSignalDetectionConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ActivationSignalDetectionConfiguration(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_ActivationSignalDetectionConfiguration(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActivationSignalDetectionConfiguration[] = {
        { "apply_training_data", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_ApplyTrainingData), METH_VARARGS, nullptr },
        { "apply_training_data_async", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_ApplyTrainingDataAsync), METH_VARARGS, nullptr },
        { "clear_model_data", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_ClearModelData), METH_VARARGS, nullptr },
        { "clear_model_data_async", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_ClearModelDataAsync), METH_VARARGS, nullptr },
        { "clear_training_data", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_ClearTrainingData), METH_VARARGS, nullptr },
        { "clear_training_data_async", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_ClearTrainingDataAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_Close), METH_VARARGS, nullptr },
        { "get_model_data", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_GetModelData), METH_VARARGS, nullptr },
        { "get_model_data_async", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_GetModelDataAsync), METH_VARARGS, nullptr },
        { "get_model_data_type", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_GetModelDataType), METH_VARARGS, nullptr },
        { "get_model_data_type_async", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_GetModelDataTypeAsync), METH_VARARGS, nullptr },
        { "set_enabled", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_SetEnabled), METH_VARARGS, nullptr },
        { "set_enabled_async", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_SetEnabledAsync), METH_VARARGS, nullptr },
        { "set_enabled_with_result", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_SetEnabledWithResult), METH_VARARGS, nullptr },
        { "set_enabled_with_result_async", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_SetEnabledWithResultAsync), METH_VARARGS, nullptr },
        { "set_model_data", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_SetModelData), METH_VARARGS, nullptr },
        { "set_model_data_async", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_SetModelDataAsync), METH_VARARGS, nullptr },
        { "set_model_data_with_result", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_SetModelDataWithResult), METH_VARARGS, nullptr },
        { "set_model_data_with_result_async", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_SetModelDataWithResultAsync), METH_VARARGS, nullptr },
        { "add_availability_changed", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_add_AvailabilityChanged), METH_O, nullptr },
        { "remove_availability_changed", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_remove_AvailabilityChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ActivationSignalDetectionConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ActivationSignalDetectionConfiguration), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ActivationSignalDetectionConfiguration), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_ActivationSignalDetectionConfiguration), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ActivationSignalDetectionConfiguration[] = {
        { "availability_info", reinterpret_cast<getter>(ActivationSignalDetectionConfiguration_get_AvailabilityInfo), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(ActivationSignalDetectionConfiguration_get_DisplayName), nullptr, nullptr, nullptr },
        { "is_active", reinterpret_cast<getter>(ActivationSignalDetectionConfiguration_get_IsActive), nullptr, nullptr, nullptr },
        { "model_id", reinterpret_cast<getter>(ActivationSignalDetectionConfiguration_get_ModelId), nullptr, nullptr, nullptr },
        { "signal_id", reinterpret_cast<getter>(ActivationSignalDetectionConfiguration_get_SignalId), nullptr, nullptr, nullptr },
        { "training_data_format", reinterpret_cast<getter>(ActivationSignalDetectionConfiguration_get_TrainingDataFormat), nullptr, nullptr, nullptr },
        { "training_steps_completed", reinterpret_cast<getter>(ActivationSignalDetectionConfiguration_get_TrainingStepsCompleted), nullptr, nullptr, nullptr },
        { "training_steps_remaining", reinterpret_cast<getter>(ActivationSignalDetectionConfiguration_get_TrainingStepsRemaining), nullptr, nullptr, nullptr },
        { "training_step_completion_max_allowed_time", reinterpret_cast<getter>(ActivationSignalDetectionConfiguration_get_TrainingStepCompletionMaxAllowedTime), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ActivationSignalDetectionConfiguration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ActivationSignalDetectionConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ActivationSignalDetectionConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ActivationSignalDetectionConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ActivationSignalDetectionConfiguration) },
        { },
    };

    static PyType_Spec type_spec_ActivationSignalDetectionConfiguration =
    {
        "winrt._winrt_windows_applicationmodel_conversationalagent.ActivationSignalDetectionConfiguration",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ActivationSignalDetectionConfiguration
    };

    // ----- ActivationSignalDetectionConfigurationCreationResult class --------------------

    static PyObject* _new_ActivationSignalDetectionConfigurationCreationResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfigurationCreationResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfigurationCreationResult>::type_name);
        return nullptr;
    }

    static void _dealloc_ActivationSignalDetectionConfigurationCreationResult(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfigurationCreationResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ActivationSignalDetectionConfigurationCreationResult_get_Configuration(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfigurationCreationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetectionConfigurationCreationResult", L"Configuration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Configuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfigurationCreationResult_get_Status(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfigurationCreationResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetectionConfigurationCreationResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ActivationSignalDetectionConfigurationCreationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfigurationCreationResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ActivationSignalDetectionConfigurationCreationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfigurationCreationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActivationSignalDetectionConfigurationCreationResult[] = {
        { "_assign_array_", _assign_array_ActivationSignalDetectionConfigurationCreationResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ActivationSignalDetectionConfigurationCreationResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ActivationSignalDetectionConfigurationCreationResult[] = {
        { "configuration", reinterpret_cast<getter>(ActivationSignalDetectionConfigurationCreationResult_get_Configuration), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(ActivationSignalDetectionConfigurationCreationResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ActivationSignalDetectionConfigurationCreationResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ActivationSignalDetectionConfigurationCreationResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ActivationSignalDetectionConfigurationCreationResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ActivationSignalDetectionConfigurationCreationResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ActivationSignalDetectionConfigurationCreationResult) },
        { },
    };

    static PyType_Spec type_spec_ActivationSignalDetectionConfigurationCreationResult =
    {
        "winrt._winrt_windows_applicationmodel_conversationalagent.ActivationSignalDetectionConfigurationCreationResult",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfigurationCreationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ActivationSignalDetectionConfigurationCreationResult
    };

    // ----- ActivationSignalDetector class --------------------

    static PyObject* _new_ActivationSignalDetector(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector>::type_name);
        return nullptr;
    }

    static void _dealloc_ActivationSignalDetector(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ActivationSignalDetector_CreateConfiguration(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetector", L"CreateConfiguration", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                self->obj.CreateConfiguration(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_CreateConfigurationAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetector", L"CreateConfigurationAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.CreateConfigurationAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_CreateConfigurationWithResult(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetector", L"CreateConfigurationWithResult", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.CreateConfigurationWithResult(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_CreateConfigurationWithResultAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetector", L"CreateConfigurationWithResultAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.CreateConfigurationWithResultAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_GetAvailableModelIdsForSignalId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetector", L"GetAvailableModelIdsForSignalId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetAvailableModelIdsForSignalId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_GetAvailableModelIdsForSignalIdAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetector", L"GetAvailableModelIdsForSignalIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetAvailableModelIdsForSignalIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_GetConfiguration(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetector", L"GetConfiguration", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.GetConfiguration(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_GetConfigurationAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetector", L"GetConfigurationAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.GetConfigurationAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_GetConfigurations(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetector", L"GetConfigurations", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetConfigurations());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_GetConfigurationsAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetector", L"GetConfigurationsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetConfigurationsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_GetSupportedModelIdsForSignalId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetector", L"GetSupportedModelIdsForSignalId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetSupportedModelIdsForSignalId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_GetSupportedModelIdsForSignalIdAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetector", L"GetSupportedModelIdsForSignalIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetSupportedModelIdsForSignalIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_RemoveConfiguration(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetector", L"RemoveConfiguration", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.RemoveConfiguration(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_RemoveConfigurationAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetector", L"RemoveConfigurationAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.RemoveConfigurationAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_RemoveConfigurationWithResult(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetector", L"RemoveConfigurationWithResult", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.RemoveConfigurationWithResult(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_RemoveConfigurationWithResultAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetector", L"RemoveConfigurationWithResultAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.RemoveConfigurationWithResultAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_get_CanCreateConfigurations(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetector", L"CanCreateConfigurations"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CanCreateConfigurations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_get_Kind(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetector", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_get_ProviderId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetector", L"ProviderId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_get_SupportedModelDataTypes(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetector", L"SupportedModelDataTypes"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedModelDataTypes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_get_SupportedPowerStates(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetector", L"SupportedPowerStates"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedPowerStates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_get_SupportedTrainingDataFormats(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetector", L"SupportedTrainingDataFormats"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SupportedTrainingDataFormats());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_get_DetectorId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ActivationSignalDetector", L"DetectorId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DetectorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ActivationSignalDetector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ActivationSignalDetector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActivationSignalDetector[] = {
        { "create_configuration", reinterpret_cast<PyCFunction>(ActivationSignalDetector_CreateConfiguration), METH_VARARGS, nullptr },
        { "create_configuration_async", reinterpret_cast<PyCFunction>(ActivationSignalDetector_CreateConfigurationAsync), METH_VARARGS, nullptr },
        { "create_configuration_with_result", reinterpret_cast<PyCFunction>(ActivationSignalDetector_CreateConfigurationWithResult), METH_VARARGS, nullptr },
        { "create_configuration_with_result_async", reinterpret_cast<PyCFunction>(ActivationSignalDetector_CreateConfigurationWithResultAsync), METH_VARARGS, nullptr },
        { "get_available_model_ids_for_signal_id", reinterpret_cast<PyCFunction>(ActivationSignalDetector_GetAvailableModelIdsForSignalId), METH_VARARGS, nullptr },
        { "get_available_model_ids_for_signal_id_async", reinterpret_cast<PyCFunction>(ActivationSignalDetector_GetAvailableModelIdsForSignalIdAsync), METH_VARARGS, nullptr },
        { "get_configuration", reinterpret_cast<PyCFunction>(ActivationSignalDetector_GetConfiguration), METH_VARARGS, nullptr },
        { "get_configuration_async", reinterpret_cast<PyCFunction>(ActivationSignalDetector_GetConfigurationAsync), METH_VARARGS, nullptr },
        { "get_configurations", reinterpret_cast<PyCFunction>(ActivationSignalDetector_GetConfigurations), METH_VARARGS, nullptr },
        { "get_configurations_async", reinterpret_cast<PyCFunction>(ActivationSignalDetector_GetConfigurationsAsync), METH_VARARGS, nullptr },
        { "get_supported_model_ids_for_signal_id", reinterpret_cast<PyCFunction>(ActivationSignalDetector_GetSupportedModelIdsForSignalId), METH_VARARGS, nullptr },
        { "get_supported_model_ids_for_signal_id_async", reinterpret_cast<PyCFunction>(ActivationSignalDetector_GetSupportedModelIdsForSignalIdAsync), METH_VARARGS, nullptr },
        { "remove_configuration", reinterpret_cast<PyCFunction>(ActivationSignalDetector_RemoveConfiguration), METH_VARARGS, nullptr },
        { "remove_configuration_async", reinterpret_cast<PyCFunction>(ActivationSignalDetector_RemoveConfigurationAsync), METH_VARARGS, nullptr },
        { "remove_configuration_with_result", reinterpret_cast<PyCFunction>(ActivationSignalDetector_RemoveConfigurationWithResult), METH_VARARGS, nullptr },
        { "remove_configuration_with_result_async", reinterpret_cast<PyCFunction>(ActivationSignalDetector_RemoveConfigurationWithResultAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ActivationSignalDetector, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ActivationSignalDetector), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ActivationSignalDetector[] = {
        { "can_create_configurations", reinterpret_cast<getter>(ActivationSignalDetector_get_CanCreateConfigurations), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ActivationSignalDetector_get_Kind), nullptr, nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(ActivationSignalDetector_get_ProviderId), nullptr, nullptr, nullptr },
        { "supported_model_data_types", reinterpret_cast<getter>(ActivationSignalDetector_get_SupportedModelDataTypes), nullptr, nullptr, nullptr },
        { "supported_power_states", reinterpret_cast<getter>(ActivationSignalDetector_get_SupportedPowerStates), nullptr, nullptr, nullptr },
        { "supported_training_data_formats", reinterpret_cast<getter>(ActivationSignalDetector_get_SupportedTrainingDataFormats), nullptr, nullptr, nullptr },
        { "detector_id", reinterpret_cast<getter>(ActivationSignalDetector_get_DetectorId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ActivationSignalDetector[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ActivationSignalDetector) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ActivationSignalDetector) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ActivationSignalDetector) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ActivationSignalDetector) },
        { },
    };

    static PyType_Spec type_spec_ActivationSignalDetector =
    {
        "winrt._winrt_windows_applicationmodel_conversationalagent.ActivationSignalDetector",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ActivationSignalDetector
    };

    // ----- ConversationalAgentDetectorManager class --------------------

    static PyObject* _new_ConversationalAgentDetectorManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager>::type_name);
        return nullptr;
    }

    static void _dealloc_ConversationalAgentDetectorManager(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ConversationalAgentDetectorManager_GetActivationSignalDetectorFromId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentDetectorManager", L"GetActivationSignalDetectorFromId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetActivationSignalDetectorFromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentDetectorManager_GetActivationSignalDetectorFromIdAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentDetectorManager", L"GetActivationSignalDetectorFromIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetActivationSignalDetectorFromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentDetectorManager_GetActivationSignalDetectors(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentDetectorManager", L"GetActivationSignalDetectors", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectorKind>(args, 0);

                return py::convert(self->obj.GetActivationSignalDetectors(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentDetectorManager_GetActivationSignalDetectorsAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentDetectorManager", L"GetActivationSignalDetectorsAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectorKind>(args, 0);

                return py::convert(self->obj.GetActivationSignalDetectorsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentDetectorManager_GetAllActivationSignalDetectors(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentDetectorManager", L"GetAllActivationSignalDetectors", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAllActivationSignalDetectors());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentDetectorManager_GetAllActivationSignalDetectorsAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentDetectorManager", L"GetAllActivationSignalDetectorsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAllActivationSignalDetectorsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentDetectorManager_get_Default(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentDetectorManager", L"Default"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager::Default());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ConversationalAgentDetectorManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ConversationalAgentDetectorManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConversationalAgentDetectorManager[] = {
        { "get_activation_signal_detector_from_id", reinterpret_cast<PyCFunction>(ConversationalAgentDetectorManager_GetActivationSignalDetectorFromId), METH_VARARGS, nullptr },
        { "get_activation_signal_detector_from_id_async", reinterpret_cast<PyCFunction>(ConversationalAgentDetectorManager_GetActivationSignalDetectorFromIdAsync), METH_VARARGS, nullptr },
        { "get_activation_signal_detectors", reinterpret_cast<PyCFunction>(ConversationalAgentDetectorManager_GetActivationSignalDetectors), METH_VARARGS, nullptr },
        { "get_activation_signal_detectors_async", reinterpret_cast<PyCFunction>(ConversationalAgentDetectorManager_GetActivationSignalDetectorsAsync), METH_VARARGS, nullptr },
        { "get_all_activation_signal_detectors", reinterpret_cast<PyCFunction>(ConversationalAgentDetectorManager_GetAllActivationSignalDetectors), METH_VARARGS, nullptr },
        { "get_all_activation_signal_detectors_async", reinterpret_cast<PyCFunction>(ConversationalAgentDetectorManager_GetAllActivationSignalDetectorsAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ConversationalAgentDetectorManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ConversationalAgentDetectorManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConversationalAgentDetectorManager[] = {
        { }
    };

    static PyType_Slot _type_slots_ConversationalAgentDetectorManager[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ConversationalAgentDetectorManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ConversationalAgentDetectorManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ConversationalAgentDetectorManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ConversationalAgentDetectorManager) },
        { },
    };

    static PyType_Spec type_spec_ConversationalAgentDetectorManager =
    {
        "winrt._winrt_windows_applicationmodel_conversationalagent.ConversationalAgentDetectorManager",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConversationalAgentDetectorManager
    };

    static PyGetSetDef getset_ConversationalAgentDetectorManager_Static[] = {
        { "default", reinterpret_cast<getter>(ConversationalAgentDetectorManager_get_Default), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_ConversationalAgentDetectorManager_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ConversationalAgentDetectorManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ConversationalAgentDetectorManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ConversationalAgentDetectorManager_Static) },
        { }
    };

    static PyType_Spec type_spec_ConversationalAgentDetectorManager_Static =
    {
        "winrt._winrt_windows_applicationmodel_conversationalagent.ConversationalAgentDetectorManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ConversationalAgentDetectorManager_Static
    };

    // ----- ConversationalAgentSession class --------------------

    static PyObject* _new_ConversationalAgentSession(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession>::type_name);
        return nullptr;
    }

    static void _dealloc_ConversationalAgentSession(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ConversationalAgentSession_Close(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_CreateAudioDeviceInputNode(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"CreateAudioDeviceInputNode", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioGraph>(args, 0);

                return py::convert(self->obj.CreateAudioDeviceInputNode(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_CreateAudioDeviceInputNodeAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"CreateAudioDeviceInputNodeAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioGraph>(args, 0);

                return py::convert(self->obj.CreateAudioDeviceInputNodeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetAudioCaptureDeviceId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"GetAudioCaptureDeviceId", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAudioCaptureDeviceId());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetAudioCaptureDeviceIdAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"GetAudioCaptureDeviceIdAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAudioCaptureDeviceIdAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetAudioClient(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"GetAudioClient", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAudioClient());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetAudioClientAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"GetAudioClientAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAudioClientAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetAudioRenderDeviceId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"GetAudioRenderDeviceId", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAudioRenderDeviceId());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetAudioRenderDeviceIdAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"GetAudioRenderDeviceIdAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetAudioRenderDeviceIdAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetCurrentSessionAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"GetCurrentSessionAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession::GetCurrentSessionAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetCurrentSessionSync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"GetCurrentSessionSync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession::GetCurrentSessionSync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetMissingPrerequisites(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"GetMissingPrerequisites", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetMissingPrerequisites());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetMissingPrerequisitesAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"GetMissingPrerequisitesAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetMissingPrerequisitesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetSignalModelId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"GetSignalModelId", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetSignalModelId());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetSignalModelIdAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"GetSignalModelIdAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetSignalModelIdAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetSupportedSignalModelIds(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"GetSupportedSignalModelIds", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetSupportedSignalModelIds());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetSupportedSignalModelIdsAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"GetSupportedSignalModelIdsAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetSupportedSignalModelIdsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_RequestActivation(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"RequestActivation", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentActivationKind>(args, 0);

                return py::convert(self->obj.RequestActivation(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_RequestActivationAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"RequestActivationAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentActivationKind>(args, 0);

                return py::convert(self->obj.RequestActivationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_RequestAgentStateChange(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"RequestAgentStateChange", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentState>(args, 0);

                return py::convert(self->obj.RequestAgentStateChange(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_RequestAgentStateChangeAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"RequestAgentStateChangeAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentState>(args, 0);

                return py::convert(self->obj.RequestAgentStateChangeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_RequestForegroundActivation(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"RequestForegroundActivation", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.RequestForegroundActivation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_RequestForegroundActivationAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"RequestForegroundActivationAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.RequestForegroundActivationAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_RequestInterruptible(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"RequestInterruptible", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.RequestInterruptible(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_RequestInterruptibleAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"RequestInterruptibleAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.RequestInterruptibleAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_SetSignalModelId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"SetSignalModelId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.SetSignalModelId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_SetSignalModelIdAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"SetSignalModelIdAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.SetSignalModelIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_SetSupportLockScreenActivation(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"SetSupportLockScreenActivation", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.SetSupportLockScreenActivation(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_SetSupportLockScreenActivationAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"SetSupportLockScreenActivationAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.SetSupportLockScreenActivationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_get_AgentState(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"AgentState"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AgentState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_get_IsIndicatorLightAvailable(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"IsIndicatorLightAvailable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsIndicatorLightAvailable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_get_IsInterrupted(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"IsInterrupted"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsInterrupted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_get_IsInterruptible(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"IsInterruptible"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsInterruptible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_get_IsScreenAvailable(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"IsScreenAvailable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsScreenAvailable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_get_IsUserAuthenticated(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"IsUserAuthenticated"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsUserAuthenticated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_get_IsVoiceActivationAvailable(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"IsVoiceActivationAvailable"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsVoiceActivationAvailable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_get_Signal(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"Signal"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Signal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_add_SessionInterrupted(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"SessionInterrupted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession, winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSessionInterruptedEventArgs>>(arg);

            return py::convert(self->obj.SessionInterrupted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_remove_SessionInterrupted(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"SessionInterrupted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SessionInterrupted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_add_SignalDetected(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"SignalDetected"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession, winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignalDetectedEventArgs>>(arg);

            return py::convert(self->obj.SignalDetected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_remove_SignalDetected(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"SignalDetected"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SignalDetected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_add_SystemStateChanged(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"SystemStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession, winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSystemStateChangedEventArgs>>(arg);

            return py::convert(self->obj.SystemStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_remove_SystemStateChanged(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSession", L"SystemStateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SystemStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ConversationalAgentSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ConversationalAgentSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ConversationalAgentSession(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_ConversationalAgentSession(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConversationalAgentSession[] = {
        { "close", reinterpret_cast<PyCFunction>(ConversationalAgentSession_Close), METH_VARARGS, nullptr },
        { "create_audio_device_input_node", reinterpret_cast<PyCFunction>(ConversationalAgentSession_CreateAudioDeviceInputNode), METH_VARARGS, nullptr },
        { "create_audio_device_input_node_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_CreateAudioDeviceInputNodeAsync), METH_VARARGS, nullptr },
        { "get_audio_capture_device_id", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetAudioCaptureDeviceId), METH_VARARGS, nullptr },
        { "get_audio_capture_device_id_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetAudioCaptureDeviceIdAsync), METH_VARARGS, nullptr },
        { "get_audio_client", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetAudioClient), METH_VARARGS, nullptr },
        { "get_audio_client_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetAudioClientAsync), METH_VARARGS, nullptr },
        { "get_audio_render_device_id", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetAudioRenderDeviceId), METH_VARARGS, nullptr },
        { "get_audio_render_device_id_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetAudioRenderDeviceIdAsync), METH_VARARGS, nullptr },
        { "get_missing_prerequisites", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetMissingPrerequisites), METH_VARARGS, nullptr },
        { "get_missing_prerequisites_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetMissingPrerequisitesAsync), METH_VARARGS, nullptr },
        { "get_signal_model_id", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetSignalModelId), METH_VARARGS, nullptr },
        { "get_signal_model_id_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetSignalModelIdAsync), METH_VARARGS, nullptr },
        { "get_supported_signal_model_ids", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetSupportedSignalModelIds), METH_VARARGS, nullptr },
        { "get_supported_signal_model_ids_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetSupportedSignalModelIdsAsync), METH_VARARGS, nullptr },
        { "request_activation", reinterpret_cast<PyCFunction>(ConversationalAgentSession_RequestActivation), METH_VARARGS, nullptr },
        { "request_activation_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_RequestActivationAsync), METH_VARARGS, nullptr },
        { "request_agent_state_change", reinterpret_cast<PyCFunction>(ConversationalAgentSession_RequestAgentStateChange), METH_VARARGS, nullptr },
        { "request_agent_state_change_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_RequestAgentStateChangeAsync), METH_VARARGS, nullptr },
        { "request_foreground_activation", reinterpret_cast<PyCFunction>(ConversationalAgentSession_RequestForegroundActivation), METH_VARARGS, nullptr },
        { "request_foreground_activation_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_RequestForegroundActivationAsync), METH_VARARGS, nullptr },
        { "request_interruptible", reinterpret_cast<PyCFunction>(ConversationalAgentSession_RequestInterruptible), METH_VARARGS, nullptr },
        { "request_interruptible_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_RequestInterruptibleAsync), METH_VARARGS, nullptr },
        { "set_signal_model_id", reinterpret_cast<PyCFunction>(ConversationalAgentSession_SetSignalModelId), METH_VARARGS, nullptr },
        { "set_signal_model_id_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_SetSignalModelIdAsync), METH_VARARGS, nullptr },
        { "set_support_lock_screen_activation", reinterpret_cast<PyCFunction>(ConversationalAgentSession_SetSupportLockScreenActivation), METH_VARARGS, nullptr },
        { "set_support_lock_screen_activation_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_SetSupportLockScreenActivationAsync), METH_VARARGS, nullptr },
        { "add_session_interrupted", reinterpret_cast<PyCFunction>(ConversationalAgentSession_add_SessionInterrupted), METH_O, nullptr },
        { "remove_session_interrupted", reinterpret_cast<PyCFunction>(ConversationalAgentSession_remove_SessionInterrupted), METH_O, nullptr },
        { "add_signal_detected", reinterpret_cast<PyCFunction>(ConversationalAgentSession_add_SignalDetected), METH_O, nullptr },
        { "remove_signal_detected", reinterpret_cast<PyCFunction>(ConversationalAgentSession_remove_SignalDetected), METH_O, nullptr },
        { "add_system_state_changed", reinterpret_cast<PyCFunction>(ConversationalAgentSession_add_SystemStateChanged), METH_O, nullptr },
        { "remove_system_state_changed", reinterpret_cast<PyCFunction>(ConversationalAgentSession_remove_SystemStateChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_ConversationalAgentSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ConversationalAgentSession), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ConversationalAgentSession), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_ConversationalAgentSession), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConversationalAgentSession[] = {
        { "agent_state", reinterpret_cast<getter>(ConversationalAgentSession_get_AgentState), nullptr, nullptr, nullptr },
        { "is_indicator_light_available", reinterpret_cast<getter>(ConversationalAgentSession_get_IsIndicatorLightAvailable), nullptr, nullptr, nullptr },
        { "is_interrupted", reinterpret_cast<getter>(ConversationalAgentSession_get_IsInterrupted), nullptr, nullptr, nullptr },
        { "is_interruptible", reinterpret_cast<getter>(ConversationalAgentSession_get_IsInterruptible), nullptr, nullptr, nullptr },
        { "is_screen_available", reinterpret_cast<getter>(ConversationalAgentSession_get_IsScreenAvailable), nullptr, nullptr, nullptr },
        { "is_user_authenticated", reinterpret_cast<getter>(ConversationalAgentSession_get_IsUserAuthenticated), nullptr, nullptr, nullptr },
        { "is_voice_activation_available", reinterpret_cast<getter>(ConversationalAgentSession_get_IsVoiceActivationAvailable), nullptr, nullptr, nullptr },
        { "signal", reinterpret_cast<getter>(ConversationalAgentSession_get_Signal), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ConversationalAgentSession[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ConversationalAgentSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ConversationalAgentSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ConversationalAgentSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ConversationalAgentSession) },
        { },
    };

    static PyType_Spec type_spec_ConversationalAgentSession =
    {
        "winrt._winrt_windows_applicationmodel_conversationalagent.ConversationalAgentSession",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConversationalAgentSession
    };

    static PyGetSetDef getset_ConversationalAgentSession_Static[] = {
        { }
    };

    static PyMethodDef methods_ConversationalAgentSession_Static[] = {
        { "get_current_session_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetCurrentSessionAsync), METH_VARARGS, nullptr },
        { "get_current_session_sync", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetCurrentSessionSync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_ConversationalAgentSession_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ConversationalAgentSession_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ConversationalAgentSession_Static) },
        { }
    };

    static PyType_Spec type_spec_ConversationalAgentSession_Static =
    {
        "winrt._winrt_windows_applicationmodel_conversationalagent.ConversationalAgentSession_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ConversationalAgentSession_Static
    };

    // ----- ConversationalAgentSessionInterruptedEventArgs class --------------------

    static PyObject* _new_ConversationalAgentSessionInterruptedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSessionInterruptedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSessionInterruptedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ConversationalAgentSessionInterruptedEventArgs(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSessionInterruptedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ConversationalAgentSessionInterruptedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSessionInterruptedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ConversationalAgentSessionInterruptedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSessionInterruptedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConversationalAgentSessionInterruptedEventArgs[] = {
        { "_assign_array_", _assign_array_ConversationalAgentSessionInterruptedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ConversationalAgentSessionInterruptedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConversationalAgentSessionInterruptedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_ConversationalAgentSessionInterruptedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ConversationalAgentSessionInterruptedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ConversationalAgentSessionInterruptedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ConversationalAgentSessionInterruptedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ConversationalAgentSessionInterruptedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ConversationalAgentSessionInterruptedEventArgs =
    {
        "winrt._winrt_windows_applicationmodel_conversationalagent.ConversationalAgentSessionInterruptedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSessionInterruptedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConversationalAgentSessionInterruptedEventArgs
    };

    // ----- ConversationalAgentSignal class --------------------

    static PyObject* _new_ConversationalAgentSignal(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal>::type_name);
        return nullptr;
    }

    static void _dealloc_ConversationalAgentSignal(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ConversationalAgentSignal_get_SignalStart(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSignal", L"SignalStart"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SignalStart());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConversationalAgentSignal_put_SignalStart(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSignal", L"SignalStart"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.SignalStart(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConversationalAgentSignal_get_SignalName(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSignal", L"SignalName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SignalName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConversationalAgentSignal_put_SignalName(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSignal", L"SignalName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SignalName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConversationalAgentSignal_get_SignalId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSignal", L"SignalId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SignalId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConversationalAgentSignal_put_SignalId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSignal", L"SignalId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SignalId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConversationalAgentSignal_get_SignalEnd(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSignal", L"SignalEnd"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SignalEnd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConversationalAgentSignal_put_SignalEnd(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSignal", L"SignalEnd"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.SignalEnd(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConversationalAgentSignal_get_SignalContext(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSignal", L"SignalContext"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SignalContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConversationalAgentSignal_put_SignalContext(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSignal", L"SignalContext"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.SignalContext(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConversationalAgentSignal_get_IsSignalVerificationRequired(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSignal", L"IsSignalVerificationRequired"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSignalVerificationRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConversationalAgentSignal_put_IsSignalVerificationRequired(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSignal", L"IsSignalVerificationRequired"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsSignalVerificationRequired(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConversationalAgentSignal_get_DetectorId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSignal", L"DetectorId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DetectorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSignal_get_DetectorKind(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSignal", L"DetectorKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DetectorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ConversationalAgentSignal(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ConversationalAgentSignal(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConversationalAgentSignal[] = {
        { "_assign_array_", _assign_array_ConversationalAgentSignal, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ConversationalAgentSignal), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConversationalAgentSignal[] = {
        { "signal_start", reinterpret_cast<getter>(ConversationalAgentSignal_get_SignalStart), reinterpret_cast<setter>(ConversationalAgentSignal_put_SignalStart), nullptr, nullptr },
        { "signal_name", reinterpret_cast<getter>(ConversationalAgentSignal_get_SignalName), reinterpret_cast<setter>(ConversationalAgentSignal_put_SignalName), nullptr, nullptr },
        { "signal_id", reinterpret_cast<getter>(ConversationalAgentSignal_get_SignalId), reinterpret_cast<setter>(ConversationalAgentSignal_put_SignalId), nullptr, nullptr },
        { "signal_end", reinterpret_cast<getter>(ConversationalAgentSignal_get_SignalEnd), reinterpret_cast<setter>(ConversationalAgentSignal_put_SignalEnd), nullptr, nullptr },
        { "signal_context", reinterpret_cast<getter>(ConversationalAgentSignal_get_SignalContext), reinterpret_cast<setter>(ConversationalAgentSignal_put_SignalContext), nullptr, nullptr },
        { "is_signal_verification_required", reinterpret_cast<getter>(ConversationalAgentSignal_get_IsSignalVerificationRequired), reinterpret_cast<setter>(ConversationalAgentSignal_put_IsSignalVerificationRequired), nullptr, nullptr },
        { "detector_id", reinterpret_cast<getter>(ConversationalAgentSignal_get_DetectorId), nullptr, nullptr, nullptr },
        { "detector_kind", reinterpret_cast<getter>(ConversationalAgentSignal_get_DetectorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ConversationalAgentSignal[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ConversationalAgentSignal) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ConversationalAgentSignal) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ConversationalAgentSignal) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ConversationalAgentSignal) },
        { },
    };

    static PyType_Spec type_spec_ConversationalAgentSignal =
    {
        "winrt._winrt_windows_applicationmodel_conversationalagent.ConversationalAgentSignal",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConversationalAgentSignal
    };

    // ----- ConversationalAgentSignalDetectedEventArgs class --------------------

    static PyObject* _new_ConversationalAgentSignalDetectedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignalDetectedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignalDetectedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ConversationalAgentSignalDetectedEventArgs(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignalDetectedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ConversationalAgentSignalDetectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignalDetectedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ConversationalAgentSignalDetectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignalDetectedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConversationalAgentSignalDetectedEventArgs[] = {
        { "_assign_array_", _assign_array_ConversationalAgentSignalDetectedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ConversationalAgentSignalDetectedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConversationalAgentSignalDetectedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_ConversationalAgentSignalDetectedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ConversationalAgentSignalDetectedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ConversationalAgentSignalDetectedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ConversationalAgentSignalDetectedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ConversationalAgentSignalDetectedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ConversationalAgentSignalDetectedEventArgs =
    {
        "winrt._winrt_windows_applicationmodel_conversationalagent.ConversationalAgentSignalDetectedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignalDetectedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConversationalAgentSignalDetectedEventArgs
    };

    // ----- ConversationalAgentSystemStateChangedEventArgs class --------------------

    static PyObject* _new_ConversationalAgentSystemStateChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSystemStateChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSystemStateChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_ConversationalAgentSystemStateChangedEventArgs(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSystemStateChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ConversationalAgentSystemStateChangedEventArgs_get_SystemStateChangeType(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSystemStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.ConversationalAgentSystemStateChangedEventArgs", L"SystemStateChangeType"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SystemStateChangeType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ConversationalAgentSystemStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSystemStateChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ConversationalAgentSystemStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSystemStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConversationalAgentSystemStateChangedEventArgs[] = {
        { "_assign_array_", _assign_array_ConversationalAgentSystemStateChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ConversationalAgentSystemStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConversationalAgentSystemStateChangedEventArgs[] = {
        { "system_state_change_type", reinterpret_cast<getter>(ConversationalAgentSystemStateChangedEventArgs_get_SystemStateChangeType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ConversationalAgentSystemStateChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ConversationalAgentSystemStateChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ConversationalAgentSystemStateChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ConversationalAgentSystemStateChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ConversationalAgentSystemStateChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_ConversationalAgentSystemStateChangedEventArgs =
    {
        "winrt._winrt_windows_applicationmodel_conversationalagent.ConversationalAgentSystemStateChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSystemStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConversationalAgentSystemStateChangedEventArgs
    };

    // ----- DetectionConfigurationAvailabilityChangedEventArgs class --------------------

    static PyObject* _new_DetectionConfigurationAvailabilityChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_DetectionConfigurationAvailabilityChangedEventArgs(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DetectionConfigurationAvailabilityChangedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityChangedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.DetectionConfigurationAvailabilityChangedEventArgs", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DetectionConfigurationAvailabilityChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DetectionConfigurationAvailabilityChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DetectionConfigurationAvailabilityChangedEventArgs[] = {
        { "_assign_array_", _assign_array_DetectionConfigurationAvailabilityChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DetectionConfigurationAvailabilityChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DetectionConfigurationAvailabilityChangedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(DetectionConfigurationAvailabilityChangedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DetectionConfigurationAvailabilityChangedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DetectionConfigurationAvailabilityChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DetectionConfigurationAvailabilityChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DetectionConfigurationAvailabilityChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DetectionConfigurationAvailabilityChangedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_DetectionConfigurationAvailabilityChangedEventArgs =
    {
        "winrt._winrt_windows_applicationmodel_conversationalagent.DetectionConfigurationAvailabilityChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DetectionConfigurationAvailabilityChangedEventArgs
    };

    // ----- DetectionConfigurationAvailabilityInfo class --------------------

    static PyObject* _new_DetectionConfigurationAvailabilityInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_DetectionConfigurationAvailabilityInfo(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DetectionConfigurationAvailabilityInfo_get_HasLockScreenPermission(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.DetectionConfigurationAvailabilityInfo", L"HasLockScreenPermission"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasLockScreenPermission());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DetectionConfigurationAvailabilityInfo_get_HasPermission(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.DetectionConfigurationAvailabilityInfo", L"HasPermission"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasPermission());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DetectionConfigurationAvailabilityInfo_get_HasSystemResourceAccess(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.DetectionConfigurationAvailabilityInfo", L"HasSystemResourceAccess"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HasSystemResourceAccess());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DetectionConfigurationAvailabilityInfo_get_IsEnabled(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.DetectionConfigurationAvailabilityInfo", L"IsEnabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DetectionConfigurationAvailabilityInfo_get_UnavailableSystemResources(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.ApplicationModel.ConversationalAgent.DetectionConfigurationAvailabilityInfo", L"UnavailableSystemResources"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UnavailableSystemResources());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DetectionConfigurationAvailabilityInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DetectionConfigurationAvailabilityInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DetectionConfigurationAvailabilityInfo[] = {
        { "_assign_array_", _assign_array_DetectionConfigurationAvailabilityInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DetectionConfigurationAvailabilityInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DetectionConfigurationAvailabilityInfo[] = {
        { "has_lock_screen_permission", reinterpret_cast<getter>(DetectionConfigurationAvailabilityInfo_get_HasLockScreenPermission), nullptr, nullptr, nullptr },
        { "has_permission", reinterpret_cast<getter>(DetectionConfigurationAvailabilityInfo_get_HasPermission), nullptr, nullptr, nullptr },
        { "has_system_resource_access", reinterpret_cast<getter>(DetectionConfigurationAvailabilityInfo_get_HasSystemResourceAccess), nullptr, nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(DetectionConfigurationAvailabilityInfo_get_IsEnabled), nullptr, nullptr, nullptr },
        { "unavailable_system_resources", reinterpret_cast<getter>(DetectionConfigurationAvailabilityInfo_get_UnavailableSystemResources), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DetectionConfigurationAvailabilityInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_DetectionConfigurationAvailabilityInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DetectionConfigurationAvailabilityInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DetectionConfigurationAvailabilityInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DetectionConfigurationAvailabilityInfo) },
        { },
    };

    static PyType_Spec type_spec_DetectionConfigurationAvailabilityInfo =
    {
        "winrt._winrt_windows_applicationmodel_conversationalagent.DetectionConfigurationAvailabilityInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DetectionConfigurationAvailabilityInfo
    };

    // ----- Windows.ApplicationModel.ConversationalAgent Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::ApplicationModel::ConversationalAgent");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_applicationmodel_conversationalagent",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::ApplicationModel::ConversationalAgent

PyMODINIT_FUNC PyInit__winrt_windows_applicationmodel_conversationalagent(void) noexcept
{
    using namespace py::cpp::Windows::ApplicationModel::ConversationalAgent;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ActivationSignalDetectionConfiguration, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ActivationSignalDetectionConfigurationCreationResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ActivationSignalDetector, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ConversationalAgentDetectorManager_Static{PyType_FromSpec(&type_spec_ConversationalAgentDetectorManager_Static)};
    if (!type_ConversationalAgentDetectorManager_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ConversationalAgentDetectorManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ConversationalAgentDetectorManager_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_ConversationalAgentSession_Static{PyType_FromSpec(&type_spec_ConversationalAgentSession_Static)};
    if (!type_ConversationalAgentSession_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ConversationalAgentSession, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ConversationalAgentSession_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ConversationalAgentSessionInterruptedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ConversationalAgentSignal, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ConversationalAgentSignalDetectedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ConversationalAgentSystemStateChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DetectionConfigurationAvailabilityChangedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_DetectionConfigurationAvailabilityInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
