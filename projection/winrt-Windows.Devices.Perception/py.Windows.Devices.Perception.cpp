// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.Devices.Perception.h"

namespace py::cpp::Windows::Devices::Perception
{
    // ----- KnownCameraIntrinsicsProperties class --------------------

    static PyObject* _new_KnownCameraIntrinsicsProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Perception::KnownCameraIntrinsicsProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Perception::KnownCameraIntrinsicsProperties>::type_name);
        return nullptr;
    }

    static PyObject* KnownCameraIntrinsicsProperties_get_FocalLength(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownCameraIntrinsicsProperties", L"FocalLength");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Perception::KnownCameraIntrinsicsProperties::FocalLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownCameraIntrinsicsProperties_get_PrincipalPoint(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownCameraIntrinsicsProperties", L"PrincipalPoint");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Perception::KnownCameraIntrinsicsProperties::PrincipalPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownCameraIntrinsicsProperties_get_RadialDistortion(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownCameraIntrinsicsProperties", L"RadialDistortion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Perception::KnownCameraIntrinsicsProperties::RadialDistortion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownCameraIntrinsicsProperties_get_TangentialDistortion(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownCameraIntrinsicsProperties", L"TangentialDistortion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Perception::KnownCameraIntrinsicsProperties::TangentialDistortion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownCameraIntrinsicsProperties[] = {
        { }
    };

    static PyGetSetDef _getset_KnownCameraIntrinsicsProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownCameraIntrinsicsProperties[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownCameraIntrinsicsProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownCameraIntrinsicsProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownCameraIntrinsicsProperties) },
        { }
    };

    static PyType_Spec type_spec_KnownCameraIntrinsicsProperties = {
        "winrt._winrt_windows_devices_perception.KnownCameraIntrinsicsProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownCameraIntrinsicsProperties};

    static PyGetSetDef getset_KnownCameraIntrinsicsProperties_Static[] = {
        { "focal_length", reinterpret_cast<getter>(KnownCameraIntrinsicsProperties_get_FocalLength), nullptr, nullptr, nullptr },
        { "principal_point", reinterpret_cast<getter>(KnownCameraIntrinsicsProperties_get_PrincipalPoint), nullptr, nullptr, nullptr },
        { "radial_distortion", reinterpret_cast<getter>(KnownCameraIntrinsicsProperties_get_RadialDistortion), nullptr, nullptr, nullptr },
        { "tangential_distortion", reinterpret_cast<getter>(KnownCameraIntrinsicsProperties_get_TangentialDistortion), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_KnownCameraIntrinsicsProperties_Static[] = {
        { }
    };

    static PyType_Slot type_slots_KnownCameraIntrinsicsProperties_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownCameraIntrinsicsProperties_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_KnownCameraIntrinsicsProperties_Static) },
        { }
    };

    static PyType_Spec type_spec_KnownCameraIntrinsicsProperties_Static =
    {
        "winrt._winrt_windows_devices_perception.KnownCameraIntrinsicsProperties_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownCameraIntrinsicsProperties_Static
    };

    // ----- KnownPerceptionColorFrameSourceProperties class --------------------

    static PyObject* _new_KnownPerceptionColorFrameSourceProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Perception::KnownPerceptionColorFrameSourceProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Perception::KnownPerceptionColorFrameSourceProperties>::type_name);
        return nullptr;
    }

    static PyObject* KnownPerceptionColorFrameSourceProperties_get_AutoExposureEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionColorFrameSourceProperties", L"AutoExposureEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionColorFrameSourceProperties::AutoExposureEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionColorFrameSourceProperties_get_Exposure(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionColorFrameSourceProperties", L"Exposure");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionColorFrameSourceProperties::Exposure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionColorFrameSourceProperties_get_ExposureCompensation(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionColorFrameSourceProperties", L"ExposureCompensation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionColorFrameSourceProperties::ExposureCompensation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownPerceptionColorFrameSourceProperties[] = {
        { }
    };

    static PyGetSetDef _getset_KnownPerceptionColorFrameSourceProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownPerceptionColorFrameSourceProperties[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownPerceptionColorFrameSourceProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownPerceptionColorFrameSourceProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownPerceptionColorFrameSourceProperties) },
        { }
    };

    static PyType_Spec type_spec_KnownPerceptionColorFrameSourceProperties = {
        "winrt._winrt_windows_devices_perception.KnownPerceptionColorFrameSourceProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownPerceptionColorFrameSourceProperties};

    static PyGetSetDef getset_KnownPerceptionColorFrameSourceProperties_Static[] = {
        { "auto_exposure_enabled", reinterpret_cast<getter>(KnownPerceptionColorFrameSourceProperties_get_AutoExposureEnabled), nullptr, nullptr, nullptr },
        { "exposure", reinterpret_cast<getter>(KnownPerceptionColorFrameSourceProperties_get_Exposure), nullptr, nullptr, nullptr },
        { "exposure_compensation", reinterpret_cast<getter>(KnownPerceptionColorFrameSourceProperties_get_ExposureCompensation), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_KnownPerceptionColorFrameSourceProperties_Static[] = {
        { }
    };

    static PyType_Slot type_slots_KnownPerceptionColorFrameSourceProperties_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownPerceptionColorFrameSourceProperties_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_KnownPerceptionColorFrameSourceProperties_Static) },
        { }
    };

    static PyType_Spec type_spec_KnownPerceptionColorFrameSourceProperties_Static =
    {
        "winrt._winrt_windows_devices_perception.KnownPerceptionColorFrameSourceProperties_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownPerceptionColorFrameSourceProperties_Static
    };

    // ----- KnownPerceptionDepthFrameSourceProperties class --------------------

    static PyObject* _new_KnownPerceptionDepthFrameSourceProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Perception::KnownPerceptionDepthFrameSourceProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Perception::KnownPerceptionDepthFrameSourceProperties>::type_name);
        return nullptr;
    }

    static PyObject* KnownPerceptionDepthFrameSourceProperties_get_MaxDepth(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionDepthFrameSourceProperties", L"MaxDepth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionDepthFrameSourceProperties::MaxDepth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionDepthFrameSourceProperties_get_MinDepth(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionDepthFrameSourceProperties", L"MinDepth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionDepthFrameSourceProperties::MinDepth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownPerceptionDepthFrameSourceProperties[] = {
        { }
    };

    static PyGetSetDef _getset_KnownPerceptionDepthFrameSourceProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownPerceptionDepthFrameSourceProperties[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownPerceptionDepthFrameSourceProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownPerceptionDepthFrameSourceProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownPerceptionDepthFrameSourceProperties) },
        { }
    };

    static PyType_Spec type_spec_KnownPerceptionDepthFrameSourceProperties = {
        "winrt._winrt_windows_devices_perception.KnownPerceptionDepthFrameSourceProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownPerceptionDepthFrameSourceProperties};

    static PyGetSetDef getset_KnownPerceptionDepthFrameSourceProperties_Static[] = {
        { "max_depth", reinterpret_cast<getter>(KnownPerceptionDepthFrameSourceProperties_get_MaxDepth), nullptr, nullptr, nullptr },
        { "min_depth", reinterpret_cast<getter>(KnownPerceptionDepthFrameSourceProperties_get_MinDepth), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_KnownPerceptionDepthFrameSourceProperties_Static[] = {
        { }
    };

    static PyType_Slot type_slots_KnownPerceptionDepthFrameSourceProperties_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownPerceptionDepthFrameSourceProperties_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_KnownPerceptionDepthFrameSourceProperties_Static) },
        { }
    };

    static PyType_Spec type_spec_KnownPerceptionDepthFrameSourceProperties_Static =
    {
        "winrt._winrt_windows_devices_perception.KnownPerceptionDepthFrameSourceProperties_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownPerceptionDepthFrameSourceProperties_Static
    };

    // ----- KnownPerceptionFrameSourceProperties class --------------------

    static PyObject* _new_KnownPerceptionFrameSourceProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Perception::KnownPerceptionFrameSourceProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Perception::KnownPerceptionFrameSourceProperties>::type_name);
        return nullptr;
    }

    static PyObject* KnownPerceptionFrameSourceProperties_get_DeviceModelVersion(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionFrameSourceProperties", L"DeviceModelVersion");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionFrameSourceProperties::DeviceModelVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionFrameSourceProperties_get_EnclosureLocation(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionFrameSourceProperties", L"EnclosureLocation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionFrameSourceProperties::EnclosureLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionFrameSourceProperties_get_FrameKind(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionFrameSourceProperties", L"FrameKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionFrameSourceProperties::FrameKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionFrameSourceProperties_get_Id(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionFrameSourceProperties", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionFrameSourceProperties::Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionFrameSourceProperties_get_PhysicalDeviceIds(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionFrameSourceProperties", L"PhysicalDeviceIds");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionFrameSourceProperties::PhysicalDeviceIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionFrameSourceProperties_get_DeviceId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionFrameSourceProperties", L"DeviceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionFrameSourceProperties::DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownPerceptionFrameSourceProperties[] = {
        { }
    };

    static PyGetSetDef _getset_KnownPerceptionFrameSourceProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownPerceptionFrameSourceProperties[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownPerceptionFrameSourceProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownPerceptionFrameSourceProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownPerceptionFrameSourceProperties) },
        { }
    };

    static PyType_Spec type_spec_KnownPerceptionFrameSourceProperties = {
        "winrt._winrt_windows_devices_perception.KnownPerceptionFrameSourceProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownPerceptionFrameSourceProperties};

    static PyGetSetDef getset_KnownPerceptionFrameSourceProperties_Static[] = {
        { "device_model_version", reinterpret_cast<getter>(KnownPerceptionFrameSourceProperties_get_DeviceModelVersion), nullptr, nullptr, nullptr },
        { "enclosure_location", reinterpret_cast<getter>(KnownPerceptionFrameSourceProperties_get_EnclosureLocation), nullptr, nullptr, nullptr },
        { "frame_kind", reinterpret_cast<getter>(KnownPerceptionFrameSourceProperties_get_FrameKind), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(KnownPerceptionFrameSourceProperties_get_Id), nullptr, nullptr, nullptr },
        { "physical_device_ids", reinterpret_cast<getter>(KnownPerceptionFrameSourceProperties_get_PhysicalDeviceIds), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(KnownPerceptionFrameSourceProperties_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_KnownPerceptionFrameSourceProperties_Static[] = {
        { }
    };

    static PyType_Slot type_slots_KnownPerceptionFrameSourceProperties_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownPerceptionFrameSourceProperties_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_KnownPerceptionFrameSourceProperties_Static) },
        { }
    };

    static PyType_Spec type_spec_KnownPerceptionFrameSourceProperties_Static =
    {
        "winrt._winrt_windows_devices_perception.KnownPerceptionFrameSourceProperties_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownPerceptionFrameSourceProperties_Static
    };

    // ----- KnownPerceptionInfraredFrameSourceProperties class --------------------

    static PyObject* _new_KnownPerceptionInfraredFrameSourceProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Perception::KnownPerceptionInfraredFrameSourceProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Perception::KnownPerceptionInfraredFrameSourceProperties>::type_name);
        return nullptr;
    }

    static PyObject* KnownPerceptionInfraredFrameSourceProperties_get_ActiveIlluminationEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionInfraredFrameSourceProperties", L"ActiveIlluminationEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionInfraredFrameSourceProperties::ActiveIlluminationEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionInfraredFrameSourceProperties_get_AmbientSubtractionEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionInfraredFrameSourceProperties", L"AmbientSubtractionEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionInfraredFrameSourceProperties::AmbientSubtractionEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionInfraredFrameSourceProperties_get_AutoExposureEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionInfraredFrameSourceProperties", L"AutoExposureEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionInfraredFrameSourceProperties::AutoExposureEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionInfraredFrameSourceProperties_get_Exposure(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionInfraredFrameSourceProperties", L"Exposure");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionInfraredFrameSourceProperties::Exposure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionInfraredFrameSourceProperties_get_ExposureCompensation(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionInfraredFrameSourceProperties", L"ExposureCompensation");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionInfraredFrameSourceProperties::ExposureCompensation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionInfraredFrameSourceProperties_get_InterleavedIlluminationEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionInfraredFrameSourceProperties", L"InterleavedIlluminationEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionInfraredFrameSourceProperties::InterleavedIlluminationEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionInfraredFrameSourceProperties_get_StructureLightPatternEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionInfraredFrameSourceProperties", L"StructureLightPatternEnabled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionInfraredFrameSourceProperties::StructureLightPatternEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownPerceptionInfraredFrameSourceProperties[] = {
        { }
    };

    static PyGetSetDef _getset_KnownPerceptionInfraredFrameSourceProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownPerceptionInfraredFrameSourceProperties[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownPerceptionInfraredFrameSourceProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownPerceptionInfraredFrameSourceProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownPerceptionInfraredFrameSourceProperties) },
        { }
    };

    static PyType_Spec type_spec_KnownPerceptionInfraredFrameSourceProperties = {
        "winrt._winrt_windows_devices_perception.KnownPerceptionInfraredFrameSourceProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownPerceptionInfraredFrameSourceProperties};

    static PyGetSetDef getset_KnownPerceptionInfraredFrameSourceProperties_Static[] = {
        { "active_illumination_enabled", reinterpret_cast<getter>(KnownPerceptionInfraredFrameSourceProperties_get_ActiveIlluminationEnabled), nullptr, nullptr, nullptr },
        { "ambient_subtraction_enabled", reinterpret_cast<getter>(KnownPerceptionInfraredFrameSourceProperties_get_AmbientSubtractionEnabled), nullptr, nullptr, nullptr },
        { "auto_exposure_enabled", reinterpret_cast<getter>(KnownPerceptionInfraredFrameSourceProperties_get_AutoExposureEnabled), nullptr, nullptr, nullptr },
        { "exposure", reinterpret_cast<getter>(KnownPerceptionInfraredFrameSourceProperties_get_Exposure), nullptr, nullptr, nullptr },
        { "exposure_compensation", reinterpret_cast<getter>(KnownPerceptionInfraredFrameSourceProperties_get_ExposureCompensation), nullptr, nullptr, nullptr },
        { "interleaved_illumination_enabled", reinterpret_cast<getter>(KnownPerceptionInfraredFrameSourceProperties_get_InterleavedIlluminationEnabled), nullptr, nullptr, nullptr },
        { "structure_light_pattern_enabled", reinterpret_cast<getter>(KnownPerceptionInfraredFrameSourceProperties_get_StructureLightPatternEnabled), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_KnownPerceptionInfraredFrameSourceProperties_Static[] = {
        { }
    };

    static PyType_Slot type_slots_KnownPerceptionInfraredFrameSourceProperties_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownPerceptionInfraredFrameSourceProperties_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_KnownPerceptionInfraredFrameSourceProperties_Static) },
        { }
    };

    static PyType_Spec type_spec_KnownPerceptionInfraredFrameSourceProperties_Static =
    {
        "winrt._winrt_windows_devices_perception.KnownPerceptionInfraredFrameSourceProperties_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownPerceptionInfraredFrameSourceProperties_Static
    };

    // ----- KnownPerceptionVideoFrameSourceProperties class --------------------

    static PyObject* _new_KnownPerceptionVideoFrameSourceProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Perception::KnownPerceptionVideoFrameSourceProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Perception::KnownPerceptionVideoFrameSourceProperties>::type_name);
        return nullptr;
    }

    static PyObject* KnownPerceptionVideoFrameSourceProperties_get_AvailableVideoProfiles(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionVideoFrameSourceProperties", L"AvailableVideoProfiles");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionVideoFrameSourceProperties::AvailableVideoProfiles());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionVideoFrameSourceProperties_get_CameraIntrinsics(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionVideoFrameSourceProperties", L"CameraIntrinsics");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionVideoFrameSourceProperties::CameraIntrinsics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionVideoFrameSourceProperties_get_IsMirrored(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionVideoFrameSourceProperties", L"IsMirrored");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionVideoFrameSourceProperties::IsMirrored());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionVideoFrameSourceProperties_get_SupportedVideoProfiles(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionVideoFrameSourceProperties", L"SupportedVideoProfiles");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionVideoFrameSourceProperties::SupportedVideoProfiles());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionVideoFrameSourceProperties_get_VideoProfile(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionVideoFrameSourceProperties", L"VideoProfile");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionVideoFrameSourceProperties::VideoProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownPerceptionVideoFrameSourceProperties[] = {
        { }
    };

    static PyGetSetDef _getset_KnownPerceptionVideoFrameSourceProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownPerceptionVideoFrameSourceProperties[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownPerceptionVideoFrameSourceProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownPerceptionVideoFrameSourceProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownPerceptionVideoFrameSourceProperties) },
        { }
    };

    static PyType_Spec type_spec_KnownPerceptionVideoFrameSourceProperties = {
        "winrt._winrt_windows_devices_perception.KnownPerceptionVideoFrameSourceProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownPerceptionVideoFrameSourceProperties};

    static PyGetSetDef getset_KnownPerceptionVideoFrameSourceProperties_Static[] = {
        { "available_video_profiles", reinterpret_cast<getter>(KnownPerceptionVideoFrameSourceProperties_get_AvailableVideoProfiles), nullptr, nullptr, nullptr },
        { "camera_intrinsics", reinterpret_cast<getter>(KnownPerceptionVideoFrameSourceProperties_get_CameraIntrinsics), nullptr, nullptr, nullptr },
        { "is_mirrored", reinterpret_cast<getter>(KnownPerceptionVideoFrameSourceProperties_get_IsMirrored), nullptr, nullptr, nullptr },
        { "supported_video_profiles", reinterpret_cast<getter>(KnownPerceptionVideoFrameSourceProperties_get_SupportedVideoProfiles), nullptr, nullptr, nullptr },
        { "video_profile", reinterpret_cast<getter>(KnownPerceptionVideoFrameSourceProperties_get_VideoProfile), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_KnownPerceptionVideoFrameSourceProperties_Static[] = {
        { }
    };

    static PyType_Slot type_slots_KnownPerceptionVideoFrameSourceProperties_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownPerceptionVideoFrameSourceProperties_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_KnownPerceptionVideoFrameSourceProperties_Static) },
        { }
    };

    static PyType_Spec type_spec_KnownPerceptionVideoFrameSourceProperties_Static =
    {
        "winrt._winrt_windows_devices_perception.KnownPerceptionVideoFrameSourceProperties_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownPerceptionVideoFrameSourceProperties_Static
    };

    // ----- KnownPerceptionVideoProfileProperties class --------------------

    static PyObject* _new_KnownPerceptionVideoProfileProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Perception::KnownPerceptionVideoProfileProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Perception::KnownPerceptionVideoProfileProperties>::type_name);
        return nullptr;
    }

    static PyObject* KnownPerceptionVideoProfileProperties_get_BitmapAlphaMode(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionVideoProfileProperties", L"BitmapAlphaMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionVideoProfileProperties::BitmapAlphaMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionVideoProfileProperties_get_BitmapPixelFormat(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionVideoProfileProperties", L"BitmapPixelFormat");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionVideoProfileProperties::BitmapPixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionVideoProfileProperties_get_FrameDuration(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionVideoProfileProperties", L"FrameDuration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionVideoProfileProperties::FrameDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionVideoProfileProperties_get_Height(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionVideoProfileProperties", L"Height");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionVideoProfileProperties::Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionVideoProfileProperties_get_Width(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.KnownPerceptionVideoProfileProperties", L"Width");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionVideoProfileProperties::Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownPerceptionVideoProfileProperties[] = {
        { }
    };

    static PyGetSetDef _getset_KnownPerceptionVideoProfileProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownPerceptionVideoProfileProperties[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_KnownPerceptionVideoProfileProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_KnownPerceptionVideoProfileProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_KnownPerceptionVideoProfileProperties) },
        { }
    };

    static PyType_Spec type_spec_KnownPerceptionVideoProfileProperties = {
        "winrt._winrt_windows_devices_perception.KnownPerceptionVideoProfileProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownPerceptionVideoProfileProperties};

    static PyGetSetDef getset_KnownPerceptionVideoProfileProperties_Static[] = {
        { "bitmap_alpha_mode", reinterpret_cast<getter>(KnownPerceptionVideoProfileProperties_get_BitmapAlphaMode), nullptr, nullptr, nullptr },
        { "bitmap_pixel_format", reinterpret_cast<getter>(KnownPerceptionVideoProfileProperties_get_BitmapPixelFormat), nullptr, nullptr, nullptr },
        { "frame_duration", reinterpret_cast<getter>(KnownPerceptionVideoProfileProperties_get_FrameDuration), nullptr, nullptr, nullptr },
        { "height", reinterpret_cast<getter>(KnownPerceptionVideoProfileProperties_get_Height), nullptr, nullptr, nullptr },
        { "width", reinterpret_cast<getter>(KnownPerceptionVideoProfileProperties_get_Width), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_KnownPerceptionVideoProfileProperties_Static[] = {
        { }
    };

    static PyType_Slot type_slots_KnownPerceptionVideoProfileProperties_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_KnownPerceptionVideoProfileProperties_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_KnownPerceptionVideoProfileProperties_Static) },
        { }
    };

    static PyType_Spec type_spec_KnownPerceptionVideoProfileProperties_Static =
    {
        "winrt._winrt_windows_devices_perception.KnownPerceptionVideoProfileProperties_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_KnownPerceptionVideoProfileProperties_Static
    };

    // ----- PerceptionColorFrame class --------------------

    static PyObject* _new_PerceptionColorFrame(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Perception::PerceptionColorFrame>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Perception::PerceptionColorFrame>::type_name);
        return nullptr;
    }

    static void _dealloc_PerceptionColorFrame(py::wrapper::Windows::Devices::Perception::PerceptionColorFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionColorFrame_Close(py::wrapper::Windows::Devices::Perception::PerceptionColorFrame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionColorFrame", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrame_get_VideoFrame(py::wrapper::Windows::Devices::Perception::PerceptionColorFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrame", L"VideoFrame");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionColorFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionColorFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionColorFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionColorFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_PerceptionColorFrame(py::wrapper::Windows::Devices::Perception::PerceptionColorFrame* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_PerceptionColorFrame(py::wrapper::Windows::Devices::Perception::PerceptionColorFrame* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionColorFrame[] = {
        { "close", reinterpret_cast<PyCFunction>(PerceptionColorFrame_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PerceptionColorFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionColorFrame), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_PerceptionColorFrame), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_PerceptionColorFrame), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionColorFrame[] = {
        { "video_frame", reinterpret_cast<getter>(PerceptionColorFrame_get_VideoFrame), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionColorFrame[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionColorFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionColorFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionColorFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionColorFrame) },
        { }
    };

    static PyType_Spec type_spec_PerceptionColorFrame = {
        "winrt._winrt_windows_devices_perception.PerceptionColorFrame",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionColorFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionColorFrame};

    // ----- PerceptionColorFrameArrivedEventArgs class --------------------

    static PyObject* _new_PerceptionColorFrameArrivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Perception::PerceptionColorFrameArrivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Perception::PerceptionColorFrameArrivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PerceptionColorFrameArrivedEventArgs(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameArrivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionColorFrameArrivedEventArgs_TryOpenFrame(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameArrivedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionColorFrameArrivedEventArgs", L"TryOpenFrame", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TryOpenFrame());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameArrivedEventArgs_get_RelativeTime(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameArrivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrameArrivedEventArgs", L"RelativeTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionColorFrameArrivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionColorFrameArrivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionColorFrameArrivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionColorFrameArrivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionColorFrameArrivedEventArgs[] = {
        { "try_open_frame", reinterpret_cast<PyCFunction>(PerceptionColorFrameArrivedEventArgs_TryOpenFrame), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PerceptionColorFrameArrivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionColorFrameArrivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionColorFrameArrivedEventArgs[] = {
        { "relative_time", reinterpret_cast<getter>(PerceptionColorFrameArrivedEventArgs_get_RelativeTime), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionColorFrameArrivedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionColorFrameArrivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionColorFrameArrivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionColorFrameArrivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionColorFrameArrivedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_PerceptionColorFrameArrivedEventArgs = {
        "winrt._winrt_windows_devices_perception.PerceptionColorFrameArrivedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameArrivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionColorFrameArrivedEventArgs};

    // ----- PerceptionColorFrameReader class --------------------

    static PyObject* _new_PerceptionColorFrameReader(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Perception::PerceptionColorFrameReader>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Perception::PerceptionColorFrameReader>::type_name);
        return nullptr;
    }

    static void _dealloc_PerceptionColorFrameReader(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameReader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionColorFrameReader_Close(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionColorFrameReader", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameReader_TryReadLatestFrame(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionColorFrameReader", L"TryReadLatestFrame", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TryReadLatestFrame());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameReader_get_IsPaused(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameReader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrameReader", L"IsPaused");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPaused());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PerceptionColorFrameReader_put_IsPaused(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrameReader", L"IsPaused");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsPaused(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PerceptionColorFrameReader_get_Source(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameReader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrameReader", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameReader_add_FrameArrived(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameReader* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameReader", L"FrameArrived");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionColorFrameReader, winrt::Windows::Devices::Perception::PerceptionColorFrameArrivedEventArgs>>(arg);

            return py::convert(self->obj.FrameArrived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameReader_remove_FrameArrived(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameReader* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameReader", L"FrameArrived");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FrameArrived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionColorFrameReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionColorFrameReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionColorFrameReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionColorFrameReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_PerceptionColorFrameReader(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameReader* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_PerceptionColorFrameReader(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameReader* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionColorFrameReader[] = {
        { "close", reinterpret_cast<PyCFunction>(PerceptionColorFrameReader_Close), METH_VARARGS, nullptr },
        { "try_read_latest_frame", reinterpret_cast<PyCFunction>(PerceptionColorFrameReader_TryReadLatestFrame), METH_VARARGS, nullptr },
        { "add_frame_arrived", reinterpret_cast<PyCFunction>(PerceptionColorFrameReader_add_FrameArrived), METH_O, nullptr },
        { "remove_frame_arrived", reinterpret_cast<PyCFunction>(PerceptionColorFrameReader_remove_FrameArrived), METH_O, nullptr },
        { "_assign_array_", _assign_array_PerceptionColorFrameReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionColorFrameReader), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_PerceptionColorFrameReader), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_PerceptionColorFrameReader), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionColorFrameReader[] = {
        { "is_paused", reinterpret_cast<getter>(PerceptionColorFrameReader_get_IsPaused), reinterpret_cast<setter>(PerceptionColorFrameReader_put_IsPaused), nullptr, nullptr },
        { "source", reinterpret_cast<getter>(PerceptionColorFrameReader_get_Source), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionColorFrameReader[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionColorFrameReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionColorFrameReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionColorFrameReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionColorFrameReader) },
        { }
    };

    static PyType_Spec type_spec_PerceptionColorFrameReader = {
        "winrt._winrt_windows_devices_perception.PerceptionColorFrameReader",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionColorFrameReader};

    // ----- PerceptionColorFrameSource class --------------------

    static PyObject* _new_PerceptionColorFrameSource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Perception::PerceptionColorFrameSource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Perception::PerceptionColorFrameSource>::type_name);
        return nullptr;
    }

    static void _dealloc_PerceptionColorFrameSource(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionColorFrameSource_AcquireControlSession(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"AcquireControlSession", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.AcquireControlSession());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_CanControlIndependentlyFrom(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"CanControlIndependentlyFrom", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CanControlIndependentlyFrom(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_CreateWatcher(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"CreateWatcher", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Perception::PerceptionColorFrameSource::CreateWatcher());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_FindAllAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"FindAllAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Perception::PerceptionColorFrameSource::FindAllAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"FromIdAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Perception::PerceptionColorFrameSource::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_IsCorrelatedWith(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"IsCorrelatedWith", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.IsCorrelatedWith(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_OpenReader(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"OpenReader", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.OpenReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_RequestAccessAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"RequestAccessAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Perception::PerceptionColorFrameSource::RequestAccessAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_TryGetDepthCorrelatedCameraIntrinsicsAsync(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"TryGetDepthCorrelatedCameraIntrinsicsAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource>(args, 0);

                return py::convert(self->obj.TryGetDepthCorrelatedCameraIntrinsicsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_TryGetDepthCorrelatedCoordinateMapperAsync(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"TryGetDepthCorrelatedCoordinateMapperAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource>(args, 1);

                return py::convert(self->obj.TryGetDepthCorrelatedCoordinateMapperAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_TryGetTransformTo(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"TryGetTransformTo", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Foundation::Numerics::float4x4 param1{};

                auto return_value = self->obj.TryGetTransformTo(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_TrySetVideoProfileAsync(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"TrySetVideoProfileAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionControlSession>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionVideoProfile>(args, 1);

                return py::convert(self->obj.TrySetVideoProfileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_get_Active(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"Active");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Active());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_get_Available(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"Available");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Available());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_get_AvailableVideoProfiles(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"AvailableVideoProfiles");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AvailableVideoProfiles());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_get_CameraIntrinsics(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"CameraIntrinsics");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CameraIntrinsics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_get_DeviceKind(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"DeviceKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_get_DisplayName(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_get_Id(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_get_IsControlled(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"IsControlled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsControlled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_get_Properties(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"Properties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_get_SupportedVideoProfiles(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"SupportedVideoProfiles");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedVideoProfiles());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_get_VideoProfile(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"VideoProfile");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_get_DeviceId(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"DeviceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_add_ActiveChanged(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"ActiveChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionColorFrameSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ActiveChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_remove_ActiveChanged(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"ActiveChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ActiveChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_add_AvailableChanged(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"AvailableChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionColorFrameSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.AvailableChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_remove_AvailableChanged(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"AvailableChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AvailableChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_add_CameraIntrinsicsChanged(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"CameraIntrinsicsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionColorFrameSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.CameraIntrinsicsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_remove_CameraIntrinsicsChanged(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"CameraIntrinsicsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CameraIntrinsicsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_add_PropertiesChanged(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"PropertiesChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionColorFrameSource, winrt::Windows::Devices::Perception::PerceptionFrameSourcePropertiesChangedEventArgs>>(arg);

            return py::convert(self->obj.PropertiesChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_remove_PropertiesChanged(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"PropertiesChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PropertiesChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_add_VideoProfileChanged(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"VideoProfileChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionColorFrameSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.VideoProfileChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_remove_VideoProfileChanged(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameSource", L"VideoProfileChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VideoProfileChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionColorFrameSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionColorFrameSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionColorFrameSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionColorFrameSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionColorFrameSource[] = {
        { "acquire_control_session", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_AcquireControlSession), METH_VARARGS, nullptr },
        { "can_control_independently_from", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_CanControlIndependentlyFrom), METH_VARARGS, nullptr },
        { "is_correlated_with", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_IsCorrelatedWith), METH_VARARGS, nullptr },
        { "open_reader", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_OpenReader), METH_VARARGS, nullptr },
        { "try_get_depth_correlated_camera_intrinsics_async", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_TryGetDepthCorrelatedCameraIntrinsicsAsync), METH_VARARGS, nullptr },
        { "try_get_depth_correlated_coordinate_mapper_async", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_TryGetDepthCorrelatedCoordinateMapperAsync), METH_VARARGS, nullptr },
        { "try_get_transform_to", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_TryGetTransformTo), METH_VARARGS, nullptr },
        { "try_set_video_profile_async", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_TrySetVideoProfileAsync), METH_VARARGS, nullptr },
        { "add_active_changed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_add_ActiveChanged), METH_O, nullptr },
        { "remove_active_changed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_remove_ActiveChanged), METH_O, nullptr },
        { "add_available_changed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_add_AvailableChanged), METH_O, nullptr },
        { "remove_available_changed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_remove_AvailableChanged), METH_O, nullptr },
        { "add_camera_intrinsics_changed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_add_CameraIntrinsicsChanged), METH_O, nullptr },
        { "remove_camera_intrinsics_changed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_remove_CameraIntrinsicsChanged), METH_O, nullptr },
        { "add_properties_changed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_add_PropertiesChanged), METH_O, nullptr },
        { "remove_properties_changed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_remove_PropertiesChanged), METH_O, nullptr },
        { "add_video_profile_changed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_add_VideoProfileChanged), METH_O, nullptr },
        { "remove_video_profile_changed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_remove_VideoProfileChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_PerceptionColorFrameSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionColorFrameSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionColorFrameSource[] = {
        { "active", reinterpret_cast<getter>(PerceptionColorFrameSource_get_Active), nullptr, nullptr, nullptr },
        { "available", reinterpret_cast<getter>(PerceptionColorFrameSource_get_Available), nullptr, nullptr, nullptr },
        { "available_video_profiles", reinterpret_cast<getter>(PerceptionColorFrameSource_get_AvailableVideoProfiles), nullptr, nullptr, nullptr },
        { "camera_intrinsics", reinterpret_cast<getter>(PerceptionColorFrameSource_get_CameraIntrinsics), nullptr, nullptr, nullptr },
        { "device_kind", reinterpret_cast<getter>(PerceptionColorFrameSource_get_DeviceKind), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(PerceptionColorFrameSource_get_DisplayName), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(PerceptionColorFrameSource_get_Id), nullptr, nullptr, nullptr },
        { "is_controlled", reinterpret_cast<getter>(PerceptionColorFrameSource_get_IsControlled), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(PerceptionColorFrameSource_get_Properties), nullptr, nullptr, nullptr },
        { "supported_video_profiles", reinterpret_cast<getter>(PerceptionColorFrameSource_get_SupportedVideoProfiles), nullptr, nullptr, nullptr },
        { "video_profile", reinterpret_cast<getter>(PerceptionColorFrameSource_get_VideoProfile), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(PerceptionColorFrameSource_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionColorFrameSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionColorFrameSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionColorFrameSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionColorFrameSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionColorFrameSource) },
        { }
    };

    static PyType_Spec type_spec_PerceptionColorFrameSource = {
        "winrt._winrt_windows_devices_perception.PerceptionColorFrameSource",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionColorFrameSource};

    static PyGetSetDef getset_PerceptionColorFrameSource_Static[] = {
        { }
    };

    static PyMethodDef methods_PerceptionColorFrameSource_Static[] = {
        { "create_watcher", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_CreateWatcher), METH_VARARGS, nullptr },
        { "find_all_async", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_FindAllAsync), METH_VARARGS, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_FromIdAsync), METH_VARARGS, nullptr },
        { "request_access_async", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_RequestAccessAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_PerceptionColorFrameSource_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PerceptionColorFrameSource_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PerceptionColorFrameSource_Static) },
        { }
    };

    static PyType_Spec type_spec_PerceptionColorFrameSource_Static =
    {
        "winrt._winrt_windows_devices_perception.PerceptionColorFrameSource_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PerceptionColorFrameSource_Static
    };

    // ----- PerceptionColorFrameSourceAddedEventArgs class --------------------

    static PyObject* _new_PerceptionColorFrameSourceAddedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Perception::PerceptionColorFrameSourceAddedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Perception::PerceptionColorFrameSourceAddedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PerceptionColorFrameSourceAddedEventArgs(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceAddedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionColorFrameSourceAddedEventArgs_get_FrameSource(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceAddedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrameSourceAddedEventArgs", L"FrameSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FrameSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionColorFrameSourceAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionColorFrameSourceAddedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionColorFrameSourceAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionColorFrameSourceAddedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionColorFrameSourceAddedEventArgs[] = {
        { "_assign_array_", _assign_array_PerceptionColorFrameSourceAddedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionColorFrameSourceAddedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionColorFrameSourceAddedEventArgs[] = {
        { "frame_source", reinterpret_cast<getter>(PerceptionColorFrameSourceAddedEventArgs_get_FrameSource), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionColorFrameSourceAddedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionColorFrameSourceAddedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionColorFrameSourceAddedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionColorFrameSourceAddedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionColorFrameSourceAddedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_PerceptionColorFrameSourceAddedEventArgs = {
        "winrt._winrt_windows_devices_perception.PerceptionColorFrameSourceAddedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceAddedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionColorFrameSourceAddedEventArgs};

    // ----- PerceptionColorFrameSourceRemovedEventArgs class --------------------

    static PyObject* _new_PerceptionColorFrameSourceRemovedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Perception::PerceptionColorFrameSourceRemovedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Perception::PerceptionColorFrameSourceRemovedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PerceptionColorFrameSourceRemovedEventArgs(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceRemovedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionColorFrameSourceRemovedEventArgs_get_FrameSource(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceRemovedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrameSourceRemovedEventArgs", L"FrameSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FrameSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionColorFrameSourceRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionColorFrameSourceRemovedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionColorFrameSourceRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionColorFrameSourceRemovedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionColorFrameSourceRemovedEventArgs[] = {
        { "_assign_array_", _assign_array_PerceptionColorFrameSourceRemovedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionColorFrameSourceRemovedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionColorFrameSourceRemovedEventArgs[] = {
        { "frame_source", reinterpret_cast<getter>(PerceptionColorFrameSourceRemovedEventArgs_get_FrameSource), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionColorFrameSourceRemovedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionColorFrameSourceRemovedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionColorFrameSourceRemovedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionColorFrameSourceRemovedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionColorFrameSourceRemovedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_PerceptionColorFrameSourceRemovedEventArgs = {
        "winrt._winrt_windows_devices_perception.PerceptionColorFrameSourceRemovedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceRemovedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionColorFrameSourceRemovedEventArgs};

    // ----- PerceptionColorFrameSourceWatcher class --------------------

    static PyObject* _new_PerceptionColorFrameSourceWatcher(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher>::type_name);
        return nullptr;
    }

    static void _dealloc_PerceptionColorFrameSourceWatcher(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionColorFrameSourceWatcher_Start(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionColorFrameSourceWatcher", L"Start", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSourceWatcher_Stop(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionColorFrameSourceWatcher", L"Stop", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSourceWatcher_get_Status(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionColorFrameSourceWatcher", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSourceWatcher_add_EnumerationCompleted(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameSourceWatcher", L"EnumerationCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.EnumerationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSourceWatcher_remove_EnumerationCompleted(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameSourceWatcher", L"EnumerationCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnumerationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSourceWatcher_add_SourceAdded(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameSourceWatcher", L"SourceAdded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher, winrt::Windows::Devices::Perception::PerceptionColorFrameSourceAddedEventArgs>>(arg);

            return py::convert(self->obj.SourceAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSourceWatcher_remove_SourceAdded(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameSourceWatcher", L"SourceAdded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSourceWatcher_add_SourceRemoved(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameSourceWatcher", L"SourceRemoved");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher, winrt::Windows::Devices::Perception::PerceptionColorFrameSourceRemovedEventArgs>>(arg);

            return py::convert(self->obj.SourceRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSourceWatcher_remove_SourceRemoved(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameSourceWatcher", L"SourceRemoved");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSourceWatcher_add_Stopped(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameSourceWatcher", L"Stopped");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Stopped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSourceWatcher_remove_Stopped(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionColorFrameSourceWatcher", L"Stopped");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Stopped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionColorFrameSourceWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionColorFrameSourceWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionColorFrameSourceWatcher[] = {
        { "start", reinterpret_cast<PyCFunction>(PerceptionColorFrameSourceWatcher_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(PerceptionColorFrameSourceWatcher_Stop), METH_VARARGS, nullptr },
        { "add_enumeration_completed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSourceWatcher_add_EnumerationCompleted), METH_O, nullptr },
        { "remove_enumeration_completed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSourceWatcher_remove_EnumerationCompleted), METH_O, nullptr },
        { "add_source_added", reinterpret_cast<PyCFunction>(PerceptionColorFrameSourceWatcher_add_SourceAdded), METH_O, nullptr },
        { "remove_source_added", reinterpret_cast<PyCFunction>(PerceptionColorFrameSourceWatcher_remove_SourceAdded), METH_O, nullptr },
        { "add_source_removed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSourceWatcher_add_SourceRemoved), METH_O, nullptr },
        { "remove_source_removed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSourceWatcher_remove_SourceRemoved), METH_O, nullptr },
        { "add_stopped", reinterpret_cast<PyCFunction>(PerceptionColorFrameSourceWatcher_add_Stopped), METH_O, nullptr },
        { "remove_stopped", reinterpret_cast<PyCFunction>(PerceptionColorFrameSourceWatcher_remove_Stopped), METH_O, nullptr },
        { "_assign_array_", _assign_array_PerceptionColorFrameSourceWatcher, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionColorFrameSourceWatcher), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionColorFrameSourceWatcher[] = {
        { "status", reinterpret_cast<getter>(PerceptionColorFrameSourceWatcher_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionColorFrameSourceWatcher[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionColorFrameSourceWatcher) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionColorFrameSourceWatcher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionColorFrameSourceWatcher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionColorFrameSourceWatcher) },
        { }
    };

    static PyType_Spec type_spec_PerceptionColorFrameSourceWatcher = {
        "winrt._winrt_windows_devices_perception.PerceptionColorFrameSourceWatcher",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionColorFrameSourceWatcher};

    // ----- PerceptionControlSession class --------------------

    static PyObject* _new_PerceptionControlSession(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Perception::PerceptionControlSession>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Perception::PerceptionControlSession>::type_name);
        return nullptr;
    }

    static void _dealloc_PerceptionControlSession(py::wrapper::Windows::Devices::Perception::PerceptionControlSession* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionControlSession_Close(py::wrapper::Windows::Devices::Perception::PerceptionControlSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionControlSession", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionControlSession_TrySetPropertyAsync(py::wrapper::Windows::Devices::Perception::PerceptionControlSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionControlSession", L"TrySetPropertyAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.TrySetPropertyAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionControlSession_add_ControlLost(py::wrapper::Windows::Devices::Perception::PerceptionControlSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionControlSession", L"ControlLost");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionControlSession, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ControlLost(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionControlSession_remove_ControlLost(py::wrapper::Windows::Devices::Perception::PerceptionControlSession* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionControlSession", L"ControlLost");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ControlLost(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionControlSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionControlSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionControlSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionControlSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_PerceptionControlSession(py::wrapper::Windows::Devices::Perception::PerceptionControlSession* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_PerceptionControlSession(py::wrapper::Windows::Devices::Perception::PerceptionControlSession* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionControlSession[] = {
        { "close", reinterpret_cast<PyCFunction>(PerceptionControlSession_Close), METH_VARARGS, nullptr },
        { "try_set_property_async", reinterpret_cast<PyCFunction>(PerceptionControlSession_TrySetPropertyAsync), METH_VARARGS, nullptr },
        { "add_control_lost", reinterpret_cast<PyCFunction>(PerceptionControlSession_add_ControlLost), METH_O, nullptr },
        { "remove_control_lost", reinterpret_cast<PyCFunction>(PerceptionControlSession_remove_ControlLost), METH_O, nullptr },
        { "_assign_array_", _assign_array_PerceptionControlSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionControlSession), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_PerceptionControlSession), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_PerceptionControlSession), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionControlSession[] = {
        { }
    };

    static PyType_Slot _type_slots_PerceptionControlSession[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionControlSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionControlSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionControlSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionControlSession) },
        { }
    };

    static PyType_Spec type_spec_PerceptionControlSession = {
        "winrt._winrt_windows_devices_perception.PerceptionControlSession",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionControlSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionControlSession};

    // ----- PerceptionDepthCorrelatedCameraIntrinsics class --------------------

    static PyObject* _new_PerceptionDepthCorrelatedCameraIntrinsics(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Perception::PerceptionDepthCorrelatedCameraIntrinsics>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Perception::PerceptionDepthCorrelatedCameraIntrinsics>::type_name);
        return nullptr;
    }

    static void _dealloc_PerceptionDepthCorrelatedCameraIntrinsics(py::wrapper::Windows::Devices::Perception::PerceptionDepthCorrelatedCameraIntrinsics* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionDepthCorrelatedCameraIntrinsics_UnprojectAllPixelsAtCorrelatedDepthAsync(py::wrapper::Windows::Devices::Perception::PerceptionDepthCorrelatedCameraIntrinsics* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthCorrelatedCameraIntrinsics", L"UnprojectAllPixelsAtCorrelatedDepthAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrame>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Numerics::float3, true>>(args, 1);

                return py::convert(self->obj.UnprojectAllPixelsAtCorrelatedDepthAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthCorrelatedCameraIntrinsics_UnprojectPixelAtCorrelatedDepth(py::wrapper::Windows::Devices::Perception::PerceptionDepthCorrelatedCameraIntrinsics* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthCorrelatedCameraIntrinsics", L"UnprojectPixelAtCorrelatedDepth", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrame>(args, 1);

                return py::convert(self->obj.UnprojectPixelAtCorrelatedDepth(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthCorrelatedCameraIntrinsics_UnprojectPixelsAtCorrelatedDepth(py::wrapper::Windows::Devices::Perception::PerceptionDepthCorrelatedCameraIntrinsics* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthCorrelatedCameraIntrinsics", L"UnprojectPixelsAtCorrelatedDepth", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrame>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Numerics::float3, true>>(args, 2);

                self->obj.UnprojectPixelsAtCorrelatedDepth(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthCorrelatedCameraIntrinsics_UnprojectRegionPixelsAtCorrelatedDepthAsync(py::wrapper::Windows::Devices::Perception::PerceptionDepthCorrelatedCameraIntrinsics* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthCorrelatedCameraIntrinsics", L"UnprojectRegionPixelsAtCorrelatedDepthAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrame>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Numerics::float3, true>>(args, 2);

                return py::convert(self->obj.UnprojectRegionPixelsAtCorrelatedDepthAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionDepthCorrelatedCameraIntrinsics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionDepthCorrelatedCameraIntrinsics>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionDepthCorrelatedCameraIntrinsics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionDepthCorrelatedCameraIntrinsics>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionDepthCorrelatedCameraIntrinsics[] = {
        { "unproject_all_pixels_at_correlated_depth_async", reinterpret_cast<PyCFunction>(PerceptionDepthCorrelatedCameraIntrinsics_UnprojectAllPixelsAtCorrelatedDepthAsync), METH_VARARGS, nullptr },
        { "unproject_pixel_at_correlated_depth", reinterpret_cast<PyCFunction>(PerceptionDepthCorrelatedCameraIntrinsics_UnprojectPixelAtCorrelatedDepth), METH_VARARGS, nullptr },
        { "unproject_pixels_at_correlated_depth", reinterpret_cast<PyCFunction>(PerceptionDepthCorrelatedCameraIntrinsics_UnprojectPixelsAtCorrelatedDepth), METH_VARARGS, nullptr },
        { "unproject_region_pixels_at_correlated_depth_async", reinterpret_cast<PyCFunction>(PerceptionDepthCorrelatedCameraIntrinsics_UnprojectRegionPixelsAtCorrelatedDepthAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PerceptionDepthCorrelatedCameraIntrinsics, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionDepthCorrelatedCameraIntrinsics), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionDepthCorrelatedCameraIntrinsics[] = {
        { }
    };

    static PyType_Slot _type_slots_PerceptionDepthCorrelatedCameraIntrinsics[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionDepthCorrelatedCameraIntrinsics) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionDepthCorrelatedCameraIntrinsics) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionDepthCorrelatedCameraIntrinsics) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionDepthCorrelatedCameraIntrinsics) },
        { }
    };

    static PyType_Spec type_spec_PerceptionDepthCorrelatedCameraIntrinsics = {
        "winrt._winrt_windows_devices_perception.PerceptionDepthCorrelatedCameraIntrinsics",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionDepthCorrelatedCameraIntrinsics),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionDepthCorrelatedCameraIntrinsics};

    // ----- PerceptionDepthCorrelatedCoordinateMapper class --------------------

    static PyObject* _new_PerceptionDepthCorrelatedCoordinateMapper(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Perception::PerceptionDepthCorrelatedCoordinateMapper>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Perception::PerceptionDepthCorrelatedCoordinateMapper>::type_name);
        return nullptr;
    }

    static void _dealloc_PerceptionDepthCorrelatedCoordinateMapper(py::wrapper::Windows::Devices::Perception::PerceptionDepthCorrelatedCoordinateMapper* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionDepthCorrelatedCoordinateMapper_MapAllPixelsToTargetAsync(py::wrapper::Windows::Devices::Perception::PerceptionDepthCorrelatedCoordinateMapper* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthCorrelatedCoordinateMapper", L"MapAllPixelsToTargetAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrame>(args, 0);
                auto param1 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, true>>(args, 1);

                return py::convert(self->obj.MapAllPixelsToTargetAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthCorrelatedCoordinateMapper_MapPixelToTarget(py::wrapper::Windows::Devices::Perception::PerceptionDepthCorrelatedCoordinateMapper* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthCorrelatedCoordinateMapper", L"MapPixelToTarget", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrame>(args, 1);

                return py::convert(self->obj.MapPixelToTarget(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthCorrelatedCoordinateMapper_MapPixelsToTarget(py::wrapper::Windows::Devices::Perception::PerceptionDepthCorrelatedCoordinateMapper* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthCorrelatedCoordinateMapper", L"MapPixelsToTarget", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, false>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrame>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, true>>(args, 2);

                self->obj.MapPixelsToTarget(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthCorrelatedCoordinateMapper_MapRegionOfPixelsToTargetAsync(py::wrapper::Windows::Devices::Perception::PerceptionDepthCorrelatedCoordinateMapper* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthCorrelatedCoordinateMapper", L"MapRegionOfPixelsToTargetAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrame>(args, 1);
                auto param2 = py::convert_to<py::pybuf_view<winrt::Windows::Foundation::Point, true>>(args, 2);

                return py::convert(self->obj.MapRegionOfPixelsToTargetAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionDepthCorrelatedCoordinateMapper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionDepthCorrelatedCoordinateMapper>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionDepthCorrelatedCoordinateMapper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionDepthCorrelatedCoordinateMapper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionDepthCorrelatedCoordinateMapper[] = {
        { "map_all_pixels_to_target_async", reinterpret_cast<PyCFunction>(PerceptionDepthCorrelatedCoordinateMapper_MapAllPixelsToTargetAsync), METH_VARARGS, nullptr },
        { "map_pixel_to_target", reinterpret_cast<PyCFunction>(PerceptionDepthCorrelatedCoordinateMapper_MapPixelToTarget), METH_VARARGS, nullptr },
        { "map_pixels_to_target", reinterpret_cast<PyCFunction>(PerceptionDepthCorrelatedCoordinateMapper_MapPixelsToTarget), METH_VARARGS, nullptr },
        { "map_region_of_pixels_to_target_async", reinterpret_cast<PyCFunction>(PerceptionDepthCorrelatedCoordinateMapper_MapRegionOfPixelsToTargetAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PerceptionDepthCorrelatedCoordinateMapper, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionDepthCorrelatedCoordinateMapper), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionDepthCorrelatedCoordinateMapper[] = {
        { }
    };

    static PyType_Slot _type_slots_PerceptionDepthCorrelatedCoordinateMapper[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionDepthCorrelatedCoordinateMapper) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionDepthCorrelatedCoordinateMapper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionDepthCorrelatedCoordinateMapper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionDepthCorrelatedCoordinateMapper) },
        { }
    };

    static PyType_Spec type_spec_PerceptionDepthCorrelatedCoordinateMapper = {
        "winrt._winrt_windows_devices_perception.PerceptionDepthCorrelatedCoordinateMapper",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionDepthCorrelatedCoordinateMapper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionDepthCorrelatedCoordinateMapper};

    // ----- PerceptionDepthFrame class --------------------

    static PyObject* _new_PerceptionDepthFrame(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Perception::PerceptionDepthFrame>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Perception::PerceptionDepthFrame>::type_name);
        return nullptr;
    }

    static void _dealloc_PerceptionDepthFrame(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionDepthFrame_Close(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthFrame", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrame_get_VideoFrame(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrame", L"VideoFrame");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionDepthFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionDepthFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionDepthFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionDepthFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_PerceptionDepthFrame(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrame* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_PerceptionDepthFrame(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrame* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionDepthFrame[] = {
        { "close", reinterpret_cast<PyCFunction>(PerceptionDepthFrame_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PerceptionDepthFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionDepthFrame), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_PerceptionDepthFrame), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_PerceptionDepthFrame), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionDepthFrame[] = {
        { "video_frame", reinterpret_cast<getter>(PerceptionDepthFrame_get_VideoFrame), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionDepthFrame[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionDepthFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionDepthFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionDepthFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionDepthFrame) },
        { }
    };

    static PyType_Spec type_spec_PerceptionDepthFrame = {
        "winrt._winrt_windows_devices_perception.PerceptionDepthFrame",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionDepthFrame};

    // ----- PerceptionDepthFrameArrivedEventArgs class --------------------

    static PyObject* _new_PerceptionDepthFrameArrivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Perception::PerceptionDepthFrameArrivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Perception::PerceptionDepthFrameArrivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PerceptionDepthFrameArrivedEventArgs(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameArrivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionDepthFrameArrivedEventArgs_TryOpenFrame(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameArrivedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthFrameArrivedEventArgs", L"TryOpenFrame", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TryOpenFrame());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameArrivedEventArgs_get_RelativeTime(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameArrivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrameArrivedEventArgs", L"RelativeTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionDepthFrameArrivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionDepthFrameArrivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionDepthFrameArrivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionDepthFrameArrivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionDepthFrameArrivedEventArgs[] = {
        { "try_open_frame", reinterpret_cast<PyCFunction>(PerceptionDepthFrameArrivedEventArgs_TryOpenFrame), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PerceptionDepthFrameArrivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionDepthFrameArrivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionDepthFrameArrivedEventArgs[] = {
        { "relative_time", reinterpret_cast<getter>(PerceptionDepthFrameArrivedEventArgs_get_RelativeTime), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionDepthFrameArrivedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionDepthFrameArrivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionDepthFrameArrivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionDepthFrameArrivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionDepthFrameArrivedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_PerceptionDepthFrameArrivedEventArgs = {
        "winrt._winrt_windows_devices_perception.PerceptionDepthFrameArrivedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameArrivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionDepthFrameArrivedEventArgs};

    // ----- PerceptionDepthFrameReader class --------------------

    static PyObject* _new_PerceptionDepthFrameReader(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Perception::PerceptionDepthFrameReader>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Perception::PerceptionDepthFrameReader>::type_name);
        return nullptr;
    }

    static void _dealloc_PerceptionDepthFrameReader(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameReader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionDepthFrameReader_Close(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthFrameReader", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameReader_TryReadLatestFrame(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthFrameReader", L"TryReadLatestFrame", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TryReadLatestFrame());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameReader_get_IsPaused(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameReader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrameReader", L"IsPaused");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPaused());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PerceptionDepthFrameReader_put_IsPaused(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrameReader", L"IsPaused");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsPaused(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PerceptionDepthFrameReader_get_Source(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameReader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrameReader", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameReader_add_FrameArrived(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameReader* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameReader", L"FrameArrived");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionDepthFrameReader, winrt::Windows::Devices::Perception::PerceptionDepthFrameArrivedEventArgs>>(arg);

            return py::convert(self->obj.FrameArrived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameReader_remove_FrameArrived(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameReader* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameReader", L"FrameArrived");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FrameArrived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionDepthFrameReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionDepthFrameReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionDepthFrameReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionDepthFrameReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_PerceptionDepthFrameReader(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameReader* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_PerceptionDepthFrameReader(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameReader* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionDepthFrameReader[] = {
        { "close", reinterpret_cast<PyCFunction>(PerceptionDepthFrameReader_Close), METH_VARARGS, nullptr },
        { "try_read_latest_frame", reinterpret_cast<PyCFunction>(PerceptionDepthFrameReader_TryReadLatestFrame), METH_VARARGS, nullptr },
        { "add_frame_arrived", reinterpret_cast<PyCFunction>(PerceptionDepthFrameReader_add_FrameArrived), METH_O, nullptr },
        { "remove_frame_arrived", reinterpret_cast<PyCFunction>(PerceptionDepthFrameReader_remove_FrameArrived), METH_O, nullptr },
        { "_assign_array_", _assign_array_PerceptionDepthFrameReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionDepthFrameReader), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_PerceptionDepthFrameReader), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_PerceptionDepthFrameReader), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionDepthFrameReader[] = {
        { "is_paused", reinterpret_cast<getter>(PerceptionDepthFrameReader_get_IsPaused), reinterpret_cast<setter>(PerceptionDepthFrameReader_put_IsPaused), nullptr, nullptr },
        { "source", reinterpret_cast<getter>(PerceptionDepthFrameReader_get_Source), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionDepthFrameReader[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionDepthFrameReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionDepthFrameReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionDepthFrameReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionDepthFrameReader) },
        { }
    };

    static PyType_Spec type_spec_PerceptionDepthFrameReader = {
        "winrt._winrt_windows_devices_perception.PerceptionDepthFrameReader",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionDepthFrameReader};

    // ----- PerceptionDepthFrameSource class --------------------

    static PyObject* _new_PerceptionDepthFrameSource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource>::type_name);
        return nullptr;
    }

    static void _dealloc_PerceptionDepthFrameSource(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionDepthFrameSource_AcquireControlSession(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"AcquireControlSession", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.AcquireControlSession());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_CanControlIndependentlyFrom(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"CanControlIndependentlyFrom", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CanControlIndependentlyFrom(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_CreateWatcher(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"CreateWatcher", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Perception::PerceptionDepthFrameSource::CreateWatcher());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_FindAllAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"FindAllAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Perception::PerceptionDepthFrameSource::FindAllAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"FromIdAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Perception::PerceptionDepthFrameSource::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_IsCorrelatedWith(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"IsCorrelatedWith", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.IsCorrelatedWith(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_OpenReader(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"OpenReader", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.OpenReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_RequestAccessAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"RequestAccessAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Perception::PerceptionDepthFrameSource::RequestAccessAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_TryGetDepthCorrelatedCameraIntrinsicsAsync(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"TryGetDepthCorrelatedCameraIntrinsicsAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource>(args, 0);

                return py::convert(self->obj.TryGetDepthCorrelatedCameraIntrinsicsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_TryGetDepthCorrelatedCoordinateMapperAsync(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"TryGetDepthCorrelatedCoordinateMapperAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource>(args, 1);

                return py::convert(self->obj.TryGetDepthCorrelatedCoordinateMapperAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_TryGetTransformTo(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"TryGetTransformTo", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Foundation::Numerics::float4x4 param1{};

                auto return_value = self->obj.TryGetTransformTo(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_TrySetVideoProfileAsync(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"TrySetVideoProfileAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionControlSession>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionVideoProfile>(args, 1);

                return py::convert(self->obj.TrySetVideoProfileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_get_Active(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"Active");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Active());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_get_Available(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"Available");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Available());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_get_AvailableVideoProfiles(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"AvailableVideoProfiles");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AvailableVideoProfiles());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_get_CameraIntrinsics(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"CameraIntrinsics");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CameraIntrinsics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_get_DeviceKind(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"DeviceKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_get_DisplayName(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_get_Id(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_get_IsControlled(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"IsControlled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsControlled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_get_Properties(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"Properties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_get_SupportedVideoProfiles(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"SupportedVideoProfiles");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedVideoProfiles());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_get_VideoProfile(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"VideoProfile");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_get_DeviceId(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"DeviceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_add_ActiveChanged(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"ActiveChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ActiveChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_remove_ActiveChanged(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"ActiveChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ActiveChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_add_AvailableChanged(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"AvailableChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.AvailableChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_remove_AvailableChanged(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"AvailableChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AvailableChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_add_CameraIntrinsicsChanged(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"CameraIntrinsicsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.CameraIntrinsicsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_remove_CameraIntrinsicsChanged(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"CameraIntrinsicsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CameraIntrinsicsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_add_PropertiesChanged(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"PropertiesChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource, winrt::Windows::Devices::Perception::PerceptionFrameSourcePropertiesChangedEventArgs>>(arg);

            return py::convert(self->obj.PropertiesChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_remove_PropertiesChanged(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"PropertiesChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PropertiesChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_add_VideoProfileChanged(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"VideoProfileChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.VideoProfileChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_remove_VideoProfileChanged(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSource", L"VideoProfileChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VideoProfileChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionDepthFrameSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionDepthFrameSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionDepthFrameSource[] = {
        { "acquire_control_session", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_AcquireControlSession), METH_VARARGS, nullptr },
        { "can_control_independently_from", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_CanControlIndependentlyFrom), METH_VARARGS, nullptr },
        { "is_correlated_with", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_IsCorrelatedWith), METH_VARARGS, nullptr },
        { "open_reader", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_OpenReader), METH_VARARGS, nullptr },
        { "try_get_depth_correlated_camera_intrinsics_async", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_TryGetDepthCorrelatedCameraIntrinsicsAsync), METH_VARARGS, nullptr },
        { "try_get_depth_correlated_coordinate_mapper_async", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_TryGetDepthCorrelatedCoordinateMapperAsync), METH_VARARGS, nullptr },
        { "try_get_transform_to", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_TryGetTransformTo), METH_VARARGS, nullptr },
        { "try_set_video_profile_async", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_TrySetVideoProfileAsync), METH_VARARGS, nullptr },
        { "add_active_changed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_add_ActiveChanged), METH_O, nullptr },
        { "remove_active_changed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_remove_ActiveChanged), METH_O, nullptr },
        { "add_available_changed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_add_AvailableChanged), METH_O, nullptr },
        { "remove_available_changed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_remove_AvailableChanged), METH_O, nullptr },
        { "add_camera_intrinsics_changed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_add_CameraIntrinsicsChanged), METH_O, nullptr },
        { "remove_camera_intrinsics_changed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_remove_CameraIntrinsicsChanged), METH_O, nullptr },
        { "add_properties_changed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_add_PropertiesChanged), METH_O, nullptr },
        { "remove_properties_changed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_remove_PropertiesChanged), METH_O, nullptr },
        { "add_video_profile_changed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_add_VideoProfileChanged), METH_O, nullptr },
        { "remove_video_profile_changed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_remove_VideoProfileChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_PerceptionDepthFrameSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionDepthFrameSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionDepthFrameSource[] = {
        { "active", reinterpret_cast<getter>(PerceptionDepthFrameSource_get_Active), nullptr, nullptr, nullptr },
        { "available", reinterpret_cast<getter>(PerceptionDepthFrameSource_get_Available), nullptr, nullptr, nullptr },
        { "available_video_profiles", reinterpret_cast<getter>(PerceptionDepthFrameSource_get_AvailableVideoProfiles), nullptr, nullptr, nullptr },
        { "camera_intrinsics", reinterpret_cast<getter>(PerceptionDepthFrameSource_get_CameraIntrinsics), nullptr, nullptr, nullptr },
        { "device_kind", reinterpret_cast<getter>(PerceptionDepthFrameSource_get_DeviceKind), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(PerceptionDepthFrameSource_get_DisplayName), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(PerceptionDepthFrameSource_get_Id), nullptr, nullptr, nullptr },
        { "is_controlled", reinterpret_cast<getter>(PerceptionDepthFrameSource_get_IsControlled), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(PerceptionDepthFrameSource_get_Properties), nullptr, nullptr, nullptr },
        { "supported_video_profiles", reinterpret_cast<getter>(PerceptionDepthFrameSource_get_SupportedVideoProfiles), nullptr, nullptr, nullptr },
        { "video_profile", reinterpret_cast<getter>(PerceptionDepthFrameSource_get_VideoProfile), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(PerceptionDepthFrameSource_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionDepthFrameSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionDepthFrameSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionDepthFrameSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionDepthFrameSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionDepthFrameSource) },
        { }
    };

    static PyType_Spec type_spec_PerceptionDepthFrameSource = {
        "winrt._winrt_windows_devices_perception.PerceptionDepthFrameSource",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionDepthFrameSource};

    static PyGetSetDef getset_PerceptionDepthFrameSource_Static[] = {
        { }
    };

    static PyMethodDef methods_PerceptionDepthFrameSource_Static[] = {
        { "create_watcher", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_CreateWatcher), METH_VARARGS, nullptr },
        { "find_all_async", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_FindAllAsync), METH_VARARGS, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_FromIdAsync), METH_VARARGS, nullptr },
        { "request_access_async", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_RequestAccessAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_PerceptionDepthFrameSource_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PerceptionDepthFrameSource_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PerceptionDepthFrameSource_Static) },
        { }
    };

    static PyType_Spec type_spec_PerceptionDepthFrameSource_Static =
    {
        "winrt._winrt_windows_devices_perception.PerceptionDepthFrameSource_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PerceptionDepthFrameSource_Static
    };

    // ----- PerceptionDepthFrameSourceAddedEventArgs class --------------------

    static PyObject* _new_PerceptionDepthFrameSourceAddedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceAddedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceAddedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PerceptionDepthFrameSourceAddedEventArgs(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceAddedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionDepthFrameSourceAddedEventArgs_get_FrameSource(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceAddedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSourceAddedEventArgs", L"FrameSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FrameSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionDepthFrameSourceAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceAddedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionDepthFrameSourceAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceAddedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionDepthFrameSourceAddedEventArgs[] = {
        { "_assign_array_", _assign_array_PerceptionDepthFrameSourceAddedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionDepthFrameSourceAddedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionDepthFrameSourceAddedEventArgs[] = {
        { "frame_source", reinterpret_cast<getter>(PerceptionDepthFrameSourceAddedEventArgs_get_FrameSource), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionDepthFrameSourceAddedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionDepthFrameSourceAddedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionDepthFrameSourceAddedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionDepthFrameSourceAddedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionDepthFrameSourceAddedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_PerceptionDepthFrameSourceAddedEventArgs = {
        "winrt._winrt_windows_devices_perception.PerceptionDepthFrameSourceAddedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceAddedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionDepthFrameSourceAddedEventArgs};

    // ----- PerceptionDepthFrameSourceRemovedEventArgs class --------------------

    static PyObject* _new_PerceptionDepthFrameSourceRemovedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceRemovedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceRemovedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PerceptionDepthFrameSourceRemovedEventArgs(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceRemovedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionDepthFrameSourceRemovedEventArgs_get_FrameSource(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceRemovedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSourceRemovedEventArgs", L"FrameSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FrameSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionDepthFrameSourceRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceRemovedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionDepthFrameSourceRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceRemovedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionDepthFrameSourceRemovedEventArgs[] = {
        { "_assign_array_", _assign_array_PerceptionDepthFrameSourceRemovedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionDepthFrameSourceRemovedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionDepthFrameSourceRemovedEventArgs[] = {
        { "frame_source", reinterpret_cast<getter>(PerceptionDepthFrameSourceRemovedEventArgs_get_FrameSource), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionDepthFrameSourceRemovedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionDepthFrameSourceRemovedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionDepthFrameSourceRemovedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionDepthFrameSourceRemovedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionDepthFrameSourceRemovedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_PerceptionDepthFrameSourceRemovedEventArgs = {
        "winrt._winrt_windows_devices_perception.PerceptionDepthFrameSourceRemovedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceRemovedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionDepthFrameSourceRemovedEventArgs};

    // ----- PerceptionDepthFrameSourceWatcher class --------------------

    static PyObject* _new_PerceptionDepthFrameSourceWatcher(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher>::type_name);
        return nullptr;
    }

    static void _dealloc_PerceptionDepthFrameSourceWatcher(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionDepthFrameSourceWatcher_Start(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher", L"Start", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSourceWatcher_Stop(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher", L"Stop", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSourceWatcher_get_Status(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSourceWatcher_add_EnumerationCompleted(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher", L"EnumerationCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.EnumerationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSourceWatcher_remove_EnumerationCompleted(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher", L"EnumerationCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnumerationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSourceWatcher_add_SourceAdded(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher", L"SourceAdded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher, winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceAddedEventArgs>>(arg);

            return py::convert(self->obj.SourceAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSourceWatcher_remove_SourceAdded(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher", L"SourceAdded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSourceWatcher_add_SourceRemoved(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher", L"SourceRemoved");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher, winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceRemovedEventArgs>>(arg);

            return py::convert(self->obj.SourceRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSourceWatcher_remove_SourceRemoved(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher", L"SourceRemoved");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSourceWatcher_add_Stopped(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher", L"Stopped");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Stopped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSourceWatcher_remove_Stopped(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionDepthFrameSourceWatcher", L"Stopped");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Stopped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionDepthFrameSourceWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionDepthFrameSourceWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionDepthFrameSourceWatcher[] = {
        { "start", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSourceWatcher_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSourceWatcher_Stop), METH_VARARGS, nullptr },
        { "add_enumeration_completed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSourceWatcher_add_EnumerationCompleted), METH_O, nullptr },
        { "remove_enumeration_completed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSourceWatcher_remove_EnumerationCompleted), METH_O, nullptr },
        { "add_source_added", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSourceWatcher_add_SourceAdded), METH_O, nullptr },
        { "remove_source_added", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSourceWatcher_remove_SourceAdded), METH_O, nullptr },
        { "add_source_removed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSourceWatcher_add_SourceRemoved), METH_O, nullptr },
        { "remove_source_removed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSourceWatcher_remove_SourceRemoved), METH_O, nullptr },
        { "add_stopped", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSourceWatcher_add_Stopped), METH_O, nullptr },
        { "remove_stopped", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSourceWatcher_remove_Stopped), METH_O, nullptr },
        { "_assign_array_", _assign_array_PerceptionDepthFrameSourceWatcher, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionDepthFrameSourceWatcher), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionDepthFrameSourceWatcher[] = {
        { "status", reinterpret_cast<getter>(PerceptionDepthFrameSourceWatcher_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionDepthFrameSourceWatcher[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionDepthFrameSourceWatcher) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionDepthFrameSourceWatcher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionDepthFrameSourceWatcher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionDepthFrameSourceWatcher) },
        { }
    };

    static PyType_Spec type_spec_PerceptionDepthFrameSourceWatcher = {
        "winrt._winrt_windows_devices_perception.PerceptionDepthFrameSourceWatcher",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionDepthFrameSourceWatcher};

    // ----- PerceptionFrameSourcePropertiesChangedEventArgs class --------------------

    static PyObject* _new_PerceptionFrameSourcePropertiesChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Perception::PerceptionFrameSourcePropertiesChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Perception::PerceptionFrameSourcePropertiesChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PerceptionFrameSourcePropertiesChangedEventArgs(py::wrapper::Windows::Devices::Perception::PerceptionFrameSourcePropertiesChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionFrameSourcePropertiesChangedEventArgs_get_CollectionChange(py::wrapper::Windows::Devices::Perception::PerceptionFrameSourcePropertiesChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionFrameSourcePropertiesChangedEventArgs", L"CollectionChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CollectionChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionFrameSourcePropertiesChangedEventArgs_get_Key(py::wrapper::Windows::Devices::Perception::PerceptionFrameSourcePropertiesChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionFrameSourcePropertiesChangedEventArgs", L"Key");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Key());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionFrameSourcePropertiesChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionFrameSourcePropertiesChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionFrameSourcePropertiesChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionFrameSourcePropertiesChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionFrameSourcePropertiesChangedEventArgs[] = {
        { "_assign_array_", _assign_array_PerceptionFrameSourcePropertiesChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionFrameSourcePropertiesChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionFrameSourcePropertiesChangedEventArgs[] = {
        { "collection_change", reinterpret_cast<getter>(PerceptionFrameSourcePropertiesChangedEventArgs_get_CollectionChange), nullptr, nullptr, nullptr },
        { "key", reinterpret_cast<getter>(PerceptionFrameSourcePropertiesChangedEventArgs_get_Key), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionFrameSourcePropertiesChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionFrameSourcePropertiesChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionFrameSourcePropertiesChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionFrameSourcePropertiesChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionFrameSourcePropertiesChangedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_PerceptionFrameSourcePropertiesChangedEventArgs = {
        "winrt._winrt_windows_devices_perception.PerceptionFrameSourcePropertiesChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionFrameSourcePropertiesChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionFrameSourcePropertiesChangedEventArgs};

    // ----- PerceptionFrameSourcePropertyChangeResult class --------------------

    static PyObject* _new_PerceptionFrameSourcePropertyChangeResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Perception::PerceptionFrameSourcePropertyChangeResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Perception::PerceptionFrameSourcePropertyChangeResult>::type_name);
        return nullptr;
    }

    static void _dealloc_PerceptionFrameSourcePropertyChangeResult(py::wrapper::Windows::Devices::Perception::PerceptionFrameSourcePropertyChangeResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionFrameSourcePropertyChangeResult_get_NewValue(py::wrapper::Windows::Devices::Perception::PerceptionFrameSourcePropertyChangeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionFrameSourcePropertyChangeResult", L"NewValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.NewValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionFrameSourcePropertyChangeResult_get_Status(py::wrapper::Windows::Devices::Perception::PerceptionFrameSourcePropertyChangeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionFrameSourcePropertyChangeResult", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionFrameSourcePropertyChangeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionFrameSourcePropertyChangeResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionFrameSourcePropertyChangeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionFrameSourcePropertyChangeResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionFrameSourcePropertyChangeResult[] = {
        { "_assign_array_", _assign_array_PerceptionFrameSourcePropertyChangeResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionFrameSourcePropertyChangeResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionFrameSourcePropertyChangeResult[] = {
        { "new_value", reinterpret_cast<getter>(PerceptionFrameSourcePropertyChangeResult_get_NewValue), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(PerceptionFrameSourcePropertyChangeResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionFrameSourcePropertyChangeResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionFrameSourcePropertyChangeResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionFrameSourcePropertyChangeResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionFrameSourcePropertyChangeResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionFrameSourcePropertyChangeResult) },
        { }
    };

    static PyType_Spec type_spec_PerceptionFrameSourcePropertyChangeResult = {
        "winrt._winrt_windows_devices_perception.PerceptionFrameSourcePropertyChangeResult",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionFrameSourcePropertyChangeResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionFrameSourcePropertyChangeResult};

    // ----- PerceptionInfraredFrame class --------------------

    static PyObject* _new_PerceptionInfraredFrame(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Perception::PerceptionInfraredFrame>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Perception::PerceptionInfraredFrame>::type_name);
        return nullptr;
    }

    static void _dealloc_PerceptionInfraredFrame(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrame* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionInfraredFrame_Close(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrame* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionInfraredFrame", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrame_get_VideoFrame(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrame", L"VideoFrame");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionInfraredFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionInfraredFrame>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionInfraredFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionInfraredFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_PerceptionInfraredFrame(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrame* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_PerceptionInfraredFrame(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrame* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionInfraredFrame[] = {
        { "close", reinterpret_cast<PyCFunction>(PerceptionInfraredFrame_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PerceptionInfraredFrame, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionInfraredFrame), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_PerceptionInfraredFrame), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_PerceptionInfraredFrame), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionInfraredFrame[] = {
        { "video_frame", reinterpret_cast<getter>(PerceptionInfraredFrame_get_VideoFrame), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionInfraredFrame[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionInfraredFrame) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionInfraredFrame) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionInfraredFrame) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionInfraredFrame) },
        { }
    };

    static PyType_Spec type_spec_PerceptionInfraredFrame = {
        "winrt._winrt_windows_devices_perception.PerceptionInfraredFrame",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionInfraredFrame};

    // ----- PerceptionInfraredFrameArrivedEventArgs class --------------------

    static PyObject* _new_PerceptionInfraredFrameArrivedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Perception::PerceptionInfraredFrameArrivedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Perception::PerceptionInfraredFrameArrivedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PerceptionInfraredFrameArrivedEventArgs(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameArrivedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionInfraredFrameArrivedEventArgs_TryOpenFrame(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameArrivedEventArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameArrivedEventArgs", L"TryOpenFrame", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TryOpenFrame());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameArrivedEventArgs_get_RelativeTime(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameArrivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameArrivedEventArgs", L"RelativeTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionInfraredFrameArrivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionInfraredFrameArrivedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionInfraredFrameArrivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionInfraredFrameArrivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionInfraredFrameArrivedEventArgs[] = {
        { "try_open_frame", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameArrivedEventArgs_TryOpenFrame), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PerceptionInfraredFrameArrivedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionInfraredFrameArrivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionInfraredFrameArrivedEventArgs[] = {
        { "relative_time", reinterpret_cast<getter>(PerceptionInfraredFrameArrivedEventArgs_get_RelativeTime), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionInfraredFrameArrivedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionInfraredFrameArrivedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionInfraredFrameArrivedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionInfraredFrameArrivedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionInfraredFrameArrivedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_PerceptionInfraredFrameArrivedEventArgs = {
        "winrt._winrt_windows_devices_perception.PerceptionInfraredFrameArrivedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameArrivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionInfraredFrameArrivedEventArgs};

    // ----- PerceptionInfraredFrameReader class --------------------

    static PyObject* _new_PerceptionInfraredFrameReader(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Perception::PerceptionInfraredFrameReader>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Perception::PerceptionInfraredFrameReader>::type_name);
        return nullptr;
    }

    static void _dealloc_PerceptionInfraredFrameReader(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameReader* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionInfraredFrameReader_Close(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameReader", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameReader_TryReadLatestFrame(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameReader* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameReader", L"TryReadLatestFrame", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.TryReadLatestFrame());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameReader_get_IsPaused(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameReader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameReader", L"IsPaused");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPaused());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PerceptionInfraredFrameReader_put_IsPaused(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameReader", L"IsPaused");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsPaused(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PerceptionInfraredFrameReader_get_Source(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameReader* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameReader", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameReader_add_FrameArrived(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameReader* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameReader", L"FrameArrived");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionInfraredFrameReader, winrt::Windows::Devices::Perception::PerceptionInfraredFrameArrivedEventArgs>>(arg);

            return py::convert(self->obj.FrameArrived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameReader_remove_FrameArrived(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameReader* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameReader", L"FrameArrived");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FrameArrived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionInfraredFrameReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionInfraredFrameReader>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionInfraredFrameReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionInfraredFrameReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_PerceptionInfraredFrameReader(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameReader* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_PerceptionInfraredFrameReader(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameReader* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionInfraredFrameReader[] = {
        { "close", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameReader_Close), METH_VARARGS, nullptr },
        { "try_read_latest_frame", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameReader_TryReadLatestFrame), METH_VARARGS, nullptr },
        { "add_frame_arrived", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameReader_add_FrameArrived), METH_O, nullptr },
        { "remove_frame_arrived", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameReader_remove_FrameArrived), METH_O, nullptr },
        { "_assign_array_", _assign_array_PerceptionInfraredFrameReader, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionInfraredFrameReader), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_PerceptionInfraredFrameReader), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_PerceptionInfraredFrameReader), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionInfraredFrameReader[] = {
        { "is_paused", reinterpret_cast<getter>(PerceptionInfraredFrameReader_get_IsPaused), reinterpret_cast<setter>(PerceptionInfraredFrameReader_put_IsPaused), nullptr, nullptr },
        { "source", reinterpret_cast<getter>(PerceptionInfraredFrameReader_get_Source), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionInfraredFrameReader[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionInfraredFrameReader) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionInfraredFrameReader) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionInfraredFrameReader) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionInfraredFrameReader) },
        { }
    };

    static PyType_Spec type_spec_PerceptionInfraredFrameReader = {
        "winrt._winrt_windows_devices_perception.PerceptionInfraredFrameReader",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionInfraredFrameReader};

    // ----- PerceptionInfraredFrameSource class --------------------

    static PyObject* _new_PerceptionInfraredFrameSource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSource>::type_name);
        return nullptr;
    }

    static void _dealloc_PerceptionInfraredFrameSource(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionInfraredFrameSource_AcquireControlSession(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"AcquireControlSession", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.AcquireControlSession());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_CanControlIndependentlyFrom(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"CanControlIndependentlyFrom", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CanControlIndependentlyFrom(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_CreateWatcher(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"CreateWatcher", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Perception::PerceptionInfraredFrameSource::CreateWatcher());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_FindAllAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"FindAllAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Perception::PerceptionInfraredFrameSource::FindAllAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"FromIdAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Perception::PerceptionInfraredFrameSource::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_IsCorrelatedWith(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"IsCorrelatedWith", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.IsCorrelatedWith(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_OpenReader(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"OpenReader", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.OpenReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_RequestAccessAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"RequestAccessAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Perception::PerceptionInfraredFrameSource::RequestAccessAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_TryGetDepthCorrelatedCameraIntrinsicsAsync(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"TryGetDepthCorrelatedCameraIntrinsicsAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource>(args, 0);

                return py::convert(self->obj.TryGetDepthCorrelatedCameraIntrinsicsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_TryGetDepthCorrelatedCoordinateMapperAsync(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"TryGetDepthCorrelatedCoordinateMapperAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource>(args, 1);

                return py::convert(self->obj.TryGetDepthCorrelatedCoordinateMapperAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_TryGetTransformTo(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"TryGetTransformTo", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Foundation::Numerics::float4x4 param1{};

                auto return_value = self->obj.TryGetTransformTo(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_TrySetVideoProfileAsync(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"TrySetVideoProfileAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionControlSession>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionVideoProfile>(args, 1);

                return py::convert(self->obj.TrySetVideoProfileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_get_Active(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"Active");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Active());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_get_Available(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"Available");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Available());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_get_AvailableVideoProfiles(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"AvailableVideoProfiles");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AvailableVideoProfiles());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_get_CameraIntrinsics(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"CameraIntrinsics");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CameraIntrinsics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_get_DeviceKind(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"DeviceKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_get_DisplayName(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_get_Id(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_get_IsControlled(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"IsControlled");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsControlled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_get_Properties(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"Properties");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_get_SupportedVideoProfiles(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"SupportedVideoProfiles");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedVideoProfiles());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_get_VideoProfile(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"VideoProfile");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_get_DeviceId(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"DeviceId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_add_ActiveChanged(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"ActiveChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ActiveChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_remove_ActiveChanged(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"ActiveChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ActiveChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_add_AvailableChanged(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"AvailableChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.AvailableChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_remove_AvailableChanged(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"AvailableChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AvailableChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_add_CameraIntrinsicsChanged(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"CameraIntrinsicsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.CameraIntrinsicsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_remove_CameraIntrinsicsChanged(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"CameraIntrinsicsChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CameraIntrinsicsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_add_PropertiesChanged(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"PropertiesChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSource, winrt::Windows::Devices::Perception::PerceptionFrameSourcePropertiesChangedEventArgs>>(arg);

            return py::convert(self->obj.PropertiesChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_remove_PropertiesChanged(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"PropertiesChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PropertiesChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_add_VideoProfileChanged(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"VideoProfileChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.VideoProfileChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_remove_VideoProfileChanged(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSource", L"VideoProfileChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VideoProfileChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionInfraredFrameSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionInfraredFrameSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionInfraredFrameSource[] = {
        { "acquire_control_session", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_AcquireControlSession), METH_VARARGS, nullptr },
        { "can_control_independently_from", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_CanControlIndependentlyFrom), METH_VARARGS, nullptr },
        { "is_correlated_with", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_IsCorrelatedWith), METH_VARARGS, nullptr },
        { "open_reader", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_OpenReader), METH_VARARGS, nullptr },
        { "try_get_depth_correlated_camera_intrinsics_async", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_TryGetDepthCorrelatedCameraIntrinsicsAsync), METH_VARARGS, nullptr },
        { "try_get_depth_correlated_coordinate_mapper_async", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_TryGetDepthCorrelatedCoordinateMapperAsync), METH_VARARGS, nullptr },
        { "try_get_transform_to", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_TryGetTransformTo), METH_VARARGS, nullptr },
        { "try_set_video_profile_async", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_TrySetVideoProfileAsync), METH_VARARGS, nullptr },
        { "add_active_changed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_add_ActiveChanged), METH_O, nullptr },
        { "remove_active_changed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_remove_ActiveChanged), METH_O, nullptr },
        { "add_available_changed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_add_AvailableChanged), METH_O, nullptr },
        { "remove_available_changed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_remove_AvailableChanged), METH_O, nullptr },
        { "add_camera_intrinsics_changed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_add_CameraIntrinsicsChanged), METH_O, nullptr },
        { "remove_camera_intrinsics_changed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_remove_CameraIntrinsicsChanged), METH_O, nullptr },
        { "add_properties_changed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_add_PropertiesChanged), METH_O, nullptr },
        { "remove_properties_changed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_remove_PropertiesChanged), METH_O, nullptr },
        { "add_video_profile_changed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_add_VideoProfileChanged), METH_O, nullptr },
        { "remove_video_profile_changed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_remove_VideoProfileChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_PerceptionInfraredFrameSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionInfraredFrameSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionInfraredFrameSource[] = {
        { "active", reinterpret_cast<getter>(PerceptionInfraredFrameSource_get_Active), nullptr, nullptr, nullptr },
        { "available", reinterpret_cast<getter>(PerceptionInfraredFrameSource_get_Available), nullptr, nullptr, nullptr },
        { "available_video_profiles", reinterpret_cast<getter>(PerceptionInfraredFrameSource_get_AvailableVideoProfiles), nullptr, nullptr, nullptr },
        { "camera_intrinsics", reinterpret_cast<getter>(PerceptionInfraredFrameSource_get_CameraIntrinsics), nullptr, nullptr, nullptr },
        { "device_kind", reinterpret_cast<getter>(PerceptionInfraredFrameSource_get_DeviceKind), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(PerceptionInfraredFrameSource_get_DisplayName), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(PerceptionInfraredFrameSource_get_Id), nullptr, nullptr, nullptr },
        { "is_controlled", reinterpret_cast<getter>(PerceptionInfraredFrameSource_get_IsControlled), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(PerceptionInfraredFrameSource_get_Properties), nullptr, nullptr, nullptr },
        { "supported_video_profiles", reinterpret_cast<getter>(PerceptionInfraredFrameSource_get_SupportedVideoProfiles), nullptr, nullptr, nullptr },
        { "video_profile", reinterpret_cast<getter>(PerceptionInfraredFrameSource_get_VideoProfile), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(PerceptionInfraredFrameSource_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionInfraredFrameSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionInfraredFrameSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionInfraredFrameSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionInfraredFrameSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionInfraredFrameSource) },
        { }
    };

    static PyType_Spec type_spec_PerceptionInfraredFrameSource = {
        "winrt._winrt_windows_devices_perception.PerceptionInfraredFrameSource",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionInfraredFrameSource};

    static PyGetSetDef getset_PerceptionInfraredFrameSource_Static[] = {
        { }
    };

    static PyMethodDef methods_PerceptionInfraredFrameSource_Static[] = {
        { "create_watcher", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_CreateWatcher), METH_VARARGS, nullptr },
        { "find_all_async", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_FindAllAsync), METH_VARARGS, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_FromIdAsync), METH_VARARGS, nullptr },
        { "request_access_async", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_RequestAccessAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_PerceptionInfraredFrameSource_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PerceptionInfraredFrameSource_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PerceptionInfraredFrameSource_Static) },
        { }
    };

    static PyType_Spec type_spec_PerceptionInfraredFrameSource_Static =
    {
        "winrt._winrt_windows_devices_perception.PerceptionInfraredFrameSource_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PerceptionInfraredFrameSource_Static
    };

    // ----- PerceptionInfraredFrameSourceAddedEventArgs class --------------------

    static PyObject* _new_PerceptionInfraredFrameSourceAddedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceAddedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceAddedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PerceptionInfraredFrameSourceAddedEventArgs(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceAddedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionInfraredFrameSourceAddedEventArgs_get_FrameSource(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceAddedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSourceAddedEventArgs", L"FrameSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FrameSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionInfraredFrameSourceAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceAddedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionInfraredFrameSourceAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceAddedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionInfraredFrameSourceAddedEventArgs[] = {
        { "_assign_array_", _assign_array_PerceptionInfraredFrameSourceAddedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionInfraredFrameSourceAddedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionInfraredFrameSourceAddedEventArgs[] = {
        { "frame_source", reinterpret_cast<getter>(PerceptionInfraredFrameSourceAddedEventArgs_get_FrameSource), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionInfraredFrameSourceAddedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionInfraredFrameSourceAddedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionInfraredFrameSourceAddedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionInfraredFrameSourceAddedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionInfraredFrameSourceAddedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_PerceptionInfraredFrameSourceAddedEventArgs = {
        "winrt._winrt_windows_devices_perception.PerceptionInfraredFrameSourceAddedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceAddedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionInfraredFrameSourceAddedEventArgs};

    // ----- PerceptionInfraredFrameSourceRemovedEventArgs class --------------------

    static PyObject* _new_PerceptionInfraredFrameSourceRemovedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceRemovedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceRemovedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PerceptionInfraredFrameSourceRemovedEventArgs(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceRemovedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionInfraredFrameSourceRemovedEventArgs_get_FrameSource(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceRemovedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSourceRemovedEventArgs", L"FrameSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FrameSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionInfraredFrameSourceRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceRemovedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionInfraredFrameSourceRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceRemovedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionInfraredFrameSourceRemovedEventArgs[] = {
        { "_assign_array_", _assign_array_PerceptionInfraredFrameSourceRemovedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionInfraredFrameSourceRemovedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionInfraredFrameSourceRemovedEventArgs[] = {
        { "frame_source", reinterpret_cast<getter>(PerceptionInfraredFrameSourceRemovedEventArgs_get_FrameSource), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionInfraredFrameSourceRemovedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionInfraredFrameSourceRemovedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionInfraredFrameSourceRemovedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionInfraredFrameSourceRemovedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionInfraredFrameSourceRemovedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_PerceptionInfraredFrameSourceRemovedEventArgs = {
        "winrt._winrt_windows_devices_perception.PerceptionInfraredFrameSourceRemovedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceRemovedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionInfraredFrameSourceRemovedEventArgs};

    // ----- PerceptionInfraredFrameSourceWatcher class --------------------

    static PyObject* _new_PerceptionInfraredFrameSourceWatcher(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher>::type_name);
        return nullptr;
    }

    static void _dealloc_PerceptionInfraredFrameSourceWatcher(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionInfraredFrameSourceWatcher_Start(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher", L"Start", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSourceWatcher_Stop(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher", L"Stop", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSourceWatcher_get_Status(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSourceWatcher_add_EnumerationCompleted(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher", L"EnumerationCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.EnumerationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSourceWatcher_remove_EnumerationCompleted(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher", L"EnumerationCompleted");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnumerationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSourceWatcher_add_SourceAdded(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher", L"SourceAdded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher, winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceAddedEventArgs>>(arg);

            return py::convert(self->obj.SourceAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSourceWatcher_remove_SourceAdded(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher", L"SourceAdded");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSourceWatcher_add_SourceRemoved(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher", L"SourceRemoved");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher, winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceRemovedEventArgs>>(arg);

            return py::convert(self->obj.SourceRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSourceWatcher_remove_SourceRemoved(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher", L"SourceRemoved");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSourceWatcher_add_Stopped(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher", L"Stopped");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Stopped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSourceWatcher_remove_Stopped(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Perception.PerceptionInfraredFrameSourceWatcher", L"Stopped");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Stopped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionInfraredFrameSourceWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionInfraredFrameSourceWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionInfraredFrameSourceWatcher[] = {
        { "start", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSourceWatcher_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSourceWatcher_Stop), METH_VARARGS, nullptr },
        { "add_enumeration_completed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSourceWatcher_add_EnumerationCompleted), METH_O, nullptr },
        { "remove_enumeration_completed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSourceWatcher_remove_EnumerationCompleted), METH_O, nullptr },
        { "add_source_added", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSourceWatcher_add_SourceAdded), METH_O, nullptr },
        { "remove_source_added", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSourceWatcher_remove_SourceAdded), METH_O, nullptr },
        { "add_source_removed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSourceWatcher_add_SourceRemoved), METH_O, nullptr },
        { "remove_source_removed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSourceWatcher_remove_SourceRemoved), METH_O, nullptr },
        { "add_stopped", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSourceWatcher_add_Stopped), METH_O, nullptr },
        { "remove_stopped", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSourceWatcher_remove_Stopped), METH_O, nullptr },
        { "_assign_array_", _assign_array_PerceptionInfraredFrameSourceWatcher, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionInfraredFrameSourceWatcher), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionInfraredFrameSourceWatcher[] = {
        { "status", reinterpret_cast<getter>(PerceptionInfraredFrameSourceWatcher_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionInfraredFrameSourceWatcher[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionInfraredFrameSourceWatcher) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionInfraredFrameSourceWatcher) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionInfraredFrameSourceWatcher) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionInfraredFrameSourceWatcher) },
        { }
    };

    static PyType_Spec type_spec_PerceptionInfraredFrameSourceWatcher = {
        "winrt._winrt_windows_devices_perception.PerceptionInfraredFrameSourceWatcher",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionInfraredFrameSourceWatcher};

    // ----- PerceptionVideoProfile class --------------------

    static PyObject* _new_PerceptionVideoProfile(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Perception::PerceptionVideoProfile>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Perception::PerceptionVideoProfile>::type_name);
        return nullptr;
    }

    static void _dealloc_PerceptionVideoProfile(py::wrapper::Windows::Devices::Perception::PerceptionVideoProfile* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionVideoProfile_IsEqual(py::wrapper::Windows::Devices::Perception::PerceptionVideoProfile* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Perception.PerceptionVideoProfile", L"IsEqual", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionVideoProfile>(args, 0);

                return py::convert(self->obj.IsEqual(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionVideoProfile_get_BitmapAlphaMode(py::wrapper::Windows::Devices::Perception::PerceptionVideoProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionVideoProfile", L"BitmapAlphaMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BitmapAlphaMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionVideoProfile_get_BitmapPixelFormat(py::wrapper::Windows::Devices::Perception::PerceptionVideoProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionVideoProfile", L"BitmapPixelFormat");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BitmapPixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionVideoProfile_get_FrameDuration(py::wrapper::Windows::Devices::Perception::PerceptionVideoProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionVideoProfile", L"FrameDuration");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FrameDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionVideoProfile_get_Height(py::wrapper::Windows::Devices::Perception::PerceptionVideoProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionVideoProfile", L"Height");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionVideoProfile_get_Width(py::wrapper::Windows::Devices::Perception::PerceptionVideoProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Perception.PerceptionVideoProfile", L"Width");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PerceptionVideoProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Perception::PerceptionVideoProfile>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PerceptionVideoProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionVideoProfile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionVideoProfile[] = {
        { "is_equal", reinterpret_cast<PyCFunction>(PerceptionVideoProfile_IsEqual), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PerceptionVideoProfile, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionVideoProfile), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionVideoProfile[] = {
        { "bitmap_alpha_mode", reinterpret_cast<getter>(PerceptionVideoProfile_get_BitmapAlphaMode), nullptr, nullptr, nullptr },
        { "bitmap_pixel_format", reinterpret_cast<getter>(PerceptionVideoProfile_get_BitmapPixelFormat), nullptr, nullptr, nullptr },
        { "frame_duration", reinterpret_cast<getter>(PerceptionVideoProfile_get_FrameDuration), nullptr, nullptr, nullptr },
        { "height", reinterpret_cast<getter>(PerceptionVideoProfile_get_Height), nullptr, nullptr, nullptr },
        { "width", reinterpret_cast<getter>(PerceptionVideoProfile_get_Width), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionVideoProfile[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PerceptionVideoProfile) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PerceptionVideoProfile) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PerceptionVideoProfile) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PerceptionVideoProfile) },
        { }
    };

    static PyType_Spec type_spec_PerceptionVideoProfile = {
        "winrt._winrt_windows_devices_perception.PerceptionVideoProfile",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionVideoProfile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionVideoProfile};

    // ----- Windows.Devices.Perception Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Devices.Perception");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_devices_perception",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Devices::Perception

PyMODINIT_FUNC PyInit__winrt_windows_devices_perception(void) noexcept
{
    using namespace py::cpp::Windows::Devices::Perception;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownCameraIntrinsicsProperties_Static{PyType_FromSpec(&type_spec_KnownCameraIntrinsicsProperties_Static)};
    if (!type_KnownCameraIntrinsicsProperties_Static)
    {
        return nullptr;
    }

    py::pytype_handle KnownCameraIntrinsicsProperties_type{py::register_python_type(module.get(), &type_spec_KnownCameraIntrinsicsProperties, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KnownCameraIntrinsicsProperties_Static.get()))};
    if (!KnownCameraIntrinsicsProperties_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownPerceptionColorFrameSourceProperties_Static{PyType_FromSpec(&type_spec_KnownPerceptionColorFrameSourceProperties_Static)};
    if (!type_KnownPerceptionColorFrameSourceProperties_Static)
    {
        return nullptr;
    }

    py::pytype_handle KnownPerceptionColorFrameSourceProperties_type{py::register_python_type(module.get(), &type_spec_KnownPerceptionColorFrameSourceProperties, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KnownPerceptionColorFrameSourceProperties_Static.get()))};
    if (!KnownPerceptionColorFrameSourceProperties_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownPerceptionDepthFrameSourceProperties_Static{PyType_FromSpec(&type_spec_KnownPerceptionDepthFrameSourceProperties_Static)};
    if (!type_KnownPerceptionDepthFrameSourceProperties_Static)
    {
        return nullptr;
    }

    py::pytype_handle KnownPerceptionDepthFrameSourceProperties_type{py::register_python_type(module.get(), &type_spec_KnownPerceptionDepthFrameSourceProperties, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KnownPerceptionDepthFrameSourceProperties_Static.get()))};
    if (!KnownPerceptionDepthFrameSourceProperties_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownPerceptionFrameSourceProperties_Static{PyType_FromSpec(&type_spec_KnownPerceptionFrameSourceProperties_Static)};
    if (!type_KnownPerceptionFrameSourceProperties_Static)
    {
        return nullptr;
    }

    py::pytype_handle KnownPerceptionFrameSourceProperties_type{py::register_python_type(module.get(), &type_spec_KnownPerceptionFrameSourceProperties, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KnownPerceptionFrameSourceProperties_Static.get()))};
    if (!KnownPerceptionFrameSourceProperties_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownPerceptionInfraredFrameSourceProperties_Static{PyType_FromSpec(&type_spec_KnownPerceptionInfraredFrameSourceProperties_Static)};
    if (!type_KnownPerceptionInfraredFrameSourceProperties_Static)
    {
        return nullptr;
    }

    py::pytype_handle KnownPerceptionInfraredFrameSourceProperties_type{py::register_python_type(module.get(), &type_spec_KnownPerceptionInfraredFrameSourceProperties, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KnownPerceptionInfraredFrameSourceProperties_Static.get()))};
    if (!KnownPerceptionInfraredFrameSourceProperties_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownPerceptionVideoFrameSourceProperties_Static{PyType_FromSpec(&type_spec_KnownPerceptionVideoFrameSourceProperties_Static)};
    if (!type_KnownPerceptionVideoFrameSourceProperties_Static)
    {
        return nullptr;
    }

    py::pytype_handle KnownPerceptionVideoFrameSourceProperties_type{py::register_python_type(module.get(), &type_spec_KnownPerceptionVideoFrameSourceProperties, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KnownPerceptionVideoFrameSourceProperties_Static.get()))};
    if (!KnownPerceptionVideoFrameSourceProperties_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_KnownPerceptionVideoProfileProperties_Static{PyType_FromSpec(&type_spec_KnownPerceptionVideoProfileProperties_Static)};
    if (!type_KnownPerceptionVideoProfileProperties_Static)
    {
        return nullptr;
    }

    py::pytype_handle KnownPerceptionVideoProfileProperties_type{py::register_python_type(module.get(), &type_spec_KnownPerceptionVideoProfileProperties, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_KnownPerceptionVideoProfileProperties_Static.get()))};
    if (!KnownPerceptionVideoProfileProperties_type)
    {
        return nullptr;
    }

    py::pytype_handle PerceptionColorFrame_type{py::register_python_type(module.get(), &type_spec_PerceptionColorFrame, object_bases.get(), nullptr)};
    if (!PerceptionColorFrame_type)
    {
        return nullptr;
    }

    py::pytype_handle PerceptionColorFrameArrivedEventArgs_type{py::register_python_type(module.get(), &type_spec_PerceptionColorFrameArrivedEventArgs, object_bases.get(), nullptr)};
    if (!PerceptionColorFrameArrivedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PerceptionColorFrameReader_type{py::register_python_type(module.get(), &type_spec_PerceptionColorFrameReader, object_bases.get(), nullptr)};
    if (!PerceptionColorFrameReader_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_PerceptionColorFrameSource_Static{PyType_FromSpec(&type_spec_PerceptionColorFrameSource_Static)};
    if (!type_PerceptionColorFrameSource_Static)
    {
        return nullptr;
    }

    py::pytype_handle PerceptionColorFrameSource_type{py::register_python_type(module.get(), &type_spec_PerceptionColorFrameSource, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PerceptionColorFrameSource_Static.get()))};
    if (!PerceptionColorFrameSource_type)
    {
        return nullptr;
    }

    py::pytype_handle PerceptionColorFrameSourceAddedEventArgs_type{py::register_python_type(module.get(), &type_spec_PerceptionColorFrameSourceAddedEventArgs, object_bases.get(), nullptr)};
    if (!PerceptionColorFrameSourceAddedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PerceptionColorFrameSourceRemovedEventArgs_type{py::register_python_type(module.get(), &type_spec_PerceptionColorFrameSourceRemovedEventArgs, object_bases.get(), nullptr)};
    if (!PerceptionColorFrameSourceRemovedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PerceptionColorFrameSourceWatcher_type{py::register_python_type(module.get(), &type_spec_PerceptionColorFrameSourceWatcher, object_bases.get(), nullptr)};
    if (!PerceptionColorFrameSourceWatcher_type)
    {
        return nullptr;
    }

    py::pytype_handle PerceptionControlSession_type{py::register_python_type(module.get(), &type_spec_PerceptionControlSession, object_bases.get(), nullptr)};
    if (!PerceptionControlSession_type)
    {
        return nullptr;
    }

    py::pytype_handle PerceptionDepthCorrelatedCameraIntrinsics_type{py::register_python_type(module.get(), &type_spec_PerceptionDepthCorrelatedCameraIntrinsics, object_bases.get(), nullptr)};
    if (!PerceptionDepthCorrelatedCameraIntrinsics_type)
    {
        return nullptr;
    }

    py::pytype_handle PerceptionDepthCorrelatedCoordinateMapper_type{py::register_python_type(module.get(), &type_spec_PerceptionDepthCorrelatedCoordinateMapper, object_bases.get(), nullptr)};
    if (!PerceptionDepthCorrelatedCoordinateMapper_type)
    {
        return nullptr;
    }

    py::pytype_handle PerceptionDepthFrame_type{py::register_python_type(module.get(), &type_spec_PerceptionDepthFrame, object_bases.get(), nullptr)};
    if (!PerceptionDepthFrame_type)
    {
        return nullptr;
    }

    py::pytype_handle PerceptionDepthFrameArrivedEventArgs_type{py::register_python_type(module.get(), &type_spec_PerceptionDepthFrameArrivedEventArgs, object_bases.get(), nullptr)};
    if (!PerceptionDepthFrameArrivedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PerceptionDepthFrameReader_type{py::register_python_type(module.get(), &type_spec_PerceptionDepthFrameReader, object_bases.get(), nullptr)};
    if (!PerceptionDepthFrameReader_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_PerceptionDepthFrameSource_Static{PyType_FromSpec(&type_spec_PerceptionDepthFrameSource_Static)};
    if (!type_PerceptionDepthFrameSource_Static)
    {
        return nullptr;
    }

    py::pytype_handle PerceptionDepthFrameSource_type{py::register_python_type(module.get(), &type_spec_PerceptionDepthFrameSource, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PerceptionDepthFrameSource_Static.get()))};
    if (!PerceptionDepthFrameSource_type)
    {
        return nullptr;
    }

    py::pytype_handle PerceptionDepthFrameSourceAddedEventArgs_type{py::register_python_type(module.get(), &type_spec_PerceptionDepthFrameSourceAddedEventArgs, object_bases.get(), nullptr)};
    if (!PerceptionDepthFrameSourceAddedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PerceptionDepthFrameSourceRemovedEventArgs_type{py::register_python_type(module.get(), &type_spec_PerceptionDepthFrameSourceRemovedEventArgs, object_bases.get(), nullptr)};
    if (!PerceptionDepthFrameSourceRemovedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PerceptionDepthFrameSourceWatcher_type{py::register_python_type(module.get(), &type_spec_PerceptionDepthFrameSourceWatcher, object_bases.get(), nullptr)};
    if (!PerceptionDepthFrameSourceWatcher_type)
    {
        return nullptr;
    }

    py::pytype_handle PerceptionFrameSourcePropertiesChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_PerceptionFrameSourcePropertiesChangedEventArgs, object_bases.get(), nullptr)};
    if (!PerceptionFrameSourcePropertiesChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PerceptionFrameSourcePropertyChangeResult_type{py::register_python_type(module.get(), &type_spec_PerceptionFrameSourcePropertyChangeResult, object_bases.get(), nullptr)};
    if (!PerceptionFrameSourcePropertyChangeResult_type)
    {
        return nullptr;
    }

    py::pytype_handle PerceptionInfraredFrame_type{py::register_python_type(module.get(), &type_spec_PerceptionInfraredFrame, object_bases.get(), nullptr)};
    if (!PerceptionInfraredFrame_type)
    {
        return nullptr;
    }

    py::pytype_handle PerceptionInfraredFrameArrivedEventArgs_type{py::register_python_type(module.get(), &type_spec_PerceptionInfraredFrameArrivedEventArgs, object_bases.get(), nullptr)};
    if (!PerceptionInfraredFrameArrivedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PerceptionInfraredFrameReader_type{py::register_python_type(module.get(), &type_spec_PerceptionInfraredFrameReader, object_bases.get(), nullptr)};
    if (!PerceptionInfraredFrameReader_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_PerceptionInfraredFrameSource_Static{PyType_FromSpec(&type_spec_PerceptionInfraredFrameSource_Static)};
    if (!type_PerceptionInfraredFrameSource_Static)
    {
        return nullptr;
    }

    py::pytype_handle PerceptionInfraredFrameSource_type{py::register_python_type(module.get(), &type_spec_PerceptionInfraredFrameSource, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PerceptionInfraredFrameSource_Static.get()))};
    if (!PerceptionInfraredFrameSource_type)
    {
        return nullptr;
    }

    py::pytype_handle PerceptionInfraredFrameSourceAddedEventArgs_type{py::register_python_type(module.get(), &type_spec_PerceptionInfraredFrameSourceAddedEventArgs, object_bases.get(), nullptr)};
    if (!PerceptionInfraredFrameSourceAddedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PerceptionInfraredFrameSourceRemovedEventArgs_type{py::register_python_type(module.get(), &type_spec_PerceptionInfraredFrameSourceRemovedEventArgs, object_bases.get(), nullptr)};
    if (!PerceptionInfraredFrameSourceRemovedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PerceptionInfraredFrameSourceWatcher_type{py::register_python_type(module.get(), &type_spec_PerceptionInfraredFrameSourceWatcher, object_bases.get(), nullptr)};
    if (!PerceptionInfraredFrameSourceWatcher_type)
    {
        return nullptr;
    }

    py::pytype_handle PerceptionVideoProfile_type{py::register_python_type(module.get(), &type_spec_PerceptionVideoProfile, object_bases.get(), nullptr)};
    if (!PerceptionVideoProfile_type)
    {
        return nullptr;
    }


    return module.detach();
}
