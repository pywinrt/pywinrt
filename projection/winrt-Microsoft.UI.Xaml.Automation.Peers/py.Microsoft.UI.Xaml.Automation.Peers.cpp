// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Microsoft.UI.Xaml.Automation.Peers.h"

namespace py::cpp::Microsoft::UI::Xaml::Automation::Peers
{
    // ----- AnimatedVisualPlayerAutomationPeer class --------------------

    static PyObject* _new_AnimatedVisualPlayerAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::AnimatedVisualPlayer>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::AnimatedVisualPlayerAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AnimatedVisualPlayerAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AnimatedVisualPlayerAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_AnimatedVisualPlayerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::AnimatedVisualPlayerAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AnimatedVisualPlayerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::AnimatedVisualPlayerAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AnimatedVisualPlayerAutomationPeer[] = {
        { "_assign_array_", _assign_array_AnimatedVisualPlayerAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AnimatedVisualPlayerAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AnimatedVisualPlayerAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_AnimatedVisualPlayerAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AnimatedVisualPlayerAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AnimatedVisualPlayerAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AnimatedVisualPlayerAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AnimatedVisualPlayerAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_AnimatedVisualPlayerAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.AnimatedVisualPlayerAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AnimatedVisualPlayerAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AnimatedVisualPlayerAutomationPeer};

    static PyGetSetDef getset_AnimatedVisualPlayerAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_AnimatedVisualPlayerAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_AnimatedVisualPlayerAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AnimatedVisualPlayerAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AnimatedVisualPlayerAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_AnimatedVisualPlayerAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.AnimatedVisualPlayerAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AnimatedVisualPlayerAutomationPeer_Static
    };

    // ----- AppBarAutomationPeer class --------------------

    static PyObject* _new_AppBarAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::AppBar>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::AppBarAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppBarAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBarAutomationPeer_Close(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_Collapse(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"Collapse", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Collapse();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_Expand(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"Expand", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Expand();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_SetVisualState(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"SetVisualState", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::WindowVisualState>(args, 0);

                self->obj.SetVisualState(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_Toggle(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"Toggle", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Toggle();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_WaitForInputIdle(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"WaitForInputIdle", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.WaitForInputIdle(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_get_ExpandCollapseState(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"ExpandCollapseState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpandCollapseState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_get_ToggleState(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"ToggleState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ToggleState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_get_InteractionState(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"InteractionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InteractionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_get_IsModal(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"IsModal");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsModal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_get_IsTopmost(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"IsTopmost");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsTopmost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_get_Maximizable(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"Maximizable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Maximizable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_get_Minimizable(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"Minimizable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Minimizable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppBarAutomationPeer_get_VisualState(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AppBarAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.AppBarAutomationPeer", L"VisualState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VisualState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::AppBarAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::AppBarAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBarAutomationPeer[] = {
        { "close", reinterpret_cast<PyCFunction>(AppBarAutomationPeer_Close), METH_VARARGS, nullptr },
        { "collapse", reinterpret_cast<PyCFunction>(AppBarAutomationPeer_Collapse), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(AppBarAutomationPeer_Expand), METH_VARARGS, nullptr },
        { "set_visual_state", reinterpret_cast<PyCFunction>(AppBarAutomationPeer_SetVisualState), METH_VARARGS, nullptr },
        { "toggle", reinterpret_cast<PyCFunction>(AppBarAutomationPeer_Toggle), METH_VARARGS, nullptr },
        { "wait_for_input_idle", reinterpret_cast<PyCFunction>(AppBarAutomationPeer_WaitForInputIdle), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppBarAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBarAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBarAutomationPeer[] = {
        { "expand_collapse_state", reinterpret_cast<getter>(AppBarAutomationPeer_get_ExpandCollapseState), nullptr, nullptr, nullptr },
        { "toggle_state", reinterpret_cast<getter>(AppBarAutomationPeer_get_ToggleState), nullptr, nullptr, nullptr },
        { "interaction_state", reinterpret_cast<getter>(AppBarAutomationPeer_get_InteractionState), nullptr, nullptr, nullptr },
        { "is_modal", reinterpret_cast<getter>(AppBarAutomationPeer_get_IsModal), nullptr, nullptr, nullptr },
        { "is_topmost", reinterpret_cast<getter>(AppBarAutomationPeer_get_IsTopmost), nullptr, nullptr, nullptr },
        { "maximizable", reinterpret_cast<getter>(AppBarAutomationPeer_get_Maximizable), nullptr, nullptr, nullptr },
        { "minimizable", reinterpret_cast<getter>(AppBarAutomationPeer_get_Minimizable), nullptr, nullptr, nullptr },
        { "visual_state", reinterpret_cast<getter>(AppBarAutomationPeer_get_VisualState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBarAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBarAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBarAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBarAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBarAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_AppBarAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.AppBarAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AppBarAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBarAutomationPeer};

    static PyGetSetDef getset_AppBarAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_AppBarAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_AppBarAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AppBarAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AppBarAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_AppBarAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.AppBarAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AppBarAutomationPeer_Static
    };

    // ----- AppBarButtonAutomationPeer class --------------------

    static PyObject* _new_AppBarButtonAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::AppBarButton>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppBarButtonAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppBarButtonAutomationPeer_Collapse(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AppBarButtonAutomationPeer", L"Collapse", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Collapse();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBarButtonAutomationPeer_Expand(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AppBarButtonAutomationPeer", L"Expand", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Expand();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppBarButtonAutomationPeer_get_ExpandCollapseState(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.AppBarButtonAutomationPeer", L"ExpandCollapseState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpandCollapseState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AppBarButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBarButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBarButtonAutomationPeer[] = {
        { "collapse", reinterpret_cast<PyCFunction>(AppBarButtonAutomationPeer_Collapse), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(AppBarButtonAutomationPeer_Expand), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AppBarButtonAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBarButtonAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBarButtonAutomationPeer[] = {
        { "expand_collapse_state", reinterpret_cast<getter>(AppBarButtonAutomationPeer_get_ExpandCollapseState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppBarButtonAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBarButtonAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBarButtonAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBarButtonAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBarButtonAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_AppBarButtonAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.AppBarButtonAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AppBarButtonAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBarButtonAutomationPeer};

    static PyGetSetDef getset_AppBarButtonAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_AppBarButtonAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_AppBarButtonAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AppBarButtonAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AppBarButtonAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_AppBarButtonAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.AppBarButtonAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AppBarButtonAutomationPeer_Static
    };

    // ----- AppBarToggleButtonAutomationPeer class --------------------

    static PyObject* _new_AppBarToggleButtonAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::AppBarToggleButton>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::AppBarToggleButtonAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppBarToggleButtonAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AppBarToggleButtonAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_AppBarToggleButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::AppBarToggleButtonAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AppBarToggleButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::AppBarToggleButtonAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppBarToggleButtonAutomationPeer[] = {
        { "_assign_array_", _assign_array_AppBarToggleButtonAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppBarToggleButtonAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppBarToggleButtonAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_AppBarToggleButtonAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AppBarToggleButtonAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AppBarToggleButtonAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AppBarToggleButtonAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AppBarToggleButtonAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_AppBarToggleButtonAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.AppBarToggleButtonAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AppBarToggleButtonAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppBarToggleButtonAutomationPeer};

    static PyGetSetDef getset_AppBarToggleButtonAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_AppBarToggleButtonAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_AppBarToggleButtonAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AppBarToggleButtonAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AppBarToggleButtonAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_AppBarToggleButtonAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.AppBarToggleButtonAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AppBarToggleButtonAutomationPeer_Static
    };

    // ----- AutoSuggestBoxAutomationPeer class --------------------

    static PyObject* _new_AutoSuggestBoxAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::AutoSuggestBox>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::AutoSuggestBoxAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AutoSuggestBoxAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutoSuggestBoxAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AutoSuggestBoxAutomationPeer_Invoke(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutoSuggestBoxAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutoSuggestBoxAutomationPeer", L"Invoke", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Invoke();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_AutoSuggestBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::AutoSuggestBoxAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AutoSuggestBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::AutoSuggestBoxAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AutoSuggestBoxAutomationPeer[] = {
        { "invoke", reinterpret_cast<PyCFunction>(AutoSuggestBoxAutomationPeer_Invoke), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AutoSuggestBoxAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AutoSuggestBoxAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AutoSuggestBoxAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_AutoSuggestBoxAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AutoSuggestBoxAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AutoSuggestBoxAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AutoSuggestBoxAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AutoSuggestBoxAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_AutoSuggestBoxAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.AutoSuggestBoxAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutoSuggestBoxAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AutoSuggestBoxAutomationPeer};

    // ----- AutomationPeer class --------------------

    static PyObject* _new_AutomationPeer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer>::type_name);
        return nullptr;
    }

    static void _dealloc_AutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AutomationPeer_GenerateRawElementProviderRuntimeId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"GenerateRawElementProviderRuntimeId", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer::GenerateRawElementProviderRuntimeId());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetAcceleratorKey(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"GetAcceleratorKey", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetAcceleratorKey());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetAccessKey(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"GetAccessKey", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetAccessKey());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetAnnotations(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"GetAnnotations", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetAnnotations());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetAutomationControlType(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"GetAutomationControlType", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetAutomationControlType());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetAutomationId(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"GetAutomationId", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetAutomationId());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetBoundingRectangle(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"GetBoundingRectangle", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetBoundingRectangle());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetChildren(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"GetChildren", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetChildren());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetClassName(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"GetClassName", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetClassName());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetClickablePoint(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"GetClickablePoint", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetClickablePoint());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetControlledPeers(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"GetControlledPeers", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetControlledPeers());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetCulture(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"GetCulture", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetCulture());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetElementFromPoint(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"GetElementFromPoint", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.GetElementFromPoint(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetFocusedElement(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"GetFocusedElement", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetFocusedElement());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetFullDescription(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"GetFullDescription", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetFullDescription());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetHeadingLevel(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"GetHeadingLevel", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetHeadingLevel());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetHelpText(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"GetHelpText", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetHelpText());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetItemStatus(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"GetItemStatus", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetItemStatus());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetItemType(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"GetItemType", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetItemType());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetLabeledBy(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"GetLabeledBy", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetLabeledBy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetLandmarkType(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"GetLandmarkType", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetLandmarkType());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetLevel(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"GetLevel", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetLevel());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetLiveSetting(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"GetLiveSetting", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetLiveSetting());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetLocalizedControlType(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"GetLocalizedControlType", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetLocalizedControlType());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetLocalizedLandmarkType(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"GetLocalizedLandmarkType", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetLocalizedLandmarkType());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetName(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"GetName", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetName());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetOrientation(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"GetOrientation", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetOrientation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetParent(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"GetParent", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetParent());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetPattern(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"GetPattern", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Peers::PatternInterface>(args, 0);

                return py::convert(self->obj.GetPattern(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetPeerFromPoint(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"GetPeerFromPoint", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.GetPeerFromPoint(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetPositionInSet(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"GetPositionInSet", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetPositionInSet());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_GetSizeOfSet(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"GetSizeOfSet", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetSizeOfSet());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_HasKeyboardFocus(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"HasKeyboardFocus", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.HasKeyboardFocus());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_InvalidatePeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"InvalidatePeer", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.InvalidatePeer();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsContentElement(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"IsContentElement", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.IsContentElement());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsControlElement(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"IsControlElement", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.IsControlElement());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsDataValidForForm(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"IsDataValidForForm", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.IsDataValidForForm());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsDialog(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"IsDialog", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.IsDialog());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsEnabled(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"IsEnabled", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.IsEnabled());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsKeyboardFocusable(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"IsKeyboardFocusable", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.IsKeyboardFocusable());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsOffscreen(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"IsOffscreen", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.IsOffscreen());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsPassword(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"IsPassword", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.IsPassword());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsPeripheral(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"IsPeripheral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.IsPeripheral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_IsRequiredForForm(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"IsRequiredForForm", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.IsRequiredForForm());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_ListenerExists(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"ListenerExists", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Peers::AutomationEvents>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer::ListenerExists(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_Navigate(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"Navigate", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Peers::AutomationNavigationDirection>(args, 0);

                return py::convert(self->obj.Navigate(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_RaiseAutomationEvent(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"RaiseAutomationEvent", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Peers::AutomationEvents>(args, 0);

                self->obj.RaiseAutomationEvent(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_RaiseNotificationEvent(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"RaiseNotificationEvent", 4);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(4);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Peers::AutomationNotificationKind>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Peers::AutomationNotificationProcessing>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                self->obj.RaiseNotificationEvent(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_RaisePropertyChangedEvent(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"RaisePropertyChangedEvent", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::AutomationProperty>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);

                self->obj.RaisePropertyChangedEvent(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_RaiseStructureChangedEvent(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"RaiseStructureChangedEvent", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Peers::AutomationStructureChangeType>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer>(args, 1);

                self->obj.RaiseStructureChangedEvent(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_RaiseTextEditTextChangedEvent(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"RaiseTextEditTextChangedEvent", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::AutomationTextEditChangeType>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IVectorView<winrt::hstring>>(args, 1);

                self->obj.RaiseTextEditTextChangedEvent(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_SetFocus(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"SetFocus", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.SetFocus();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_SetParent(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"SetParent", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer>(args, 0);

                self->obj.SetParent(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_ShowContextMenu(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"ShowContextMenu", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.ShowContextMenu();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationPeer_get_EventsSource(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"EventsSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.EventsSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutomationPeer_put_EventsSource(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeer", L"EventsSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer>(arg);

            self->obj.EventsSource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AutomationPeer[] = {
        { "get_accelerator_key", reinterpret_cast<PyCFunction>(AutomationPeer_GetAcceleratorKey), METH_VARARGS, nullptr },
        { "get_access_key", reinterpret_cast<PyCFunction>(AutomationPeer_GetAccessKey), METH_VARARGS, nullptr },
        { "get_annotations", reinterpret_cast<PyCFunction>(AutomationPeer_GetAnnotations), METH_VARARGS, nullptr },
        { "get_automation_control_type", reinterpret_cast<PyCFunction>(AutomationPeer_GetAutomationControlType), METH_VARARGS, nullptr },
        { "get_automation_id", reinterpret_cast<PyCFunction>(AutomationPeer_GetAutomationId), METH_VARARGS, nullptr },
        { "get_bounding_rectangle", reinterpret_cast<PyCFunction>(AutomationPeer_GetBoundingRectangle), METH_VARARGS, nullptr },
        { "get_children", reinterpret_cast<PyCFunction>(AutomationPeer_GetChildren), METH_VARARGS, nullptr },
        { "get_class_name", reinterpret_cast<PyCFunction>(AutomationPeer_GetClassName), METH_VARARGS, nullptr },
        { "get_clickable_point", reinterpret_cast<PyCFunction>(AutomationPeer_GetClickablePoint), METH_VARARGS, nullptr },
        { "get_controlled_peers", reinterpret_cast<PyCFunction>(AutomationPeer_GetControlledPeers), METH_VARARGS, nullptr },
        { "get_culture", reinterpret_cast<PyCFunction>(AutomationPeer_GetCulture), METH_VARARGS, nullptr },
        { "get_element_from_point", reinterpret_cast<PyCFunction>(AutomationPeer_GetElementFromPoint), METH_VARARGS, nullptr },
        { "get_focused_element", reinterpret_cast<PyCFunction>(AutomationPeer_GetFocusedElement), METH_VARARGS, nullptr },
        { "get_full_description", reinterpret_cast<PyCFunction>(AutomationPeer_GetFullDescription), METH_VARARGS, nullptr },
        { "get_heading_level", reinterpret_cast<PyCFunction>(AutomationPeer_GetHeadingLevel), METH_VARARGS, nullptr },
        { "get_help_text", reinterpret_cast<PyCFunction>(AutomationPeer_GetHelpText), METH_VARARGS, nullptr },
        { "get_item_status", reinterpret_cast<PyCFunction>(AutomationPeer_GetItemStatus), METH_VARARGS, nullptr },
        { "get_item_type", reinterpret_cast<PyCFunction>(AutomationPeer_GetItemType), METH_VARARGS, nullptr },
        { "get_labeled_by", reinterpret_cast<PyCFunction>(AutomationPeer_GetLabeledBy), METH_VARARGS, nullptr },
        { "get_landmark_type", reinterpret_cast<PyCFunction>(AutomationPeer_GetLandmarkType), METH_VARARGS, nullptr },
        { "get_level", reinterpret_cast<PyCFunction>(AutomationPeer_GetLevel), METH_VARARGS, nullptr },
        { "get_live_setting", reinterpret_cast<PyCFunction>(AutomationPeer_GetLiveSetting), METH_VARARGS, nullptr },
        { "get_localized_control_type", reinterpret_cast<PyCFunction>(AutomationPeer_GetLocalizedControlType), METH_VARARGS, nullptr },
        { "get_localized_landmark_type", reinterpret_cast<PyCFunction>(AutomationPeer_GetLocalizedLandmarkType), METH_VARARGS, nullptr },
        { "get_name", reinterpret_cast<PyCFunction>(AutomationPeer_GetName), METH_VARARGS, nullptr },
        { "get_orientation", reinterpret_cast<PyCFunction>(AutomationPeer_GetOrientation), METH_VARARGS, nullptr },
        { "get_parent", reinterpret_cast<PyCFunction>(AutomationPeer_GetParent), METH_VARARGS, nullptr },
        { "get_pattern", reinterpret_cast<PyCFunction>(AutomationPeer_GetPattern), METH_VARARGS, nullptr },
        { "get_peer_from_point", reinterpret_cast<PyCFunction>(AutomationPeer_GetPeerFromPoint), METH_VARARGS, nullptr },
        { "get_position_in_set", reinterpret_cast<PyCFunction>(AutomationPeer_GetPositionInSet), METH_VARARGS, nullptr },
        { "get_size_of_set", reinterpret_cast<PyCFunction>(AutomationPeer_GetSizeOfSet), METH_VARARGS, nullptr },
        { "has_keyboard_focus", reinterpret_cast<PyCFunction>(AutomationPeer_HasKeyboardFocus), METH_VARARGS, nullptr },
        { "invalidate_peer", reinterpret_cast<PyCFunction>(AutomationPeer_InvalidatePeer), METH_VARARGS, nullptr },
        { "is_content_element", reinterpret_cast<PyCFunction>(AutomationPeer_IsContentElement), METH_VARARGS, nullptr },
        { "is_control_element", reinterpret_cast<PyCFunction>(AutomationPeer_IsControlElement), METH_VARARGS, nullptr },
        { "is_data_valid_for_form", reinterpret_cast<PyCFunction>(AutomationPeer_IsDataValidForForm), METH_VARARGS, nullptr },
        { "is_dialog", reinterpret_cast<PyCFunction>(AutomationPeer_IsDialog), METH_VARARGS, nullptr },
        { "is_enabled", reinterpret_cast<PyCFunction>(AutomationPeer_IsEnabled), METH_VARARGS, nullptr },
        { "is_keyboard_focusable", reinterpret_cast<PyCFunction>(AutomationPeer_IsKeyboardFocusable), METH_VARARGS, nullptr },
        { "is_offscreen", reinterpret_cast<PyCFunction>(AutomationPeer_IsOffscreen), METH_VARARGS, nullptr },
        { "is_password", reinterpret_cast<PyCFunction>(AutomationPeer_IsPassword), METH_VARARGS, nullptr },
        { "is_peripheral", reinterpret_cast<PyCFunction>(AutomationPeer_IsPeripheral), METH_VARARGS, nullptr },
        { "is_required_for_form", reinterpret_cast<PyCFunction>(AutomationPeer_IsRequiredForForm), METH_VARARGS, nullptr },
        { "navigate", reinterpret_cast<PyCFunction>(AutomationPeer_Navigate), METH_VARARGS, nullptr },
        { "raise_automation_event", reinterpret_cast<PyCFunction>(AutomationPeer_RaiseAutomationEvent), METH_VARARGS, nullptr },
        { "raise_notification_event", reinterpret_cast<PyCFunction>(AutomationPeer_RaiseNotificationEvent), METH_VARARGS, nullptr },
        { "raise_property_changed_event", reinterpret_cast<PyCFunction>(AutomationPeer_RaisePropertyChangedEvent), METH_VARARGS, nullptr },
        { "raise_structure_changed_event", reinterpret_cast<PyCFunction>(AutomationPeer_RaiseStructureChangedEvent), METH_VARARGS, nullptr },
        { "raise_text_edit_text_changed_event", reinterpret_cast<PyCFunction>(AutomationPeer_RaiseTextEditTextChangedEvent), METH_VARARGS, nullptr },
        { "set_focus", reinterpret_cast<PyCFunction>(AutomationPeer_SetFocus), METH_VARARGS, nullptr },
        { "set_parent", reinterpret_cast<PyCFunction>(AutomationPeer_SetParent), METH_VARARGS, nullptr },
        { "show_context_menu", reinterpret_cast<PyCFunction>(AutomationPeer_ShowContextMenu), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AutomationPeer[] = {
        { "events_source", reinterpret_cast<getter>(AutomationPeer_get_EventsSource), reinterpret_cast<setter>(AutomationPeer_put_EventsSource), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_AutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.AutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AutomationPeer};

    static PyGetSetDef getset_AutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_AutomationPeer_Static[] = {
        { "generate_raw_element_provider_runtime_id", reinterpret_cast<PyCFunction>(AutomationPeer_GenerateRawElementProviderRuntimeId), METH_VARARGS, nullptr },
        { "listener_exists", reinterpret_cast<PyCFunction>(AutomationPeer_ListenerExists), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_AutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.AutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AutomationPeer_Static
    };

    // ----- AutomationPeerAnnotation class --------------------

    static PyObject* _new_AutomationPeerAnnotation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::AnnotationType>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::AutomationPeerAnnotation instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::AnnotationType>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer>(args, 1);

                winrt::Microsoft::UI::Xaml::Automation::Peers::AutomationPeerAnnotation instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Automation::Peers::AutomationPeerAnnotation instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AutomationPeerAnnotation(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeerAnnotation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AutomationPeerAnnotation_get_Type(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeerAnnotation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeerAnnotation", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutomationPeerAnnotation_put_Type(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeerAnnotation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeerAnnotation", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::AnnotationType>(arg);

            self->obj.Type(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AutomationPeerAnnotation_get_Peer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeerAnnotation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeerAnnotation", L"Peer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Peer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutomationPeerAnnotation_put_Peer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeerAnnotation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeerAnnotation", L"Peer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Peers::AutomationPeer>(arg);

            self->obj.Peer(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AutomationPeerAnnotation_get_PeerProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeerAnnotation", L"PeerProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Automation::Peers::AutomationPeerAnnotation::PeerProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationPeerAnnotation_get_TypeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.AutomationPeerAnnotation", L"TypeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Microsoft::UI::Xaml::Automation::Peers::AutomationPeerAnnotation::TypeProperty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AutomationPeerAnnotation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::AutomationPeerAnnotation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AutomationPeerAnnotation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::AutomationPeerAnnotation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AutomationPeerAnnotation[] = {
        { "_assign_array_", _assign_array_AutomationPeerAnnotation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AutomationPeerAnnotation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AutomationPeerAnnotation[] = {
        { "type", reinterpret_cast<getter>(AutomationPeerAnnotation_get_Type), reinterpret_cast<setter>(AutomationPeerAnnotation_put_Type), nullptr, nullptr },
        { "peer", reinterpret_cast<getter>(AutomationPeerAnnotation_get_Peer), reinterpret_cast<setter>(AutomationPeerAnnotation_put_Peer), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AutomationPeerAnnotation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AutomationPeerAnnotation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AutomationPeerAnnotation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AutomationPeerAnnotation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AutomationPeerAnnotation) },
        { }
    };

    static PyType_Spec type_spec_AutomationPeerAnnotation = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.AutomationPeerAnnotation",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::AutomationPeerAnnotation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AutomationPeerAnnotation};

    static PyGetSetDef getset_AutomationPeerAnnotation_Static[] = {
        { "peer_property", reinterpret_cast<getter>(AutomationPeerAnnotation_get_PeerProperty), nullptr, nullptr, nullptr },
        { "type_property", reinterpret_cast<getter>(AutomationPeerAnnotation_get_TypeProperty), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_AutomationPeerAnnotation_Static[] = {
        { }
    };

    static PyType_Slot type_slots_AutomationPeerAnnotation_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AutomationPeerAnnotation_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AutomationPeerAnnotation_Static) },
        { }
    };

    static PyType_Spec type_spec_AutomationPeerAnnotation_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.AutomationPeerAnnotation_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AutomationPeerAnnotation_Static
    };

    // ----- BreadcrumbBarItemAutomationPeer class --------------------

    static PyObject* _new_BreadcrumbBarItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::BreadcrumbBarItem>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::BreadcrumbBarItemAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BreadcrumbBarItemAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::BreadcrumbBarItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BreadcrumbBarItemAutomationPeer_Invoke(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::BreadcrumbBarItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.BreadcrumbBarItemAutomationPeer", L"Invoke", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Invoke();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_BreadcrumbBarItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::BreadcrumbBarItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BreadcrumbBarItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::BreadcrumbBarItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BreadcrumbBarItemAutomationPeer[] = {
        { "invoke", reinterpret_cast<PyCFunction>(BreadcrumbBarItemAutomationPeer_Invoke), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BreadcrumbBarItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BreadcrumbBarItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BreadcrumbBarItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_BreadcrumbBarItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BreadcrumbBarItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BreadcrumbBarItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BreadcrumbBarItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BreadcrumbBarItemAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_BreadcrumbBarItemAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.BreadcrumbBarItemAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::BreadcrumbBarItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BreadcrumbBarItemAutomationPeer};

    static PyGetSetDef getset_BreadcrumbBarItemAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_BreadcrumbBarItemAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_BreadcrumbBarItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BreadcrumbBarItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BreadcrumbBarItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_BreadcrumbBarItemAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.BreadcrumbBarItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BreadcrumbBarItemAutomationPeer_Static
    };

    // ----- ButtonAutomationPeer class --------------------

    static PyObject* _new_ButtonAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Button>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::ButtonAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ButtonAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ButtonAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ButtonAutomationPeer_Invoke(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.ButtonAutomationPeer", L"Invoke", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Invoke();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::ButtonAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::ButtonAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ButtonAutomationPeer[] = {
        { "invoke", reinterpret_cast<PyCFunction>(ButtonAutomationPeer_Invoke), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ButtonAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ButtonAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ButtonAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ButtonAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ButtonAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ButtonAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ButtonAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ButtonAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ButtonAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ButtonAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ButtonAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ButtonAutomationPeer};

    static PyGetSetDef getset_ButtonAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ButtonAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ButtonAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ButtonAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ButtonAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ButtonAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ButtonAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ButtonAutomationPeer_Static
    };

    // ----- ButtonBaseAutomationPeer class --------------------

    static PyObject* _new_ButtonBaseAutomationPeer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Peers::ButtonBaseAutomationPeer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Peers::ButtonBaseAutomationPeer>::type_name);
        return nullptr;
    }

    static void _dealloc_ButtonBaseAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ButtonBaseAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ButtonBaseAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::ButtonBaseAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ButtonBaseAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::ButtonBaseAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ButtonBaseAutomationPeer[] = {
        { "_assign_array_", _assign_array_ButtonBaseAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ButtonBaseAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ButtonBaseAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ButtonBaseAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ButtonBaseAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ButtonBaseAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ButtonBaseAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ButtonBaseAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ButtonBaseAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ButtonBaseAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ButtonBaseAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ButtonBaseAutomationPeer};

    static PyGetSetDef getset_ButtonBaseAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ButtonBaseAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ButtonBaseAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ButtonBaseAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ButtonBaseAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ButtonBaseAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ButtonBaseAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ButtonBaseAutomationPeer_Static
    };

    // ----- CalendarDatePickerAutomationPeer class --------------------

    static PyObject* _new_CalendarDatePickerAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::CalendarDatePicker>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CalendarDatePickerAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CalendarDatePickerAutomationPeer_Invoke(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.CalendarDatePickerAutomationPeer", L"Invoke", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Invoke();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CalendarDatePickerAutomationPeer_SetValue(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.CalendarDatePickerAutomationPeer", L"SetValue", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.SetValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CalendarDatePickerAutomationPeer_get_IsReadOnly(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.CalendarDatePickerAutomationPeer", L"IsReadOnly");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CalendarDatePickerAutomationPeer_get_Value(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.CalendarDatePickerAutomationPeer", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CalendarDatePickerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CalendarDatePickerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CalendarDatePickerAutomationPeer[] = {
        { "invoke", reinterpret_cast<PyCFunction>(CalendarDatePickerAutomationPeer_Invoke), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(CalendarDatePickerAutomationPeer_SetValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_CalendarDatePickerAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CalendarDatePickerAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CalendarDatePickerAutomationPeer[] = {
        { "is_read_only", reinterpret_cast<getter>(CalendarDatePickerAutomationPeer_get_IsReadOnly), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(CalendarDatePickerAutomationPeer_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CalendarDatePickerAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CalendarDatePickerAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CalendarDatePickerAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CalendarDatePickerAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CalendarDatePickerAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_CalendarDatePickerAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.CalendarDatePickerAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::CalendarDatePickerAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CalendarDatePickerAutomationPeer};

    static PyGetSetDef getset_CalendarDatePickerAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_CalendarDatePickerAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_CalendarDatePickerAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CalendarDatePickerAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CalendarDatePickerAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_CalendarDatePickerAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.CalendarDatePickerAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CalendarDatePickerAutomationPeer_Static
    };

    // ----- CheckBoxAutomationPeer class --------------------

    static PyObject* _new_CheckBoxAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::CheckBox>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::CheckBoxAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CheckBoxAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::CheckBoxAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_CheckBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::CheckBoxAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CheckBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::CheckBoxAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CheckBoxAutomationPeer[] = {
        { "_assign_array_", _assign_array_CheckBoxAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CheckBoxAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CheckBoxAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_CheckBoxAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CheckBoxAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CheckBoxAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CheckBoxAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CheckBoxAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_CheckBoxAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.CheckBoxAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::CheckBoxAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CheckBoxAutomationPeer};

    static PyGetSetDef getset_CheckBoxAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_CheckBoxAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_CheckBoxAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_CheckBoxAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_CheckBoxAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_CheckBoxAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.CheckBoxAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_CheckBoxAutomationPeer_Static
    };

    // ----- ColorPickerSliderAutomationPeer class --------------------

    static PyObject* _new_ColorPickerSliderAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorPickerSlider>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::ColorPickerSliderAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ColorPickerSliderAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ColorPickerSliderAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ColorPickerSliderAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::ColorPickerSliderAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ColorPickerSliderAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::ColorPickerSliderAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ColorPickerSliderAutomationPeer[] = {
        { "_assign_array_", _assign_array_ColorPickerSliderAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ColorPickerSliderAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ColorPickerSliderAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ColorPickerSliderAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ColorPickerSliderAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ColorPickerSliderAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ColorPickerSliderAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ColorPickerSliderAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ColorPickerSliderAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ColorPickerSliderAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ColorPickerSliderAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ColorPickerSliderAutomationPeer};

    static PyGetSetDef getset_ColorPickerSliderAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ColorPickerSliderAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ColorPickerSliderAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ColorPickerSliderAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ColorPickerSliderAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ColorPickerSliderAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ColorPickerSliderAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ColorPickerSliderAutomationPeer_Static
    };

    // ----- ColorSpectrumAutomationPeer class --------------------

    static PyObject* _new_ColorSpectrumAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::ColorSpectrum>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::ColorSpectrumAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ColorSpectrumAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ColorSpectrumAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ColorSpectrumAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::ColorSpectrumAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ColorSpectrumAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::ColorSpectrumAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ColorSpectrumAutomationPeer[] = {
        { "_assign_array_", _assign_array_ColorSpectrumAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ColorSpectrumAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ColorSpectrumAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ColorSpectrumAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ColorSpectrumAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ColorSpectrumAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ColorSpectrumAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ColorSpectrumAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ColorSpectrumAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ColorSpectrumAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ColorSpectrumAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ColorSpectrumAutomationPeer};

    static PyGetSetDef getset_ColorSpectrumAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ColorSpectrumAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ColorSpectrumAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ColorSpectrumAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ColorSpectrumAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ColorSpectrumAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ColorSpectrumAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ColorSpectrumAutomationPeer_Static
    };

    // ----- ComboBoxAutomationPeer class --------------------

    static PyObject* _new_ComboBoxAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ComboBox>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ComboBoxAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ComboBoxAutomationPeer_Close(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_Collapse(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"Collapse", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Collapse();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_Expand(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"Expand", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Expand();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_SetValue(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"SetValue", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.SetValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_SetVisualState(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"SetVisualState", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::WindowVisualState>(args, 0);

                self->obj.SetVisualState(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_WaitForInputIdle(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"WaitForInputIdle", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.WaitForInputIdle(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_get_ExpandCollapseState(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"ExpandCollapseState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpandCollapseState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_get_IsReadOnly(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"IsReadOnly");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_get_Value(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_get_InteractionState(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"InteractionState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InteractionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_get_IsModal(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"IsModal");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsModal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_get_IsTopmost(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"IsTopmost");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsTopmost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_get_Maximizable(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"Maximizable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Maximizable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_get_Minimizable(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"Minimizable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Minimizable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ComboBoxAutomationPeer_get_VisualState(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ComboBoxAutomationPeer", L"VisualState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VisualState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ComboBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ComboBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ComboBoxAutomationPeer[] = {
        { "close", reinterpret_cast<PyCFunction>(ComboBoxAutomationPeer_Close), METH_VARARGS, nullptr },
        { "collapse", reinterpret_cast<PyCFunction>(ComboBoxAutomationPeer_Collapse), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(ComboBoxAutomationPeer_Expand), METH_VARARGS, nullptr },
        { "set_value", reinterpret_cast<PyCFunction>(ComboBoxAutomationPeer_SetValue), METH_VARARGS, nullptr },
        { "set_visual_state", reinterpret_cast<PyCFunction>(ComboBoxAutomationPeer_SetVisualState), METH_VARARGS, nullptr },
        { "wait_for_input_idle", reinterpret_cast<PyCFunction>(ComboBoxAutomationPeer_WaitForInputIdle), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ComboBoxAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ComboBoxAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ComboBoxAutomationPeer[] = {
        { "expand_collapse_state", reinterpret_cast<getter>(ComboBoxAutomationPeer_get_ExpandCollapseState), nullptr, nullptr, nullptr },
        { "is_read_only", reinterpret_cast<getter>(ComboBoxAutomationPeer_get_IsReadOnly), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(ComboBoxAutomationPeer_get_Value), nullptr, nullptr, nullptr },
        { "interaction_state", reinterpret_cast<getter>(ComboBoxAutomationPeer_get_InteractionState), nullptr, nullptr, nullptr },
        { "is_modal", reinterpret_cast<getter>(ComboBoxAutomationPeer_get_IsModal), nullptr, nullptr, nullptr },
        { "is_topmost", reinterpret_cast<getter>(ComboBoxAutomationPeer_get_IsTopmost), nullptr, nullptr, nullptr },
        { "maximizable", reinterpret_cast<getter>(ComboBoxAutomationPeer_get_Maximizable), nullptr, nullptr, nullptr },
        { "minimizable", reinterpret_cast<getter>(ComboBoxAutomationPeer_get_Minimizable), nullptr, nullptr, nullptr },
        { "visual_state", reinterpret_cast<getter>(ComboBoxAutomationPeer_get_VisualState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ComboBoxAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ComboBoxAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ComboBoxAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ComboBoxAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ComboBoxAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ComboBoxAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ComboBoxAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ComboBoxAutomationPeer};

    static PyGetSetDef getset_ComboBoxAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ComboBoxAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ComboBoxAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ComboBoxAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ComboBoxAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ComboBoxAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ComboBoxAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ComboBoxAutomationPeer_Static
    };

    // ----- ComboBoxItemAutomationPeer class --------------------

    static PyObject* _new_ComboBoxItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ComboBoxItem>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::ComboBoxItemAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ComboBoxItemAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ComboBoxItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ComboBoxItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::ComboBoxItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ComboBoxItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::ComboBoxItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ComboBoxItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_ComboBoxItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ComboBoxItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ComboBoxItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ComboBoxItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ComboBoxItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ComboBoxItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ComboBoxItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ComboBoxItemAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ComboBoxItemAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ComboBoxItemAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ComboBoxItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ComboBoxItemAutomationPeer};

    static PyGetSetDef getset_ComboBoxItemAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ComboBoxItemAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ComboBoxItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ComboBoxItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ComboBoxItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ComboBoxItemAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ComboBoxItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ComboBoxItemAutomationPeer_Static
    };

    // ----- ComboBoxItemDataAutomationPeer class --------------------

    static PyObject* _new_ComboBoxItemDataAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Peers::ComboBoxAutomationPeer>(args, 1);

                winrt::Microsoft::UI::Xaml::Automation::Peers::ComboBoxItemDataAutomationPeer instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ComboBoxItemDataAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ComboBoxItemDataAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ComboBoxItemDataAutomationPeer_ScrollIntoView(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ComboBoxItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.ComboBoxItemDataAutomationPeer", L"ScrollIntoView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.ScrollIntoView();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ComboBoxItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::ComboBoxItemDataAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ComboBoxItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::ComboBoxItemDataAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ComboBoxItemDataAutomationPeer[] = {
        { "scroll_into_view", reinterpret_cast<PyCFunction>(ComboBoxItemDataAutomationPeer_ScrollIntoView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ComboBoxItemDataAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ComboBoxItemDataAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ComboBoxItemDataAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ComboBoxItemDataAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ComboBoxItemDataAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ComboBoxItemDataAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ComboBoxItemDataAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ComboBoxItemDataAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ComboBoxItemDataAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ComboBoxItemDataAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ComboBoxItemDataAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ComboBoxItemDataAutomationPeer};

    static PyGetSetDef getset_ComboBoxItemDataAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ComboBoxItemDataAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ComboBoxItemDataAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ComboBoxItemDataAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ComboBoxItemDataAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ComboBoxItemDataAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ComboBoxItemDataAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ComboBoxItemDataAutomationPeer_Static
    };

    // ----- DatePickerAutomationPeer class --------------------

    static PyObject* _new_DatePickerAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::DatePicker>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::DatePickerAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DatePickerAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::DatePickerAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_DatePickerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::DatePickerAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DatePickerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::DatePickerAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DatePickerAutomationPeer[] = {
        { "_assign_array_", _assign_array_DatePickerAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DatePickerAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DatePickerAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_DatePickerAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DatePickerAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DatePickerAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DatePickerAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DatePickerAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_DatePickerAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.DatePickerAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::DatePickerAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DatePickerAutomationPeer};

    static PyGetSetDef getset_DatePickerAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_DatePickerAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_DatePickerAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DatePickerAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_DatePickerAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_DatePickerAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.DatePickerAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DatePickerAutomationPeer_Static
    };

    // ----- DatePickerFlyoutPresenterAutomationPeer class --------------------

    static PyObject* _new_DatePickerFlyoutPresenterAutomationPeer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Peers::DatePickerFlyoutPresenterAutomationPeer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Peers::DatePickerFlyoutPresenterAutomationPeer>::type_name);
        return nullptr;
    }

    static void _dealloc_DatePickerFlyoutPresenterAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::DatePickerFlyoutPresenterAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_DatePickerFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::DatePickerFlyoutPresenterAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DatePickerFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::DatePickerFlyoutPresenterAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DatePickerFlyoutPresenterAutomationPeer[] = {
        { "_assign_array_", _assign_array_DatePickerFlyoutPresenterAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DatePickerFlyoutPresenterAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DatePickerFlyoutPresenterAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_DatePickerFlyoutPresenterAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DatePickerFlyoutPresenterAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DatePickerFlyoutPresenterAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DatePickerFlyoutPresenterAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DatePickerFlyoutPresenterAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_DatePickerFlyoutPresenterAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.DatePickerFlyoutPresenterAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::DatePickerFlyoutPresenterAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DatePickerFlyoutPresenterAutomationPeer};

    // ----- DropDownButtonAutomationPeer class --------------------

    static PyObject* _new_DropDownButtonAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::DropDownButton>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::DropDownButtonAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DropDownButtonAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::DropDownButtonAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DropDownButtonAutomationPeer_Collapse(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::DropDownButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.DropDownButtonAutomationPeer", L"Collapse", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Collapse();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DropDownButtonAutomationPeer_Expand(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::DropDownButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.DropDownButtonAutomationPeer", L"Expand", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Expand();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DropDownButtonAutomationPeer_get_ExpandCollapseState(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::DropDownButtonAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.DropDownButtonAutomationPeer", L"ExpandCollapseState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpandCollapseState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_DropDownButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::DropDownButtonAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DropDownButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::DropDownButtonAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DropDownButtonAutomationPeer[] = {
        { "collapse", reinterpret_cast<PyCFunction>(DropDownButtonAutomationPeer_Collapse), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(DropDownButtonAutomationPeer_Expand), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_DropDownButtonAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DropDownButtonAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DropDownButtonAutomationPeer[] = {
        { "expand_collapse_state", reinterpret_cast<getter>(DropDownButtonAutomationPeer_get_ExpandCollapseState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DropDownButtonAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DropDownButtonAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DropDownButtonAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DropDownButtonAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DropDownButtonAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_DropDownButtonAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.DropDownButtonAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::DropDownButtonAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DropDownButtonAutomationPeer};

    static PyGetSetDef getset_DropDownButtonAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_DropDownButtonAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_DropDownButtonAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_DropDownButtonAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_DropDownButtonAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_DropDownButtonAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.DropDownButtonAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_DropDownButtonAutomationPeer_Static
    };

    // ----- ExpanderAutomationPeer class --------------------

    static PyObject* _new_ExpanderAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Expander>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::ExpanderAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ExpanderAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ExpanderAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ExpanderAutomationPeer_Collapse(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ExpanderAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.ExpanderAutomationPeer", L"Collapse", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Collapse();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ExpanderAutomationPeer_Expand(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ExpanderAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.ExpanderAutomationPeer", L"Expand", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Expand();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ExpanderAutomationPeer_get_ExpandCollapseState(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ExpanderAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ExpanderAutomationPeer", L"ExpandCollapseState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpandCollapseState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ExpanderAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::ExpanderAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ExpanderAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::ExpanderAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ExpanderAutomationPeer[] = {
        { "collapse", reinterpret_cast<PyCFunction>(ExpanderAutomationPeer_Collapse), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(ExpanderAutomationPeer_Expand), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ExpanderAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ExpanderAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ExpanderAutomationPeer[] = {
        { "expand_collapse_state", reinterpret_cast<getter>(ExpanderAutomationPeer_get_ExpandCollapseState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ExpanderAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ExpanderAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ExpanderAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ExpanderAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ExpanderAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ExpanderAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ExpanderAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ExpanderAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ExpanderAutomationPeer};

    static PyGetSetDef getset_ExpanderAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ExpanderAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ExpanderAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ExpanderAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ExpanderAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ExpanderAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ExpanderAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ExpanderAutomationPeer_Static
    };

    // ----- FlipViewAutomationPeer class --------------------

    static PyObject* _new_FlipViewAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::FlipView>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::FlipViewAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FlipViewAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::FlipViewAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_FlipViewAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::FlipViewAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FlipViewAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::FlipViewAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlipViewAutomationPeer[] = {
        { "_assign_array_", _assign_array_FlipViewAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FlipViewAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FlipViewAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_FlipViewAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FlipViewAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FlipViewAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FlipViewAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FlipViewAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_FlipViewAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.FlipViewAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::FlipViewAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FlipViewAutomationPeer};

    static PyGetSetDef getset_FlipViewAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_FlipViewAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_FlipViewAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FlipViewAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_FlipViewAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_FlipViewAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.FlipViewAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_FlipViewAutomationPeer_Static
    };

    // ----- FlipViewItemAutomationPeer class --------------------

    static PyObject* _new_FlipViewItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::FlipViewItem>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::FlipViewItemAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FlipViewItemAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::FlipViewItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_FlipViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::FlipViewItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FlipViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::FlipViewItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlipViewItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_FlipViewItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FlipViewItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FlipViewItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_FlipViewItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FlipViewItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FlipViewItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FlipViewItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FlipViewItemAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_FlipViewItemAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.FlipViewItemAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::FlipViewItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FlipViewItemAutomationPeer};

    static PyGetSetDef getset_FlipViewItemAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_FlipViewItemAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_FlipViewItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FlipViewItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_FlipViewItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_FlipViewItemAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.FlipViewItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_FlipViewItemAutomationPeer_Static
    };

    // ----- FlipViewItemDataAutomationPeer class --------------------

    static PyObject* _new_FlipViewItemDataAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Peers::FlipViewAutomationPeer>(args, 1);

                winrt::Microsoft::UI::Xaml::Automation::Peers::FlipViewItemDataAutomationPeer instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FlipViewItemDataAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::FlipViewItemDataAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FlipViewItemDataAutomationPeer_ScrollIntoView(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::FlipViewItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.FlipViewItemDataAutomationPeer", L"ScrollIntoView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.ScrollIntoView();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_FlipViewItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::FlipViewItemDataAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FlipViewItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::FlipViewItemDataAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlipViewItemDataAutomationPeer[] = {
        { "scroll_into_view", reinterpret_cast<PyCFunction>(FlipViewItemDataAutomationPeer_ScrollIntoView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_FlipViewItemDataAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FlipViewItemDataAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FlipViewItemDataAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_FlipViewItemDataAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FlipViewItemDataAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FlipViewItemDataAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FlipViewItemDataAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FlipViewItemDataAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_FlipViewItemDataAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.FlipViewItemDataAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::FlipViewItemDataAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FlipViewItemDataAutomationPeer};

    static PyGetSetDef getset_FlipViewItemDataAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_FlipViewItemDataAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_FlipViewItemDataAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FlipViewItemDataAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_FlipViewItemDataAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_FlipViewItemDataAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.FlipViewItemDataAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_FlipViewItemDataAutomationPeer_Static
    };

    // ----- FlyoutPresenterAutomationPeer class --------------------

    static PyObject* _new_FlyoutPresenterAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::FlyoutPresenter>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::FlyoutPresenterAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FlyoutPresenterAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::FlyoutPresenterAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_FlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::FlyoutPresenterAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::FlyoutPresenterAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlyoutPresenterAutomationPeer[] = {
        { "_assign_array_", _assign_array_FlyoutPresenterAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FlyoutPresenterAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FlyoutPresenterAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_FlyoutPresenterAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FlyoutPresenterAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FlyoutPresenterAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FlyoutPresenterAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FlyoutPresenterAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_FlyoutPresenterAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.FlyoutPresenterAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::FlyoutPresenterAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FlyoutPresenterAutomationPeer};

    static PyGetSetDef getset_FlyoutPresenterAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_FlyoutPresenterAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_FlyoutPresenterAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FlyoutPresenterAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_FlyoutPresenterAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_FlyoutPresenterAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.FlyoutPresenterAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_FlyoutPresenterAutomationPeer_Static
    };

    // ----- FrameworkElementAutomationPeer class --------------------

    static PyObject* _new_FrameworkElementAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::FrameworkElement>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::FrameworkElementAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FrameworkElementAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::FrameworkElementAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FrameworkElementAutomationPeer_CreatePeerForElement(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.FrameworkElementAutomationPeer", L"CreatePeerForElement", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Automation::Peers::FrameworkElementAutomationPeer::CreatePeerForElement(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FrameworkElementAutomationPeer_FromElement(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.FrameworkElementAutomationPeer", L"FromElement", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 0);

                return py::convert(winrt::Microsoft::UI::Xaml::Automation::Peers::FrameworkElementAutomationPeer::FromElement(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FrameworkElementAutomationPeer_get_Owner(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::FrameworkElementAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.FrameworkElementAutomationPeer", L"Owner");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Owner());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FrameworkElementAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::FrameworkElementAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FrameworkElementAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::FrameworkElementAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameworkElementAutomationPeer[] = {
        { "_assign_array_", _assign_array_FrameworkElementAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameworkElementAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FrameworkElementAutomationPeer[] = {
        { "owner", reinterpret_cast<getter>(FrameworkElementAutomationPeer_get_Owner), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FrameworkElementAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_FrameworkElementAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FrameworkElementAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FrameworkElementAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FrameworkElementAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_FrameworkElementAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.FrameworkElementAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::FrameworkElementAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameworkElementAutomationPeer};

    static PyGetSetDef getset_FrameworkElementAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_FrameworkElementAutomationPeer_Static[] = {
        { "create_peer_for_element", reinterpret_cast<PyCFunction>(FrameworkElementAutomationPeer_CreatePeerForElement), METH_VARARGS, nullptr },
        { "from_element", reinterpret_cast<PyCFunction>(FrameworkElementAutomationPeer_FromElement), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_FrameworkElementAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_FrameworkElementAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_FrameworkElementAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_FrameworkElementAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.FrameworkElementAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_FrameworkElementAutomationPeer_Static
    };

    // ----- GridViewAutomationPeer class --------------------

    static PyObject* _new_GridViewAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::GridView>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::GridViewAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GridViewAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::GridViewAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_GridViewAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::GridViewAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GridViewAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::GridViewAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GridViewAutomationPeer[] = {
        { "_assign_array_", _assign_array_GridViewAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GridViewAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GridViewAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_GridViewAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GridViewAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GridViewAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GridViewAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GridViewAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_GridViewAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.GridViewAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::GridViewAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GridViewAutomationPeer};

    static PyGetSetDef getset_GridViewAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_GridViewAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_GridViewAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GridViewAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GridViewAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_GridViewAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.GridViewAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GridViewAutomationPeer_Static
    };

    // ----- GridViewHeaderItemAutomationPeer class --------------------

    static PyObject* _new_GridViewHeaderItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::GridViewHeaderItem>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::GridViewHeaderItemAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GridViewHeaderItemAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::GridViewHeaderItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_GridViewHeaderItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::GridViewHeaderItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GridViewHeaderItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::GridViewHeaderItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GridViewHeaderItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_GridViewHeaderItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GridViewHeaderItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GridViewHeaderItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_GridViewHeaderItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GridViewHeaderItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GridViewHeaderItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GridViewHeaderItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GridViewHeaderItemAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_GridViewHeaderItemAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.GridViewHeaderItemAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::GridViewHeaderItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GridViewHeaderItemAutomationPeer};

    static PyGetSetDef getset_GridViewHeaderItemAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_GridViewHeaderItemAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_GridViewHeaderItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GridViewHeaderItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GridViewHeaderItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_GridViewHeaderItemAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.GridViewHeaderItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GridViewHeaderItemAutomationPeer_Static
    };

    // ----- GridViewItemAutomationPeer class --------------------

    static PyObject* _new_GridViewItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::GridViewItem>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::GridViewItemAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GridViewItemAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::GridViewItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_GridViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::GridViewItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GridViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::GridViewItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GridViewItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_GridViewItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GridViewItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GridViewItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_GridViewItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GridViewItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GridViewItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GridViewItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GridViewItemAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_GridViewItemAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.GridViewItemAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::GridViewItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GridViewItemAutomationPeer};

    static PyGetSetDef getset_GridViewItemAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_GridViewItemAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_GridViewItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GridViewItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GridViewItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_GridViewItemAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.GridViewItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GridViewItemAutomationPeer_Static
    };

    // ----- GridViewItemDataAutomationPeer class --------------------

    static PyObject* _new_GridViewItemDataAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Peers::GridViewAutomationPeer>(args, 1);

                winrt::Microsoft::UI::Xaml::Automation::Peers::GridViewItemDataAutomationPeer instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GridViewItemDataAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::GridViewItemDataAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* GridViewItemDataAutomationPeer_ScrollIntoView(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::GridViewItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.GridViewItemDataAutomationPeer", L"ScrollIntoView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.ScrollIntoView();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_GridViewItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::GridViewItemDataAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GridViewItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::GridViewItemDataAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GridViewItemDataAutomationPeer[] = {
        { "scroll_into_view", reinterpret_cast<PyCFunction>(GridViewItemDataAutomationPeer_ScrollIntoView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_GridViewItemDataAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GridViewItemDataAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GridViewItemDataAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_GridViewItemDataAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GridViewItemDataAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GridViewItemDataAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GridViewItemDataAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GridViewItemDataAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_GridViewItemDataAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.GridViewItemDataAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::GridViewItemDataAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GridViewItemDataAutomationPeer};

    static PyGetSetDef getset_GridViewItemDataAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_GridViewItemDataAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_GridViewItemDataAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GridViewItemDataAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GridViewItemDataAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_GridViewItemDataAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.GridViewItemDataAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GridViewItemDataAutomationPeer_Static
    };

    // ----- GroupItemAutomationPeer class --------------------

    static PyObject* _new_GroupItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::GroupItem>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::GroupItemAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GroupItemAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::GroupItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_GroupItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::GroupItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_GroupItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::GroupItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GroupItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_GroupItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GroupItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GroupItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_GroupItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_GroupItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_GroupItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_GroupItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_GroupItemAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_GroupItemAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.GroupItemAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::GroupItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GroupItemAutomationPeer};

    static PyGetSetDef getset_GroupItemAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_GroupItemAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_GroupItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_GroupItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_GroupItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_GroupItemAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.GroupItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_GroupItemAutomationPeer_Static
    };

    // ----- HubAutomationPeer class --------------------

    static PyObject* _new_HubAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Hub>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::HubAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HubAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::HubAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_HubAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::HubAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HubAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::HubAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HubAutomationPeer[] = {
        { "_assign_array_", _assign_array_HubAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HubAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HubAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_HubAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_HubAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HubAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HubAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HubAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_HubAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.HubAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::HubAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HubAutomationPeer};

    static PyGetSetDef getset_HubAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_HubAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_HubAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HubAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HubAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_HubAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.HubAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_HubAutomationPeer_Static
    };

    // ----- HubSectionAutomationPeer class --------------------

    static PyObject* _new_HubSectionAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::HubSection>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::HubSectionAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HubSectionAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::HubSectionAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HubSectionAutomationPeer_ScrollIntoView(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::HubSectionAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.HubSectionAutomationPeer", L"ScrollIntoView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.ScrollIntoView();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_HubSectionAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::HubSectionAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HubSectionAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::HubSectionAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HubSectionAutomationPeer[] = {
        { "scroll_into_view", reinterpret_cast<PyCFunction>(HubSectionAutomationPeer_ScrollIntoView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HubSectionAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HubSectionAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HubSectionAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_HubSectionAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_HubSectionAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HubSectionAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HubSectionAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HubSectionAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_HubSectionAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.HubSectionAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::HubSectionAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HubSectionAutomationPeer};

    static PyGetSetDef getset_HubSectionAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_HubSectionAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_HubSectionAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HubSectionAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HubSectionAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_HubSectionAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.HubSectionAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_HubSectionAutomationPeer_Static
    };

    // ----- HyperlinkButtonAutomationPeer class --------------------

    static PyObject* _new_HyperlinkButtonAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::HyperlinkButton>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::HyperlinkButtonAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_HyperlinkButtonAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::HyperlinkButtonAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HyperlinkButtonAutomationPeer_Invoke(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::HyperlinkButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.HyperlinkButtonAutomationPeer", L"Invoke", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Invoke();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_HyperlinkButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::HyperlinkButtonAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_HyperlinkButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::HyperlinkButtonAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HyperlinkButtonAutomationPeer[] = {
        { "invoke", reinterpret_cast<PyCFunction>(HyperlinkButtonAutomationPeer_Invoke), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_HyperlinkButtonAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HyperlinkButtonAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HyperlinkButtonAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_HyperlinkButtonAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_HyperlinkButtonAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_HyperlinkButtonAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_HyperlinkButtonAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_HyperlinkButtonAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_HyperlinkButtonAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.HyperlinkButtonAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::HyperlinkButtonAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HyperlinkButtonAutomationPeer};

    static PyGetSetDef getset_HyperlinkButtonAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_HyperlinkButtonAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_HyperlinkButtonAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_HyperlinkButtonAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_HyperlinkButtonAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_HyperlinkButtonAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.HyperlinkButtonAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_HyperlinkButtonAutomationPeer_Static
    };

    // ----- ImageAutomationPeer class --------------------

    static PyObject* _new_ImageAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Image>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::ImageAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ImageAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ImageAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ImageAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::ImageAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ImageAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::ImageAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageAutomationPeer[] = {
        { "_assign_array_", _assign_array_ImageAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ImageAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ImageAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ImageAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ImageAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ImageAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ImageAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ImageAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ImageAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ImageAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ImageAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageAutomationPeer};

    static PyGetSetDef getset_ImageAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ImageAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ImageAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ImageAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImageAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ImageAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ImageAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ImageAutomationPeer_Static
    };

    // ----- InfoBarAutomationPeer class --------------------

    static PyObject* _new_InfoBarAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::InfoBar>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::InfoBarAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InfoBarAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::InfoBarAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_InfoBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::InfoBarAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_InfoBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::InfoBarAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InfoBarAutomationPeer[] = {
        { "_assign_array_", _assign_array_InfoBarAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InfoBarAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InfoBarAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_InfoBarAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_InfoBarAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_InfoBarAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_InfoBarAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_InfoBarAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_InfoBarAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.InfoBarAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::InfoBarAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InfoBarAutomationPeer};

    static PyGetSetDef getset_InfoBarAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_InfoBarAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_InfoBarAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_InfoBarAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_InfoBarAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_InfoBarAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.InfoBarAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_InfoBarAutomationPeer_Static
    };

    // ----- ItemAutomationPeer class --------------------

    static PyObject* _new_ItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Peers::ItemsControlAutomationPeer>(args, 1);

                winrt::Microsoft::UI::Xaml::Automation::Peers::ItemAutomationPeer instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ItemAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ItemAutomationPeer_Realize(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.ItemAutomationPeer", L"Realize", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Realize();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ItemAutomationPeer_get_Item(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ItemAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ItemAutomationPeer", L"Item");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Item());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemAutomationPeer_get_ItemsControlAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ItemAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ItemAutomationPeer", L"ItemsControlAutomationPeer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ItemsControlAutomationPeer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::ItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::ItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ItemAutomationPeer[] = {
        { "realize", reinterpret_cast<PyCFunction>(ItemAutomationPeer_Realize), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ItemAutomationPeer[] = {
        { "item", reinterpret_cast<getter>(ItemAutomationPeer_get_Item), nullptr, nullptr, nullptr },
        { "items_control_automation_peer", reinterpret_cast<getter>(ItemAutomationPeer_get_ItemsControlAutomationPeer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ItemAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ItemAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ItemAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ItemAutomationPeer};

    static PyGetSetDef getset_ItemAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ItemAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ItemAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ItemAutomationPeer_Static
    };

    // ----- ItemContainerAutomationPeer class --------------------

    static PyObject* _new_ItemContainerAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ItemContainer>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::ItemContainerAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ItemContainerAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ItemContainerAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ItemContainerAutomationPeer_AddToSelection(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ItemContainerAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.ItemContainerAutomationPeer", L"AddToSelection", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.AddToSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ItemContainerAutomationPeer_Invoke(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ItemContainerAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.ItemContainerAutomationPeer", L"Invoke", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Invoke();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ItemContainerAutomationPeer_RemoveFromSelection(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ItemContainerAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.ItemContainerAutomationPeer", L"RemoveFromSelection", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveFromSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ItemContainerAutomationPeer_Select(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ItemContainerAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.ItemContainerAutomationPeer", L"Select", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Select();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ItemContainerAutomationPeer_get_IsSelected(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ItemContainerAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ItemContainerAutomationPeer", L"IsSelected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemContainerAutomationPeer_get_SelectionContainer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ItemContainerAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ItemContainerAutomationPeer", L"SelectionContainer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectionContainer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ItemContainerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::ItemContainerAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ItemContainerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::ItemContainerAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ItemContainerAutomationPeer[] = {
        { "add_to_selection", reinterpret_cast<PyCFunction>(ItemContainerAutomationPeer_AddToSelection), METH_VARARGS, nullptr },
        { "invoke", reinterpret_cast<PyCFunction>(ItemContainerAutomationPeer_Invoke), METH_VARARGS, nullptr },
        { "remove_from_selection", reinterpret_cast<PyCFunction>(ItemContainerAutomationPeer_RemoveFromSelection), METH_VARARGS, nullptr },
        { "select", reinterpret_cast<PyCFunction>(ItemContainerAutomationPeer_Select), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ItemContainerAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ItemContainerAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ItemContainerAutomationPeer[] = {
        { "is_selected", reinterpret_cast<getter>(ItemContainerAutomationPeer_get_IsSelected), nullptr, nullptr, nullptr },
        { "selection_container", reinterpret_cast<getter>(ItemContainerAutomationPeer_get_SelectionContainer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ItemContainerAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ItemContainerAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ItemContainerAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ItemContainerAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ItemContainerAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ItemContainerAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ItemContainerAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ItemContainerAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ItemContainerAutomationPeer};

    static PyGetSetDef getset_ItemContainerAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ItemContainerAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ItemContainerAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ItemContainerAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ItemContainerAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ItemContainerAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ItemContainerAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ItemContainerAutomationPeer_Static
    };

    // ----- ItemsControlAutomationPeer class --------------------

    static PyObject* _new_ItemsControlAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ItemsControl>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::ItemsControlAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ItemsControlAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ItemsControlAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ItemsControlAutomationPeer_CreateItemAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ItemsControlAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.ItemsControlAutomationPeer", L"CreateItemAutomationPeer", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.CreateItemAutomationPeer(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ItemsControlAutomationPeer_FindItemByProperty(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ItemsControlAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.ItemsControlAutomationPeer", L"FindItemByProperty", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Provider::IRawElementProviderSimple>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::AutomationProperty>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);

                return py::convert(self->obj.FindItemByProperty(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ItemsControlAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::ItemsControlAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ItemsControlAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::ItemsControlAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ItemsControlAutomationPeer[] = {
        { "create_item_automation_peer", reinterpret_cast<PyCFunction>(ItemsControlAutomationPeer_CreateItemAutomationPeer), METH_VARARGS, nullptr },
        { "find_item_by_property", reinterpret_cast<PyCFunction>(ItemsControlAutomationPeer_FindItemByProperty), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ItemsControlAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ItemsControlAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ItemsControlAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ItemsControlAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ItemsControlAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ItemsControlAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ItemsControlAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ItemsControlAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ItemsControlAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ItemsControlAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ItemsControlAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ItemsControlAutomationPeer};

    static PyGetSetDef getset_ItemsControlAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ItemsControlAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ItemsControlAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ItemsControlAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ItemsControlAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ItemsControlAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ItemsControlAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ItemsControlAutomationPeer_Static
    };

    // ----- ItemsViewAutomationPeer class --------------------

    static PyObject* _new_ItemsViewAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ItemsView>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::ItemsViewAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ItemsViewAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ItemsViewAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ItemsViewAutomationPeer_GetSelection(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ItemsViewAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.ItemsViewAutomationPeer", L"GetSelection", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetSelection());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ItemsViewAutomationPeer_get_CanSelectMultiple(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ItemsViewAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ItemsViewAutomationPeer", L"CanSelectMultiple");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanSelectMultiple());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ItemsViewAutomationPeer_get_IsSelectionRequired(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ItemsViewAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ItemsViewAutomationPeer", L"IsSelectionRequired");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSelectionRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ItemsViewAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::ItemsViewAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ItemsViewAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::ItemsViewAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ItemsViewAutomationPeer[] = {
        { "get_selection", reinterpret_cast<PyCFunction>(ItemsViewAutomationPeer_GetSelection), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ItemsViewAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ItemsViewAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ItemsViewAutomationPeer[] = {
        { "can_select_multiple", reinterpret_cast<getter>(ItemsViewAutomationPeer_get_CanSelectMultiple), nullptr, nullptr, nullptr },
        { "is_selection_required", reinterpret_cast<getter>(ItemsViewAutomationPeer_get_IsSelectionRequired), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ItemsViewAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ItemsViewAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ItemsViewAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ItemsViewAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ItemsViewAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ItemsViewAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ItemsViewAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ItemsViewAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ItemsViewAutomationPeer};

    static PyGetSetDef getset_ItemsViewAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ItemsViewAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ItemsViewAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ItemsViewAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ItemsViewAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ItemsViewAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ItemsViewAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ItemsViewAutomationPeer_Static
    };

    // ----- ListBoxAutomationPeer class --------------------

    static PyObject* _new_ListBoxAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ListBox>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::ListBoxAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListBoxAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ListBoxAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ListBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::ListBoxAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::ListBoxAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListBoxAutomationPeer[] = {
        { "_assign_array_", _assign_array_ListBoxAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListBoxAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListBoxAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ListBoxAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListBoxAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListBoxAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListBoxAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListBoxAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ListBoxAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ListBoxAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ListBoxAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListBoxAutomationPeer};

    static PyGetSetDef getset_ListBoxAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ListBoxAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListBoxAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListBoxAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListBoxAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ListBoxAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ListBoxAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ListBoxAutomationPeer_Static
    };

    // ----- ListBoxItemAutomationPeer class --------------------

    static PyObject* _new_ListBoxItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ListBoxItem>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::ListBoxItemAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListBoxItemAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ListBoxItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ListBoxItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::ListBoxItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListBoxItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::ListBoxItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListBoxItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_ListBoxItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListBoxItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListBoxItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ListBoxItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListBoxItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListBoxItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListBoxItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListBoxItemAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ListBoxItemAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ListBoxItemAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ListBoxItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListBoxItemAutomationPeer};

    static PyGetSetDef getset_ListBoxItemAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ListBoxItemAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListBoxItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListBoxItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListBoxItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ListBoxItemAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ListBoxItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ListBoxItemAutomationPeer_Static
    };

    // ----- ListBoxItemDataAutomationPeer class --------------------

    static PyObject* _new_ListBoxItemDataAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Peers::ListBoxAutomationPeer>(args, 1);

                winrt::Microsoft::UI::Xaml::Automation::Peers::ListBoxItemDataAutomationPeer instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListBoxItemDataAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ListBoxItemDataAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ListBoxItemDataAutomationPeer_ScrollIntoView(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ListBoxItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.ListBoxItemDataAutomationPeer", L"ScrollIntoView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.ScrollIntoView();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ListBoxItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::ListBoxItemDataAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListBoxItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::ListBoxItemDataAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListBoxItemDataAutomationPeer[] = {
        { "scroll_into_view", reinterpret_cast<PyCFunction>(ListBoxItemDataAutomationPeer_ScrollIntoView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ListBoxItemDataAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListBoxItemDataAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListBoxItemDataAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ListBoxItemDataAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListBoxItemDataAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListBoxItemDataAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListBoxItemDataAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListBoxItemDataAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ListBoxItemDataAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ListBoxItemDataAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ListBoxItemDataAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListBoxItemDataAutomationPeer};

    static PyGetSetDef getset_ListBoxItemDataAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ListBoxItemDataAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListBoxItemDataAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListBoxItemDataAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListBoxItemDataAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ListBoxItemDataAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ListBoxItemDataAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ListBoxItemDataAutomationPeer_Static
    };

    // ----- ListPickerFlyoutPresenterAutomationPeer class --------------------

    static PyObject* _new_ListPickerFlyoutPresenterAutomationPeer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Peers::ListPickerFlyoutPresenterAutomationPeer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Peers::ListPickerFlyoutPresenterAutomationPeer>::type_name);
        return nullptr;
    }

    static void _dealloc_ListPickerFlyoutPresenterAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ListPickerFlyoutPresenterAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ListPickerFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::ListPickerFlyoutPresenterAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListPickerFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::ListPickerFlyoutPresenterAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListPickerFlyoutPresenterAutomationPeer[] = {
        { "_assign_array_", _assign_array_ListPickerFlyoutPresenterAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListPickerFlyoutPresenterAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListPickerFlyoutPresenterAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ListPickerFlyoutPresenterAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListPickerFlyoutPresenterAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListPickerFlyoutPresenterAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListPickerFlyoutPresenterAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListPickerFlyoutPresenterAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ListPickerFlyoutPresenterAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ListPickerFlyoutPresenterAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ListPickerFlyoutPresenterAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListPickerFlyoutPresenterAutomationPeer};

    // ----- ListViewAutomationPeer class --------------------

    static PyObject* _new_ListViewAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ListView>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::ListViewAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListViewAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ListViewAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ListViewAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::ListViewAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListViewAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::ListViewAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListViewAutomationPeer[] = {
        { "_assign_array_", _assign_array_ListViewAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListViewAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListViewAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ListViewAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListViewAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListViewAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListViewAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListViewAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ListViewAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ListViewAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ListViewAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListViewAutomationPeer};

    static PyGetSetDef getset_ListViewAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ListViewAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListViewAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListViewAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListViewAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ListViewAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ListViewAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ListViewAutomationPeer_Static
    };

    // ----- ListViewBaseAutomationPeer class --------------------

    static PyObject* _new_ListViewBaseAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ListViewBase>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListViewBaseAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ListViewBaseAutomationPeer_get_DropEffect(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ListViewBaseAutomationPeer", L"DropEffect");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DropEffect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ListViewBaseAutomationPeer_get_DropEffects(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ListViewBaseAutomationPeer", L"DropEffects");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DropEffects());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ListViewBaseAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListViewBaseAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListViewBaseAutomationPeer[] = {
        { "_assign_array_", _assign_array_ListViewBaseAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListViewBaseAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListViewBaseAutomationPeer[] = {
        { "drop_effect", reinterpret_cast<getter>(ListViewBaseAutomationPeer_get_DropEffect), nullptr, nullptr, nullptr },
        { "drop_effects", reinterpret_cast<getter>(ListViewBaseAutomationPeer_get_DropEffects), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ListViewBaseAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListViewBaseAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListViewBaseAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListViewBaseAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListViewBaseAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ListViewBaseAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ListViewBaseAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListViewBaseAutomationPeer};

    static PyGetSetDef getset_ListViewBaseAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ListViewBaseAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListViewBaseAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListViewBaseAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListViewBaseAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ListViewBaseAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ListViewBaseAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ListViewBaseAutomationPeer_Static
    };

    // ----- ListViewBaseHeaderItemAutomationPeer class --------------------

    static PyObject* _new_ListViewBaseHeaderItemAutomationPeer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Peers::ListViewBaseHeaderItemAutomationPeer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Peers::ListViewBaseHeaderItemAutomationPeer>::type_name);
        return nullptr;
    }

    static void _dealloc_ListViewBaseHeaderItemAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ListViewBaseHeaderItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ListViewBaseHeaderItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::ListViewBaseHeaderItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListViewBaseHeaderItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::ListViewBaseHeaderItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListViewBaseHeaderItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_ListViewBaseHeaderItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListViewBaseHeaderItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListViewBaseHeaderItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ListViewBaseHeaderItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListViewBaseHeaderItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListViewBaseHeaderItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListViewBaseHeaderItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListViewBaseHeaderItemAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ListViewBaseHeaderItemAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ListViewBaseHeaderItemAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ListViewBaseHeaderItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListViewBaseHeaderItemAutomationPeer};

    static PyGetSetDef getset_ListViewBaseHeaderItemAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ListViewBaseHeaderItemAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListViewBaseHeaderItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListViewBaseHeaderItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListViewBaseHeaderItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ListViewBaseHeaderItemAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ListViewBaseHeaderItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ListViewBaseHeaderItemAutomationPeer_Static
    };

    // ----- ListViewHeaderItemAutomationPeer class --------------------

    static PyObject* _new_ListViewHeaderItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ListViewHeaderItem>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::ListViewHeaderItemAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListViewHeaderItemAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ListViewHeaderItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ListViewHeaderItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::ListViewHeaderItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListViewHeaderItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::ListViewHeaderItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListViewHeaderItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_ListViewHeaderItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListViewHeaderItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListViewHeaderItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ListViewHeaderItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListViewHeaderItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListViewHeaderItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListViewHeaderItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListViewHeaderItemAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ListViewHeaderItemAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ListViewHeaderItemAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ListViewHeaderItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListViewHeaderItemAutomationPeer};

    static PyGetSetDef getset_ListViewHeaderItemAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ListViewHeaderItemAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListViewHeaderItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListViewHeaderItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListViewHeaderItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ListViewHeaderItemAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ListViewHeaderItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ListViewHeaderItemAutomationPeer_Static
    };

    // ----- ListViewItemAutomationPeer class --------------------

    static PyObject* _new_ListViewItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ListViewItem>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::ListViewItemAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListViewItemAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ListViewItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ListViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::ListViewItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::ListViewItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListViewItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_ListViewItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListViewItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListViewItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ListViewItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListViewItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListViewItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListViewItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListViewItemAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ListViewItemAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ListViewItemAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ListViewItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListViewItemAutomationPeer};

    static PyGetSetDef getset_ListViewItemAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ListViewItemAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListViewItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListViewItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListViewItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ListViewItemAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ListViewItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ListViewItemAutomationPeer_Static
    };

    // ----- ListViewItemDataAutomationPeer class --------------------

    static PyObject* _new_ListViewItemDataAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Peers::ListViewBaseAutomationPeer>(args, 1);

                winrt::Microsoft::UI::Xaml::Automation::Peers::ListViewItemDataAutomationPeer instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ListViewItemDataAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ListViewItemDataAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ListViewItemDataAutomationPeer_ScrollIntoView(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ListViewItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.ListViewItemDataAutomationPeer", L"ScrollIntoView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.ScrollIntoView();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_ListViewItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::ListViewItemDataAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ListViewItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::ListViewItemDataAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ListViewItemDataAutomationPeer[] = {
        { "scroll_into_view", reinterpret_cast<PyCFunction>(ListViewItemDataAutomationPeer_ScrollIntoView), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ListViewItemDataAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ListViewItemDataAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ListViewItemDataAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ListViewItemDataAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ListViewItemDataAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ListViewItemDataAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ListViewItemDataAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ListViewItemDataAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ListViewItemDataAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ListViewItemDataAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ListViewItemDataAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ListViewItemDataAutomationPeer};

    static PyGetSetDef getset_ListViewItemDataAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ListViewItemDataAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ListViewItemDataAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ListViewItemDataAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ListViewItemDataAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ListViewItemDataAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ListViewItemDataAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ListViewItemDataAutomationPeer_Static
    };

    // ----- LoopingSelectorAutomationPeer class --------------------

    static PyObject* _new_LoopingSelectorAutomationPeer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer>::type_name);
        return nullptr;
    }

    static void _dealloc_LoopingSelectorAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LoopingSelectorAutomationPeer_FindItemByProperty(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"FindItemByProperty", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Provider::IRawElementProviderSimple>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::AutomationProperty>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);

                return py::convert(self->obj.FindItemByProperty(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_GetSelection(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"GetSelection", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetSelection());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_Scroll(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"Scroll", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::ScrollAmount>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::ScrollAmount>(args, 1);

                self->obj.Scroll(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_SetScrollPercent(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"SetScrollPercent", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.SetScrollPercent(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_get_HorizontalScrollPercent(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"HorizontalScrollPercent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontalScrollPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_get_HorizontalViewSize(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"HorizontalViewSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontalViewSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_get_HorizontallyScrollable(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"HorizontallyScrollable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontallyScrollable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_get_VerticalScrollPercent(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"VerticalScrollPercent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticalScrollPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_get_VerticalViewSize(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"VerticalViewSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticalViewSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_get_VerticallyScrollable(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"VerticallyScrollable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticallyScrollable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_get_CanSelectMultiple(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"CanSelectMultiple");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanSelectMultiple());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorAutomationPeer_get_IsSelectionRequired(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.LoopingSelectorAutomationPeer", L"IsSelectionRequired");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSelectionRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LoopingSelectorAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LoopingSelectorAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoopingSelectorAutomationPeer[] = {
        { "find_item_by_property", reinterpret_cast<PyCFunction>(LoopingSelectorAutomationPeer_FindItemByProperty), METH_VARARGS, nullptr },
        { "get_selection", reinterpret_cast<PyCFunction>(LoopingSelectorAutomationPeer_GetSelection), METH_VARARGS, nullptr },
        { "scroll", reinterpret_cast<PyCFunction>(LoopingSelectorAutomationPeer_Scroll), METH_VARARGS, nullptr },
        { "set_scroll_percent", reinterpret_cast<PyCFunction>(LoopingSelectorAutomationPeer_SetScrollPercent), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LoopingSelectorAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LoopingSelectorAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LoopingSelectorAutomationPeer[] = {
        { "horizontal_scroll_percent", reinterpret_cast<getter>(LoopingSelectorAutomationPeer_get_HorizontalScrollPercent), nullptr, nullptr, nullptr },
        { "horizontal_view_size", reinterpret_cast<getter>(LoopingSelectorAutomationPeer_get_HorizontalViewSize), nullptr, nullptr, nullptr },
        { "horizontally_scrollable", reinterpret_cast<getter>(LoopingSelectorAutomationPeer_get_HorizontallyScrollable), nullptr, nullptr, nullptr },
        { "vertical_scroll_percent", reinterpret_cast<getter>(LoopingSelectorAutomationPeer_get_VerticalScrollPercent), nullptr, nullptr, nullptr },
        { "vertical_view_size", reinterpret_cast<getter>(LoopingSelectorAutomationPeer_get_VerticalViewSize), nullptr, nullptr, nullptr },
        { "vertically_scrollable", reinterpret_cast<getter>(LoopingSelectorAutomationPeer_get_VerticallyScrollable), nullptr, nullptr, nullptr },
        { "can_select_multiple", reinterpret_cast<getter>(LoopingSelectorAutomationPeer_get_CanSelectMultiple), nullptr, nullptr, nullptr },
        { "is_selection_required", reinterpret_cast<getter>(LoopingSelectorAutomationPeer_get_IsSelectionRequired), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LoopingSelectorAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LoopingSelectorAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LoopingSelectorAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LoopingSelectorAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LoopingSelectorAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_LoopingSelectorAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.LoopingSelectorAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::LoopingSelectorAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoopingSelectorAutomationPeer};

    // ----- LoopingSelectorItemAutomationPeer class --------------------

    static PyObject* _new_LoopingSelectorItemAutomationPeer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer>::type_name);
        return nullptr;
    }

    static void _dealloc_LoopingSelectorItemAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LoopingSelectorItemAutomationPeer_AddToSelection(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.LoopingSelectorItemAutomationPeer", L"AddToSelection", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.AddToSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorItemAutomationPeer_RemoveFromSelection(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.LoopingSelectorItemAutomationPeer", L"RemoveFromSelection", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveFromSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorItemAutomationPeer_ScrollIntoView(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.LoopingSelectorItemAutomationPeer", L"ScrollIntoView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.ScrollIntoView();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorItemAutomationPeer_Select(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.LoopingSelectorItemAutomationPeer", L"Select", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Select();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorItemAutomationPeer_get_IsSelected(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.LoopingSelectorItemAutomationPeer", L"IsSelected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoopingSelectorItemAutomationPeer_get_SelectionContainer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.LoopingSelectorItemAutomationPeer", L"SelectionContainer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectionContainer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LoopingSelectorItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LoopingSelectorItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoopingSelectorItemAutomationPeer[] = {
        { "add_to_selection", reinterpret_cast<PyCFunction>(LoopingSelectorItemAutomationPeer_AddToSelection), METH_VARARGS, nullptr },
        { "remove_from_selection", reinterpret_cast<PyCFunction>(LoopingSelectorItemAutomationPeer_RemoveFromSelection), METH_VARARGS, nullptr },
        { "scroll_into_view", reinterpret_cast<PyCFunction>(LoopingSelectorItemAutomationPeer_ScrollIntoView), METH_VARARGS, nullptr },
        { "select", reinterpret_cast<PyCFunction>(LoopingSelectorItemAutomationPeer_Select), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LoopingSelectorItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LoopingSelectorItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LoopingSelectorItemAutomationPeer[] = {
        { "is_selected", reinterpret_cast<getter>(LoopingSelectorItemAutomationPeer_get_IsSelected), nullptr, nullptr, nullptr },
        { "selection_container", reinterpret_cast<getter>(LoopingSelectorItemAutomationPeer_get_SelectionContainer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LoopingSelectorItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LoopingSelectorItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LoopingSelectorItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LoopingSelectorItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LoopingSelectorItemAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_LoopingSelectorItemAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.LoopingSelectorItemAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::LoopingSelectorItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoopingSelectorItemAutomationPeer};

    // ----- LoopingSelectorItemDataAutomationPeer class --------------------

    static PyObject* _new_LoopingSelectorItemDataAutomationPeer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Peers::LoopingSelectorItemDataAutomationPeer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Peers::LoopingSelectorItemDataAutomationPeer>::type_name);
        return nullptr;
    }

    static void _dealloc_LoopingSelectorItemDataAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::LoopingSelectorItemDataAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LoopingSelectorItemDataAutomationPeer_Realize(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::LoopingSelectorItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.LoopingSelectorItemDataAutomationPeer", L"Realize", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Realize();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_LoopingSelectorItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::LoopingSelectorItemDataAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LoopingSelectorItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::LoopingSelectorItemDataAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoopingSelectorItemDataAutomationPeer[] = {
        { "realize", reinterpret_cast<PyCFunction>(LoopingSelectorItemDataAutomationPeer_Realize), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_LoopingSelectorItemDataAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LoopingSelectorItemDataAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LoopingSelectorItemDataAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_LoopingSelectorItemDataAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_LoopingSelectorItemDataAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LoopingSelectorItemDataAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LoopingSelectorItemDataAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LoopingSelectorItemDataAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_LoopingSelectorItemDataAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.LoopingSelectorItemDataAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::LoopingSelectorItemDataAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoopingSelectorItemDataAutomationPeer};

    // ----- MediaPlayerElementAutomationPeer class --------------------

    static PyObject* _new_MediaPlayerElementAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::MediaPlayerElement>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::MediaPlayerElementAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaPlayerElementAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::MediaPlayerElementAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MediaPlayerElementAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::MediaPlayerElementAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaPlayerElementAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::MediaPlayerElementAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaPlayerElementAutomationPeer[] = {
        { "_assign_array_", _assign_array_MediaPlayerElementAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaPlayerElementAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaPlayerElementAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaPlayerElementAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaPlayerElementAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaPlayerElementAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaPlayerElementAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaPlayerElementAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_MediaPlayerElementAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.MediaPlayerElementAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::MediaPlayerElementAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPlayerElementAutomationPeer};

    static PyGetSetDef getset_MediaPlayerElementAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_MediaPlayerElementAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_MediaPlayerElementAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MediaPlayerElementAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MediaPlayerElementAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_MediaPlayerElementAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.MediaPlayerElementAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MediaPlayerElementAutomationPeer_Static
    };

    // ----- MediaTransportControlsAutomationPeer class --------------------

    static PyObject* _new_MediaTransportControlsAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::MediaTransportControls>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::MediaTransportControlsAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaTransportControlsAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::MediaTransportControlsAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MediaTransportControlsAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::MediaTransportControlsAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaTransportControlsAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::MediaTransportControlsAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaTransportControlsAutomationPeer[] = {
        { "_assign_array_", _assign_array_MediaTransportControlsAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaTransportControlsAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaTransportControlsAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaTransportControlsAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaTransportControlsAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaTransportControlsAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaTransportControlsAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaTransportControlsAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_MediaTransportControlsAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.MediaTransportControlsAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::MediaTransportControlsAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaTransportControlsAutomationPeer};

    static PyGetSetDef getset_MediaTransportControlsAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_MediaTransportControlsAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_MediaTransportControlsAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MediaTransportControlsAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MediaTransportControlsAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_MediaTransportControlsAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.MediaTransportControlsAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MediaTransportControlsAutomationPeer_Static
    };

    // ----- MenuBarAutomationPeer class --------------------

    static PyObject* _new_MenuBarAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::MenuBar>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::MenuBarAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MenuBarAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::MenuBarAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MenuBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::MenuBarAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MenuBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::MenuBarAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MenuBarAutomationPeer[] = {
        { "_assign_array_", _assign_array_MenuBarAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MenuBarAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MenuBarAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_MenuBarAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MenuBarAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MenuBarAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MenuBarAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MenuBarAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_MenuBarAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.MenuBarAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::MenuBarAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MenuBarAutomationPeer};

    static PyGetSetDef getset_MenuBarAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_MenuBarAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_MenuBarAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MenuBarAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MenuBarAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_MenuBarAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.MenuBarAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MenuBarAutomationPeer_Static
    };

    // ----- MenuBarItemAutomationPeer class --------------------

    static PyObject* _new_MenuBarItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::MenuBarItem>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MenuBarItemAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MenuBarItemAutomationPeer_Collapse(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.MenuBarItemAutomationPeer", L"Collapse", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Collapse();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MenuBarItemAutomationPeer_Expand(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.MenuBarItemAutomationPeer", L"Expand", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Expand();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MenuBarItemAutomationPeer_Invoke(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.MenuBarItemAutomationPeer", L"Invoke", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Invoke();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MenuBarItemAutomationPeer_get_ExpandCollapseState(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.MenuBarItemAutomationPeer", L"ExpandCollapseState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpandCollapseState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MenuBarItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MenuBarItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MenuBarItemAutomationPeer[] = {
        { "collapse", reinterpret_cast<PyCFunction>(MenuBarItemAutomationPeer_Collapse), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(MenuBarItemAutomationPeer_Expand), METH_VARARGS, nullptr },
        { "invoke", reinterpret_cast<PyCFunction>(MenuBarItemAutomationPeer_Invoke), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MenuBarItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MenuBarItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MenuBarItemAutomationPeer[] = {
        { "expand_collapse_state", reinterpret_cast<getter>(MenuBarItemAutomationPeer_get_ExpandCollapseState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MenuBarItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MenuBarItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MenuBarItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MenuBarItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MenuBarItemAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_MenuBarItemAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.MenuBarItemAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::MenuBarItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MenuBarItemAutomationPeer};

    static PyGetSetDef getset_MenuBarItemAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_MenuBarItemAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_MenuBarItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MenuBarItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MenuBarItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_MenuBarItemAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.MenuBarItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MenuBarItemAutomationPeer_Static
    };

    // ----- MenuFlyoutItemAutomationPeer class --------------------

    static PyObject* _new_MenuFlyoutItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::MenuFlyoutItem>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::MenuFlyoutItemAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MenuFlyoutItemAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::MenuFlyoutItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MenuFlyoutItemAutomationPeer_Invoke(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::MenuFlyoutItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.MenuFlyoutItemAutomationPeer", L"Invoke", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Invoke();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_MenuFlyoutItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::MenuFlyoutItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MenuFlyoutItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::MenuFlyoutItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MenuFlyoutItemAutomationPeer[] = {
        { "invoke", reinterpret_cast<PyCFunction>(MenuFlyoutItemAutomationPeer_Invoke), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_MenuFlyoutItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MenuFlyoutItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MenuFlyoutItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_MenuFlyoutItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MenuFlyoutItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MenuFlyoutItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MenuFlyoutItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MenuFlyoutItemAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_MenuFlyoutItemAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.MenuFlyoutItemAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::MenuFlyoutItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MenuFlyoutItemAutomationPeer};

    static PyGetSetDef getset_MenuFlyoutItemAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_MenuFlyoutItemAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_MenuFlyoutItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MenuFlyoutItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MenuFlyoutItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_MenuFlyoutItemAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.MenuFlyoutItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MenuFlyoutItemAutomationPeer_Static
    };

    // ----- MenuFlyoutPresenterAutomationPeer class --------------------

    static PyObject* _new_MenuFlyoutPresenterAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::MenuFlyoutPresenter>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::MenuFlyoutPresenterAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MenuFlyoutPresenterAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::MenuFlyoutPresenterAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_MenuFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::MenuFlyoutPresenterAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MenuFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::MenuFlyoutPresenterAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MenuFlyoutPresenterAutomationPeer[] = {
        { "_assign_array_", _assign_array_MenuFlyoutPresenterAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MenuFlyoutPresenterAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MenuFlyoutPresenterAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_MenuFlyoutPresenterAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_MenuFlyoutPresenterAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MenuFlyoutPresenterAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MenuFlyoutPresenterAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MenuFlyoutPresenterAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_MenuFlyoutPresenterAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.MenuFlyoutPresenterAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::MenuFlyoutPresenterAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MenuFlyoutPresenterAutomationPeer};

    static PyGetSetDef getset_MenuFlyoutPresenterAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_MenuFlyoutPresenterAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_MenuFlyoutPresenterAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_MenuFlyoutPresenterAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_MenuFlyoutPresenterAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_MenuFlyoutPresenterAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.MenuFlyoutPresenterAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_MenuFlyoutPresenterAutomationPeer_Static
    };

    // ----- NavigationViewAutomationPeer class --------------------

    static PyObject* _new_NavigationViewAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::NavigationView>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::NavigationViewAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NavigationViewAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::NavigationViewAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_NavigationViewAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::NavigationViewAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::NavigationViewAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewAutomationPeer[] = {
        { "_assign_array_", _assign_array_NavigationViewAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NavigationViewAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_NavigationViewAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.NavigationViewAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::NavigationViewAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NavigationViewAutomationPeer};

    static PyGetSetDef getset_NavigationViewAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_NavigationViewAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_NavigationViewAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_NavigationViewAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_NavigationViewAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.NavigationViewAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_NavigationViewAutomationPeer_Static
    };

    // ----- NavigationViewItemAutomationPeer class --------------------

    static PyObject* _new_NavigationViewItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::NavigationViewItem>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::NavigationViewItemAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NavigationViewItemAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::NavigationViewItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NavigationViewItemAutomationPeer_Collapse(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::NavigationViewItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.NavigationViewItemAutomationPeer", L"Collapse", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Collapse();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NavigationViewItemAutomationPeer_Expand(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::NavigationViewItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.NavigationViewItemAutomationPeer", L"Expand", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Expand();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NavigationViewItemAutomationPeer_get_ExpandCollapseState(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::NavigationViewItemAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.NavigationViewItemAutomationPeer", L"ExpandCollapseState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpandCollapseState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_NavigationViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::NavigationViewItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NavigationViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::NavigationViewItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NavigationViewItemAutomationPeer[] = {
        { "collapse", reinterpret_cast<PyCFunction>(NavigationViewItemAutomationPeer_Collapse), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(NavigationViewItemAutomationPeer_Expand), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_NavigationViewItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NavigationViewItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NavigationViewItemAutomationPeer[] = {
        { "expand_collapse_state", reinterpret_cast<getter>(NavigationViewItemAutomationPeer_get_ExpandCollapseState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NavigationViewItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NavigationViewItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NavigationViewItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NavigationViewItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NavigationViewItemAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewItemAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.NavigationViewItemAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::NavigationViewItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NavigationViewItemAutomationPeer};

    static PyGetSetDef getset_NavigationViewItemAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_NavigationViewItemAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_NavigationViewItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_NavigationViewItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_NavigationViewItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_NavigationViewItemAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.NavigationViewItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_NavigationViewItemAutomationPeer_Static
    };

    // ----- NumberBoxAutomationPeer class --------------------

    static PyObject* _new_NumberBoxAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::NumberBox>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::NumberBoxAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NumberBoxAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::NumberBoxAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_NumberBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::NumberBoxAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_NumberBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::NumberBoxAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NumberBoxAutomationPeer[] = {
        { "_assign_array_", _assign_array_NumberBoxAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NumberBoxAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NumberBoxAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_NumberBoxAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_NumberBoxAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_NumberBoxAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_NumberBoxAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_NumberBoxAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_NumberBoxAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.NumberBoxAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::NumberBoxAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NumberBoxAutomationPeer};

    static PyGetSetDef getset_NumberBoxAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_NumberBoxAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_NumberBoxAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_NumberBoxAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_NumberBoxAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_NumberBoxAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.NumberBoxAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_NumberBoxAutomationPeer_Static
    };

    // ----- PasswordBoxAutomationPeer class --------------------

    static PyObject* _new_PasswordBoxAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::PasswordBox>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::PasswordBoxAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PasswordBoxAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::PasswordBoxAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PasswordBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::PasswordBoxAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PasswordBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::PasswordBoxAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PasswordBoxAutomationPeer[] = {
        { "_assign_array_", _assign_array_PasswordBoxAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PasswordBoxAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PasswordBoxAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_PasswordBoxAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PasswordBoxAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PasswordBoxAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PasswordBoxAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PasswordBoxAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_PasswordBoxAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.PasswordBoxAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::PasswordBoxAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PasswordBoxAutomationPeer};

    static PyGetSetDef getset_PasswordBoxAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_PasswordBoxAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_PasswordBoxAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PasswordBoxAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PasswordBoxAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_PasswordBoxAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.PasswordBoxAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PasswordBoxAutomationPeer_Static
    };

    // ----- PersonPictureAutomationPeer class --------------------

    static PyObject* _new_PersonPictureAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::PersonPicture>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::PersonPictureAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PersonPictureAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::PersonPictureAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PersonPictureAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::PersonPictureAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PersonPictureAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::PersonPictureAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PersonPictureAutomationPeer[] = {
        { "_assign_array_", _assign_array_PersonPictureAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PersonPictureAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PersonPictureAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_PersonPictureAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PersonPictureAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PersonPictureAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PersonPictureAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PersonPictureAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_PersonPictureAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.PersonPictureAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::PersonPictureAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PersonPictureAutomationPeer};

    static PyGetSetDef getset_PersonPictureAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_PersonPictureAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_PersonPictureAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PersonPictureAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PersonPictureAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_PersonPictureAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.PersonPictureAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PersonPictureAutomationPeer_Static
    };

    // ----- PickerFlyoutPresenterAutomationPeer class --------------------

    static PyObject* _new_PickerFlyoutPresenterAutomationPeer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Peers::PickerFlyoutPresenterAutomationPeer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Peers::PickerFlyoutPresenterAutomationPeer>::type_name);
        return nullptr;
    }

    static void _dealloc_PickerFlyoutPresenterAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::PickerFlyoutPresenterAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PickerFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::PickerFlyoutPresenterAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PickerFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::PickerFlyoutPresenterAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PickerFlyoutPresenterAutomationPeer[] = {
        { "_assign_array_", _assign_array_PickerFlyoutPresenterAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PickerFlyoutPresenterAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PickerFlyoutPresenterAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_PickerFlyoutPresenterAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PickerFlyoutPresenterAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PickerFlyoutPresenterAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PickerFlyoutPresenterAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PickerFlyoutPresenterAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_PickerFlyoutPresenterAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.PickerFlyoutPresenterAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::PickerFlyoutPresenterAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PickerFlyoutPresenterAutomationPeer};

    // ----- PipsPagerAutomationPeer class --------------------

    static PyObject* _new_PipsPagerAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::PipsPager>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::PipsPagerAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PipsPagerAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::PipsPagerAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PipsPagerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::PipsPagerAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PipsPagerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::PipsPagerAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PipsPagerAutomationPeer[] = {
        { "_assign_array_", _assign_array_PipsPagerAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PipsPagerAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PipsPagerAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_PipsPagerAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PipsPagerAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PipsPagerAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PipsPagerAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PipsPagerAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_PipsPagerAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.PipsPagerAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::PipsPagerAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PipsPagerAutomationPeer};

    static PyGetSetDef getset_PipsPagerAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_PipsPagerAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_PipsPagerAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PipsPagerAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PipsPagerAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_PipsPagerAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.PipsPagerAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PipsPagerAutomationPeer_Static
    };

    // ----- PivotAutomationPeer class --------------------

    static PyObject* _new_PivotAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Pivot>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::PivotAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PivotAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::PivotAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PivotAutomationPeer_GetSelection(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"GetSelection", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetSelection());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_Scroll(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"Scroll", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::ScrollAmount>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::ScrollAmount>(args, 1);

                self->obj.Scroll(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_SetScrollPercent(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"SetScrollPercent", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.SetScrollPercent(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_get_HorizontalScrollPercent(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"HorizontalScrollPercent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontalScrollPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_get_HorizontalViewSize(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"HorizontalViewSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontalViewSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_get_HorizontallyScrollable(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"HorizontallyScrollable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontallyScrollable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_get_VerticalScrollPercent(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"VerticalScrollPercent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticalScrollPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_get_VerticalViewSize(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"VerticalViewSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticalViewSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_get_VerticallyScrollable(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"VerticallyScrollable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticallyScrollable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_get_CanSelectMultiple(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"CanSelectMultiple");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanSelectMultiple());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotAutomationPeer_get_IsSelectionRequired(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::PivotAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.PivotAutomationPeer", L"IsSelectionRequired");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSelectionRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PivotAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::PivotAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PivotAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::PivotAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PivotAutomationPeer[] = {
        { "get_selection", reinterpret_cast<PyCFunction>(PivotAutomationPeer_GetSelection), METH_VARARGS, nullptr },
        { "scroll", reinterpret_cast<PyCFunction>(PivotAutomationPeer_Scroll), METH_VARARGS, nullptr },
        { "set_scroll_percent", reinterpret_cast<PyCFunction>(PivotAutomationPeer_SetScrollPercent), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PivotAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PivotAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PivotAutomationPeer[] = {
        { "horizontal_scroll_percent", reinterpret_cast<getter>(PivotAutomationPeer_get_HorizontalScrollPercent), nullptr, nullptr, nullptr },
        { "horizontal_view_size", reinterpret_cast<getter>(PivotAutomationPeer_get_HorizontalViewSize), nullptr, nullptr, nullptr },
        { "horizontally_scrollable", reinterpret_cast<getter>(PivotAutomationPeer_get_HorizontallyScrollable), nullptr, nullptr, nullptr },
        { "vertical_scroll_percent", reinterpret_cast<getter>(PivotAutomationPeer_get_VerticalScrollPercent), nullptr, nullptr, nullptr },
        { "vertical_view_size", reinterpret_cast<getter>(PivotAutomationPeer_get_VerticalViewSize), nullptr, nullptr, nullptr },
        { "vertically_scrollable", reinterpret_cast<getter>(PivotAutomationPeer_get_VerticallyScrollable), nullptr, nullptr, nullptr },
        { "can_select_multiple", reinterpret_cast<getter>(PivotAutomationPeer_get_CanSelectMultiple), nullptr, nullptr, nullptr },
        { "is_selection_required", reinterpret_cast<getter>(PivotAutomationPeer_get_IsSelectionRequired), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PivotAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PivotAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PivotAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PivotAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PivotAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_PivotAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.PivotAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::PivotAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PivotAutomationPeer};

    // ----- PivotItemAutomationPeer class --------------------

    static PyObject* _new_PivotItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::PivotItem>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::PivotItemAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PivotItemAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::PivotItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PivotItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::PivotItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PivotItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::PivotItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PivotItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_PivotItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PivotItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PivotItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_PivotItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PivotItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PivotItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PivotItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PivotItemAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_PivotItemAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.PivotItemAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::PivotItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PivotItemAutomationPeer};

    // ----- PivotItemDataAutomationPeer class --------------------

    static PyObject* _new_PivotItemDataAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Peers::PivotAutomationPeer>(args, 1);

                winrt::Microsoft::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PivotItemDataAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PivotItemDataAutomationPeer_AddToSelection(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.PivotItemDataAutomationPeer", L"AddToSelection", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.AddToSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PivotItemDataAutomationPeer_Realize(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.PivotItemDataAutomationPeer", L"Realize", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Realize();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PivotItemDataAutomationPeer_RemoveFromSelection(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.PivotItemDataAutomationPeer", L"RemoveFromSelection", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveFromSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PivotItemDataAutomationPeer_ScrollIntoView(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.PivotItemDataAutomationPeer", L"ScrollIntoView", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.ScrollIntoView();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PivotItemDataAutomationPeer_Select(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.PivotItemDataAutomationPeer", L"Select", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Select();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PivotItemDataAutomationPeer_get_IsSelected(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.PivotItemDataAutomationPeer", L"IsSelected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PivotItemDataAutomationPeer_get_SelectionContainer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.PivotItemDataAutomationPeer", L"SelectionContainer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectionContainer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PivotItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PivotItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PivotItemDataAutomationPeer[] = {
        { "add_to_selection", reinterpret_cast<PyCFunction>(PivotItemDataAutomationPeer_AddToSelection), METH_VARARGS, nullptr },
        { "realize", reinterpret_cast<PyCFunction>(PivotItemDataAutomationPeer_Realize), METH_VARARGS, nullptr },
        { "remove_from_selection", reinterpret_cast<PyCFunction>(PivotItemDataAutomationPeer_RemoveFromSelection), METH_VARARGS, nullptr },
        { "scroll_into_view", reinterpret_cast<PyCFunction>(PivotItemDataAutomationPeer_ScrollIntoView), METH_VARARGS, nullptr },
        { "select", reinterpret_cast<PyCFunction>(PivotItemDataAutomationPeer_Select), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PivotItemDataAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PivotItemDataAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PivotItemDataAutomationPeer[] = {
        { "is_selected", reinterpret_cast<getter>(PivotItemDataAutomationPeer_get_IsSelected), nullptr, nullptr, nullptr },
        { "selection_container", reinterpret_cast<getter>(PivotItemDataAutomationPeer_get_SelectionContainer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PivotItemDataAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PivotItemDataAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PivotItemDataAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PivotItemDataAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PivotItemDataAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_PivotItemDataAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.PivotItemDataAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::PivotItemDataAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PivotItemDataAutomationPeer};

    // ----- ProgressBarAutomationPeer class --------------------

    static PyObject* _new_ProgressBarAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ProgressBar>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::ProgressBarAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ProgressBarAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ProgressBarAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ProgressBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::ProgressBarAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProgressBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::ProgressBarAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProgressBarAutomationPeer[] = {
        { "_assign_array_", _assign_array_ProgressBarAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProgressBarAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProgressBarAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ProgressBarAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProgressBarAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProgressBarAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProgressBarAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProgressBarAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ProgressBarAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ProgressBarAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ProgressBarAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProgressBarAutomationPeer};

    static PyGetSetDef getset_ProgressBarAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ProgressBarAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ProgressBarAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ProgressBarAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ProgressBarAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ProgressBarAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ProgressBarAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ProgressBarAutomationPeer_Static
    };

    // ----- ProgressRingAutomationPeer class --------------------

    static PyObject* _new_ProgressRingAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ProgressRing>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ProgressRingAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProgressRingAutomationPeer_SetValue(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.ProgressRingAutomationPeer", L"SetValue", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                self->obj.SetValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProgressRingAutomationPeer_get_IsReadOnly(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ProgressRingAutomationPeer", L"IsReadOnly");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressRingAutomationPeer_get_LargeChange(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ProgressRingAutomationPeer", L"LargeChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LargeChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressRingAutomationPeer_get_Maximum(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ProgressRingAutomationPeer", L"Maximum");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Maximum());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressRingAutomationPeer_get_Minimum(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ProgressRingAutomationPeer", L"Minimum");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Minimum());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressRingAutomationPeer_get_SmallChange(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ProgressRingAutomationPeer", L"SmallChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SmallChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProgressRingAutomationPeer_get_Value(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ProgressRingAutomationPeer", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ProgressRingAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ProgressRingAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProgressRingAutomationPeer[] = {
        { "set_value", reinterpret_cast<PyCFunction>(ProgressRingAutomationPeer_SetValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ProgressRingAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProgressRingAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProgressRingAutomationPeer[] = {
        { "is_read_only", reinterpret_cast<getter>(ProgressRingAutomationPeer_get_IsReadOnly), nullptr, nullptr, nullptr },
        { "large_change", reinterpret_cast<getter>(ProgressRingAutomationPeer_get_LargeChange), nullptr, nullptr, nullptr },
        { "maximum", reinterpret_cast<getter>(ProgressRingAutomationPeer_get_Maximum), nullptr, nullptr, nullptr },
        { "minimum", reinterpret_cast<getter>(ProgressRingAutomationPeer_get_Minimum), nullptr, nullptr, nullptr },
        { "small_change", reinterpret_cast<getter>(ProgressRingAutomationPeer_get_SmallChange), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(ProgressRingAutomationPeer_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProgressRingAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ProgressRingAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ProgressRingAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ProgressRingAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ProgressRingAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ProgressRingAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ProgressRingAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ProgressRingAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProgressRingAutomationPeer};

    static PyGetSetDef getset_ProgressRingAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ProgressRingAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ProgressRingAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ProgressRingAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ProgressRingAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ProgressRingAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ProgressRingAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ProgressRingAutomationPeer_Static
    };

    // ----- RadioButtonAutomationPeer class --------------------

    static PyObject* _new_RadioButtonAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::RadioButton>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RadioButtonAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RadioButtonAutomationPeer_AddToSelection(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.RadioButtonAutomationPeer", L"AddToSelection", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.AddToSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadioButtonAutomationPeer_RemoveFromSelection(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.RadioButtonAutomationPeer", L"RemoveFromSelection", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveFromSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadioButtonAutomationPeer_Select(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.RadioButtonAutomationPeer", L"Select", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Select();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RadioButtonAutomationPeer_get_IsSelected(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.RadioButtonAutomationPeer", L"IsSelected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RadioButtonAutomationPeer_get_SelectionContainer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.RadioButtonAutomationPeer", L"SelectionContainer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectionContainer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RadioButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RadioButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadioButtonAutomationPeer[] = {
        { "add_to_selection", reinterpret_cast<PyCFunction>(RadioButtonAutomationPeer_AddToSelection), METH_VARARGS, nullptr },
        { "remove_from_selection", reinterpret_cast<PyCFunction>(RadioButtonAutomationPeer_RemoveFromSelection), METH_VARARGS, nullptr },
        { "select", reinterpret_cast<PyCFunction>(RadioButtonAutomationPeer_Select), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RadioButtonAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RadioButtonAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RadioButtonAutomationPeer[] = {
        { "is_selected", reinterpret_cast<getter>(RadioButtonAutomationPeer_get_IsSelected), nullptr, nullptr, nullptr },
        { "selection_container", reinterpret_cast<getter>(RadioButtonAutomationPeer_get_SelectionContainer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RadioButtonAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RadioButtonAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RadioButtonAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RadioButtonAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RadioButtonAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_RadioButtonAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.RadioButtonAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::RadioButtonAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RadioButtonAutomationPeer};

    static PyGetSetDef getset_RadioButtonAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_RadioButtonAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RadioButtonAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RadioButtonAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RadioButtonAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_RadioButtonAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.RadioButtonAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RadioButtonAutomationPeer_Static
    };

    // ----- RadioButtonsAutomationPeer class --------------------

    static PyObject* _new_RadioButtonsAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::RadioButtons>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::RadioButtonsAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RadioButtonsAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::RadioButtonsAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_RadioButtonsAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::RadioButtonsAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RadioButtonsAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::RadioButtonsAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RadioButtonsAutomationPeer[] = {
        { "_assign_array_", _assign_array_RadioButtonsAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RadioButtonsAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RadioButtonsAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_RadioButtonsAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RadioButtonsAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RadioButtonsAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RadioButtonsAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RadioButtonsAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_RadioButtonsAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.RadioButtonsAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::RadioButtonsAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RadioButtonsAutomationPeer};

    static PyGetSetDef getset_RadioButtonsAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_RadioButtonsAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RadioButtonsAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RadioButtonsAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RadioButtonsAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_RadioButtonsAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.RadioButtonsAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RadioButtonsAutomationPeer_Static
    };

    // ----- RangeBaseAutomationPeer class --------------------

    static PyObject* _new_RangeBaseAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::RangeBase>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RangeBaseAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RangeBaseAutomationPeer_SetValue(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.RangeBaseAutomationPeer", L"SetValue", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);

                self->obj.SetValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RangeBaseAutomationPeer_get_IsReadOnly(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.RangeBaseAutomationPeer", L"IsReadOnly");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBaseAutomationPeer_get_LargeChange(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.RangeBaseAutomationPeer", L"LargeChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LargeChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBaseAutomationPeer_get_Maximum(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.RangeBaseAutomationPeer", L"Maximum");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Maximum());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBaseAutomationPeer_get_Minimum(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.RangeBaseAutomationPeer", L"Minimum");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Minimum());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBaseAutomationPeer_get_SmallChange(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.RangeBaseAutomationPeer", L"SmallChange");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SmallChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RangeBaseAutomationPeer_get_Value(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.RangeBaseAutomationPeer", L"Value");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RangeBaseAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RangeBaseAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RangeBaseAutomationPeer[] = {
        { "set_value", reinterpret_cast<PyCFunction>(RangeBaseAutomationPeer_SetValue), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RangeBaseAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RangeBaseAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RangeBaseAutomationPeer[] = {
        { "is_read_only", reinterpret_cast<getter>(RangeBaseAutomationPeer_get_IsReadOnly), nullptr, nullptr, nullptr },
        { "large_change", reinterpret_cast<getter>(RangeBaseAutomationPeer_get_LargeChange), nullptr, nullptr, nullptr },
        { "maximum", reinterpret_cast<getter>(RangeBaseAutomationPeer_get_Maximum), nullptr, nullptr, nullptr },
        { "minimum", reinterpret_cast<getter>(RangeBaseAutomationPeer_get_Minimum), nullptr, nullptr, nullptr },
        { "small_change", reinterpret_cast<getter>(RangeBaseAutomationPeer_get_SmallChange), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(RangeBaseAutomationPeer_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RangeBaseAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RangeBaseAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RangeBaseAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RangeBaseAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RangeBaseAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_RangeBaseAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.RangeBaseAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::RangeBaseAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RangeBaseAutomationPeer};

    static PyGetSetDef getset_RangeBaseAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_RangeBaseAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RangeBaseAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RangeBaseAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RangeBaseAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_RangeBaseAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.RangeBaseAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RangeBaseAutomationPeer_Static
    };

    // ----- RatingControlAutomationPeer class --------------------

    static PyObject* _new_RatingControlAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::RatingControl>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::RatingControlAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RatingControlAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::RatingControlAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_RatingControlAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::RatingControlAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RatingControlAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::RatingControlAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RatingControlAutomationPeer[] = {
        { "_assign_array_", _assign_array_RatingControlAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RatingControlAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RatingControlAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_RatingControlAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RatingControlAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RatingControlAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RatingControlAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RatingControlAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_RatingControlAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.RatingControlAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::RatingControlAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RatingControlAutomationPeer};

    static PyGetSetDef getset_RatingControlAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_RatingControlAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RatingControlAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RatingControlAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RatingControlAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_RatingControlAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.RatingControlAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RatingControlAutomationPeer_Static
    };

    // ----- RepeatButtonAutomationPeer class --------------------

    static PyObject* _new_RepeatButtonAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::RepeatButton>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::RepeatButtonAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RepeatButtonAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::RepeatButtonAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RepeatButtonAutomationPeer_Invoke(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::RepeatButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.RepeatButtonAutomationPeer", L"Invoke", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Invoke();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_RepeatButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::RepeatButtonAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RepeatButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::RepeatButtonAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RepeatButtonAutomationPeer[] = {
        { "invoke", reinterpret_cast<PyCFunction>(RepeatButtonAutomationPeer_Invoke), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RepeatButtonAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RepeatButtonAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RepeatButtonAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_RepeatButtonAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RepeatButtonAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RepeatButtonAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RepeatButtonAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RepeatButtonAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_RepeatButtonAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.RepeatButtonAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::RepeatButtonAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RepeatButtonAutomationPeer};

    static PyGetSetDef getset_RepeatButtonAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_RepeatButtonAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RepeatButtonAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RepeatButtonAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RepeatButtonAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_RepeatButtonAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.RepeatButtonAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RepeatButtonAutomationPeer_Static
    };

    // ----- RepeaterAutomationPeer class --------------------

    static PyObject* _new_RepeaterAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ItemsRepeater>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::RepeaterAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RepeaterAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::RepeaterAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_RepeaterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::RepeaterAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RepeaterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::RepeaterAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RepeaterAutomationPeer[] = {
        { "_assign_array_", _assign_array_RepeaterAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RepeaterAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RepeaterAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_RepeaterAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RepeaterAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RepeaterAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RepeaterAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RepeaterAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_RepeaterAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.RepeaterAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::RepeaterAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RepeaterAutomationPeer};

    static PyGetSetDef getset_RepeaterAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_RepeaterAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RepeaterAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RepeaterAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RepeaterAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_RepeaterAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.RepeaterAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RepeaterAutomationPeer_Static
    };

    // ----- RichEditBoxAutomationPeer class --------------------

    static PyObject* _new_RichEditBoxAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::RichEditBox>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::RichEditBoxAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RichEditBoxAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::RichEditBoxAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_RichEditBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::RichEditBoxAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RichEditBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::RichEditBoxAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RichEditBoxAutomationPeer[] = {
        { "_assign_array_", _assign_array_RichEditBoxAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RichEditBoxAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RichEditBoxAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_RichEditBoxAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RichEditBoxAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RichEditBoxAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RichEditBoxAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RichEditBoxAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_RichEditBoxAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.RichEditBoxAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::RichEditBoxAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RichEditBoxAutomationPeer};

    static PyGetSetDef getset_RichEditBoxAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_RichEditBoxAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RichEditBoxAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RichEditBoxAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RichEditBoxAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_RichEditBoxAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.RichEditBoxAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RichEditBoxAutomationPeer_Static
    };

    // ----- RichTextBlockAutomationPeer class --------------------

    static PyObject* _new_RichTextBlockAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::RichTextBlock>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::RichTextBlockAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RichTextBlockAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::RichTextBlockAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_RichTextBlockAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::RichTextBlockAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RichTextBlockAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::RichTextBlockAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RichTextBlockAutomationPeer[] = {
        { "_assign_array_", _assign_array_RichTextBlockAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RichTextBlockAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RichTextBlockAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_RichTextBlockAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RichTextBlockAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RichTextBlockAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RichTextBlockAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RichTextBlockAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_RichTextBlockAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.RichTextBlockAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::RichTextBlockAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RichTextBlockAutomationPeer};

    static PyGetSetDef getset_RichTextBlockAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_RichTextBlockAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RichTextBlockAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RichTextBlockAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RichTextBlockAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_RichTextBlockAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.RichTextBlockAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RichTextBlockAutomationPeer_Static
    };

    // ----- RichTextBlockOverflowAutomationPeer class --------------------

    static PyObject* _new_RichTextBlockOverflowAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::RichTextBlockOverflow>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::RichTextBlockOverflowAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RichTextBlockOverflowAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::RichTextBlockOverflowAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_RichTextBlockOverflowAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::RichTextBlockOverflowAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RichTextBlockOverflowAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::RichTextBlockOverflowAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RichTextBlockOverflowAutomationPeer[] = {
        { "_assign_array_", _assign_array_RichTextBlockOverflowAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RichTextBlockOverflowAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RichTextBlockOverflowAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_RichTextBlockOverflowAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RichTextBlockOverflowAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RichTextBlockOverflowAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RichTextBlockOverflowAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RichTextBlockOverflowAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_RichTextBlockOverflowAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.RichTextBlockOverflowAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::RichTextBlockOverflowAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RichTextBlockOverflowAutomationPeer};

    static PyGetSetDef getset_RichTextBlockOverflowAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_RichTextBlockOverflowAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_RichTextBlockOverflowAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RichTextBlockOverflowAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RichTextBlockOverflowAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_RichTextBlockOverflowAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.RichTextBlockOverflowAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RichTextBlockOverflowAutomationPeer_Static
    };

    // ----- ScrollBarAutomationPeer class --------------------

    static PyObject* _new_ScrollBarAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollBar>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::ScrollBarAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ScrollBarAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ScrollBarAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ScrollBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::ScrollBarAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScrollBarAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::ScrollBarAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScrollBarAutomationPeer[] = {
        { "_assign_array_", _assign_array_ScrollBarAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScrollBarAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScrollBarAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ScrollBarAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScrollBarAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScrollBarAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScrollBarAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScrollBarAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ScrollBarAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ScrollBarAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ScrollBarAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScrollBarAutomationPeer};

    static PyGetSetDef getset_ScrollBarAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ScrollBarAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ScrollBarAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ScrollBarAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ScrollBarAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ScrollBarAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ScrollBarAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ScrollBarAutomationPeer_Static
    };

    // ----- ScrollPresenterAutomationPeer class --------------------

    static PyObject* _new_ScrollPresenterAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::ScrollPresenter>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::ScrollPresenterAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ScrollPresenterAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ScrollPresenterAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ScrollPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::ScrollPresenterAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScrollPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::ScrollPresenterAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScrollPresenterAutomationPeer[] = {
        { "_assign_array_", _assign_array_ScrollPresenterAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScrollPresenterAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScrollPresenterAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ScrollPresenterAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScrollPresenterAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScrollPresenterAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScrollPresenterAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScrollPresenterAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ScrollPresenterAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ScrollPresenterAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ScrollPresenterAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScrollPresenterAutomationPeer};

    static PyGetSetDef getset_ScrollPresenterAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ScrollPresenterAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ScrollPresenterAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ScrollPresenterAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ScrollPresenterAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ScrollPresenterAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ScrollPresenterAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ScrollPresenterAutomationPeer_Static
    };

    // ----- ScrollViewerAutomationPeer class --------------------

    static PyObject* _new_ScrollViewerAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ScrollViewer>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ScrollViewerAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ScrollViewerAutomationPeer_Scroll(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.ScrollViewerAutomationPeer", L"Scroll", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::ScrollAmount>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::ScrollAmount>(args, 1);

                self->obj.Scroll(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ScrollViewerAutomationPeer_SetScrollPercent(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.ScrollViewerAutomationPeer", L"SetScrollPercent", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.SetScrollPercent(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ScrollViewerAutomationPeer_get_HorizontalScrollPercent(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ScrollViewerAutomationPeer", L"HorizontalScrollPercent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontalScrollPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollViewerAutomationPeer_get_HorizontalViewSize(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ScrollViewerAutomationPeer", L"HorizontalViewSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontalViewSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollViewerAutomationPeer_get_HorizontallyScrollable(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ScrollViewerAutomationPeer", L"HorizontallyScrollable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HorizontallyScrollable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollViewerAutomationPeer_get_VerticalScrollPercent(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ScrollViewerAutomationPeer", L"VerticalScrollPercent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticalScrollPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollViewerAutomationPeer_get_VerticalViewSize(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ScrollViewerAutomationPeer", L"VerticalViewSize");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticalViewSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ScrollViewerAutomationPeer_get_VerticallyScrollable(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ScrollViewerAutomationPeer", L"VerticallyScrollable");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VerticallyScrollable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ScrollViewerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ScrollViewerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ScrollViewerAutomationPeer[] = {
        { "scroll", reinterpret_cast<PyCFunction>(ScrollViewerAutomationPeer_Scroll), METH_VARARGS, nullptr },
        { "set_scroll_percent", reinterpret_cast<PyCFunction>(ScrollViewerAutomationPeer_SetScrollPercent), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ScrollViewerAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ScrollViewerAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ScrollViewerAutomationPeer[] = {
        { "horizontal_scroll_percent", reinterpret_cast<getter>(ScrollViewerAutomationPeer_get_HorizontalScrollPercent), nullptr, nullptr, nullptr },
        { "horizontal_view_size", reinterpret_cast<getter>(ScrollViewerAutomationPeer_get_HorizontalViewSize), nullptr, nullptr, nullptr },
        { "horizontally_scrollable", reinterpret_cast<getter>(ScrollViewerAutomationPeer_get_HorizontallyScrollable), nullptr, nullptr, nullptr },
        { "vertical_scroll_percent", reinterpret_cast<getter>(ScrollViewerAutomationPeer_get_VerticalScrollPercent), nullptr, nullptr, nullptr },
        { "vertical_view_size", reinterpret_cast<getter>(ScrollViewerAutomationPeer_get_VerticalViewSize), nullptr, nullptr, nullptr },
        { "vertically_scrollable", reinterpret_cast<getter>(ScrollViewerAutomationPeer_get_VerticallyScrollable), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ScrollViewerAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ScrollViewerAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ScrollViewerAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ScrollViewerAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ScrollViewerAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ScrollViewerAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ScrollViewerAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ScrollViewerAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ScrollViewerAutomationPeer};

    static PyGetSetDef getset_ScrollViewerAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ScrollViewerAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ScrollViewerAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ScrollViewerAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ScrollViewerAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ScrollViewerAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ScrollViewerAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ScrollViewerAutomationPeer_Static
    };

    // ----- SelectorAutomationPeer class --------------------

    static PyObject* _new_SelectorAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::Selector>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::SelectorAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SelectorAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::SelectorAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SelectorAutomationPeer_GetSelection(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::SelectorAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.SelectorAutomationPeer", L"GetSelection", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetSelection());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SelectorAutomationPeer_get_CanSelectMultiple(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::SelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.SelectorAutomationPeer", L"CanSelectMultiple");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CanSelectMultiple());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SelectorAutomationPeer_get_IsSelectionRequired(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::SelectorAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.SelectorAutomationPeer", L"IsSelectionRequired");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSelectionRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SelectorAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::SelectorAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SelectorAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::SelectorAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SelectorAutomationPeer[] = {
        { "get_selection", reinterpret_cast<PyCFunction>(SelectorAutomationPeer_GetSelection), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SelectorAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SelectorAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SelectorAutomationPeer[] = {
        { "can_select_multiple", reinterpret_cast<getter>(SelectorAutomationPeer_get_CanSelectMultiple), nullptr, nullptr, nullptr },
        { "is_selection_required", reinterpret_cast<getter>(SelectorAutomationPeer_get_IsSelectionRequired), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SelectorAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SelectorAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SelectorAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SelectorAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SelectorAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_SelectorAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.SelectorAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::SelectorAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SelectorAutomationPeer};

    static PyGetSetDef getset_SelectorAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_SelectorAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_SelectorAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SelectorAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SelectorAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_SelectorAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.SelectorAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SelectorAutomationPeer_Static
    };

    // ----- SelectorBarItemAutomationPeer class --------------------

    static PyObject* _new_SelectorBarItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::SelectorBarItem>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::SelectorBarItemAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SelectorBarItemAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::SelectorBarItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SelectorBarItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::SelectorBarItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SelectorBarItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::SelectorBarItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SelectorBarItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_SelectorBarItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SelectorBarItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SelectorBarItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_SelectorBarItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SelectorBarItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SelectorBarItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SelectorBarItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SelectorBarItemAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_SelectorBarItemAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.SelectorBarItemAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::SelectorBarItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SelectorBarItemAutomationPeer};

    static PyGetSetDef getset_SelectorBarItemAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_SelectorBarItemAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_SelectorBarItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SelectorBarItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SelectorBarItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_SelectorBarItemAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.SelectorBarItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SelectorBarItemAutomationPeer_Static
    };

    // ----- SelectorItemAutomationPeer class --------------------

    static PyObject* _new_SelectorItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Peers::SelectorAutomationPeer>(args, 1);

                winrt::Microsoft::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SelectorItemAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SelectorItemAutomationPeer_AddToSelection(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.SelectorItemAutomationPeer", L"AddToSelection", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.AddToSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SelectorItemAutomationPeer_RemoveFromSelection(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.SelectorItemAutomationPeer", L"RemoveFromSelection", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.RemoveFromSelection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SelectorItemAutomationPeer_Select(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.SelectorItemAutomationPeer", L"Select", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Select();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SelectorItemAutomationPeer_get_IsSelected(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.SelectorItemAutomationPeer", L"IsSelected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SelectorItemAutomationPeer_get_SelectionContainer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.SelectorItemAutomationPeer", L"SelectionContainer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectionContainer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SelectorItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SelectorItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SelectorItemAutomationPeer[] = {
        { "add_to_selection", reinterpret_cast<PyCFunction>(SelectorItemAutomationPeer_AddToSelection), METH_VARARGS, nullptr },
        { "remove_from_selection", reinterpret_cast<PyCFunction>(SelectorItemAutomationPeer_RemoveFromSelection), METH_VARARGS, nullptr },
        { "select", reinterpret_cast<PyCFunction>(SelectorItemAutomationPeer_Select), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SelectorItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SelectorItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SelectorItemAutomationPeer[] = {
        { "is_selected", reinterpret_cast<getter>(SelectorItemAutomationPeer_get_IsSelected), nullptr, nullptr, nullptr },
        { "selection_container", reinterpret_cast<getter>(SelectorItemAutomationPeer_get_SelectionContainer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SelectorItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SelectorItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SelectorItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SelectorItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SelectorItemAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_SelectorItemAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.SelectorItemAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::SelectorItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SelectorItemAutomationPeer};

    static PyGetSetDef getset_SelectorItemAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_SelectorItemAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_SelectorItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SelectorItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SelectorItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_SelectorItemAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.SelectorItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SelectorItemAutomationPeer_Static
    };

    // ----- SemanticZoomAutomationPeer class --------------------

    static PyObject* _new_SemanticZoomAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::SemanticZoom>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::SemanticZoomAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SemanticZoomAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::SemanticZoomAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SemanticZoomAutomationPeer_Toggle(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::SemanticZoomAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.SemanticZoomAutomationPeer", L"Toggle", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Toggle();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SemanticZoomAutomationPeer_get_ToggleState(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::SemanticZoomAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.SemanticZoomAutomationPeer", L"ToggleState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ToggleState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SemanticZoomAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::SemanticZoomAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SemanticZoomAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::SemanticZoomAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SemanticZoomAutomationPeer[] = {
        { "toggle", reinterpret_cast<PyCFunction>(SemanticZoomAutomationPeer_Toggle), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SemanticZoomAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SemanticZoomAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SemanticZoomAutomationPeer[] = {
        { "toggle_state", reinterpret_cast<getter>(SemanticZoomAutomationPeer_get_ToggleState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SemanticZoomAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SemanticZoomAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SemanticZoomAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SemanticZoomAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SemanticZoomAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_SemanticZoomAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.SemanticZoomAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::SemanticZoomAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SemanticZoomAutomationPeer};

    static PyGetSetDef getset_SemanticZoomAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_SemanticZoomAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_SemanticZoomAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SemanticZoomAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SemanticZoomAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_SemanticZoomAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.SemanticZoomAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SemanticZoomAutomationPeer_Static
    };

    // ----- SliderAutomationPeer class --------------------

    static PyObject* _new_SliderAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Slider>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::SliderAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SliderAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::SliderAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SliderAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::SliderAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SliderAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::SliderAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SliderAutomationPeer[] = {
        { "_assign_array_", _assign_array_SliderAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SliderAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SliderAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_SliderAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SliderAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SliderAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SliderAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SliderAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_SliderAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.SliderAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::SliderAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SliderAutomationPeer};

    static PyGetSetDef getset_SliderAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_SliderAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_SliderAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SliderAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SliderAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_SliderAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.SliderAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SliderAutomationPeer_Static
    };

    // ----- SplitButtonAutomationPeer class --------------------

    static PyObject* _new_SplitButtonAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::SplitButton>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::SplitButtonAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SplitButtonAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::SplitButtonAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SplitButtonAutomationPeer_Collapse(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::SplitButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.SplitButtonAutomationPeer", L"Collapse", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Collapse();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SplitButtonAutomationPeer_Expand(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::SplitButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.SplitButtonAutomationPeer", L"Expand", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Expand();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SplitButtonAutomationPeer_Invoke(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::SplitButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.SplitButtonAutomationPeer", L"Invoke", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Invoke();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SplitButtonAutomationPeer_get_ExpandCollapseState(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::SplitButtonAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.SplitButtonAutomationPeer", L"ExpandCollapseState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpandCollapseState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SplitButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::SplitButtonAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SplitButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::SplitButtonAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SplitButtonAutomationPeer[] = {
        { "collapse", reinterpret_cast<PyCFunction>(SplitButtonAutomationPeer_Collapse), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(SplitButtonAutomationPeer_Expand), METH_VARARGS, nullptr },
        { "invoke", reinterpret_cast<PyCFunction>(SplitButtonAutomationPeer_Invoke), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SplitButtonAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SplitButtonAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SplitButtonAutomationPeer[] = {
        { "expand_collapse_state", reinterpret_cast<getter>(SplitButtonAutomationPeer_get_ExpandCollapseState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SplitButtonAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SplitButtonAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SplitButtonAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SplitButtonAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SplitButtonAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_SplitButtonAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.SplitButtonAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::SplitButtonAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SplitButtonAutomationPeer};

    static PyGetSetDef getset_SplitButtonAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_SplitButtonAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_SplitButtonAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SplitButtonAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SplitButtonAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_SplitButtonAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.SplitButtonAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SplitButtonAutomationPeer_Static
    };

    // ----- TabViewAutomationPeer class --------------------

    static PyObject* _new_TabViewAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::TabView>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::TabViewAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TabViewAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::TabViewAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TabViewAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::TabViewAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TabViewAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::TabViewAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TabViewAutomationPeer[] = {
        { "_assign_array_", _assign_array_TabViewAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TabViewAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TabViewAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_TabViewAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TabViewAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TabViewAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TabViewAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TabViewAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_TabViewAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.TabViewAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::TabViewAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TabViewAutomationPeer};

    static PyGetSetDef getset_TabViewAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_TabViewAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TabViewAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TabViewAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TabViewAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_TabViewAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.TabViewAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TabViewAutomationPeer_Static
    };

    // ----- TabViewItemAutomationPeer class --------------------

    static PyObject* _new_TabViewItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::TabViewItem>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::TabViewItemAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TabViewItemAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::TabViewItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TabViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::TabViewItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TabViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::TabViewItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TabViewItemAutomationPeer[] = {
        { "_assign_array_", _assign_array_TabViewItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TabViewItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TabViewItemAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_TabViewItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TabViewItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TabViewItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TabViewItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TabViewItemAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_TabViewItemAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.TabViewItemAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::TabViewItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TabViewItemAutomationPeer};

    static PyGetSetDef getset_TabViewItemAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_TabViewItemAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TabViewItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TabViewItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TabViewItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_TabViewItemAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.TabViewItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TabViewItemAutomationPeer_Static
    };

    // ----- TeachingTipAutomationPeer class --------------------

    static PyObject* _new_TeachingTipAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::TeachingTip>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::TeachingTipAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TeachingTipAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::TeachingTipAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TeachingTipAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::TeachingTipAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TeachingTipAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::TeachingTipAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TeachingTipAutomationPeer[] = {
        { "_assign_array_", _assign_array_TeachingTipAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TeachingTipAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TeachingTipAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_TeachingTipAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TeachingTipAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TeachingTipAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TeachingTipAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TeachingTipAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_TeachingTipAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.TeachingTipAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::TeachingTipAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TeachingTipAutomationPeer};

    static PyGetSetDef getset_TeachingTipAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_TeachingTipAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TeachingTipAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TeachingTipAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TeachingTipAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_TeachingTipAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.TeachingTipAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TeachingTipAutomationPeer_Static
    };

    // ----- TextBlockAutomationPeer class --------------------

    static PyObject* _new_TextBlockAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::TextBlock>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::TextBlockAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TextBlockAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::TextBlockAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TextBlockAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::TextBlockAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TextBlockAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::TextBlockAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TextBlockAutomationPeer[] = {
        { "_assign_array_", _assign_array_TextBlockAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TextBlockAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TextBlockAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_TextBlockAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TextBlockAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TextBlockAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TextBlockAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TextBlockAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_TextBlockAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.TextBlockAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::TextBlockAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TextBlockAutomationPeer};

    static PyGetSetDef getset_TextBlockAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_TextBlockAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TextBlockAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TextBlockAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TextBlockAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_TextBlockAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.TextBlockAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TextBlockAutomationPeer_Static
    };

    // ----- TextBoxAutomationPeer class --------------------

    static PyObject* _new_TextBoxAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::TextBox>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::TextBoxAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TextBoxAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::TextBoxAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TextBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::TextBoxAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TextBoxAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::TextBoxAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TextBoxAutomationPeer[] = {
        { "_assign_array_", _assign_array_TextBoxAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TextBoxAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TextBoxAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_TextBoxAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TextBoxAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TextBoxAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TextBoxAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TextBoxAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_TextBoxAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.TextBoxAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::TextBoxAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TextBoxAutomationPeer};

    static PyGetSetDef getset_TextBoxAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_TextBoxAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TextBoxAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TextBoxAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TextBoxAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_TextBoxAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.TextBoxAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TextBoxAutomationPeer_Static
    };

    // ----- ThumbAutomationPeer class --------------------

    static PyObject* _new_ThumbAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::Thumb>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::ThumbAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ThumbAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ThumbAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_ThumbAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::ThumbAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ThumbAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::ThumbAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ThumbAutomationPeer[] = {
        { "_assign_array_", _assign_array_ThumbAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ThumbAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ThumbAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_ThumbAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ThumbAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ThumbAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ThumbAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ThumbAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ThumbAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ThumbAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ThumbAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ThumbAutomationPeer};

    static PyGetSetDef getset_ThumbAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ThumbAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ThumbAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ThumbAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ThumbAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ThumbAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ThumbAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ThumbAutomationPeer_Static
    };

    // ----- TimePickerAutomationPeer class --------------------

    static PyObject* _new_TimePickerAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::TimePicker>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::TimePickerAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimePickerAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::TimePickerAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TimePickerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::TimePickerAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimePickerAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::TimePickerAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimePickerAutomationPeer[] = {
        { "_assign_array_", _assign_array_TimePickerAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimePickerAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimePickerAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_TimePickerAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimePickerAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimePickerAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimePickerAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimePickerAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_TimePickerAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.TimePickerAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::TimePickerAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimePickerAutomationPeer};

    static PyGetSetDef getset_TimePickerAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_TimePickerAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TimePickerAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TimePickerAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TimePickerAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_TimePickerAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.TimePickerAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TimePickerAutomationPeer_Static
    };

    // ----- TimePickerFlyoutPresenterAutomationPeer class --------------------

    static PyObject* _new_TimePickerFlyoutPresenterAutomationPeer(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Peers::TimePickerFlyoutPresenterAutomationPeer>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Automation::Peers::TimePickerFlyoutPresenterAutomationPeer>::type_name);
        return nullptr;
    }

    static void _dealloc_TimePickerFlyoutPresenterAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::TimePickerFlyoutPresenterAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TimePickerFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::TimePickerFlyoutPresenterAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TimePickerFlyoutPresenterAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::TimePickerFlyoutPresenterAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimePickerFlyoutPresenterAutomationPeer[] = {
        { "_assign_array_", _assign_array_TimePickerFlyoutPresenterAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimePickerFlyoutPresenterAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimePickerFlyoutPresenterAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_TimePickerFlyoutPresenterAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TimePickerFlyoutPresenterAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TimePickerFlyoutPresenterAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TimePickerFlyoutPresenterAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TimePickerFlyoutPresenterAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_TimePickerFlyoutPresenterAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.TimePickerFlyoutPresenterAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::TimePickerFlyoutPresenterAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimePickerFlyoutPresenterAutomationPeer};

    // ----- ToggleButtonAutomationPeer class --------------------

    static PyObject* _new_ToggleButtonAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::Primitives::ToggleButton>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::ToggleButtonAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ToggleButtonAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ToggleButtonAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToggleButtonAutomationPeer_Toggle(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ToggleButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.ToggleButtonAutomationPeer", L"Toggle", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Toggle();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToggleButtonAutomationPeer_get_ToggleState(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ToggleButtonAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ToggleButtonAutomationPeer", L"ToggleState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ToggleState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToggleButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::ToggleButtonAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToggleButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::ToggleButtonAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToggleButtonAutomationPeer[] = {
        { "toggle", reinterpret_cast<PyCFunction>(ToggleButtonAutomationPeer_Toggle), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ToggleButtonAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToggleButtonAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToggleButtonAutomationPeer[] = {
        { "toggle_state", reinterpret_cast<getter>(ToggleButtonAutomationPeer_get_ToggleState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ToggleButtonAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToggleButtonAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToggleButtonAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToggleButtonAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToggleButtonAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ToggleButtonAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ToggleButtonAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ToggleButtonAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToggleButtonAutomationPeer};

    static PyGetSetDef getset_ToggleButtonAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ToggleButtonAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ToggleButtonAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ToggleButtonAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ToggleButtonAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ToggleButtonAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ToggleButtonAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ToggleButtonAutomationPeer_Static
    };

    // ----- ToggleMenuFlyoutItemAutomationPeer class --------------------

    static PyObject* _new_ToggleMenuFlyoutItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ToggleMenuFlyoutItem>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::ToggleMenuFlyoutItemAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ToggleMenuFlyoutItemAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ToggleMenuFlyoutItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToggleMenuFlyoutItemAutomationPeer_Toggle(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ToggleMenuFlyoutItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.ToggleMenuFlyoutItemAutomationPeer", L"Toggle", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Toggle();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToggleMenuFlyoutItemAutomationPeer_get_ToggleState(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ToggleMenuFlyoutItemAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ToggleMenuFlyoutItemAutomationPeer", L"ToggleState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ToggleState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToggleMenuFlyoutItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::ToggleMenuFlyoutItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToggleMenuFlyoutItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::ToggleMenuFlyoutItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToggleMenuFlyoutItemAutomationPeer[] = {
        { "toggle", reinterpret_cast<PyCFunction>(ToggleMenuFlyoutItemAutomationPeer_Toggle), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ToggleMenuFlyoutItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToggleMenuFlyoutItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToggleMenuFlyoutItemAutomationPeer[] = {
        { "toggle_state", reinterpret_cast<getter>(ToggleMenuFlyoutItemAutomationPeer_get_ToggleState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ToggleMenuFlyoutItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToggleMenuFlyoutItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToggleMenuFlyoutItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToggleMenuFlyoutItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToggleMenuFlyoutItemAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ToggleMenuFlyoutItemAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ToggleMenuFlyoutItemAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ToggleMenuFlyoutItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToggleMenuFlyoutItemAutomationPeer};

    static PyGetSetDef getset_ToggleMenuFlyoutItemAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ToggleMenuFlyoutItemAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ToggleMenuFlyoutItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ToggleMenuFlyoutItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ToggleMenuFlyoutItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ToggleMenuFlyoutItemAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ToggleMenuFlyoutItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ToggleMenuFlyoutItemAutomationPeer_Static
    };

    // ----- ToggleSplitButtonAutomationPeer class --------------------

    static PyObject* _new_ToggleSplitButtonAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ToggleSplitButton>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::ToggleSplitButtonAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ToggleSplitButtonAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ToggleSplitButtonAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToggleSplitButtonAutomationPeer_Collapse(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ToggleSplitButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.ToggleSplitButtonAutomationPeer", L"Collapse", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Collapse();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToggleSplitButtonAutomationPeer_Expand(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ToggleSplitButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.ToggleSplitButtonAutomationPeer", L"Expand", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Expand();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToggleSplitButtonAutomationPeer_Toggle(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ToggleSplitButtonAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.ToggleSplitButtonAutomationPeer", L"Toggle", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Toggle();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToggleSplitButtonAutomationPeer_get_ExpandCollapseState(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ToggleSplitButtonAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ToggleSplitButtonAutomationPeer", L"ExpandCollapseState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpandCollapseState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToggleSplitButtonAutomationPeer_get_ToggleState(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ToggleSplitButtonAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ToggleSplitButtonAutomationPeer", L"ToggleState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ToggleState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToggleSplitButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::ToggleSplitButtonAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToggleSplitButtonAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::ToggleSplitButtonAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToggleSplitButtonAutomationPeer[] = {
        { "collapse", reinterpret_cast<PyCFunction>(ToggleSplitButtonAutomationPeer_Collapse), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(ToggleSplitButtonAutomationPeer_Expand), METH_VARARGS, nullptr },
        { "toggle", reinterpret_cast<PyCFunction>(ToggleSplitButtonAutomationPeer_Toggle), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ToggleSplitButtonAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToggleSplitButtonAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToggleSplitButtonAutomationPeer[] = {
        { "expand_collapse_state", reinterpret_cast<getter>(ToggleSplitButtonAutomationPeer_get_ExpandCollapseState), nullptr, nullptr, nullptr },
        { "toggle_state", reinterpret_cast<getter>(ToggleSplitButtonAutomationPeer_get_ToggleState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ToggleSplitButtonAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToggleSplitButtonAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToggleSplitButtonAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToggleSplitButtonAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToggleSplitButtonAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ToggleSplitButtonAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ToggleSplitButtonAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ToggleSplitButtonAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToggleSplitButtonAutomationPeer};

    static PyGetSetDef getset_ToggleSplitButtonAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ToggleSplitButtonAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ToggleSplitButtonAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ToggleSplitButtonAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ToggleSplitButtonAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ToggleSplitButtonAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ToggleSplitButtonAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ToggleSplitButtonAutomationPeer_Static
    };

    // ----- ToggleSwitchAutomationPeer class --------------------

    static PyObject* _new_ToggleSwitchAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::ToggleSwitch>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::ToggleSwitchAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ToggleSwitchAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ToggleSwitchAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToggleSwitchAutomationPeer_Toggle(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ToggleSwitchAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.ToggleSwitchAutomationPeer", L"Toggle", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Toggle();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ToggleSwitchAutomationPeer_get_ToggleState(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ToggleSwitchAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.ToggleSwitchAutomationPeer", L"ToggleState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ToggleState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ToggleSwitchAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::ToggleSwitchAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ToggleSwitchAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::ToggleSwitchAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToggleSwitchAutomationPeer[] = {
        { "toggle", reinterpret_cast<PyCFunction>(ToggleSwitchAutomationPeer_Toggle), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_ToggleSwitchAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ToggleSwitchAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToggleSwitchAutomationPeer[] = {
        { "toggle_state", reinterpret_cast<getter>(ToggleSwitchAutomationPeer_get_ToggleState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ToggleSwitchAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_ToggleSwitchAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ToggleSwitchAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ToggleSwitchAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ToggleSwitchAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_ToggleSwitchAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ToggleSwitchAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::ToggleSwitchAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToggleSwitchAutomationPeer};

    static PyGetSetDef getset_ToggleSwitchAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_ToggleSwitchAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_ToggleSwitchAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_ToggleSwitchAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_ToggleSwitchAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_ToggleSwitchAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.ToggleSwitchAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_ToggleSwitchAutomationPeer_Static
    };

    // ----- TreeViewItemAutomationPeer class --------------------

    static PyObject* _new_TreeViewItemAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::TreeViewItem>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TreeViewItemAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TreeViewItemAutomationPeer_Collapse(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.TreeViewItemAutomationPeer", L"Collapse", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Collapse();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TreeViewItemAutomationPeer_Expand(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.TreeViewItemAutomationPeer", L"Expand", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Expand();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TreeViewItemAutomationPeer_get_ExpandCollapseState(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.TreeViewItemAutomationPeer", L"ExpandCollapseState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpandCollapseState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TreeViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TreeViewItemAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TreeViewItemAutomationPeer[] = {
        { "collapse", reinterpret_cast<PyCFunction>(TreeViewItemAutomationPeer_Collapse), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(TreeViewItemAutomationPeer_Expand), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TreeViewItemAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TreeViewItemAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TreeViewItemAutomationPeer[] = {
        { "expand_collapse_state", reinterpret_cast<getter>(TreeViewItemAutomationPeer_get_ExpandCollapseState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TreeViewItemAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TreeViewItemAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TreeViewItemAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TreeViewItemAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TreeViewItemAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_TreeViewItemAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.TreeViewItemAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::TreeViewItemAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TreeViewItemAutomationPeer};

    static PyGetSetDef getset_TreeViewItemAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_TreeViewItemAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TreeViewItemAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TreeViewItemAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TreeViewItemAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_TreeViewItemAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.TreeViewItemAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TreeViewItemAutomationPeer_Static
    };

    // ----- TreeViewItemDataAutomationPeer class --------------------

    static PyObject* _new_TreeViewItemDataAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Microsoft::UI::Xaml::Automation::Peers::TreeViewListAutomationPeer>(args, 1);

                winrt::Microsoft::UI::Xaml::Automation::Peers::TreeViewItemDataAutomationPeer instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TreeViewItemDataAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::TreeViewItemDataAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TreeViewItemDataAutomationPeer_Collapse(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::TreeViewItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.TreeViewItemDataAutomationPeer", L"Collapse", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Collapse();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TreeViewItemDataAutomationPeer_Expand(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::TreeViewItemDataAutomationPeer* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Automation.Peers.TreeViewItemDataAutomationPeer", L"Expand", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Expand();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TreeViewItemDataAutomationPeer_get_ExpandCollapseState(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::TreeViewItemDataAutomationPeer* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Automation.Peers.TreeViewItemDataAutomationPeer", L"ExpandCollapseState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ExpandCollapseState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_TreeViewItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::TreeViewItemDataAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TreeViewItemDataAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::TreeViewItemDataAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TreeViewItemDataAutomationPeer[] = {
        { "collapse", reinterpret_cast<PyCFunction>(TreeViewItemDataAutomationPeer_Collapse), METH_VARARGS, nullptr },
        { "expand", reinterpret_cast<PyCFunction>(TreeViewItemDataAutomationPeer_Expand), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_TreeViewItemDataAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TreeViewItemDataAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TreeViewItemDataAutomationPeer[] = {
        { "expand_collapse_state", reinterpret_cast<getter>(TreeViewItemDataAutomationPeer_get_ExpandCollapseState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TreeViewItemDataAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TreeViewItemDataAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TreeViewItemDataAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TreeViewItemDataAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TreeViewItemDataAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_TreeViewItemDataAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.TreeViewItemDataAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::TreeViewItemDataAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TreeViewItemDataAutomationPeer};

    static PyGetSetDef getset_TreeViewItemDataAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_TreeViewItemDataAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TreeViewItemDataAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TreeViewItemDataAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TreeViewItemDataAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_TreeViewItemDataAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.TreeViewItemDataAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TreeViewItemDataAutomationPeer_Static
    };

    // ----- TreeViewListAutomationPeer class --------------------

    static PyObject* _new_TreeViewListAutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::TreeViewList>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::TreeViewListAutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TreeViewListAutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::TreeViewListAutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_TreeViewListAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::TreeViewListAutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_TreeViewListAutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::TreeViewListAutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TreeViewListAutomationPeer[] = {
        { "_assign_array_", _assign_array_TreeViewListAutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TreeViewListAutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TreeViewListAutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_TreeViewListAutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_TreeViewListAutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_TreeViewListAutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_TreeViewListAutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_TreeViewListAutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_TreeViewListAutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.TreeViewListAutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::TreeViewListAutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TreeViewListAutomationPeer};

    static PyGetSetDef getset_TreeViewListAutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_TreeViewListAutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_TreeViewListAutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_TreeViewListAutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_TreeViewListAutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_TreeViewListAutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.TreeViewListAutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_TreeViewListAutomationPeer_Static
    };

    // ----- WebView2AutomationPeer class --------------------

    static PyObject* _new_WebView2AutomationPeer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Controls::WebView2>(args, 0);

                winrt::Microsoft::UI::Xaml::Automation::Peers::WebView2AutomationPeer instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WebView2AutomationPeer(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::WebView2AutomationPeer* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_WebView2AutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::WebView2AutomationPeer>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WebView2AutomationPeer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Automation::Peers::WebView2AutomationPeer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebView2AutomationPeer[] = {
        { "_assign_array_", _assign_array_WebView2AutomationPeer, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebView2AutomationPeer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebView2AutomationPeer[] = {
        { }
    };

    static PyType_Slot _type_slots_WebView2AutomationPeer[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WebView2AutomationPeer) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WebView2AutomationPeer) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WebView2AutomationPeer) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WebView2AutomationPeer) },
        { }
    };

    static PyType_Spec type_spec_WebView2AutomationPeer = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.WebView2AutomationPeer",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::WebView2AutomationPeer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebView2AutomationPeer};

    static PyGetSetDef getset_WebView2AutomationPeer_Static[] = {
        { }
    };

    static PyMethodDef methods_WebView2AutomationPeer_Static[] = {
        { }
    };

    static PyType_Slot type_slots_WebView2AutomationPeer_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_WebView2AutomationPeer_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_WebView2AutomationPeer_Static) },
        { }
    };

    static PyType_Spec type_spec_WebView2AutomationPeer_Static =
    {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.WebView2AutomationPeer_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_WebView2AutomationPeer_Static
    };

    // ----- RawElementProviderRuntimeId struct --------------------

    winrt_struct_wrapper<winrt::Microsoft::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId>* _new_RawElementProviderRuntimeId(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Microsoft::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_RawElementProviderRuntimeId(winrt_struct_wrapper<winrt::Microsoft::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        uint32_t _Part1{};
        uint32_t _Part2{};

        static const char* kwlist[] = {"part1", "part2", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "II", const_cast<char**>(kwlist), &_Part1, &_Part2))
        {
            return -1;
        }

        try
        {
            self->obj.Part1 = _Part1;
            self->obj.Part2 = _Part2;

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_RawElementProviderRuntimeId(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_RawElementProviderRuntimeId(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_RawElementProviderRuntimeId[] = {
        { "_assign_array_", _assign_array_RawElementProviderRuntimeId, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* RawElementProviderRuntimeId_get_Part1(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Part1);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RawElementProviderRuntimeId_set_Part1(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Part1 = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RawElementProviderRuntimeId_get_Part2(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Part2);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RawElementProviderRuntimeId_set_Part2(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Part2 = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_RawElementProviderRuntimeId[] = {
        { "part1", reinterpret_cast<getter>(RawElementProviderRuntimeId_get_Part1), reinterpret_cast<setter>(RawElementProviderRuntimeId_set_Part1), nullptr, nullptr },
        { "part2", reinterpret_cast<getter>(RawElementProviderRuntimeId_get_Part2), reinterpret_cast<setter>(RawElementProviderRuntimeId_set_Part2), nullptr, nullptr },
        { }
    };

    static PyObject* _richcompare_RawElementProviderRuntimeId(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::converter<winrt::Microsoft::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId>::convert_to(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_RawElementProviderRuntimeId(PyObject* self) noexcept
    {
        py::pyobj_handle Part1{PyObject_GetAttrString(self, "part1")};
        if (!Part1)
        {
            return nullptr;
        }

        py::pyobj_handle Part2{PyObject_GetAttrString(self, "part2")};
        if (!Part2)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("RawElementProviderRuntimeId(part1=%R, part2=%R)", Part1.get(), Part2.get());
    }

    static PyType_Slot _type_slots_RawElementProviderRuntimeId[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RawElementProviderRuntimeId) },
        { Py_tp_init, reinterpret_cast<void*>(_init_RawElementProviderRuntimeId) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RawElementProviderRuntimeId) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RawElementProviderRuntimeId) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RawElementProviderRuntimeId) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_RawElementProviderRuntimeId) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_RawElementProviderRuntimeId) },
        { }
    };

    static PyType_Spec type_spec_RawElementProviderRuntimeId = {
        "winrt._winrt_microsoft_ui_xaml_automation_peers.RawElementProviderRuntimeId",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Automation::Peers::RawElementProviderRuntimeId),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RawElementProviderRuntimeId};

    // ----- Microsoft.UI.Xaml.Automation.Peers Initialization --------------------

    PyDoc_STRVAR(module_doc, "Microsoft.UI.Xaml.Automation.Peers");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_microsoft_ui_xaml_automation_peers",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Microsoft::UI::Xaml::Automation::Peers

PyMODINIT_FUNC PyInit__winrt_microsoft_ui_xaml_automation_peers(void) noexcept
{
    using namespace py::cpp::Microsoft::UI::Xaml::Automation::Peers;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_AutomationPeer_Static{PyType_FromSpec(&type_spec_AutomationPeer_Static)};
    if (!type_AutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle AutomationPeer_type{py::register_python_type(module.get(), &type_spec_AutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AutomationPeer_Static.get()))};
    if (!AutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_FrameworkElementAutomationPeer_Static{PyType_FromSpec(&type_spec_FrameworkElementAutomationPeer_Static)};
    if (!type_FrameworkElementAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle FrameworkElementAutomationPeer_type{py::register_python_type(module.get(), &type_spec_FrameworkElementAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_FrameworkElementAutomationPeer_Static.get()))};
    if (!FrameworkElementAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_AnimatedVisualPlayerAutomationPeer_Static{PyType_FromSpec(&type_spec_AnimatedVisualPlayerAutomationPeer_Static)};
    if (!type_AnimatedVisualPlayerAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle AnimatedVisualPlayerAutomationPeer_type{py::register_python_type(module.get(), &type_spec_AnimatedVisualPlayerAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AnimatedVisualPlayerAutomationPeer_Static.get()))};
    if (!AnimatedVisualPlayerAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_AppBarAutomationPeer_Static{PyType_FromSpec(&type_spec_AppBarAutomationPeer_Static)};
    if (!type_AppBarAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle AppBarAutomationPeer_type{py::register_python_type(module.get(), &type_spec_AppBarAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AppBarAutomationPeer_Static.get()))};
    if (!AppBarAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ButtonBaseAutomationPeer_Static{PyType_FromSpec(&type_spec_ButtonBaseAutomationPeer_Static)};
    if (!type_ButtonBaseAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle ButtonBaseAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ButtonBaseAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ButtonBaseAutomationPeer_Static.get()))};
    if (!ButtonBaseAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ButtonAutomationPeer_Static{PyType_FromSpec(&type_spec_ButtonAutomationPeer_Static)};
    if (!type_ButtonAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle ButtonAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ButtonAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ButtonAutomationPeer_Static.get()))};
    if (!ButtonAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_AppBarButtonAutomationPeer_Static{PyType_FromSpec(&type_spec_AppBarButtonAutomationPeer_Static)};
    if (!type_AppBarButtonAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle AppBarButtonAutomationPeer_type{py::register_python_type(module.get(), &type_spec_AppBarButtonAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AppBarButtonAutomationPeer_Static.get()))};
    if (!AppBarButtonAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ToggleButtonAutomationPeer_Static{PyType_FromSpec(&type_spec_ToggleButtonAutomationPeer_Static)};
    if (!type_ToggleButtonAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle ToggleButtonAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ToggleButtonAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ToggleButtonAutomationPeer_Static.get()))};
    if (!ToggleButtonAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_AppBarToggleButtonAutomationPeer_Static{PyType_FromSpec(&type_spec_AppBarToggleButtonAutomationPeer_Static)};
    if (!type_AppBarToggleButtonAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle AppBarToggleButtonAutomationPeer_type{py::register_python_type(module.get(), &type_spec_AppBarToggleButtonAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AppBarToggleButtonAutomationPeer_Static.get()))};
    if (!AppBarToggleButtonAutomationPeer_type)
    {
        return nullptr;
    }

    py::pytype_handle AutoSuggestBoxAutomationPeer_type{py::register_python_type(module.get(), &type_spec_AutoSuggestBoxAutomationPeer, object_bases.get(), nullptr)};
    if (!AutoSuggestBoxAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_AutomationPeerAnnotation_Static{PyType_FromSpec(&type_spec_AutomationPeerAnnotation_Static)};
    if (!type_AutomationPeerAnnotation_Static)
    {
        return nullptr;
    }

    py::pytype_handle AutomationPeerAnnotation_type{py::register_python_type(module.get(), &type_spec_AutomationPeerAnnotation, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AutomationPeerAnnotation_Static.get()))};
    if (!AutomationPeerAnnotation_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_BreadcrumbBarItemAutomationPeer_Static{PyType_FromSpec(&type_spec_BreadcrumbBarItemAutomationPeer_Static)};
    if (!type_BreadcrumbBarItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle BreadcrumbBarItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_BreadcrumbBarItemAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BreadcrumbBarItemAutomationPeer_Static.get()))};
    if (!BreadcrumbBarItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_CalendarDatePickerAutomationPeer_Static{PyType_FromSpec(&type_spec_CalendarDatePickerAutomationPeer_Static)};
    if (!type_CalendarDatePickerAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle CalendarDatePickerAutomationPeer_type{py::register_python_type(module.get(), &type_spec_CalendarDatePickerAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CalendarDatePickerAutomationPeer_Static.get()))};
    if (!CalendarDatePickerAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_CheckBoxAutomationPeer_Static{PyType_FromSpec(&type_spec_CheckBoxAutomationPeer_Static)};
    if (!type_CheckBoxAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle CheckBoxAutomationPeer_type{py::register_python_type(module.get(), &type_spec_CheckBoxAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_CheckBoxAutomationPeer_Static.get()))};
    if (!CheckBoxAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_RangeBaseAutomationPeer_Static{PyType_FromSpec(&type_spec_RangeBaseAutomationPeer_Static)};
    if (!type_RangeBaseAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle RangeBaseAutomationPeer_type{py::register_python_type(module.get(), &type_spec_RangeBaseAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RangeBaseAutomationPeer_Static.get()))};
    if (!RangeBaseAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_SliderAutomationPeer_Static{PyType_FromSpec(&type_spec_SliderAutomationPeer_Static)};
    if (!type_SliderAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle SliderAutomationPeer_type{py::register_python_type(module.get(), &type_spec_SliderAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SliderAutomationPeer_Static.get()))};
    if (!SliderAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ColorPickerSliderAutomationPeer_Static{PyType_FromSpec(&type_spec_ColorPickerSliderAutomationPeer_Static)};
    if (!type_ColorPickerSliderAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle ColorPickerSliderAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ColorPickerSliderAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ColorPickerSliderAutomationPeer_Static.get()))};
    if (!ColorPickerSliderAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ColorSpectrumAutomationPeer_Static{PyType_FromSpec(&type_spec_ColorSpectrumAutomationPeer_Static)};
    if (!type_ColorSpectrumAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle ColorSpectrumAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ColorSpectrumAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ColorSpectrumAutomationPeer_Static.get()))};
    if (!ColorSpectrumAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ItemsControlAutomationPeer_Static{PyType_FromSpec(&type_spec_ItemsControlAutomationPeer_Static)};
    if (!type_ItemsControlAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle ItemsControlAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ItemsControlAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ItemsControlAutomationPeer_Static.get()))};
    if (!ItemsControlAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_SelectorAutomationPeer_Static{PyType_FromSpec(&type_spec_SelectorAutomationPeer_Static)};
    if (!type_SelectorAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle SelectorAutomationPeer_type{py::register_python_type(module.get(), &type_spec_SelectorAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SelectorAutomationPeer_Static.get()))};
    if (!SelectorAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ComboBoxAutomationPeer_Static{PyType_FromSpec(&type_spec_ComboBoxAutomationPeer_Static)};
    if (!type_ComboBoxAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle ComboBoxAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ComboBoxAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ComboBoxAutomationPeer_Static.get()))};
    if (!ComboBoxAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ComboBoxItemAutomationPeer_Static{PyType_FromSpec(&type_spec_ComboBoxItemAutomationPeer_Static)};
    if (!type_ComboBoxItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle ComboBoxItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ComboBoxItemAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ComboBoxItemAutomationPeer_Static.get()))};
    if (!ComboBoxItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ItemAutomationPeer_Static{PyType_FromSpec(&type_spec_ItemAutomationPeer_Static)};
    if (!type_ItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle ItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ItemAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ItemAutomationPeer_Static.get()))};
    if (!ItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_SelectorItemAutomationPeer_Static{PyType_FromSpec(&type_spec_SelectorItemAutomationPeer_Static)};
    if (!type_SelectorItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle SelectorItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_SelectorItemAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SelectorItemAutomationPeer_Static.get()))};
    if (!SelectorItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ComboBoxItemDataAutomationPeer_Static{PyType_FromSpec(&type_spec_ComboBoxItemDataAutomationPeer_Static)};
    if (!type_ComboBoxItemDataAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle ComboBoxItemDataAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ComboBoxItemDataAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ComboBoxItemDataAutomationPeer_Static.get()))};
    if (!ComboBoxItemDataAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_DatePickerAutomationPeer_Static{PyType_FromSpec(&type_spec_DatePickerAutomationPeer_Static)};
    if (!type_DatePickerAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle DatePickerAutomationPeer_type{py::register_python_type(module.get(), &type_spec_DatePickerAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DatePickerAutomationPeer_Static.get()))};
    if (!DatePickerAutomationPeer_type)
    {
        return nullptr;
    }

    py::pytype_handle DatePickerFlyoutPresenterAutomationPeer_type{py::register_python_type(module.get(), &type_spec_DatePickerFlyoutPresenterAutomationPeer, object_bases.get(), nullptr)};
    if (!DatePickerFlyoutPresenterAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_DropDownButtonAutomationPeer_Static{PyType_FromSpec(&type_spec_DropDownButtonAutomationPeer_Static)};
    if (!type_DropDownButtonAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle DropDownButtonAutomationPeer_type{py::register_python_type(module.get(), &type_spec_DropDownButtonAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_DropDownButtonAutomationPeer_Static.get()))};
    if (!DropDownButtonAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ExpanderAutomationPeer_Static{PyType_FromSpec(&type_spec_ExpanderAutomationPeer_Static)};
    if (!type_ExpanderAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle ExpanderAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ExpanderAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ExpanderAutomationPeer_Static.get()))};
    if (!ExpanderAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_FlipViewAutomationPeer_Static{PyType_FromSpec(&type_spec_FlipViewAutomationPeer_Static)};
    if (!type_FlipViewAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle FlipViewAutomationPeer_type{py::register_python_type(module.get(), &type_spec_FlipViewAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_FlipViewAutomationPeer_Static.get()))};
    if (!FlipViewAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_FlipViewItemAutomationPeer_Static{PyType_FromSpec(&type_spec_FlipViewItemAutomationPeer_Static)};
    if (!type_FlipViewItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle FlipViewItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_FlipViewItemAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_FlipViewItemAutomationPeer_Static.get()))};
    if (!FlipViewItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_FlipViewItemDataAutomationPeer_Static{PyType_FromSpec(&type_spec_FlipViewItemDataAutomationPeer_Static)};
    if (!type_FlipViewItemDataAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle FlipViewItemDataAutomationPeer_type{py::register_python_type(module.get(), &type_spec_FlipViewItemDataAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_FlipViewItemDataAutomationPeer_Static.get()))};
    if (!FlipViewItemDataAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_FlyoutPresenterAutomationPeer_Static{PyType_FromSpec(&type_spec_FlyoutPresenterAutomationPeer_Static)};
    if (!type_FlyoutPresenterAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle FlyoutPresenterAutomationPeer_type{py::register_python_type(module.get(), &type_spec_FlyoutPresenterAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_FlyoutPresenterAutomationPeer_Static.get()))};
    if (!FlyoutPresenterAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListViewBaseAutomationPeer_Static{PyType_FromSpec(&type_spec_ListViewBaseAutomationPeer_Static)};
    if (!type_ListViewBaseAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle ListViewBaseAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ListViewBaseAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListViewBaseAutomationPeer_Static.get()))};
    if (!ListViewBaseAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_GridViewAutomationPeer_Static{PyType_FromSpec(&type_spec_GridViewAutomationPeer_Static)};
    if (!type_GridViewAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle GridViewAutomationPeer_type{py::register_python_type(module.get(), &type_spec_GridViewAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GridViewAutomationPeer_Static.get()))};
    if (!GridViewAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListViewBaseHeaderItemAutomationPeer_Static{PyType_FromSpec(&type_spec_ListViewBaseHeaderItemAutomationPeer_Static)};
    if (!type_ListViewBaseHeaderItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle ListViewBaseHeaderItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ListViewBaseHeaderItemAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListViewBaseHeaderItemAutomationPeer_Static.get()))};
    if (!ListViewBaseHeaderItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_GridViewHeaderItemAutomationPeer_Static{PyType_FromSpec(&type_spec_GridViewHeaderItemAutomationPeer_Static)};
    if (!type_GridViewHeaderItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle GridViewHeaderItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_GridViewHeaderItemAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GridViewHeaderItemAutomationPeer_Static.get()))};
    if (!GridViewHeaderItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_GridViewItemAutomationPeer_Static{PyType_FromSpec(&type_spec_GridViewItemAutomationPeer_Static)};
    if (!type_GridViewItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle GridViewItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_GridViewItemAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GridViewItemAutomationPeer_Static.get()))};
    if (!GridViewItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_GridViewItemDataAutomationPeer_Static{PyType_FromSpec(&type_spec_GridViewItemDataAutomationPeer_Static)};
    if (!type_GridViewItemDataAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle GridViewItemDataAutomationPeer_type{py::register_python_type(module.get(), &type_spec_GridViewItemDataAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GridViewItemDataAutomationPeer_Static.get()))};
    if (!GridViewItemDataAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_GroupItemAutomationPeer_Static{PyType_FromSpec(&type_spec_GroupItemAutomationPeer_Static)};
    if (!type_GroupItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle GroupItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_GroupItemAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_GroupItemAutomationPeer_Static.get()))};
    if (!GroupItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_HubAutomationPeer_Static{PyType_FromSpec(&type_spec_HubAutomationPeer_Static)};
    if (!type_HubAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle HubAutomationPeer_type{py::register_python_type(module.get(), &type_spec_HubAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_HubAutomationPeer_Static.get()))};
    if (!HubAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_HubSectionAutomationPeer_Static{PyType_FromSpec(&type_spec_HubSectionAutomationPeer_Static)};
    if (!type_HubSectionAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle HubSectionAutomationPeer_type{py::register_python_type(module.get(), &type_spec_HubSectionAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_HubSectionAutomationPeer_Static.get()))};
    if (!HubSectionAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_HyperlinkButtonAutomationPeer_Static{PyType_FromSpec(&type_spec_HyperlinkButtonAutomationPeer_Static)};
    if (!type_HyperlinkButtonAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle HyperlinkButtonAutomationPeer_type{py::register_python_type(module.get(), &type_spec_HyperlinkButtonAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_HyperlinkButtonAutomationPeer_Static.get()))};
    if (!HyperlinkButtonAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ImageAutomationPeer_Static{PyType_FromSpec(&type_spec_ImageAutomationPeer_Static)};
    if (!type_ImageAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle ImageAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ImageAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ImageAutomationPeer_Static.get()))};
    if (!ImageAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_InfoBarAutomationPeer_Static{PyType_FromSpec(&type_spec_InfoBarAutomationPeer_Static)};
    if (!type_InfoBarAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle InfoBarAutomationPeer_type{py::register_python_type(module.get(), &type_spec_InfoBarAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_InfoBarAutomationPeer_Static.get()))};
    if (!InfoBarAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ItemContainerAutomationPeer_Static{PyType_FromSpec(&type_spec_ItemContainerAutomationPeer_Static)};
    if (!type_ItemContainerAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle ItemContainerAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ItemContainerAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ItemContainerAutomationPeer_Static.get()))};
    if (!ItemContainerAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ItemsViewAutomationPeer_Static{PyType_FromSpec(&type_spec_ItemsViewAutomationPeer_Static)};
    if (!type_ItemsViewAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle ItemsViewAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ItemsViewAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ItemsViewAutomationPeer_Static.get()))};
    if (!ItemsViewAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListBoxAutomationPeer_Static{PyType_FromSpec(&type_spec_ListBoxAutomationPeer_Static)};
    if (!type_ListBoxAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle ListBoxAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ListBoxAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListBoxAutomationPeer_Static.get()))};
    if (!ListBoxAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListBoxItemAutomationPeer_Static{PyType_FromSpec(&type_spec_ListBoxItemAutomationPeer_Static)};
    if (!type_ListBoxItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle ListBoxItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ListBoxItemAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListBoxItemAutomationPeer_Static.get()))};
    if (!ListBoxItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListBoxItemDataAutomationPeer_Static{PyType_FromSpec(&type_spec_ListBoxItemDataAutomationPeer_Static)};
    if (!type_ListBoxItemDataAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle ListBoxItemDataAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ListBoxItemDataAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListBoxItemDataAutomationPeer_Static.get()))};
    if (!ListBoxItemDataAutomationPeer_type)
    {
        return nullptr;
    }

    py::pytype_handle ListPickerFlyoutPresenterAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ListPickerFlyoutPresenterAutomationPeer, object_bases.get(), nullptr)};
    if (!ListPickerFlyoutPresenterAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListViewAutomationPeer_Static{PyType_FromSpec(&type_spec_ListViewAutomationPeer_Static)};
    if (!type_ListViewAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle ListViewAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ListViewAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListViewAutomationPeer_Static.get()))};
    if (!ListViewAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListViewHeaderItemAutomationPeer_Static{PyType_FromSpec(&type_spec_ListViewHeaderItemAutomationPeer_Static)};
    if (!type_ListViewHeaderItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle ListViewHeaderItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ListViewHeaderItemAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListViewHeaderItemAutomationPeer_Static.get()))};
    if (!ListViewHeaderItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListViewItemAutomationPeer_Static{PyType_FromSpec(&type_spec_ListViewItemAutomationPeer_Static)};
    if (!type_ListViewItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle ListViewItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ListViewItemAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListViewItemAutomationPeer_Static.get()))};
    if (!ListViewItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ListViewItemDataAutomationPeer_Static{PyType_FromSpec(&type_spec_ListViewItemDataAutomationPeer_Static)};
    if (!type_ListViewItemDataAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle ListViewItemDataAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ListViewItemDataAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ListViewItemDataAutomationPeer_Static.get()))};
    if (!ListViewItemDataAutomationPeer_type)
    {
        return nullptr;
    }

    py::pytype_handle LoopingSelectorAutomationPeer_type{py::register_python_type(module.get(), &type_spec_LoopingSelectorAutomationPeer, object_bases.get(), nullptr)};
    if (!LoopingSelectorAutomationPeer_type)
    {
        return nullptr;
    }

    py::pytype_handle LoopingSelectorItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_LoopingSelectorItemAutomationPeer, object_bases.get(), nullptr)};
    if (!LoopingSelectorItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pytype_handle LoopingSelectorItemDataAutomationPeer_type{py::register_python_type(module.get(), &type_spec_LoopingSelectorItemDataAutomationPeer, object_bases.get(), nullptr)};
    if (!LoopingSelectorItemDataAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_MediaPlayerElementAutomationPeer_Static{PyType_FromSpec(&type_spec_MediaPlayerElementAutomationPeer_Static)};
    if (!type_MediaPlayerElementAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle MediaPlayerElementAutomationPeer_type{py::register_python_type(module.get(), &type_spec_MediaPlayerElementAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MediaPlayerElementAutomationPeer_Static.get()))};
    if (!MediaPlayerElementAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_MediaTransportControlsAutomationPeer_Static{PyType_FromSpec(&type_spec_MediaTransportControlsAutomationPeer_Static)};
    if (!type_MediaTransportControlsAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle MediaTransportControlsAutomationPeer_type{py::register_python_type(module.get(), &type_spec_MediaTransportControlsAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MediaTransportControlsAutomationPeer_Static.get()))};
    if (!MediaTransportControlsAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_MenuBarAutomationPeer_Static{PyType_FromSpec(&type_spec_MenuBarAutomationPeer_Static)};
    if (!type_MenuBarAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle MenuBarAutomationPeer_type{py::register_python_type(module.get(), &type_spec_MenuBarAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MenuBarAutomationPeer_Static.get()))};
    if (!MenuBarAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_MenuBarItemAutomationPeer_Static{PyType_FromSpec(&type_spec_MenuBarItemAutomationPeer_Static)};
    if (!type_MenuBarItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle MenuBarItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_MenuBarItemAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MenuBarItemAutomationPeer_Static.get()))};
    if (!MenuBarItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_MenuFlyoutItemAutomationPeer_Static{PyType_FromSpec(&type_spec_MenuFlyoutItemAutomationPeer_Static)};
    if (!type_MenuFlyoutItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle MenuFlyoutItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_MenuFlyoutItemAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MenuFlyoutItemAutomationPeer_Static.get()))};
    if (!MenuFlyoutItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_MenuFlyoutPresenterAutomationPeer_Static{PyType_FromSpec(&type_spec_MenuFlyoutPresenterAutomationPeer_Static)};
    if (!type_MenuFlyoutPresenterAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle MenuFlyoutPresenterAutomationPeer_type{py::register_python_type(module.get(), &type_spec_MenuFlyoutPresenterAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_MenuFlyoutPresenterAutomationPeer_Static.get()))};
    if (!MenuFlyoutPresenterAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_NavigationViewAutomationPeer_Static{PyType_FromSpec(&type_spec_NavigationViewAutomationPeer_Static)};
    if (!type_NavigationViewAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle NavigationViewAutomationPeer_type{py::register_python_type(module.get(), &type_spec_NavigationViewAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_NavigationViewAutomationPeer_Static.get()))};
    if (!NavigationViewAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_NavigationViewItemAutomationPeer_Static{PyType_FromSpec(&type_spec_NavigationViewItemAutomationPeer_Static)};
    if (!type_NavigationViewItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle NavigationViewItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_NavigationViewItemAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_NavigationViewItemAutomationPeer_Static.get()))};
    if (!NavigationViewItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_NumberBoxAutomationPeer_Static{PyType_FromSpec(&type_spec_NumberBoxAutomationPeer_Static)};
    if (!type_NumberBoxAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle NumberBoxAutomationPeer_type{py::register_python_type(module.get(), &type_spec_NumberBoxAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_NumberBoxAutomationPeer_Static.get()))};
    if (!NumberBoxAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_PasswordBoxAutomationPeer_Static{PyType_FromSpec(&type_spec_PasswordBoxAutomationPeer_Static)};
    if (!type_PasswordBoxAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle PasswordBoxAutomationPeer_type{py::register_python_type(module.get(), &type_spec_PasswordBoxAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PasswordBoxAutomationPeer_Static.get()))};
    if (!PasswordBoxAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_PersonPictureAutomationPeer_Static{PyType_FromSpec(&type_spec_PersonPictureAutomationPeer_Static)};
    if (!type_PersonPictureAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle PersonPictureAutomationPeer_type{py::register_python_type(module.get(), &type_spec_PersonPictureAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PersonPictureAutomationPeer_Static.get()))};
    if (!PersonPictureAutomationPeer_type)
    {
        return nullptr;
    }

    py::pytype_handle PickerFlyoutPresenterAutomationPeer_type{py::register_python_type(module.get(), &type_spec_PickerFlyoutPresenterAutomationPeer, object_bases.get(), nullptr)};
    if (!PickerFlyoutPresenterAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_PipsPagerAutomationPeer_Static{PyType_FromSpec(&type_spec_PipsPagerAutomationPeer_Static)};
    if (!type_PipsPagerAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle PipsPagerAutomationPeer_type{py::register_python_type(module.get(), &type_spec_PipsPagerAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PipsPagerAutomationPeer_Static.get()))};
    if (!PipsPagerAutomationPeer_type)
    {
        return nullptr;
    }

    py::pytype_handle PivotAutomationPeer_type{py::register_python_type(module.get(), &type_spec_PivotAutomationPeer, object_bases.get(), nullptr)};
    if (!PivotAutomationPeer_type)
    {
        return nullptr;
    }

    py::pytype_handle PivotItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_PivotItemAutomationPeer, object_bases.get(), nullptr)};
    if (!PivotItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pytype_handle PivotItemDataAutomationPeer_type{py::register_python_type(module.get(), &type_spec_PivotItemDataAutomationPeer, object_bases.get(), nullptr)};
    if (!PivotItemDataAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ProgressBarAutomationPeer_Static{PyType_FromSpec(&type_spec_ProgressBarAutomationPeer_Static)};
    if (!type_ProgressBarAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle ProgressBarAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ProgressBarAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ProgressBarAutomationPeer_Static.get()))};
    if (!ProgressBarAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ProgressRingAutomationPeer_Static{PyType_FromSpec(&type_spec_ProgressRingAutomationPeer_Static)};
    if (!type_ProgressRingAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle ProgressRingAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ProgressRingAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ProgressRingAutomationPeer_Static.get()))};
    if (!ProgressRingAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_RadioButtonAutomationPeer_Static{PyType_FromSpec(&type_spec_RadioButtonAutomationPeer_Static)};
    if (!type_RadioButtonAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle RadioButtonAutomationPeer_type{py::register_python_type(module.get(), &type_spec_RadioButtonAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RadioButtonAutomationPeer_Static.get()))};
    if (!RadioButtonAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_RadioButtonsAutomationPeer_Static{PyType_FromSpec(&type_spec_RadioButtonsAutomationPeer_Static)};
    if (!type_RadioButtonsAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle RadioButtonsAutomationPeer_type{py::register_python_type(module.get(), &type_spec_RadioButtonsAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RadioButtonsAutomationPeer_Static.get()))};
    if (!RadioButtonsAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_RatingControlAutomationPeer_Static{PyType_FromSpec(&type_spec_RatingControlAutomationPeer_Static)};
    if (!type_RatingControlAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle RatingControlAutomationPeer_type{py::register_python_type(module.get(), &type_spec_RatingControlAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RatingControlAutomationPeer_Static.get()))};
    if (!RatingControlAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_RepeatButtonAutomationPeer_Static{PyType_FromSpec(&type_spec_RepeatButtonAutomationPeer_Static)};
    if (!type_RepeatButtonAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle RepeatButtonAutomationPeer_type{py::register_python_type(module.get(), &type_spec_RepeatButtonAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RepeatButtonAutomationPeer_Static.get()))};
    if (!RepeatButtonAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_RepeaterAutomationPeer_Static{PyType_FromSpec(&type_spec_RepeaterAutomationPeer_Static)};
    if (!type_RepeaterAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle RepeaterAutomationPeer_type{py::register_python_type(module.get(), &type_spec_RepeaterAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RepeaterAutomationPeer_Static.get()))};
    if (!RepeaterAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_RichEditBoxAutomationPeer_Static{PyType_FromSpec(&type_spec_RichEditBoxAutomationPeer_Static)};
    if (!type_RichEditBoxAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle RichEditBoxAutomationPeer_type{py::register_python_type(module.get(), &type_spec_RichEditBoxAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RichEditBoxAutomationPeer_Static.get()))};
    if (!RichEditBoxAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_RichTextBlockAutomationPeer_Static{PyType_FromSpec(&type_spec_RichTextBlockAutomationPeer_Static)};
    if (!type_RichTextBlockAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle RichTextBlockAutomationPeer_type{py::register_python_type(module.get(), &type_spec_RichTextBlockAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RichTextBlockAutomationPeer_Static.get()))};
    if (!RichTextBlockAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_RichTextBlockOverflowAutomationPeer_Static{PyType_FromSpec(&type_spec_RichTextBlockOverflowAutomationPeer_Static)};
    if (!type_RichTextBlockOverflowAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle RichTextBlockOverflowAutomationPeer_type{py::register_python_type(module.get(), &type_spec_RichTextBlockOverflowAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_RichTextBlockOverflowAutomationPeer_Static.get()))};
    if (!RichTextBlockOverflowAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ScrollBarAutomationPeer_Static{PyType_FromSpec(&type_spec_ScrollBarAutomationPeer_Static)};
    if (!type_ScrollBarAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle ScrollBarAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ScrollBarAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ScrollBarAutomationPeer_Static.get()))};
    if (!ScrollBarAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ScrollPresenterAutomationPeer_Static{PyType_FromSpec(&type_spec_ScrollPresenterAutomationPeer_Static)};
    if (!type_ScrollPresenterAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle ScrollPresenterAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ScrollPresenterAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ScrollPresenterAutomationPeer_Static.get()))};
    if (!ScrollPresenterAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ScrollViewerAutomationPeer_Static{PyType_FromSpec(&type_spec_ScrollViewerAutomationPeer_Static)};
    if (!type_ScrollViewerAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle ScrollViewerAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ScrollViewerAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ScrollViewerAutomationPeer_Static.get()))};
    if (!ScrollViewerAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_SelectorBarItemAutomationPeer_Static{PyType_FromSpec(&type_spec_SelectorBarItemAutomationPeer_Static)};
    if (!type_SelectorBarItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle SelectorBarItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_SelectorBarItemAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SelectorBarItemAutomationPeer_Static.get()))};
    if (!SelectorBarItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_SemanticZoomAutomationPeer_Static{PyType_FromSpec(&type_spec_SemanticZoomAutomationPeer_Static)};
    if (!type_SemanticZoomAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle SemanticZoomAutomationPeer_type{py::register_python_type(module.get(), &type_spec_SemanticZoomAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SemanticZoomAutomationPeer_Static.get()))};
    if (!SemanticZoomAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_SplitButtonAutomationPeer_Static{PyType_FromSpec(&type_spec_SplitButtonAutomationPeer_Static)};
    if (!type_SplitButtonAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle SplitButtonAutomationPeer_type{py::register_python_type(module.get(), &type_spec_SplitButtonAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SplitButtonAutomationPeer_Static.get()))};
    if (!SplitButtonAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_TabViewAutomationPeer_Static{PyType_FromSpec(&type_spec_TabViewAutomationPeer_Static)};
    if (!type_TabViewAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle TabViewAutomationPeer_type{py::register_python_type(module.get(), &type_spec_TabViewAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TabViewAutomationPeer_Static.get()))};
    if (!TabViewAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_TabViewItemAutomationPeer_Static{PyType_FromSpec(&type_spec_TabViewItemAutomationPeer_Static)};
    if (!type_TabViewItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle TabViewItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_TabViewItemAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TabViewItemAutomationPeer_Static.get()))};
    if (!TabViewItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_TeachingTipAutomationPeer_Static{PyType_FromSpec(&type_spec_TeachingTipAutomationPeer_Static)};
    if (!type_TeachingTipAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle TeachingTipAutomationPeer_type{py::register_python_type(module.get(), &type_spec_TeachingTipAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TeachingTipAutomationPeer_Static.get()))};
    if (!TeachingTipAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_TextBlockAutomationPeer_Static{PyType_FromSpec(&type_spec_TextBlockAutomationPeer_Static)};
    if (!type_TextBlockAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle TextBlockAutomationPeer_type{py::register_python_type(module.get(), &type_spec_TextBlockAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TextBlockAutomationPeer_Static.get()))};
    if (!TextBlockAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_TextBoxAutomationPeer_Static{PyType_FromSpec(&type_spec_TextBoxAutomationPeer_Static)};
    if (!type_TextBoxAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle TextBoxAutomationPeer_type{py::register_python_type(module.get(), &type_spec_TextBoxAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TextBoxAutomationPeer_Static.get()))};
    if (!TextBoxAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ThumbAutomationPeer_Static{PyType_FromSpec(&type_spec_ThumbAutomationPeer_Static)};
    if (!type_ThumbAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle ThumbAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ThumbAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ThumbAutomationPeer_Static.get()))};
    if (!ThumbAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_TimePickerAutomationPeer_Static{PyType_FromSpec(&type_spec_TimePickerAutomationPeer_Static)};
    if (!type_TimePickerAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle TimePickerAutomationPeer_type{py::register_python_type(module.get(), &type_spec_TimePickerAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TimePickerAutomationPeer_Static.get()))};
    if (!TimePickerAutomationPeer_type)
    {
        return nullptr;
    }

    py::pytype_handle TimePickerFlyoutPresenterAutomationPeer_type{py::register_python_type(module.get(), &type_spec_TimePickerFlyoutPresenterAutomationPeer, object_bases.get(), nullptr)};
    if (!TimePickerFlyoutPresenterAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ToggleMenuFlyoutItemAutomationPeer_Static{PyType_FromSpec(&type_spec_ToggleMenuFlyoutItemAutomationPeer_Static)};
    if (!type_ToggleMenuFlyoutItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle ToggleMenuFlyoutItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ToggleMenuFlyoutItemAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ToggleMenuFlyoutItemAutomationPeer_Static.get()))};
    if (!ToggleMenuFlyoutItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ToggleSplitButtonAutomationPeer_Static{PyType_FromSpec(&type_spec_ToggleSplitButtonAutomationPeer_Static)};
    if (!type_ToggleSplitButtonAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle ToggleSplitButtonAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ToggleSplitButtonAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ToggleSplitButtonAutomationPeer_Static.get()))};
    if (!ToggleSplitButtonAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_ToggleSwitchAutomationPeer_Static{PyType_FromSpec(&type_spec_ToggleSwitchAutomationPeer_Static)};
    if (!type_ToggleSwitchAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle ToggleSwitchAutomationPeer_type{py::register_python_type(module.get(), &type_spec_ToggleSwitchAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_ToggleSwitchAutomationPeer_Static.get()))};
    if (!ToggleSwitchAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_TreeViewItemAutomationPeer_Static{PyType_FromSpec(&type_spec_TreeViewItemAutomationPeer_Static)};
    if (!type_TreeViewItemAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle TreeViewItemAutomationPeer_type{py::register_python_type(module.get(), &type_spec_TreeViewItemAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TreeViewItemAutomationPeer_Static.get()))};
    if (!TreeViewItemAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_TreeViewItemDataAutomationPeer_Static{PyType_FromSpec(&type_spec_TreeViewItemDataAutomationPeer_Static)};
    if (!type_TreeViewItemDataAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle TreeViewItemDataAutomationPeer_type{py::register_python_type(module.get(), &type_spec_TreeViewItemDataAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TreeViewItemDataAutomationPeer_Static.get()))};
    if (!TreeViewItemDataAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_TreeViewListAutomationPeer_Static{PyType_FromSpec(&type_spec_TreeViewListAutomationPeer_Static)};
    if (!type_TreeViewListAutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle TreeViewListAutomationPeer_type{py::register_python_type(module.get(), &type_spec_TreeViewListAutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_TreeViewListAutomationPeer_Static.get()))};
    if (!TreeViewListAutomationPeer_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_WebView2AutomationPeer_Static{PyType_FromSpec(&type_spec_WebView2AutomationPeer_Static)};
    if (!type_WebView2AutomationPeer_Static)
    {
        return nullptr;
    }

    py::pytype_handle WebView2AutomationPeer_type{py::register_python_type(module.get(), &type_spec_WebView2AutomationPeer, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_WebView2AutomationPeer_Static.get()))};
    if (!WebView2AutomationPeer_type)
    {
        return nullptr;
    }

    py::pytype_handle RawElementProviderRuntimeId_type{py::register_python_type(module.get(), &type_spec_RawElementProviderRuntimeId, nullptr, nullptr)};
    if (!RawElementProviderRuntimeId_type)
    {
        return nullptr;
    }


    return module.detach();
}
