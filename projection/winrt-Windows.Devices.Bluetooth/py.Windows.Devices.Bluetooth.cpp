// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.Devices.Bluetooth.h"


namespace py::cpp::Windows::Devices::Bluetooth
{
    // ----- BluetoothAdapter class --------------------

    static PyObject* _new_BluetoothAdapter(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::BluetoothAdapter>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::BluetoothAdapter>::type_name);
        return nullptr;
    }

    static void _dealloc_BluetoothAdapter(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BluetoothAdapter_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothAdapter", L"FromIdAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothAdapter::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_GetDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothAdapter", L"GetDefaultAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothAdapter::GetDefaultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothAdapter", L"GetDeviceSelector", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothAdapter::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_GetRadioAsync(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothAdapter", L"GetRadioAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetRadioAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_get_BluetoothAddress(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothAdapter", L"BluetoothAddress"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BluetoothAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_get_DeviceId(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothAdapter", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_get_IsAdvertisementOffloadSupported(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothAdapter", L"IsAdvertisementOffloadSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsAdvertisementOffloadSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_get_IsCentralRoleSupported(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothAdapter", L"IsCentralRoleSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsCentralRoleSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_get_IsClassicSupported(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothAdapter", L"IsClassicSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsClassicSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_get_IsLowEnergySupported(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothAdapter", L"IsLowEnergySupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsLowEnergySupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_get_IsPeripheralRoleSupported(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothAdapter", L"IsPeripheralRoleSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsPeripheralRoleSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_get_AreClassicSecureConnectionsSupported(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothAdapter", L"AreClassicSecureConnectionsSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AreClassicSecureConnectionsSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_get_AreLowEnergySecureConnectionsSupported(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothAdapter", L"AreLowEnergySecureConnectionsSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AreLowEnergySecureConnectionsSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_get_IsExtendedAdvertisingSupported(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothAdapter", L"IsExtendedAdvertisingSupported"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsExtendedAdvertisingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_get_MaxAdvertisementDataLength(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothAdapter", L"MaxAdvertisementDataLength"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxAdvertisementDataLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BluetoothAdapter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::BluetoothAdapter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BluetoothAdapter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::BluetoothAdapter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothAdapter[] = {
        { "get_radio_async", reinterpret_cast<PyCFunction>(BluetoothAdapter_GetRadioAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BluetoothAdapter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BluetoothAdapter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BluetoothAdapter[] = {
        { "bluetooth_address", reinterpret_cast<getter>(BluetoothAdapter_get_BluetoothAddress), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(BluetoothAdapter_get_DeviceId), nullptr, nullptr, nullptr },
        { "is_advertisement_offload_supported", reinterpret_cast<getter>(BluetoothAdapter_get_IsAdvertisementOffloadSupported), nullptr, nullptr, nullptr },
        { "is_central_role_supported", reinterpret_cast<getter>(BluetoothAdapter_get_IsCentralRoleSupported), nullptr, nullptr, nullptr },
        { "is_classic_supported", reinterpret_cast<getter>(BluetoothAdapter_get_IsClassicSupported), nullptr, nullptr, nullptr },
        { "is_low_energy_supported", reinterpret_cast<getter>(BluetoothAdapter_get_IsLowEnergySupported), nullptr, nullptr, nullptr },
        { "is_peripheral_role_supported", reinterpret_cast<getter>(BluetoothAdapter_get_IsPeripheralRoleSupported), nullptr, nullptr, nullptr },
        { "are_classic_secure_connections_supported", reinterpret_cast<getter>(BluetoothAdapter_get_AreClassicSecureConnectionsSupported), nullptr, nullptr, nullptr },
        { "are_low_energy_secure_connections_supported", reinterpret_cast<getter>(BluetoothAdapter_get_AreLowEnergySecureConnectionsSupported), nullptr, nullptr, nullptr },
        { "is_extended_advertising_supported", reinterpret_cast<getter>(BluetoothAdapter_get_IsExtendedAdvertisingSupported), nullptr, nullptr, nullptr },
        { "max_advertisement_data_length", reinterpret_cast<getter>(BluetoothAdapter_get_MaxAdvertisementDataLength), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BluetoothAdapter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BluetoothAdapter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BluetoothAdapter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BluetoothAdapter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BluetoothAdapter) },
        { },
    };

    static PyType_Spec type_spec_BluetoothAdapter = {
        "winrt._winrt_windows_devices_bluetooth.BluetoothAdapter",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothAdapter};

    static PyGetSetDef getset_BluetoothAdapter_Static[] = {
        { }
    };

    static PyMethodDef methods_BluetoothAdapter_Static[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(BluetoothAdapter_FromIdAsync), METH_VARARGS, nullptr },
        { "get_default_async", reinterpret_cast<PyCFunction>(BluetoothAdapter_GetDefaultAsync), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(BluetoothAdapter_GetDeviceSelector), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_BluetoothAdapter_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BluetoothAdapter_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BluetoothAdapter_Static) },
        { }
    };

    static PyType_Spec type_spec_BluetoothAdapter_Static =
    {
        "winrt._winrt_windows_devices_bluetooth.BluetoothAdapter_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BluetoothAdapter_Static
    };

    // ----- BluetoothClassOfDevice class --------------------

    static PyObject* _new_BluetoothClassOfDevice(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::BluetoothClassOfDevice>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::BluetoothClassOfDevice>::type_name);
        return nullptr;
    }

    static void _dealloc_BluetoothClassOfDevice(py::wrapper::Windows::Devices::Bluetooth::BluetoothClassOfDevice* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BluetoothClassOfDevice_FromParts(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothClassOfDevice", L"FromParts", 3))
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothMajorClass>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothMinorClass>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothServiceCapabilities>(args, 2);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothClassOfDevice::FromParts(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothClassOfDevice_FromRawValue(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothClassOfDevice", L"FromRawValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothClassOfDevice::FromRawValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothClassOfDevice_get_MajorClass(py::wrapper::Windows::Devices::Bluetooth::BluetoothClassOfDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothClassOfDevice", L"MajorClass"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MajorClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothClassOfDevice_get_MinorClass(py::wrapper::Windows::Devices::Bluetooth::BluetoothClassOfDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothClassOfDevice", L"MinorClass"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinorClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothClassOfDevice_get_RawValue(py::wrapper::Windows::Devices::Bluetooth::BluetoothClassOfDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothClassOfDevice", L"RawValue"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RawValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothClassOfDevice_get_ServiceCapabilities(py::wrapper::Windows::Devices::Bluetooth::BluetoothClassOfDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothClassOfDevice", L"ServiceCapabilities"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ServiceCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BluetoothClassOfDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::BluetoothClassOfDevice>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BluetoothClassOfDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::BluetoothClassOfDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothClassOfDevice[] = {
        { "_assign_array_", _assign_array_BluetoothClassOfDevice, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BluetoothClassOfDevice), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BluetoothClassOfDevice[] = {
        { "major_class", reinterpret_cast<getter>(BluetoothClassOfDevice_get_MajorClass), nullptr, nullptr, nullptr },
        { "minor_class", reinterpret_cast<getter>(BluetoothClassOfDevice_get_MinorClass), nullptr, nullptr, nullptr },
        { "raw_value", reinterpret_cast<getter>(BluetoothClassOfDevice_get_RawValue), nullptr, nullptr, nullptr },
        { "service_capabilities", reinterpret_cast<getter>(BluetoothClassOfDevice_get_ServiceCapabilities), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BluetoothClassOfDevice[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BluetoothClassOfDevice) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BluetoothClassOfDevice) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BluetoothClassOfDevice) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BluetoothClassOfDevice) },
        { },
    };

    static PyType_Spec type_spec_BluetoothClassOfDevice = {
        "winrt._winrt_windows_devices_bluetooth.BluetoothClassOfDevice",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::BluetoothClassOfDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothClassOfDevice};

    static PyGetSetDef getset_BluetoothClassOfDevice_Static[] = {
        { }
    };

    static PyMethodDef methods_BluetoothClassOfDevice_Static[] = {
        { "from_parts", reinterpret_cast<PyCFunction>(BluetoothClassOfDevice_FromParts), METH_VARARGS, nullptr },
        { "from_raw_value", reinterpret_cast<PyCFunction>(BluetoothClassOfDevice_FromRawValue), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_BluetoothClassOfDevice_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BluetoothClassOfDevice_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BluetoothClassOfDevice_Static) },
        { }
    };

    static PyType_Spec type_spec_BluetoothClassOfDevice_Static =
    {
        "winrt._winrt_windows_devices_bluetooth.BluetoothClassOfDevice_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BluetoothClassOfDevice_Static
    };

    // ----- BluetoothDevice class --------------------

    static PyObject* _new_BluetoothDevice(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::BluetoothDevice>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::BluetoothDevice>::type_name);
        return nullptr;
    }

    static void _dealloc_BluetoothDevice(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BluetoothDevice_Close(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothDevice", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_FromBluetoothAddressAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothDevice", L"FromBluetoothAddressAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothDevice::FromBluetoothAddressAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_FromHostNameAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothDevice", L"FromHostNameAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothDevice::FromHostNameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothDevice", L"FromIdAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothDevice::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothDevice", L"GetDeviceSelector", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothDevice::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_GetDeviceSelectorFromBluetoothAddress(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothDevice", L"GetDeviceSelectorFromBluetoothAddress", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothDevice::GetDeviceSelectorFromBluetoothAddress(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_GetDeviceSelectorFromClassOfDevice(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothDevice", L"GetDeviceSelectorFromClassOfDevice", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothClassOfDevice>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothDevice::GetDeviceSelectorFromClassOfDevice(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_GetDeviceSelectorFromConnectionStatus(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothDevice", L"GetDeviceSelectorFromConnectionStatus", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothConnectionStatus>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothDevice::GetDeviceSelectorFromConnectionStatus(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_GetDeviceSelectorFromDeviceName(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothDevice", L"GetDeviceSelectorFromDeviceName", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothDevice::GetDeviceSelectorFromDeviceName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_GetDeviceSelectorFromPairingState(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothDevice", L"GetDeviceSelectorFromPairingState", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothDevice::GetDeviceSelectorFromPairingState(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_GetRfcommServicesAsync(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothDevice", L"GetRfcommServicesAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetRfcommServicesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothDevice", L"GetRfcommServicesAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothCacheMode>(args, 0);

                return py::convert(self->obj.GetRfcommServicesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_GetRfcommServicesForIdAsync(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothDevice", L"GetRfcommServicesForIdAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::Rfcomm::RfcommServiceId>(args, 0);

                return py::convert(self->obj.GetRfcommServicesForIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothDevice", L"GetRfcommServicesForIdAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::Rfcomm::RfcommServiceId>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothCacheMode>(args, 1);

                return py::convert(self->obj.GetRfcommServicesForIdAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_RequestAccessAsync(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothDevice", L"RequestAccessAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.RequestAccessAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_get_BluetoothAddress(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothDevice", L"BluetoothAddress"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BluetoothAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_get_ClassOfDevice(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothDevice", L"ClassOfDevice"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ClassOfDevice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_get_ConnectionStatus(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothDevice", L"ConnectionStatus"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ConnectionStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_get_DeviceId(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothDevice", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_get_HostName(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothDevice", L"HostName"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HostName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_get_Name(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothDevice", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_get_RfcommServices(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothDevice", L"RfcommServices"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RfcommServices());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_get_SdpRecords(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothDevice", L"SdpRecords"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SdpRecords());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_get_DeviceInformation(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothDevice", L"DeviceInformation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_get_DeviceAccessInformation(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothDevice", L"DeviceAccessInformation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceAccessInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_get_BluetoothDeviceId(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothDevice", L"BluetoothDeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BluetoothDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_get_WasSecureConnectionUsedForPairing(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothDevice", L"WasSecureConnectionUsedForPairing"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WasSecureConnectionUsedForPairing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_add_ConnectionStatusChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.BluetoothDevice", L"ConnectionStatusChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Bluetooth::BluetoothDevice, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ConnectionStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_remove_ConnectionStatusChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.BluetoothDevice", L"ConnectionStatusChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ConnectionStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_add_NameChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.BluetoothDevice", L"NameChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Bluetooth::BluetoothDevice, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.NameChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_remove_NameChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.BluetoothDevice", L"NameChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.NameChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_add_SdpRecordsChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.BluetoothDevice", L"SdpRecordsChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Bluetooth::BluetoothDevice, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SdpRecordsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_remove_SdpRecordsChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.BluetoothDevice", L"SdpRecordsChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SdpRecordsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BluetoothDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::BluetoothDevice>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BluetoothDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::BluetoothDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_BluetoothDevice(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_BluetoothDevice(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothDevice[] = {
        { "close", reinterpret_cast<PyCFunction>(BluetoothDevice_Close), METH_VARARGS, nullptr },
        { "get_rfcomm_services_async", reinterpret_cast<PyCFunction>(BluetoothDevice_GetRfcommServicesAsync), METH_VARARGS, nullptr },
        { "get_rfcomm_services_for_id_async", reinterpret_cast<PyCFunction>(BluetoothDevice_GetRfcommServicesForIdAsync), METH_VARARGS, nullptr },
        { "request_access_async", reinterpret_cast<PyCFunction>(BluetoothDevice_RequestAccessAsync), METH_VARARGS, nullptr },
        { "add_connection_status_changed", reinterpret_cast<PyCFunction>(BluetoothDevice_add_ConnectionStatusChanged), METH_O, nullptr },
        { "remove_connection_status_changed", reinterpret_cast<PyCFunction>(BluetoothDevice_remove_ConnectionStatusChanged), METH_O, nullptr },
        { "add_name_changed", reinterpret_cast<PyCFunction>(BluetoothDevice_add_NameChanged), METH_O, nullptr },
        { "remove_name_changed", reinterpret_cast<PyCFunction>(BluetoothDevice_remove_NameChanged), METH_O, nullptr },
        { "add_sdp_records_changed", reinterpret_cast<PyCFunction>(BluetoothDevice_add_SdpRecordsChanged), METH_O, nullptr },
        { "remove_sdp_records_changed", reinterpret_cast<PyCFunction>(BluetoothDevice_remove_SdpRecordsChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_BluetoothDevice, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BluetoothDevice), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_BluetoothDevice), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_BluetoothDevice), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_BluetoothDevice[] = {
        { "bluetooth_address", reinterpret_cast<getter>(BluetoothDevice_get_BluetoothAddress), nullptr, nullptr, nullptr },
        { "class_of_device", reinterpret_cast<getter>(BluetoothDevice_get_ClassOfDevice), nullptr, nullptr, nullptr },
        { "connection_status", reinterpret_cast<getter>(BluetoothDevice_get_ConnectionStatus), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(BluetoothDevice_get_DeviceId), nullptr, nullptr, nullptr },
        { "host_name", reinterpret_cast<getter>(BluetoothDevice_get_HostName), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(BluetoothDevice_get_Name), nullptr, nullptr, nullptr },
        { "rfcomm_services", reinterpret_cast<getter>(BluetoothDevice_get_RfcommServices), nullptr, nullptr, nullptr },
        { "sdp_records", reinterpret_cast<getter>(BluetoothDevice_get_SdpRecords), nullptr, nullptr, nullptr },
        { "device_information", reinterpret_cast<getter>(BluetoothDevice_get_DeviceInformation), nullptr, nullptr, nullptr },
        { "device_access_information", reinterpret_cast<getter>(BluetoothDevice_get_DeviceAccessInformation), nullptr, nullptr, nullptr },
        { "bluetooth_device_id", reinterpret_cast<getter>(BluetoothDevice_get_BluetoothDeviceId), nullptr, nullptr, nullptr },
        { "was_secure_connection_used_for_pairing", reinterpret_cast<getter>(BluetoothDevice_get_WasSecureConnectionUsedForPairing), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BluetoothDevice[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BluetoothDevice) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BluetoothDevice) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BluetoothDevice) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BluetoothDevice) },
        { },
    };

    static PyType_Spec type_spec_BluetoothDevice = {
        "winrt._winrt_windows_devices_bluetooth.BluetoothDevice",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothDevice};

    static PyGetSetDef getset_BluetoothDevice_Static[] = {
        { }
    };

    static PyMethodDef methods_BluetoothDevice_Static[] = {
        { "from_bluetooth_address_async", reinterpret_cast<PyCFunction>(BluetoothDevice_FromBluetoothAddressAsync), METH_VARARGS, nullptr },
        { "from_host_name_async", reinterpret_cast<PyCFunction>(BluetoothDevice_FromHostNameAsync), METH_VARARGS, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(BluetoothDevice_FromIdAsync), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(BluetoothDevice_GetDeviceSelector), METH_VARARGS, nullptr },
        { "get_device_selector_from_bluetooth_address", reinterpret_cast<PyCFunction>(BluetoothDevice_GetDeviceSelectorFromBluetoothAddress), METH_VARARGS, nullptr },
        { "get_device_selector_from_class_of_device", reinterpret_cast<PyCFunction>(BluetoothDevice_GetDeviceSelectorFromClassOfDevice), METH_VARARGS, nullptr },
        { "get_device_selector_from_connection_status", reinterpret_cast<PyCFunction>(BluetoothDevice_GetDeviceSelectorFromConnectionStatus), METH_VARARGS, nullptr },
        { "get_device_selector_from_device_name", reinterpret_cast<PyCFunction>(BluetoothDevice_GetDeviceSelectorFromDeviceName), METH_VARARGS, nullptr },
        { "get_device_selector_from_pairing_state", reinterpret_cast<PyCFunction>(BluetoothDevice_GetDeviceSelectorFromPairingState), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_BluetoothDevice_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BluetoothDevice_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BluetoothDevice_Static) },
        { }
    };

    static PyType_Spec type_spec_BluetoothDevice_Static =
    {
        "winrt._winrt_windows_devices_bluetooth.BluetoothDevice_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BluetoothDevice_Static
    };

    // ----- BluetoothDeviceId class --------------------

    static PyObject* _new_BluetoothDeviceId(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::BluetoothDeviceId>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::BluetoothDeviceId>::type_name);
        return nullptr;
    }

    static void _dealloc_BluetoothDeviceId(py::wrapper::Windows::Devices::Bluetooth::BluetoothDeviceId* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BluetoothDeviceId_FromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothDeviceId", L"FromId", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothDeviceId::FromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDeviceId_get_Id(py::wrapper::Windows::Devices::Bluetooth::BluetoothDeviceId* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothDeviceId", L"Id"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDeviceId_get_IsClassicDevice(py::wrapper::Windows::Devices::Bluetooth::BluetoothDeviceId* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothDeviceId", L"IsClassicDevice"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsClassicDevice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDeviceId_get_IsLowEnergyDevice(py::wrapper::Windows::Devices::Bluetooth::BluetoothDeviceId* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothDeviceId", L"IsLowEnergyDevice"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsLowEnergyDevice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BluetoothDeviceId(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::BluetoothDeviceId>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BluetoothDeviceId(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::BluetoothDeviceId>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothDeviceId[] = {
        { "_assign_array_", _assign_array_BluetoothDeviceId, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BluetoothDeviceId), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BluetoothDeviceId[] = {
        { "id", reinterpret_cast<getter>(BluetoothDeviceId_get_Id), nullptr, nullptr, nullptr },
        { "is_classic_device", reinterpret_cast<getter>(BluetoothDeviceId_get_IsClassicDevice), nullptr, nullptr, nullptr },
        { "is_low_energy_device", reinterpret_cast<getter>(BluetoothDeviceId_get_IsLowEnergyDevice), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BluetoothDeviceId[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BluetoothDeviceId) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BluetoothDeviceId) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BluetoothDeviceId) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BluetoothDeviceId) },
        { },
    };

    static PyType_Spec type_spec_BluetoothDeviceId = {
        "winrt._winrt_windows_devices_bluetooth.BluetoothDeviceId",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::BluetoothDeviceId),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothDeviceId};

    static PyGetSetDef getset_BluetoothDeviceId_Static[] = {
        { }
    };

    static PyMethodDef methods_BluetoothDeviceId_Static[] = {
        { "from_id", reinterpret_cast<PyCFunction>(BluetoothDeviceId_FromId), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_BluetoothDeviceId_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BluetoothDeviceId_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BluetoothDeviceId_Static) },
        { }
    };

    static PyType_Spec type_spec_BluetoothDeviceId_Static =
    {
        "winrt._winrt_windows_devices_bluetooth.BluetoothDeviceId_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BluetoothDeviceId_Static
    };

    // ----- BluetoothLEAppearance class --------------------

    static PyObject* _new_BluetoothLEAppearance(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::BluetoothLEAppearance>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::BluetoothLEAppearance>::type_name);
        return nullptr;
    }

    static void _dealloc_BluetoothLEAppearance(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEAppearance* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BluetoothLEAppearance_FromParts(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearance", L"FromParts", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearance::FromParts(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearance_FromRawValue(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearance", L"FromRawValue", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint16_t>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearance::FromRawValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearance_get_Category(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEAppearance* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearance", L"Category"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Category());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearance_get_RawValue(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEAppearance* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearance", L"RawValue"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RawValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearance_get_SubCategory(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEAppearance* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearance", L"SubCategory"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SubCategory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BluetoothLEAppearance(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::BluetoothLEAppearance>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BluetoothLEAppearance(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::BluetoothLEAppearance>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEAppearance[] = {
        { "_assign_array_", _assign_array_BluetoothLEAppearance, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BluetoothLEAppearance), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BluetoothLEAppearance[] = {
        { "category", reinterpret_cast<getter>(BluetoothLEAppearance_get_Category), nullptr, nullptr, nullptr },
        { "raw_value", reinterpret_cast<getter>(BluetoothLEAppearance_get_RawValue), nullptr, nullptr, nullptr },
        { "sub_category", reinterpret_cast<getter>(BluetoothLEAppearance_get_SubCategory), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BluetoothLEAppearance[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BluetoothLEAppearance) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BluetoothLEAppearance) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BluetoothLEAppearance) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BluetoothLEAppearance) },
        { },
    };

    static PyType_Spec type_spec_BluetoothLEAppearance = {
        "winrt._winrt_windows_devices_bluetooth.BluetoothLEAppearance",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEAppearance),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEAppearance};

    static PyGetSetDef getset_BluetoothLEAppearance_Static[] = {
        { }
    };

    static PyMethodDef methods_BluetoothLEAppearance_Static[] = {
        { "from_parts", reinterpret_cast<PyCFunction>(BluetoothLEAppearance_FromParts), METH_VARARGS, nullptr },
        { "from_raw_value", reinterpret_cast<PyCFunction>(BluetoothLEAppearance_FromRawValue), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_BluetoothLEAppearance_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BluetoothLEAppearance_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BluetoothLEAppearance_Static) },
        { }
    };

    static PyType_Spec type_spec_BluetoothLEAppearance_Static =
    {
        "winrt._winrt_windows_devices_bluetooth.BluetoothLEAppearance_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BluetoothLEAppearance_Static
    };

    // ----- BluetoothLEAppearanceCategories class --------------------

    static PyObject* _new_BluetoothLEAppearanceCategories(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories>::type_name);
        return nullptr;
    }

    static PyObject* BluetoothLEAppearanceCategories_get_BarcodeScanner(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories", L"BarcodeScanner"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::BarcodeScanner());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_BloodPressure(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories", L"BloodPressure"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::BloodPressure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_Clock(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories", L"Clock"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Clock());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_Computer(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories", L"Computer"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Computer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_Cycling(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories", L"Cycling"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Cycling());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_Display(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories", L"Display"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Display());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_EyeGlasses(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories", L"EyeGlasses"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::EyeGlasses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_GlucoseMeter(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories", L"GlucoseMeter"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::GlucoseMeter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_HeartRate(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories", L"HeartRate"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::HeartRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_HumanInterfaceDevice(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories", L"HumanInterfaceDevice"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::HumanInterfaceDevice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_Keyring(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories", L"Keyring"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Keyring());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_MediaPlayer(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories", L"MediaPlayer"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::MediaPlayer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_OutdoorSportActivity(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories", L"OutdoorSportActivity"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::OutdoorSportActivity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_Phone(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories", L"Phone"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Phone());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_PulseOximeter(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories", L"PulseOximeter"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::PulseOximeter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_RemoteControl(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories", L"RemoteControl"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::RemoteControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_RunningWalking(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories", L"RunningWalking"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::RunningWalking());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_Tag(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories", L"Tag"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_Thermometer(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories", L"Thermometer"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Thermometer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_Uncategorized(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories", L"Uncategorized"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Uncategorized());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_Watch(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories", L"Watch"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Watch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_WeightScale(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceCategories", L"WeightScale"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::WeightScale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEAppearanceCategories[] = {
        { }
    };

    static PyGetSetDef _getset_BluetoothLEAppearanceCategories[] = {
        { }
    };

    static PyType_Slot _type_slots_BluetoothLEAppearanceCategories[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BluetoothLEAppearanceCategories) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BluetoothLEAppearanceCategories) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BluetoothLEAppearanceCategories) },
        { },
    };

    static PyType_Spec type_spec_BluetoothLEAppearanceCategories = {
        "winrt._winrt_windows_devices_bluetooth.BluetoothLEAppearanceCategories",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEAppearanceCategories};

    static PyGetSetDef getset_BluetoothLEAppearanceCategories_Static[] = {
        { "barcode_scanner", reinterpret_cast<getter>(BluetoothLEAppearanceCategories_get_BarcodeScanner), nullptr, nullptr, nullptr },
        { "blood_pressure", reinterpret_cast<getter>(BluetoothLEAppearanceCategories_get_BloodPressure), nullptr, nullptr, nullptr },
        { "clock", reinterpret_cast<getter>(BluetoothLEAppearanceCategories_get_Clock), nullptr, nullptr, nullptr },
        { "computer", reinterpret_cast<getter>(BluetoothLEAppearanceCategories_get_Computer), nullptr, nullptr, nullptr },
        { "cycling", reinterpret_cast<getter>(BluetoothLEAppearanceCategories_get_Cycling), nullptr, nullptr, nullptr },
        { "display", reinterpret_cast<getter>(BluetoothLEAppearanceCategories_get_Display), nullptr, nullptr, nullptr },
        { "eye_glasses", reinterpret_cast<getter>(BluetoothLEAppearanceCategories_get_EyeGlasses), nullptr, nullptr, nullptr },
        { "glucose_meter", reinterpret_cast<getter>(BluetoothLEAppearanceCategories_get_GlucoseMeter), nullptr, nullptr, nullptr },
        { "heart_rate", reinterpret_cast<getter>(BluetoothLEAppearanceCategories_get_HeartRate), nullptr, nullptr, nullptr },
        { "human_interface_device", reinterpret_cast<getter>(BluetoothLEAppearanceCategories_get_HumanInterfaceDevice), nullptr, nullptr, nullptr },
        { "keyring", reinterpret_cast<getter>(BluetoothLEAppearanceCategories_get_Keyring), nullptr, nullptr, nullptr },
        { "media_player", reinterpret_cast<getter>(BluetoothLEAppearanceCategories_get_MediaPlayer), nullptr, nullptr, nullptr },
        { "outdoor_sport_activity", reinterpret_cast<getter>(BluetoothLEAppearanceCategories_get_OutdoorSportActivity), nullptr, nullptr, nullptr },
        { "phone", reinterpret_cast<getter>(BluetoothLEAppearanceCategories_get_Phone), nullptr, nullptr, nullptr },
        { "pulse_oximeter", reinterpret_cast<getter>(BluetoothLEAppearanceCategories_get_PulseOximeter), nullptr, nullptr, nullptr },
        { "remote_control", reinterpret_cast<getter>(BluetoothLEAppearanceCategories_get_RemoteControl), nullptr, nullptr, nullptr },
        { "running_walking", reinterpret_cast<getter>(BluetoothLEAppearanceCategories_get_RunningWalking), nullptr, nullptr, nullptr },
        { "tag", reinterpret_cast<getter>(BluetoothLEAppearanceCategories_get_Tag), nullptr, nullptr, nullptr },
        { "thermometer", reinterpret_cast<getter>(BluetoothLEAppearanceCategories_get_Thermometer), nullptr, nullptr, nullptr },
        { "uncategorized", reinterpret_cast<getter>(BluetoothLEAppearanceCategories_get_Uncategorized), nullptr, nullptr, nullptr },
        { "watch", reinterpret_cast<getter>(BluetoothLEAppearanceCategories_get_Watch), nullptr, nullptr, nullptr },
        { "weight_scale", reinterpret_cast<getter>(BluetoothLEAppearanceCategories_get_WeightScale), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_BluetoothLEAppearanceCategories_Static[] = {
        { }
    };

    static PyType_Slot type_slots_BluetoothLEAppearanceCategories_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BluetoothLEAppearanceCategories_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BluetoothLEAppearanceCategories_Static) },
        { }
    };

    static PyType_Spec type_spec_BluetoothLEAppearanceCategories_Static =
    {
        "winrt._winrt_windows_devices_bluetooth.BluetoothLEAppearanceCategories_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BluetoothLEAppearanceCategories_Static
    };

    // ----- BluetoothLEAppearanceSubcategories class --------------------

    static PyObject* _new_BluetoothLEAppearanceSubcategories(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories>::type_name);
        return nullptr;
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_BarcodeScanner(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories", L"BarcodeScanner"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::BarcodeScanner());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_BloodPressureArm(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories", L"BloodPressureArm"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::BloodPressureArm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_BloodPressureWrist(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories", L"BloodPressureWrist"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::BloodPressureWrist());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_CardReader(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories", L"CardReader"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::CardReader());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_CyclingCadenceSensor(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories", L"CyclingCadenceSensor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::CyclingCadenceSensor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_CyclingComputer(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories", L"CyclingComputer"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::CyclingComputer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_CyclingPowerSensor(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories", L"CyclingPowerSensor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::CyclingPowerSensor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_CyclingSpeedCadenceSensor(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories", L"CyclingSpeedCadenceSensor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::CyclingSpeedCadenceSensor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_CyclingSpeedSensor(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories", L"CyclingSpeedSensor"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::CyclingSpeedSensor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_DigitalPen(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories", L"DigitalPen"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::DigitalPen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_DigitizerTablet(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories", L"DigitizerTablet"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::DigitizerTablet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_Gamepad(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories", L"Gamepad"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::Gamepad());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_Generic(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories", L"Generic"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::Generic());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_HeartRateBelt(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories", L"HeartRateBelt"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::HeartRateBelt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_Joystick(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories", L"Joystick"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::Joystick());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_Keyboard(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories", L"Keyboard"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::Keyboard());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_LocationDisplay(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories", L"LocationDisplay"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::LocationDisplay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_LocationNavigationDisplay(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories", L"LocationNavigationDisplay"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::LocationNavigationDisplay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_LocationNavigationPod(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories", L"LocationNavigationPod"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::LocationNavigationPod());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_LocationPod(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories", L"LocationPod"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::LocationPod());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_Mouse(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories", L"Mouse"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::Mouse());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_OximeterFingertip(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories", L"OximeterFingertip"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::OximeterFingertip());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_OximeterWristWorn(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories", L"OximeterWristWorn"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::OximeterWristWorn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_RunningWalkingInShoe(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories", L"RunningWalkingInShoe"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::RunningWalkingInShoe());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_RunningWalkingOnHip(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories", L"RunningWalkingOnHip"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::RunningWalkingOnHip());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_RunningWalkingOnShoe(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories", L"RunningWalkingOnShoe"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::RunningWalkingOnShoe());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_SportsWatch(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories", L"SportsWatch"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::SportsWatch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_ThermometerEar(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEAppearanceSubcategories", L"ThermometerEar"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::ThermometerEar());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEAppearanceSubcategories[] = {
        { }
    };

    static PyGetSetDef _getset_BluetoothLEAppearanceSubcategories[] = {
        { }
    };

    static PyType_Slot _type_slots_BluetoothLEAppearanceSubcategories[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BluetoothLEAppearanceSubcategories) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BluetoothLEAppearanceSubcategories) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BluetoothLEAppearanceSubcategories) },
        { },
    };

    static PyType_Spec type_spec_BluetoothLEAppearanceSubcategories = {
        "winrt._winrt_windows_devices_bluetooth.BluetoothLEAppearanceSubcategories",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEAppearanceSubcategories};

    static PyGetSetDef getset_BluetoothLEAppearanceSubcategories_Static[] = {
        { "barcode_scanner", reinterpret_cast<getter>(BluetoothLEAppearanceSubcategories_get_BarcodeScanner), nullptr, nullptr, nullptr },
        { "blood_pressure_arm", reinterpret_cast<getter>(BluetoothLEAppearanceSubcategories_get_BloodPressureArm), nullptr, nullptr, nullptr },
        { "blood_pressure_wrist", reinterpret_cast<getter>(BluetoothLEAppearanceSubcategories_get_BloodPressureWrist), nullptr, nullptr, nullptr },
        { "card_reader", reinterpret_cast<getter>(BluetoothLEAppearanceSubcategories_get_CardReader), nullptr, nullptr, nullptr },
        { "cycling_cadence_sensor", reinterpret_cast<getter>(BluetoothLEAppearanceSubcategories_get_CyclingCadenceSensor), nullptr, nullptr, nullptr },
        { "cycling_computer", reinterpret_cast<getter>(BluetoothLEAppearanceSubcategories_get_CyclingComputer), nullptr, nullptr, nullptr },
        { "cycling_power_sensor", reinterpret_cast<getter>(BluetoothLEAppearanceSubcategories_get_CyclingPowerSensor), nullptr, nullptr, nullptr },
        { "cycling_speed_cadence_sensor", reinterpret_cast<getter>(BluetoothLEAppearanceSubcategories_get_CyclingSpeedCadenceSensor), nullptr, nullptr, nullptr },
        { "cycling_speed_sensor", reinterpret_cast<getter>(BluetoothLEAppearanceSubcategories_get_CyclingSpeedSensor), nullptr, nullptr, nullptr },
        { "digital_pen", reinterpret_cast<getter>(BluetoothLEAppearanceSubcategories_get_DigitalPen), nullptr, nullptr, nullptr },
        { "digitizer_tablet", reinterpret_cast<getter>(BluetoothLEAppearanceSubcategories_get_DigitizerTablet), nullptr, nullptr, nullptr },
        { "gamepad", reinterpret_cast<getter>(BluetoothLEAppearanceSubcategories_get_Gamepad), nullptr, nullptr, nullptr },
        { "generic", reinterpret_cast<getter>(BluetoothLEAppearanceSubcategories_get_Generic), nullptr, nullptr, nullptr },
        { "heart_rate_belt", reinterpret_cast<getter>(BluetoothLEAppearanceSubcategories_get_HeartRateBelt), nullptr, nullptr, nullptr },
        { "joystick", reinterpret_cast<getter>(BluetoothLEAppearanceSubcategories_get_Joystick), nullptr, nullptr, nullptr },
        { "keyboard", reinterpret_cast<getter>(BluetoothLEAppearanceSubcategories_get_Keyboard), nullptr, nullptr, nullptr },
        { "location_display", reinterpret_cast<getter>(BluetoothLEAppearanceSubcategories_get_LocationDisplay), nullptr, nullptr, nullptr },
        { "location_navigation_display", reinterpret_cast<getter>(BluetoothLEAppearanceSubcategories_get_LocationNavigationDisplay), nullptr, nullptr, nullptr },
        { "location_navigation_pod", reinterpret_cast<getter>(BluetoothLEAppearanceSubcategories_get_LocationNavigationPod), nullptr, nullptr, nullptr },
        { "location_pod", reinterpret_cast<getter>(BluetoothLEAppearanceSubcategories_get_LocationPod), nullptr, nullptr, nullptr },
        { "mouse", reinterpret_cast<getter>(BluetoothLEAppearanceSubcategories_get_Mouse), nullptr, nullptr, nullptr },
        { "oximeter_fingertip", reinterpret_cast<getter>(BluetoothLEAppearanceSubcategories_get_OximeterFingertip), nullptr, nullptr, nullptr },
        { "oximeter_wrist_worn", reinterpret_cast<getter>(BluetoothLEAppearanceSubcategories_get_OximeterWristWorn), nullptr, nullptr, nullptr },
        { "running_walking_in_shoe", reinterpret_cast<getter>(BluetoothLEAppearanceSubcategories_get_RunningWalkingInShoe), nullptr, nullptr, nullptr },
        { "running_walking_on_hip", reinterpret_cast<getter>(BluetoothLEAppearanceSubcategories_get_RunningWalkingOnHip), nullptr, nullptr, nullptr },
        { "running_walking_on_shoe", reinterpret_cast<getter>(BluetoothLEAppearanceSubcategories_get_RunningWalkingOnShoe), nullptr, nullptr, nullptr },
        { "sports_watch", reinterpret_cast<getter>(BluetoothLEAppearanceSubcategories_get_SportsWatch), nullptr, nullptr, nullptr },
        { "thermometer_ear", reinterpret_cast<getter>(BluetoothLEAppearanceSubcategories_get_ThermometerEar), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_BluetoothLEAppearanceSubcategories_Static[] = {
        { }
    };

    static PyType_Slot type_slots_BluetoothLEAppearanceSubcategories_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BluetoothLEAppearanceSubcategories_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BluetoothLEAppearanceSubcategories_Static) },
        { }
    };

    static PyType_Spec type_spec_BluetoothLEAppearanceSubcategories_Static =
    {
        "winrt._winrt_windows_devices_bluetooth.BluetoothLEAppearanceSubcategories_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BluetoothLEAppearanceSubcategories_Static
    };

    // ----- BluetoothLEConnectionParameters class --------------------

    static PyObject* _new_BluetoothLEConnectionParameters(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::BluetoothLEConnectionParameters>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::BluetoothLEConnectionParameters>::type_name);
        return nullptr;
    }

    static void _dealloc_BluetoothLEConnectionParameters(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionParameters* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BluetoothLEConnectionParameters_get_ConnectionInterval(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEConnectionParameters", L"ConnectionInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ConnectionInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEConnectionParameters_get_ConnectionLatency(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEConnectionParameters", L"ConnectionLatency"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ConnectionLatency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEConnectionParameters_get_LinkTimeout(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEConnectionParameters", L"LinkTimeout"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LinkTimeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BluetoothLEConnectionParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::BluetoothLEConnectionParameters>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BluetoothLEConnectionParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::BluetoothLEConnectionParameters>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEConnectionParameters[] = {
        { "_assign_array_", _assign_array_BluetoothLEConnectionParameters, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BluetoothLEConnectionParameters), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BluetoothLEConnectionParameters[] = {
        { "connection_interval", reinterpret_cast<getter>(BluetoothLEConnectionParameters_get_ConnectionInterval), nullptr, nullptr, nullptr },
        { "connection_latency", reinterpret_cast<getter>(BluetoothLEConnectionParameters_get_ConnectionLatency), nullptr, nullptr, nullptr },
        { "link_timeout", reinterpret_cast<getter>(BluetoothLEConnectionParameters_get_LinkTimeout), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BluetoothLEConnectionParameters[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BluetoothLEConnectionParameters) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BluetoothLEConnectionParameters) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BluetoothLEConnectionParameters) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BluetoothLEConnectionParameters) },
        { },
    };

    static PyType_Spec type_spec_BluetoothLEConnectionParameters = {
        "winrt._winrt_windows_devices_bluetooth.BluetoothLEConnectionParameters",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionParameters),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEConnectionParameters};

    // ----- BluetoothLEConnectionPhy class --------------------

    static PyObject* _new_BluetoothLEConnectionPhy(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::BluetoothLEConnectionPhy>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::BluetoothLEConnectionPhy>::type_name);
        return nullptr;
    }

    static void _dealloc_BluetoothLEConnectionPhy(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionPhy* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BluetoothLEConnectionPhy_get_ReceiveInfo(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionPhy* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEConnectionPhy", L"ReceiveInfo"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ReceiveInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEConnectionPhy_get_TransmitInfo(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionPhy* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEConnectionPhy", L"TransmitInfo"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TransmitInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BluetoothLEConnectionPhy(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::BluetoothLEConnectionPhy>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BluetoothLEConnectionPhy(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::BluetoothLEConnectionPhy>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEConnectionPhy[] = {
        { "_assign_array_", _assign_array_BluetoothLEConnectionPhy, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BluetoothLEConnectionPhy), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BluetoothLEConnectionPhy[] = {
        { "receive_info", reinterpret_cast<getter>(BluetoothLEConnectionPhy_get_ReceiveInfo), nullptr, nullptr, nullptr },
        { "transmit_info", reinterpret_cast<getter>(BluetoothLEConnectionPhy_get_TransmitInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BluetoothLEConnectionPhy[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BluetoothLEConnectionPhy) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BluetoothLEConnectionPhy) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BluetoothLEConnectionPhy) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BluetoothLEConnectionPhy) },
        { },
    };

    static PyType_Spec type_spec_BluetoothLEConnectionPhy = {
        "winrt._winrt_windows_devices_bluetooth.BluetoothLEConnectionPhy",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionPhy),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEConnectionPhy};

    // ----- BluetoothLEConnectionPhyInfo class --------------------

    static PyObject* _new_BluetoothLEConnectionPhyInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::BluetoothLEConnectionPhyInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::BluetoothLEConnectionPhyInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_BluetoothLEConnectionPhyInfo(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionPhyInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BluetoothLEConnectionPhyInfo_get_IsCodedPhy(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionPhyInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEConnectionPhyInfo", L"IsCodedPhy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsCodedPhy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEConnectionPhyInfo_get_IsUncoded1MPhy(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionPhyInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEConnectionPhyInfo", L"IsUncoded1MPhy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsUncoded1MPhy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEConnectionPhyInfo_get_IsUncoded2MPhy(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionPhyInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEConnectionPhyInfo", L"IsUncoded2MPhy"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsUncoded2MPhy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BluetoothLEConnectionPhyInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::BluetoothLEConnectionPhyInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BluetoothLEConnectionPhyInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::BluetoothLEConnectionPhyInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEConnectionPhyInfo[] = {
        { "_assign_array_", _assign_array_BluetoothLEConnectionPhyInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BluetoothLEConnectionPhyInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BluetoothLEConnectionPhyInfo[] = {
        { "is_coded_phy", reinterpret_cast<getter>(BluetoothLEConnectionPhyInfo_get_IsCodedPhy), nullptr, nullptr, nullptr },
        { "is_uncoded1_m_phy", reinterpret_cast<getter>(BluetoothLEConnectionPhyInfo_get_IsUncoded1MPhy), nullptr, nullptr, nullptr },
        { "is_uncoded2_m_phy", reinterpret_cast<getter>(BluetoothLEConnectionPhyInfo_get_IsUncoded2MPhy), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BluetoothLEConnectionPhyInfo[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BluetoothLEConnectionPhyInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BluetoothLEConnectionPhyInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BluetoothLEConnectionPhyInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BluetoothLEConnectionPhyInfo) },
        { },
    };

    static PyType_Spec type_spec_BluetoothLEConnectionPhyInfo = {
        "winrt._winrt_windows_devices_bluetooth.BluetoothLEConnectionPhyInfo",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionPhyInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEConnectionPhyInfo};

    // ----- BluetoothLEDevice class --------------------

    static PyObject* _new_BluetoothLEDevice(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::BluetoothLEDevice>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::BluetoothLEDevice>::type_name);
        return nullptr;
    }

    static void _dealloc_BluetoothLEDevice(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BluetoothLEDevice_Close(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_FromBluetoothAddressAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"FromBluetoothAddressAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEDevice::FromBluetoothAddressAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"FromBluetoothAddressAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothAddressType>(args, 1);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEDevice::FromBluetoothAddressAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"FromIdAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEDevice::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_GetConnectionParameters(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"GetConnectionParameters", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetConnectionParameters());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_GetConnectionPhy(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"GetConnectionPhy", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetConnectionPhy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"GetDeviceSelector", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEDevice::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_GetDeviceSelectorFromAppearance(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"GetDeviceSelectorFromAppearance", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothLEAppearance>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEDevice::GetDeviceSelectorFromAppearance(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_GetDeviceSelectorFromBluetoothAddress(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"GetDeviceSelectorFromBluetoothAddress", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEDevice::GetDeviceSelectorFromBluetoothAddress(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"GetDeviceSelectorFromBluetoothAddress", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint64_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothAddressType>(args, 1);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEDevice::GetDeviceSelectorFromBluetoothAddress(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_GetDeviceSelectorFromConnectionStatus(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"GetDeviceSelectorFromConnectionStatus", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothConnectionStatus>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEDevice::GetDeviceSelectorFromConnectionStatus(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_GetDeviceSelectorFromDeviceName(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"GetDeviceSelectorFromDeviceName", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEDevice::GetDeviceSelectorFromDeviceName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_GetDeviceSelectorFromPairingState(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"GetDeviceSelectorFromPairingState", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEDevice::GetDeviceSelectorFromPairingState(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_GetGattService(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"GetGattService", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.GetGattService(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_GetGattServicesAsync(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"GetGattServicesAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.GetGattServicesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"GetGattServicesAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothCacheMode>(args, 0);

                return py::convert(self->obj.GetGattServicesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_GetGattServicesForUuidAsync(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"GetGattServicesForUuidAsync", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.GetGattServicesForUuidAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"GetGattServicesForUuidAsync", 2))
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothCacheMode>(args, 1);

                return py::convert(self->obj.GetGattServicesForUuidAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_RequestAccessAsync(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"RequestAccessAsync", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.RequestAccessAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_RequestPreferredConnectionParameters(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"RequestPreferredConnectionParameters", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters>(args, 0);

                return py::convert(self->obj.RequestPreferredConnectionParameters(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_get_BluetoothAddress(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"BluetoothAddress"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BluetoothAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_get_ConnectionStatus(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"ConnectionStatus"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ConnectionStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_get_DeviceId(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"DeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_get_GattServices(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"GattServices"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.GattServices());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_get_Name(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"Name"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_get_Appearance(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"Appearance"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Appearance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_get_BluetoothAddressType(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"BluetoothAddressType"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BluetoothAddressType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_get_DeviceInformation(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"DeviceInformation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_get_DeviceAccessInformation(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"DeviceAccessInformation"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeviceAccessInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_get_BluetoothDeviceId(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"BluetoothDeviceId"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BluetoothDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_get_WasSecureConnectionUsedForPairing(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"WasSecureConnectionUsedForPairing"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.WasSecureConnectionUsedForPairing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_add_ConnectionStatusChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"ConnectionStatusChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Bluetooth::BluetoothLEDevice, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ConnectionStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_remove_ConnectionStatusChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"ConnectionStatusChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ConnectionStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_add_GattServicesChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"GattServicesChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Bluetooth::BluetoothLEDevice, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.GattServicesChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_remove_GattServicesChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"GattServicesChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.GattServicesChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_add_NameChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"NameChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Bluetooth::BluetoothLEDevice, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.NameChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_remove_NameChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"NameChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.NameChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_add_ConnectionParametersChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"ConnectionParametersChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Bluetooth::BluetoothLEDevice, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ConnectionParametersChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_remove_ConnectionParametersChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"ConnectionParametersChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ConnectionParametersChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_add_ConnectionPhyChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"ConnectionPhyChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Bluetooth::BluetoothLEDevice, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ConnectionPhyChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_remove_ConnectionPhyChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* arg) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Devices.Bluetooth.BluetoothLEDevice", L"ConnectionPhyChanged"))
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ConnectionPhyChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BluetoothLEDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::BluetoothLEDevice>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BluetoothLEDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::BluetoothLEDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_BluetoothLEDevice(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_BluetoothLEDevice(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEDevice[] = {
        { "close", reinterpret_cast<PyCFunction>(BluetoothLEDevice_Close), METH_VARARGS, nullptr },
        { "get_connection_parameters", reinterpret_cast<PyCFunction>(BluetoothLEDevice_GetConnectionParameters), METH_VARARGS, nullptr },
        { "get_connection_phy", reinterpret_cast<PyCFunction>(BluetoothLEDevice_GetConnectionPhy), METH_VARARGS, nullptr },
        { "get_gatt_service", reinterpret_cast<PyCFunction>(BluetoothLEDevice_GetGattService), METH_VARARGS, nullptr },
        { "get_gatt_services_async", reinterpret_cast<PyCFunction>(BluetoothLEDevice_GetGattServicesAsync), METH_VARARGS, nullptr },
        { "get_gatt_services_for_uuid_async", reinterpret_cast<PyCFunction>(BluetoothLEDevice_GetGattServicesForUuidAsync), METH_VARARGS, nullptr },
        { "request_access_async", reinterpret_cast<PyCFunction>(BluetoothLEDevice_RequestAccessAsync), METH_VARARGS, nullptr },
        { "request_preferred_connection_parameters", reinterpret_cast<PyCFunction>(BluetoothLEDevice_RequestPreferredConnectionParameters), METH_VARARGS, nullptr },
        { "add_connection_status_changed", reinterpret_cast<PyCFunction>(BluetoothLEDevice_add_ConnectionStatusChanged), METH_O, nullptr },
        { "remove_connection_status_changed", reinterpret_cast<PyCFunction>(BluetoothLEDevice_remove_ConnectionStatusChanged), METH_O, nullptr },
        { "add_gatt_services_changed", reinterpret_cast<PyCFunction>(BluetoothLEDevice_add_GattServicesChanged), METH_O, nullptr },
        { "remove_gatt_services_changed", reinterpret_cast<PyCFunction>(BluetoothLEDevice_remove_GattServicesChanged), METH_O, nullptr },
        { "add_name_changed", reinterpret_cast<PyCFunction>(BluetoothLEDevice_add_NameChanged), METH_O, nullptr },
        { "remove_name_changed", reinterpret_cast<PyCFunction>(BluetoothLEDevice_remove_NameChanged), METH_O, nullptr },
        { "add_connection_parameters_changed", reinterpret_cast<PyCFunction>(BluetoothLEDevice_add_ConnectionParametersChanged), METH_O, nullptr },
        { "remove_connection_parameters_changed", reinterpret_cast<PyCFunction>(BluetoothLEDevice_remove_ConnectionParametersChanged), METH_O, nullptr },
        { "add_connection_phy_changed", reinterpret_cast<PyCFunction>(BluetoothLEDevice_add_ConnectionPhyChanged), METH_O, nullptr },
        { "remove_connection_phy_changed", reinterpret_cast<PyCFunction>(BluetoothLEDevice_remove_ConnectionPhyChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_BluetoothLEDevice, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BluetoothLEDevice), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_BluetoothLEDevice), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_BluetoothLEDevice), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_BluetoothLEDevice[] = {
        { "bluetooth_address", reinterpret_cast<getter>(BluetoothLEDevice_get_BluetoothAddress), nullptr, nullptr, nullptr },
        { "connection_status", reinterpret_cast<getter>(BluetoothLEDevice_get_ConnectionStatus), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(BluetoothLEDevice_get_DeviceId), nullptr, nullptr, nullptr },
        { "gatt_services", reinterpret_cast<getter>(BluetoothLEDevice_get_GattServices), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(BluetoothLEDevice_get_Name), nullptr, nullptr, nullptr },
        { "appearance", reinterpret_cast<getter>(BluetoothLEDevice_get_Appearance), nullptr, nullptr, nullptr },
        { "bluetooth_address_type", reinterpret_cast<getter>(BluetoothLEDevice_get_BluetoothAddressType), nullptr, nullptr, nullptr },
        { "device_information", reinterpret_cast<getter>(BluetoothLEDevice_get_DeviceInformation), nullptr, nullptr, nullptr },
        { "device_access_information", reinterpret_cast<getter>(BluetoothLEDevice_get_DeviceAccessInformation), nullptr, nullptr, nullptr },
        { "bluetooth_device_id", reinterpret_cast<getter>(BluetoothLEDevice_get_BluetoothDeviceId), nullptr, nullptr, nullptr },
        { "was_secure_connection_used_for_pairing", reinterpret_cast<getter>(BluetoothLEDevice_get_WasSecureConnectionUsedForPairing), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BluetoothLEDevice[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BluetoothLEDevice) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BluetoothLEDevice) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BluetoothLEDevice) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BluetoothLEDevice) },
        { },
    };

    static PyType_Spec type_spec_BluetoothLEDevice = {
        "winrt._winrt_windows_devices_bluetooth.BluetoothLEDevice",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEDevice};

    static PyGetSetDef getset_BluetoothLEDevice_Static[] = {
        { }
    };

    static PyMethodDef methods_BluetoothLEDevice_Static[] = {
        { "from_bluetooth_address_async", reinterpret_cast<PyCFunction>(BluetoothLEDevice_FromBluetoothAddressAsync), METH_VARARGS, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(BluetoothLEDevice_FromIdAsync), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(BluetoothLEDevice_GetDeviceSelector), METH_VARARGS, nullptr },
        { "get_device_selector_from_appearance", reinterpret_cast<PyCFunction>(BluetoothLEDevice_GetDeviceSelectorFromAppearance), METH_VARARGS, nullptr },
        { "get_device_selector_from_bluetooth_address", reinterpret_cast<PyCFunction>(BluetoothLEDevice_GetDeviceSelectorFromBluetoothAddress), METH_VARARGS, nullptr },
        { "get_device_selector_from_connection_status", reinterpret_cast<PyCFunction>(BluetoothLEDevice_GetDeviceSelectorFromConnectionStatus), METH_VARARGS, nullptr },
        { "get_device_selector_from_device_name", reinterpret_cast<PyCFunction>(BluetoothLEDevice_GetDeviceSelectorFromDeviceName), METH_VARARGS, nullptr },
        { "get_device_selector_from_pairing_state", reinterpret_cast<PyCFunction>(BluetoothLEDevice_GetDeviceSelectorFromPairingState), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_BluetoothLEDevice_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BluetoothLEDevice_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BluetoothLEDevice_Static) },
        { }
    };

    static PyType_Spec type_spec_BluetoothLEDevice_Static =
    {
        "winrt._winrt_windows_devices_bluetooth.BluetoothLEDevice_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BluetoothLEDevice_Static
    };

    // ----- BluetoothLEPreferredConnectionParameters class --------------------

    static PyObject* _new_BluetoothLEPreferredConnectionParameters(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters>::type_name);
        return nullptr;
    }

    static void _dealloc_BluetoothLEPreferredConnectionParameters(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BluetoothLEPreferredConnectionParameters_get_ConnectionLatency(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEPreferredConnectionParameters", L"ConnectionLatency"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ConnectionLatency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEPreferredConnectionParameters_get_LinkTimeout(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEPreferredConnectionParameters", L"LinkTimeout"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.LinkTimeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEPreferredConnectionParameters_get_MaxConnectionInterval(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEPreferredConnectionParameters", L"MaxConnectionInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MaxConnectionInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEPreferredConnectionParameters_get_MinConnectionInterval(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEPreferredConnectionParameters", L"MinConnectionInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.MinConnectionInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEPreferredConnectionParameters_get_Balanced(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEPreferredConnectionParameters", L"Balanced"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters::Balanced());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEPreferredConnectionParameters_get_PowerOptimized(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEPreferredConnectionParameters", L"PowerOptimized"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters::PowerOptimized());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEPreferredConnectionParameters_get_ThroughputOptimized(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEPreferredConnectionParameters", L"ThroughputOptimized"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters::ThroughputOptimized());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BluetoothLEPreferredConnectionParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BluetoothLEPreferredConnectionParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEPreferredConnectionParameters[] = {
        { "_assign_array_", _assign_array_BluetoothLEPreferredConnectionParameters, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BluetoothLEPreferredConnectionParameters), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BluetoothLEPreferredConnectionParameters[] = {
        { "connection_latency", reinterpret_cast<getter>(BluetoothLEPreferredConnectionParameters_get_ConnectionLatency), nullptr, nullptr, nullptr },
        { "link_timeout", reinterpret_cast<getter>(BluetoothLEPreferredConnectionParameters_get_LinkTimeout), nullptr, nullptr, nullptr },
        { "max_connection_interval", reinterpret_cast<getter>(BluetoothLEPreferredConnectionParameters_get_MaxConnectionInterval), nullptr, nullptr, nullptr },
        { "min_connection_interval", reinterpret_cast<getter>(BluetoothLEPreferredConnectionParameters_get_MinConnectionInterval), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BluetoothLEPreferredConnectionParameters[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BluetoothLEPreferredConnectionParameters) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BluetoothLEPreferredConnectionParameters) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BluetoothLEPreferredConnectionParameters) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BluetoothLEPreferredConnectionParameters) },
        { },
    };

    static PyType_Spec type_spec_BluetoothLEPreferredConnectionParameters = {
        "winrt._winrt_windows_devices_bluetooth.BluetoothLEPreferredConnectionParameters",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEPreferredConnectionParameters};

    static PyGetSetDef getset_BluetoothLEPreferredConnectionParameters_Static[] = {
        { "balanced", reinterpret_cast<getter>(BluetoothLEPreferredConnectionParameters_get_Balanced), nullptr, nullptr, nullptr },
        { "power_optimized", reinterpret_cast<getter>(BluetoothLEPreferredConnectionParameters_get_PowerOptimized), nullptr, nullptr, nullptr },
        { "throughput_optimized", reinterpret_cast<getter>(BluetoothLEPreferredConnectionParameters_get_ThroughputOptimized), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_BluetoothLEPreferredConnectionParameters_Static[] = {
        { }
    };

    static PyType_Slot type_slots_BluetoothLEPreferredConnectionParameters_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BluetoothLEPreferredConnectionParameters_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BluetoothLEPreferredConnectionParameters_Static) },
        { }
    };

    static PyType_Spec type_spec_BluetoothLEPreferredConnectionParameters_Static =
    {
        "winrt._winrt_windows_devices_bluetooth.BluetoothLEPreferredConnectionParameters_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BluetoothLEPreferredConnectionParameters_Static
    };

    // ----- BluetoothLEPreferredConnectionParametersRequest class --------------------

    static PyObject* _new_BluetoothLEPreferredConnectionParametersRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParametersRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParametersRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_BluetoothLEPreferredConnectionParametersRequest(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParametersRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BluetoothLEPreferredConnectionParametersRequest_Close(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParametersRequest* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothLEPreferredConnectionParametersRequest", L"Close", 0))
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEPreferredConnectionParametersRequest_get_Status(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParametersRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothLEPreferredConnectionParametersRequest", L"Status"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BluetoothLEPreferredConnectionParametersRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParametersRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BluetoothLEPreferredConnectionParametersRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParametersRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_BluetoothLEPreferredConnectionParametersRequest(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParametersRequest* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_BluetoothLEPreferredConnectionParametersRequest(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParametersRequest* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEPreferredConnectionParametersRequest[] = {
        { "close", reinterpret_cast<PyCFunction>(BluetoothLEPreferredConnectionParametersRequest_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BluetoothLEPreferredConnectionParametersRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BluetoothLEPreferredConnectionParametersRequest), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_BluetoothLEPreferredConnectionParametersRequest), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_BluetoothLEPreferredConnectionParametersRequest), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_BluetoothLEPreferredConnectionParametersRequest[] = {
        { "status", reinterpret_cast<getter>(BluetoothLEPreferredConnectionParametersRequest_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BluetoothLEPreferredConnectionParametersRequest[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BluetoothLEPreferredConnectionParametersRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BluetoothLEPreferredConnectionParametersRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BluetoothLEPreferredConnectionParametersRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BluetoothLEPreferredConnectionParametersRequest) },
        { },
    };

    static PyType_Spec type_spec_BluetoothLEPreferredConnectionParametersRequest = {
        "winrt._winrt_windows_devices_bluetooth.BluetoothLEPreferredConnectionParametersRequest",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParametersRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEPreferredConnectionParametersRequest};

    // ----- BluetoothSignalStrengthFilter class --------------------

    static PyObject* _new_BluetoothSignalStrengthFilter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BluetoothSignalStrengthFilter(py::wrapper::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BluetoothSignalStrengthFilter_get_SamplingInterval(py::wrapper::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothSignalStrengthFilter", L"SamplingInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SamplingInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothSignalStrengthFilter_put_SamplingInterval(py::wrapper::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothSignalStrengthFilter", L"SamplingInterval"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.SamplingInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothSignalStrengthFilter_get_OutOfRangeTimeout(py::wrapper::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothSignalStrengthFilter", L"OutOfRangeTimeout"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OutOfRangeTimeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothSignalStrengthFilter_put_OutOfRangeTimeout(py::wrapper::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothSignalStrengthFilter", L"OutOfRangeTimeout"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.OutOfRangeTimeout(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothSignalStrengthFilter_get_OutOfRangeThresholdInDBm(py::wrapper::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothSignalStrengthFilter", L"OutOfRangeThresholdInDBm"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.OutOfRangeThresholdInDBm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothSignalStrengthFilter_put_OutOfRangeThresholdInDBm(py::wrapper::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothSignalStrengthFilter", L"OutOfRangeThresholdInDBm"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int16_t>>(arg);

            self->obj.OutOfRangeThresholdInDBm(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothSignalStrengthFilter_get_InRangeThresholdInDBm(py::wrapper::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothSignalStrengthFilter", L"InRangeThresholdInDBm"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.InRangeThresholdInDBm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothSignalStrengthFilter_put_InRangeThresholdInDBm(py::wrapper::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Devices.Bluetooth.BluetoothSignalStrengthFilter", L"InRangeThresholdInDBm"))
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int16_t>>(arg);

            self->obj.InRangeThresholdInDBm(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_BluetoothSignalStrengthFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BluetoothSignalStrengthFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothSignalStrengthFilter[] = {
        { "_assign_array_", _assign_array_BluetoothSignalStrengthFilter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BluetoothSignalStrengthFilter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BluetoothSignalStrengthFilter[] = {
        { "sampling_interval", reinterpret_cast<getter>(BluetoothSignalStrengthFilter_get_SamplingInterval), reinterpret_cast<setter>(BluetoothSignalStrengthFilter_put_SamplingInterval), nullptr, nullptr },
        { "out_of_range_timeout", reinterpret_cast<getter>(BluetoothSignalStrengthFilter_get_OutOfRangeTimeout), reinterpret_cast<setter>(BluetoothSignalStrengthFilter_put_OutOfRangeTimeout), nullptr, nullptr },
        { "out_of_range_threshold_in_d_bm", reinterpret_cast<getter>(BluetoothSignalStrengthFilter_get_OutOfRangeThresholdInDBm), reinterpret_cast<setter>(BluetoothSignalStrengthFilter_put_OutOfRangeThresholdInDBm), nullptr, nullptr },
        { "in_range_threshold_in_d_bm", reinterpret_cast<getter>(BluetoothSignalStrengthFilter_get_InRangeThresholdInDBm), reinterpret_cast<setter>(BluetoothSignalStrengthFilter_put_InRangeThresholdInDBm), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BluetoothSignalStrengthFilter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BluetoothSignalStrengthFilter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BluetoothSignalStrengthFilter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BluetoothSignalStrengthFilter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BluetoothSignalStrengthFilter) },
        { },
    };

    static PyType_Spec type_spec_BluetoothSignalStrengthFilter = {
        "winrt._winrt_windows_devices_bluetooth.BluetoothSignalStrengthFilter",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothSignalStrengthFilter};

    // ----- BluetoothUuidHelper class --------------------

    static PyObject* _new_BluetoothUuidHelper(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Devices::Bluetooth::BluetoothUuidHelper>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Devices::Bluetooth::BluetoothUuidHelper>::type_name);
        return nullptr;
    }

    static PyObject* BluetoothUuidHelper_FromShortId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothUuidHelper", L"FromShortId", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothUuidHelper::FromShortId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothUuidHelper_TryGetShortId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Devices.Bluetooth.BluetoothUuidHelper", L"TryGetShortId", 1))
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothUuidHelper::TryGetShortId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothUuidHelper[] = {
        { }
    };

    static PyGetSetDef _getset_BluetoothUuidHelper[] = {
        { }
    };

    static PyType_Slot _type_slots_BluetoothUuidHelper[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_BluetoothUuidHelper) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BluetoothUuidHelper) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BluetoothUuidHelper) },
        { },
    };

    static PyType_Spec type_spec_BluetoothUuidHelper = {
        "winrt._winrt_windows_devices_bluetooth.BluetoothUuidHelper",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothUuidHelper};

    static PyGetSetDef getset_BluetoothUuidHelper_Static[] = {
        { }
    };

    static PyMethodDef methods_BluetoothUuidHelper_Static[] = {
        { "from_short_id", reinterpret_cast<PyCFunction>(BluetoothUuidHelper_FromShortId), METH_VARARGS, nullptr },
        { "try_get_short_id", reinterpret_cast<PyCFunction>(BluetoothUuidHelper_TryGetShortId), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_BluetoothUuidHelper_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BluetoothUuidHelper_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BluetoothUuidHelper_Static) },
        { }
    };

    static PyType_Spec type_spec_BluetoothUuidHelper_Static =
    {
        "winrt._winrt_windows_devices_bluetooth.BluetoothUuidHelper_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BluetoothUuidHelper_Static
    };

    // ----- Windows.Devices.Bluetooth Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Devices.Bluetooth");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_devices_bluetooth",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Devices::Bluetooth

PyMODINIT_FUNC PyInit__winrt_windows_devices_bluetooth(void) noexcept
{
    using namespace py::cpp::Windows::Devices::Bluetooth;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_BluetoothAdapter_Static{PyType_FromSpec(&type_spec_BluetoothAdapter_Static)};
    if (!type_BluetoothAdapter_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BluetoothAdapter, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BluetoothAdapter_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_BluetoothClassOfDevice_Static{PyType_FromSpec(&type_spec_BluetoothClassOfDevice_Static)};
    if (!type_BluetoothClassOfDevice_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BluetoothClassOfDevice, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BluetoothClassOfDevice_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_BluetoothDevice_Static{PyType_FromSpec(&type_spec_BluetoothDevice_Static)};
    if (!type_BluetoothDevice_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BluetoothDevice, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BluetoothDevice_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_BluetoothDeviceId_Static{PyType_FromSpec(&type_spec_BluetoothDeviceId_Static)};
    if (!type_BluetoothDeviceId_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BluetoothDeviceId, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BluetoothDeviceId_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_BluetoothLEAppearance_Static{PyType_FromSpec(&type_spec_BluetoothLEAppearance_Static)};
    if (!type_BluetoothLEAppearance_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BluetoothLEAppearance, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BluetoothLEAppearance_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_BluetoothLEAppearanceCategories_Static{PyType_FromSpec(&type_spec_BluetoothLEAppearanceCategories_Static)};
    if (!type_BluetoothLEAppearanceCategories_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BluetoothLEAppearanceCategories, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BluetoothLEAppearanceCategories_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_BluetoothLEAppearanceSubcategories_Static{PyType_FromSpec(&type_spec_BluetoothLEAppearanceSubcategories_Static)};
    if (!type_BluetoothLEAppearanceSubcategories_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BluetoothLEAppearanceSubcategories, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BluetoothLEAppearanceSubcategories_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BluetoothLEConnectionParameters, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BluetoothLEConnectionPhy, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BluetoothLEConnectionPhyInfo, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_BluetoothLEDevice_Static{PyType_FromSpec(&type_spec_BluetoothLEDevice_Static)};
    if (!type_BluetoothLEDevice_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BluetoothLEDevice, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BluetoothLEDevice_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_BluetoothLEPreferredConnectionParameters_Static{PyType_FromSpec(&type_spec_BluetoothLEPreferredConnectionParameters_Static)};
    if (!type_BluetoothLEPreferredConnectionParameters_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BluetoothLEPreferredConnectionParameters, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BluetoothLEPreferredConnectionParameters_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BluetoothLEPreferredConnectionParametersRequest, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BluetoothSignalStrengthFilter, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_BluetoothUuidHelper_Static{PyType_FromSpec(&type_spec_BluetoothUuidHelper_Static)};
    if (!type_BluetoothUuidHelper_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_BluetoothUuidHelper, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_BluetoothUuidHelper_Static.get())) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
