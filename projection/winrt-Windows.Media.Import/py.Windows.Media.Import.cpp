// WARNING: Please don't edit this file. It was generated by Python/WinRT v0.0.0

#include "py.Windows.Media.Import.h"

namespace py::cpp::Windows::Media::Import
{
    // ----- PhotoImportDeleteImportedItemsFromSourceResult class --------------------

    static PyObject* _new_PhotoImportDeleteImportedItemsFromSourceResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Import::PhotoImportDeleteImportedItemsFromSourceResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Import::PhotoImportDeleteImportedItemsFromSourceResult>::type_name);
        return nullptr;
    }

    static void _dealloc_PhotoImportDeleteImportedItemsFromSourceResult(py::wrapper::Windows::Media::Import::PhotoImportDeleteImportedItemsFromSourceResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhotoImportDeleteImportedItemsFromSourceResult_get_DeletedItems(py::wrapper::Windows::Media::Import::PhotoImportDeleteImportedItemsFromSourceResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult", L"DeletedItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeletedItems();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportDeleteImportedItemsFromSourceResult_get_HasSucceeded(py::wrapper::Windows::Media::Import::PhotoImportDeleteImportedItemsFromSourceResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult", L"HasSucceeded");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HasSucceeded();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportDeleteImportedItemsFromSourceResult_get_PhotosCount(py::wrapper::Windows::Media::Import::PhotoImportDeleteImportedItemsFromSourceResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult", L"PhotosCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PhotosCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportDeleteImportedItemsFromSourceResult_get_PhotosSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportDeleteImportedItemsFromSourceResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult", L"PhotosSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PhotosSizeInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportDeleteImportedItemsFromSourceResult_get_Session(py::wrapper::Windows::Media::Import::PhotoImportDeleteImportedItemsFromSourceResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult", L"Session");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Session();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportDeleteImportedItemsFromSourceResult_get_SiblingsCount(py::wrapper::Windows::Media::Import::PhotoImportDeleteImportedItemsFromSourceResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult", L"SiblingsCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SiblingsCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportDeleteImportedItemsFromSourceResult_get_SiblingsSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportDeleteImportedItemsFromSourceResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult", L"SiblingsSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SiblingsSizeInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportDeleteImportedItemsFromSourceResult_get_SidecarsCount(py::wrapper::Windows::Media::Import::PhotoImportDeleteImportedItemsFromSourceResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult", L"SidecarsCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SidecarsCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportDeleteImportedItemsFromSourceResult_get_SidecarsSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportDeleteImportedItemsFromSourceResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult", L"SidecarsSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SidecarsSizeInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportDeleteImportedItemsFromSourceResult_get_TotalCount(py::wrapper::Windows::Media::Import::PhotoImportDeleteImportedItemsFromSourceResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult", L"TotalCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TotalCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportDeleteImportedItemsFromSourceResult_get_TotalSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportDeleteImportedItemsFromSourceResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult", L"TotalSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TotalSizeInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportDeleteImportedItemsFromSourceResult_get_VideosCount(py::wrapper::Windows::Media::Import::PhotoImportDeleteImportedItemsFromSourceResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult", L"VideosCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VideosCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportDeleteImportedItemsFromSourceResult_get_VideosSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportDeleteImportedItemsFromSourceResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult", L"VideosSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VideosSizeInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhotoImportDeleteImportedItemsFromSourceResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Import::PhotoImportDeleteImportedItemsFromSourceResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhotoImportDeleteImportedItemsFromSourceResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Import::PhotoImportDeleteImportedItemsFromSourceResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhotoImportDeleteImportedItemsFromSourceResult[] = {
        { "_assign_array_", _assign_array_PhotoImportDeleteImportedItemsFromSourceResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhotoImportDeleteImportedItemsFromSourceResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PhotoImportDeleteImportedItemsFromSourceResult[] = {
        { "deleted_items", reinterpret_cast<getter>(PhotoImportDeleteImportedItemsFromSourceResult_get_DeletedItems), nullptr, nullptr, nullptr },
        { "has_succeeded", reinterpret_cast<getter>(PhotoImportDeleteImportedItemsFromSourceResult_get_HasSucceeded), nullptr, nullptr, nullptr },
        { "photos_count", reinterpret_cast<getter>(PhotoImportDeleteImportedItemsFromSourceResult_get_PhotosCount), nullptr, nullptr, nullptr },
        { "photos_size_in_bytes", reinterpret_cast<getter>(PhotoImportDeleteImportedItemsFromSourceResult_get_PhotosSizeInBytes), nullptr, nullptr, nullptr },
        { "session", reinterpret_cast<getter>(PhotoImportDeleteImportedItemsFromSourceResult_get_Session), nullptr, nullptr, nullptr },
        { "siblings_count", reinterpret_cast<getter>(PhotoImportDeleteImportedItemsFromSourceResult_get_SiblingsCount), nullptr, nullptr, nullptr },
        { "siblings_size_in_bytes", reinterpret_cast<getter>(PhotoImportDeleteImportedItemsFromSourceResult_get_SiblingsSizeInBytes), nullptr, nullptr, nullptr },
        { "sidecars_count", reinterpret_cast<getter>(PhotoImportDeleteImportedItemsFromSourceResult_get_SidecarsCount), nullptr, nullptr, nullptr },
        { "sidecars_size_in_bytes", reinterpret_cast<getter>(PhotoImportDeleteImportedItemsFromSourceResult_get_SidecarsSizeInBytes), nullptr, nullptr, nullptr },
        { "total_count", reinterpret_cast<getter>(PhotoImportDeleteImportedItemsFromSourceResult_get_TotalCount), nullptr, nullptr, nullptr },
        { "total_size_in_bytes", reinterpret_cast<getter>(PhotoImportDeleteImportedItemsFromSourceResult_get_TotalSizeInBytes), nullptr, nullptr, nullptr },
        { "videos_count", reinterpret_cast<getter>(PhotoImportDeleteImportedItemsFromSourceResult_get_VideosCount), nullptr, nullptr, nullptr },
        { "videos_size_in_bytes", reinterpret_cast<getter>(PhotoImportDeleteImportedItemsFromSourceResult_get_VideosSizeInBytes), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PhotoImportDeleteImportedItemsFromSourceResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhotoImportDeleteImportedItemsFromSourceResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhotoImportDeleteImportedItemsFromSourceResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhotoImportDeleteImportedItemsFromSourceResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhotoImportDeleteImportedItemsFromSourceResult) },
        { }};

    static PyType_Spec type_spec_PhotoImportDeleteImportedItemsFromSourceResult = {
        "winrt._winrt_windows_media_import_.PhotoImportDeleteImportedItemsFromSourceResult",
        sizeof(py::wrapper::Windows::Media::Import::PhotoImportDeleteImportedItemsFromSourceResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoImportDeleteImportedItemsFromSourceResult};

    // ----- PhotoImportFindItemsResult class --------------------

    static PyObject* _new_PhotoImportFindItemsResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Import::PhotoImportFindItemsResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Import::PhotoImportFindItemsResult>::type_name);
        return nullptr;
    }

    static void _dealloc_PhotoImportFindItemsResult(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhotoImportFindItemsResult_AddItemsInDateRangeToSelection(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"AddItemsInDateRangeToSelection", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.AddItemsInDateRangeToSelection(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_ImportItemsAsync(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"ImportItemsAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.ImportItemsAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_SelectAll(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SelectAll", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.SelectAll();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_SelectNewAsync(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SelectNewAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SelectNewAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_SelectNone(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SelectNone", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.SelectNone();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_SetImportMode(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SetImportMode", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Import::PhotoImportImportMode>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.SetImportMode(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_FoundItems(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"FoundItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.FoundItems();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_HasSucceeded(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"HasSucceeded");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HasSucceeded();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_ImportMode(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"ImportMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ImportMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_PhotosCount(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"PhotosCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PhotosCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_PhotosSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"PhotosSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PhotosSizeInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_SelectedPhotosCount(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SelectedPhotosCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SelectedPhotosCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_SelectedPhotosSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SelectedPhotosSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SelectedPhotosSizeInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_SelectedSiblingsCount(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SelectedSiblingsCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SelectedSiblingsCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_SelectedSiblingsSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SelectedSiblingsSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SelectedSiblingsSizeInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_SelectedSidecarsCount(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SelectedSidecarsCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SelectedSidecarsCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_SelectedSidecarsSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SelectedSidecarsSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SelectedSidecarsSizeInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_SelectedTotalCount(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SelectedTotalCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SelectedTotalCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_SelectedTotalSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SelectedTotalSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SelectedTotalSizeInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_SelectedVideosCount(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SelectedVideosCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SelectedVideosCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_SelectedVideosSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SelectedVideosSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SelectedVideosSizeInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_Session(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"Session");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Session();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_SiblingsCount(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SiblingsCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SiblingsCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_SiblingsSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SiblingsSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SiblingsSizeInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_SidecarsCount(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SidecarsCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SidecarsCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_SidecarsSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SidecarsSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SidecarsSizeInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_TotalCount(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"TotalCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TotalCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_TotalSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"TotalSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TotalSizeInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_VideosCount(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"VideosCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VideosCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_VideosSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"VideosSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VideosSizeInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_add_ItemImported(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"ItemImported");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Import::PhotoImportFindItemsResult, winrt::Windows::Media::Import::PhotoImportItemImportedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ItemImported(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_remove_ItemImported(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"ItemImported");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ItemImported(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_add_SelectionChanged(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SelectionChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Import::PhotoImportFindItemsResult, winrt::Windows::Media::Import::PhotoImportSelectionChangedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SelectionChanged(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_remove_SelectionChanged(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SelectionChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.SelectionChanged(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhotoImportFindItemsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Import::PhotoImportFindItemsResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhotoImportFindItemsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Import::PhotoImportFindItemsResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhotoImportFindItemsResult[] = {
        { "add_items_in_date_range_to_selection", reinterpret_cast<PyCFunction>(PhotoImportFindItemsResult_AddItemsInDateRangeToSelection), METH_VARARGS, nullptr },
        { "import_items_async", reinterpret_cast<PyCFunction>(PhotoImportFindItemsResult_ImportItemsAsync), METH_VARARGS, nullptr },
        { "select_all", reinterpret_cast<PyCFunction>(PhotoImportFindItemsResult_SelectAll), METH_VARARGS, nullptr },
        { "select_new_async", reinterpret_cast<PyCFunction>(PhotoImportFindItemsResult_SelectNewAsync), METH_VARARGS, nullptr },
        { "select_none", reinterpret_cast<PyCFunction>(PhotoImportFindItemsResult_SelectNone), METH_VARARGS, nullptr },
        { "set_import_mode", reinterpret_cast<PyCFunction>(PhotoImportFindItemsResult_SetImportMode), METH_VARARGS, nullptr },
        { "add_item_imported", reinterpret_cast<PyCFunction>(PhotoImportFindItemsResult_add_ItemImported), METH_O, nullptr },
        { "remove_item_imported", reinterpret_cast<PyCFunction>(PhotoImportFindItemsResult_remove_ItemImported), METH_O, nullptr },
        { "add_selection_changed", reinterpret_cast<PyCFunction>(PhotoImportFindItemsResult_add_SelectionChanged), METH_O, nullptr },
        { "remove_selection_changed", reinterpret_cast<PyCFunction>(PhotoImportFindItemsResult_remove_SelectionChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_PhotoImportFindItemsResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhotoImportFindItemsResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PhotoImportFindItemsResult[] = {
        { "found_items", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_FoundItems), nullptr, nullptr, nullptr },
        { "has_succeeded", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_HasSucceeded), nullptr, nullptr, nullptr },
        { "import_mode", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_ImportMode), nullptr, nullptr, nullptr },
        { "photos_count", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_PhotosCount), nullptr, nullptr, nullptr },
        { "photos_size_in_bytes", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_PhotosSizeInBytes), nullptr, nullptr, nullptr },
        { "selected_photos_count", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_SelectedPhotosCount), nullptr, nullptr, nullptr },
        { "selected_photos_size_in_bytes", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_SelectedPhotosSizeInBytes), nullptr, nullptr, nullptr },
        { "selected_siblings_count", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_SelectedSiblingsCount), nullptr, nullptr, nullptr },
        { "selected_siblings_size_in_bytes", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_SelectedSiblingsSizeInBytes), nullptr, nullptr, nullptr },
        { "selected_sidecars_count", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_SelectedSidecarsCount), nullptr, nullptr, nullptr },
        { "selected_sidecars_size_in_bytes", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_SelectedSidecarsSizeInBytes), nullptr, nullptr, nullptr },
        { "selected_total_count", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_SelectedTotalCount), nullptr, nullptr, nullptr },
        { "selected_total_size_in_bytes", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_SelectedTotalSizeInBytes), nullptr, nullptr, nullptr },
        { "selected_videos_count", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_SelectedVideosCount), nullptr, nullptr, nullptr },
        { "selected_videos_size_in_bytes", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_SelectedVideosSizeInBytes), nullptr, nullptr, nullptr },
        { "session", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_Session), nullptr, nullptr, nullptr },
        { "siblings_count", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_SiblingsCount), nullptr, nullptr, nullptr },
        { "siblings_size_in_bytes", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_SiblingsSizeInBytes), nullptr, nullptr, nullptr },
        { "sidecars_count", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_SidecarsCount), nullptr, nullptr, nullptr },
        { "sidecars_size_in_bytes", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_SidecarsSizeInBytes), nullptr, nullptr, nullptr },
        { "total_count", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_TotalCount), nullptr, nullptr, nullptr },
        { "total_size_in_bytes", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_TotalSizeInBytes), nullptr, nullptr, nullptr },
        { "videos_count", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_VideosCount), nullptr, nullptr, nullptr },
        { "videos_size_in_bytes", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_VideosSizeInBytes), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PhotoImportFindItemsResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhotoImportFindItemsResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhotoImportFindItemsResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhotoImportFindItemsResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhotoImportFindItemsResult) },
        { }};

    static PyType_Spec type_spec_PhotoImportFindItemsResult = {
        "winrt._winrt_windows_media_import_.PhotoImportFindItemsResult",
        sizeof(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoImportFindItemsResult};

    // ----- PhotoImportImportItemsResult class --------------------

    static PyObject* _new_PhotoImportImportItemsResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Import::PhotoImportImportItemsResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Import::PhotoImportImportItemsResult>::type_name);
        return nullptr;
    }

    static void _dealloc_PhotoImportImportItemsResult(py::wrapper::Windows::Media::Import::PhotoImportImportItemsResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhotoImportImportItemsResult_DeleteImportedItemsFromSourceAsync(py::wrapper::Windows::Media::Import::PhotoImportImportItemsResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Import.PhotoImportImportItemsResult", L"DeleteImportedItemsFromSourceAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.DeleteImportedItemsFromSourceAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhotoImportImportItemsResult_get_HasSucceeded(py::wrapper::Windows::Media::Import::PhotoImportImportItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportImportItemsResult", L"HasSucceeded");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.HasSucceeded();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportImportItemsResult_get_ImportedItems(py::wrapper::Windows::Media::Import::PhotoImportImportItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportImportItemsResult", L"ImportedItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ImportedItems();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportImportItemsResult_get_PhotosCount(py::wrapper::Windows::Media::Import::PhotoImportImportItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportImportItemsResult", L"PhotosCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PhotosCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportImportItemsResult_get_PhotosSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportImportItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportImportItemsResult", L"PhotosSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PhotosSizeInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportImportItemsResult_get_Session(py::wrapper::Windows::Media::Import::PhotoImportImportItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportImportItemsResult", L"Session");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Session();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportImportItemsResult_get_SiblingsCount(py::wrapper::Windows::Media::Import::PhotoImportImportItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportImportItemsResult", L"SiblingsCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SiblingsCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportImportItemsResult_get_SiblingsSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportImportItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportImportItemsResult", L"SiblingsSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SiblingsSizeInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportImportItemsResult_get_SidecarsCount(py::wrapper::Windows::Media::Import::PhotoImportImportItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportImportItemsResult", L"SidecarsCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SidecarsCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportImportItemsResult_get_SidecarsSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportImportItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportImportItemsResult", L"SidecarsSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SidecarsSizeInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportImportItemsResult_get_TotalCount(py::wrapper::Windows::Media::Import::PhotoImportImportItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportImportItemsResult", L"TotalCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TotalCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportImportItemsResult_get_TotalSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportImportItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportImportItemsResult", L"TotalSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.TotalSizeInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportImportItemsResult_get_VideosCount(py::wrapper::Windows::Media::Import::PhotoImportImportItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportImportItemsResult", L"VideosCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VideosCount();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportImportItemsResult_get_VideosSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportImportItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportImportItemsResult", L"VideosSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VideosSizeInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhotoImportImportItemsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Import::PhotoImportImportItemsResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhotoImportImportItemsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Import::PhotoImportImportItemsResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhotoImportImportItemsResult[] = {
        { "delete_imported_items_from_source_async", reinterpret_cast<PyCFunction>(PhotoImportImportItemsResult_DeleteImportedItemsFromSourceAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PhotoImportImportItemsResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhotoImportImportItemsResult), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PhotoImportImportItemsResult[] = {
        { "has_succeeded", reinterpret_cast<getter>(PhotoImportImportItemsResult_get_HasSucceeded), nullptr, nullptr, nullptr },
        { "imported_items", reinterpret_cast<getter>(PhotoImportImportItemsResult_get_ImportedItems), nullptr, nullptr, nullptr },
        { "photos_count", reinterpret_cast<getter>(PhotoImportImportItemsResult_get_PhotosCount), nullptr, nullptr, nullptr },
        { "photos_size_in_bytes", reinterpret_cast<getter>(PhotoImportImportItemsResult_get_PhotosSizeInBytes), nullptr, nullptr, nullptr },
        { "session", reinterpret_cast<getter>(PhotoImportImportItemsResult_get_Session), nullptr, nullptr, nullptr },
        { "siblings_count", reinterpret_cast<getter>(PhotoImportImportItemsResult_get_SiblingsCount), nullptr, nullptr, nullptr },
        { "siblings_size_in_bytes", reinterpret_cast<getter>(PhotoImportImportItemsResult_get_SiblingsSizeInBytes), nullptr, nullptr, nullptr },
        { "sidecars_count", reinterpret_cast<getter>(PhotoImportImportItemsResult_get_SidecarsCount), nullptr, nullptr, nullptr },
        { "sidecars_size_in_bytes", reinterpret_cast<getter>(PhotoImportImportItemsResult_get_SidecarsSizeInBytes), nullptr, nullptr, nullptr },
        { "total_count", reinterpret_cast<getter>(PhotoImportImportItemsResult_get_TotalCount), nullptr, nullptr, nullptr },
        { "total_size_in_bytes", reinterpret_cast<getter>(PhotoImportImportItemsResult_get_TotalSizeInBytes), nullptr, nullptr, nullptr },
        { "videos_count", reinterpret_cast<getter>(PhotoImportImportItemsResult_get_VideosCount), nullptr, nullptr, nullptr },
        { "videos_size_in_bytes", reinterpret_cast<getter>(PhotoImportImportItemsResult_get_VideosSizeInBytes), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PhotoImportImportItemsResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhotoImportImportItemsResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhotoImportImportItemsResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhotoImportImportItemsResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhotoImportImportItemsResult) },
        { }};

    static PyType_Spec type_spec_PhotoImportImportItemsResult = {
        "winrt._winrt_windows_media_import_.PhotoImportImportItemsResult",
        sizeof(py::wrapper::Windows::Media::Import::PhotoImportImportItemsResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoImportImportItemsResult};

    // ----- PhotoImportItem class --------------------

    static PyObject* _new_PhotoImportItem(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Import::PhotoImportItem>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Import::PhotoImportItem>::type_name);
        return nullptr;
    }

    static void _dealloc_PhotoImportItem(py::wrapper::Windows::Media::Import::PhotoImportItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhotoImportItem_get_IsSelected(py::wrapper::Windows::Media::Import::PhotoImportItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportItem", L"IsSelected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsSelected();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhotoImportItem_put_IsSelected(py::wrapper::Windows::Media::Import::PhotoImportItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportItem", L"IsSelected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsSelected(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhotoImportItem_get_ContentType(py::wrapper::Windows::Media::Import::PhotoImportItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportItem", L"ContentType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContentType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportItem_get_Date(py::wrapper::Windows::Media::Import::PhotoImportItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportItem", L"Date");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Date();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportItem_get_DeletedFileNames(py::wrapper::Windows::Media::Import::PhotoImportItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportItem", L"DeletedFileNames");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DeletedFileNames();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportItem_get_ImportedFileNames(py::wrapper::Windows::Media::Import::PhotoImportItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportItem", L"ImportedFileNames");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ImportedFileNames();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportItem_get_ItemKey(py::wrapper::Windows::Media::Import::PhotoImportItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportItem", L"ItemKey");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ItemKey();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportItem_get_Name(py::wrapper::Windows::Media::Import::PhotoImportItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportItem", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Name();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportItem_get_Sibling(py::wrapper::Windows::Media::Import::PhotoImportItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportItem", L"Sibling");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Sibling();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportItem_get_Sidecars(py::wrapper::Windows::Media::Import::PhotoImportItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportItem", L"Sidecars");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Sidecars();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportItem_get_SizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportItem", L"SizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SizeInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportItem_get_Thumbnail(py::wrapper::Windows::Media::Import::PhotoImportItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportItem", L"Thumbnail");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Thumbnail();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportItem_get_VideoSegments(py::wrapper::Windows::Media::Import::PhotoImportItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportItem", L"VideoSegments");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VideoSegments();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportItem_get_Path(py::wrapper::Windows::Media::Import::PhotoImportItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportItem", L"Path");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Path();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhotoImportItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Import::PhotoImportItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhotoImportItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Import::PhotoImportItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhotoImportItem[] = {
        { "_assign_array_", _assign_array_PhotoImportItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhotoImportItem), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PhotoImportItem[] = {
        { "is_selected", reinterpret_cast<getter>(PhotoImportItem_get_IsSelected), reinterpret_cast<setter>(PhotoImportItem_put_IsSelected), nullptr, nullptr },
        { "content_type", reinterpret_cast<getter>(PhotoImportItem_get_ContentType), nullptr, nullptr, nullptr },
        { "date", reinterpret_cast<getter>(PhotoImportItem_get_Date), nullptr, nullptr, nullptr },
        { "deleted_file_names", reinterpret_cast<getter>(PhotoImportItem_get_DeletedFileNames), nullptr, nullptr, nullptr },
        { "imported_file_names", reinterpret_cast<getter>(PhotoImportItem_get_ImportedFileNames), nullptr, nullptr, nullptr },
        { "item_key", reinterpret_cast<getter>(PhotoImportItem_get_ItemKey), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(PhotoImportItem_get_Name), nullptr, nullptr, nullptr },
        { "sibling", reinterpret_cast<getter>(PhotoImportItem_get_Sibling), nullptr, nullptr, nullptr },
        { "sidecars", reinterpret_cast<getter>(PhotoImportItem_get_Sidecars), nullptr, nullptr, nullptr },
        { "size_in_bytes", reinterpret_cast<getter>(PhotoImportItem_get_SizeInBytes), nullptr, nullptr, nullptr },
        { "thumbnail", reinterpret_cast<getter>(PhotoImportItem_get_Thumbnail), nullptr, nullptr, nullptr },
        { "video_segments", reinterpret_cast<getter>(PhotoImportItem_get_VideoSegments), nullptr, nullptr, nullptr },
        { "path", reinterpret_cast<getter>(PhotoImportItem_get_Path), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PhotoImportItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhotoImportItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhotoImportItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhotoImportItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhotoImportItem) },
        { }};

    static PyType_Spec type_spec_PhotoImportItem = {
        "winrt._winrt_windows_media_import_.PhotoImportItem",
        sizeof(py::wrapper::Windows::Media::Import::PhotoImportItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoImportItem};

    // ----- PhotoImportItemImportedEventArgs class --------------------

    static PyObject* _new_PhotoImportItemImportedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Import::PhotoImportItemImportedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Import::PhotoImportItemImportedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PhotoImportItemImportedEventArgs(py::wrapper::Windows::Media::Import::PhotoImportItemImportedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhotoImportItemImportedEventArgs_get_ImportedItem(py::wrapper::Windows::Media::Import::PhotoImportItemImportedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportItemImportedEventArgs", L"ImportedItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ImportedItem();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhotoImportItemImportedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Import::PhotoImportItemImportedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhotoImportItemImportedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Import::PhotoImportItemImportedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhotoImportItemImportedEventArgs[] = {
        { "_assign_array_", _assign_array_PhotoImportItemImportedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhotoImportItemImportedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PhotoImportItemImportedEventArgs[] = {
        { "imported_item", reinterpret_cast<getter>(PhotoImportItemImportedEventArgs_get_ImportedItem), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PhotoImportItemImportedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhotoImportItemImportedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhotoImportItemImportedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhotoImportItemImportedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhotoImportItemImportedEventArgs) },
        { }};

    static PyType_Spec type_spec_PhotoImportItemImportedEventArgs = {
        "winrt._winrt_windows_media_import_.PhotoImportItemImportedEventArgs",
        sizeof(py::wrapper::Windows::Media::Import::PhotoImportItemImportedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoImportItemImportedEventArgs};

    // ----- PhotoImportManager class --------------------

    static PyObject* _new_PhotoImportManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Import::PhotoImportManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Import::PhotoImportManager>::type_name);
        return nullptr;
    }

    static PyObject* PhotoImportManager_FindAllSourcesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Import.PhotoImportManager", L"FindAllSourcesAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Media::Import::PhotoImportManager::FindAllSourcesAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhotoImportManager_GetPendingOperations(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Import.PhotoImportManager", L"GetPendingOperations", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Media::Import::PhotoImportManager::GetPendingOperations();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhotoImportManager_IsSupportedAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Import.PhotoImportManager", L"IsSupportedAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Media::Import::PhotoImportManager::IsSupportedAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhotoImportManager[] = {
        { }};

    static PyGetSetDef _getset_PhotoImportManager[] = {
        { }};

    static PyType_Slot _type_slots_PhotoImportManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhotoImportManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhotoImportManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhotoImportManager) },
        { }};

    static PyType_Spec type_spec_PhotoImportManager = {
        "winrt._winrt_windows_media_import_.PhotoImportManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoImportManager};

    static PyGetSetDef getset_PhotoImportManager_Static[] = {
        { }};

    static PyMethodDef methods_PhotoImportManager_Static[] = {
        { "find_all_sources_async", reinterpret_cast<PyCFunction>(PhotoImportManager_FindAllSourcesAsync), METH_VARARGS, nullptr },
        { "get_pending_operations", reinterpret_cast<PyCFunction>(PhotoImportManager_GetPendingOperations), METH_VARARGS, nullptr },
        { "is_supported_async", reinterpret_cast<PyCFunction>(PhotoImportManager_IsSupportedAsync), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_PhotoImportManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PhotoImportManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PhotoImportManager_Static) },
        { }
    };

    static PyType_Spec type_spec_PhotoImportManager_Static = {
        "winrt._winrt_windows_media_import_.PhotoImportManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PhotoImportManager_Static};

    // ----- PhotoImportOperation class --------------------

    static PyObject* _new_PhotoImportOperation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Import::PhotoImportOperation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Import::PhotoImportOperation>::type_name);
        return nullptr;
    }

    static void _dealloc_PhotoImportOperation(py::wrapper::Windows::Media::Import::PhotoImportOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhotoImportOperation_get_ContinueDeletingImportedItemsFromSourceAsync(py::wrapper::Windows::Media::Import::PhotoImportOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportOperation", L"ContinueDeletingImportedItemsFromSourceAsync");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContinueDeletingImportedItemsFromSourceAsync();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportOperation_get_ContinueFindingItemsAsync(py::wrapper::Windows::Media::Import::PhotoImportOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportOperation", L"ContinueFindingItemsAsync");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContinueFindingItemsAsync();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportOperation_get_ContinueImportingItemsAsync(py::wrapper::Windows::Media::Import::PhotoImportOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportOperation", L"ContinueImportingItemsAsync");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContinueImportingItemsAsync();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportOperation_get_Session(py::wrapper::Windows::Media::Import::PhotoImportOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportOperation", L"Session");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Session();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportOperation_get_Stage(py::wrapper::Windows::Media::Import::PhotoImportOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportOperation", L"Stage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Stage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhotoImportOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Import::PhotoImportOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhotoImportOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Import::PhotoImportOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhotoImportOperation[] = {
        { "_assign_array_", _assign_array_PhotoImportOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhotoImportOperation), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PhotoImportOperation[] = {
        { "continue_deleting_imported_items_from_source_async", reinterpret_cast<getter>(PhotoImportOperation_get_ContinueDeletingImportedItemsFromSourceAsync), nullptr, nullptr, nullptr },
        { "continue_finding_items_async", reinterpret_cast<getter>(PhotoImportOperation_get_ContinueFindingItemsAsync), nullptr, nullptr, nullptr },
        { "continue_importing_items_async", reinterpret_cast<getter>(PhotoImportOperation_get_ContinueImportingItemsAsync), nullptr, nullptr, nullptr },
        { "session", reinterpret_cast<getter>(PhotoImportOperation_get_Session), nullptr, nullptr, nullptr },
        { "stage", reinterpret_cast<getter>(PhotoImportOperation_get_Stage), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PhotoImportOperation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhotoImportOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhotoImportOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhotoImportOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhotoImportOperation) },
        { }};

    static PyType_Spec type_spec_PhotoImportOperation = {
        "winrt._winrt_windows_media_import_.PhotoImportOperation",
        sizeof(py::wrapper::Windows::Media::Import::PhotoImportOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoImportOperation};

    // ----- PhotoImportSelectionChangedEventArgs class --------------------

    static PyObject* _new_PhotoImportSelectionChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Import::PhotoImportSelectionChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Import::PhotoImportSelectionChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PhotoImportSelectionChangedEventArgs(py::wrapper::Windows::Media::Import::PhotoImportSelectionChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhotoImportSelectionChangedEventArgs_get_IsSelectionEmpty(py::wrapper::Windows::Media::Import::PhotoImportSelectionChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSelectionChangedEventArgs", L"IsSelectionEmpty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsSelectionEmpty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhotoImportSelectionChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Import::PhotoImportSelectionChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhotoImportSelectionChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Import::PhotoImportSelectionChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhotoImportSelectionChangedEventArgs[] = {
        { "_assign_array_", _assign_array_PhotoImportSelectionChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhotoImportSelectionChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PhotoImportSelectionChangedEventArgs[] = {
        { "is_selection_empty", reinterpret_cast<getter>(PhotoImportSelectionChangedEventArgs_get_IsSelectionEmpty), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PhotoImportSelectionChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhotoImportSelectionChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhotoImportSelectionChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhotoImportSelectionChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhotoImportSelectionChangedEventArgs) },
        { }};

    static PyType_Spec type_spec_PhotoImportSelectionChangedEventArgs = {
        "winrt._winrt_windows_media_import_.PhotoImportSelectionChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Import::PhotoImportSelectionChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoImportSelectionChangedEventArgs};

    // ----- PhotoImportSession class --------------------

    static PyObject* _new_PhotoImportSession(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Import::PhotoImportSession>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Import::PhotoImportSession>::type_name);
        return nullptr;
    }

    static void _dealloc_PhotoImportSession(py::wrapper::Windows::Media::Import::PhotoImportSession* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhotoImportSession_Close(py::wrapper::Windows::Media::Import::PhotoImportSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Import.PhotoImportSession", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhotoImportSession_FindItemsAsync(py::wrapper::Windows::Media::Import::PhotoImportSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Import.PhotoImportSession", L"FindItemsAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Import::PhotoImportContentTypeFilter>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Import::PhotoImportItemSelectionMode>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.FindItemsAsync(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhotoImportSession_get_SubfolderCreationMode(py::wrapper::Windows::Media::Import::PhotoImportSession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSession", L"SubfolderCreationMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SubfolderCreationMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhotoImportSession_put_SubfolderCreationMode(py::wrapper::Windows::Media::Import::PhotoImportSession* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSession", L"SubfolderCreationMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Import::PhotoImportSubfolderCreationMode>(arg);

            {
                auto _gil = release_gil();
                self->obj.SubfolderCreationMode(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhotoImportSession_get_DestinationFolder(py::wrapper::Windows::Media::Import::PhotoImportSession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSession", L"DestinationFolder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DestinationFolder();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhotoImportSession_put_DestinationFolder(py::wrapper::Windows::Media::Import::PhotoImportSession* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSession", L"DestinationFolder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(arg);

            {
                auto _gil = release_gil();
                self->obj.DestinationFolder(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhotoImportSession_get_DestinationFileNamePrefix(py::wrapper::Windows::Media::Import::PhotoImportSession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSession", L"DestinationFileNamePrefix");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DestinationFileNamePrefix();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhotoImportSession_put_DestinationFileNamePrefix(py::wrapper::Windows::Media::Import::PhotoImportSession* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSession", L"DestinationFileNamePrefix");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.DestinationFileNamePrefix(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhotoImportSession_get_AppendSessionDateToDestinationFolder(py::wrapper::Windows::Media::Import::PhotoImportSession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSession", L"AppendSessionDateToDestinationFolder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AppendSessionDateToDestinationFolder();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhotoImportSession_put_AppendSessionDateToDestinationFolder(py::wrapper::Windows::Media::Import::PhotoImportSession* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSession", L"AppendSessionDateToDestinationFolder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.AppendSessionDateToDestinationFolder(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhotoImportSession_get_SessionId(py::wrapper::Windows::Media::Import::PhotoImportSession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSession", L"SessionId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SessionId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportSession_get_Source(py::wrapper::Windows::Media::Import::PhotoImportSession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSession", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Source();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportSession_get_SubfolderDateFormat(py::wrapper::Windows::Media::Import::PhotoImportSession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSession", L"SubfolderDateFormat");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SubfolderDateFormat();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhotoImportSession_put_SubfolderDateFormat(py::wrapper::Windows::Media::Import::PhotoImportSession* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSession", L"SubfolderDateFormat");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Import::PhotoImportSubfolderDateFormat>(arg);

            {
                auto _gil = release_gil();
                self->obj.SubfolderDateFormat(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhotoImportSession_get_RememberDeselectedItems(py::wrapper::Windows::Media::Import::PhotoImportSession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSession", L"RememberDeselectedItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.RememberDeselectedItems();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhotoImportSession_put_RememberDeselectedItems(py::wrapper::Windows::Media::Import::PhotoImportSession* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSession", L"RememberDeselectedItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.RememberDeselectedItems(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PhotoImportSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Import::PhotoImportSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhotoImportSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Import::PhotoImportSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_PhotoImportSession(py::wrapper::Windows::Media::Import::PhotoImportSession* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_PhotoImportSession(py::wrapper::Windows::Media::Import::PhotoImportSession* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhotoImportSession[] = {
        { "close", reinterpret_cast<PyCFunction>(PhotoImportSession_Close), METH_VARARGS, nullptr },
        { "find_items_async", reinterpret_cast<PyCFunction>(PhotoImportSession_FindItemsAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PhotoImportSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhotoImportSession), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_PhotoImportSession), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_PhotoImportSession), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_PhotoImportSession[] = {
        { "subfolder_creation_mode", reinterpret_cast<getter>(PhotoImportSession_get_SubfolderCreationMode), reinterpret_cast<setter>(PhotoImportSession_put_SubfolderCreationMode), nullptr, nullptr },
        { "destination_folder", reinterpret_cast<getter>(PhotoImportSession_get_DestinationFolder), reinterpret_cast<setter>(PhotoImportSession_put_DestinationFolder), nullptr, nullptr },
        { "destination_file_name_prefix", reinterpret_cast<getter>(PhotoImportSession_get_DestinationFileNamePrefix), reinterpret_cast<setter>(PhotoImportSession_put_DestinationFileNamePrefix), nullptr, nullptr },
        { "append_session_date_to_destination_folder", reinterpret_cast<getter>(PhotoImportSession_get_AppendSessionDateToDestinationFolder), reinterpret_cast<setter>(PhotoImportSession_put_AppendSessionDateToDestinationFolder), nullptr, nullptr },
        { "session_id", reinterpret_cast<getter>(PhotoImportSession_get_SessionId), nullptr, nullptr, nullptr },
        { "source", reinterpret_cast<getter>(PhotoImportSession_get_Source), nullptr, nullptr, nullptr },
        { "subfolder_date_format", reinterpret_cast<getter>(PhotoImportSession_get_SubfolderDateFormat), reinterpret_cast<setter>(PhotoImportSession_put_SubfolderDateFormat), nullptr, nullptr },
        { "remember_deselected_items", reinterpret_cast<getter>(PhotoImportSession_get_RememberDeselectedItems), reinterpret_cast<setter>(PhotoImportSession_put_RememberDeselectedItems), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PhotoImportSession[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhotoImportSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhotoImportSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhotoImportSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhotoImportSession) },
        { }};

    static PyType_Spec type_spec_PhotoImportSession = {
        "winrt._winrt_windows_media_import_.PhotoImportSession",
        sizeof(py::wrapper::Windows::Media::Import::PhotoImportSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoImportSession};

    // ----- PhotoImportSidecar class --------------------

    static PyObject* _new_PhotoImportSidecar(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Import::PhotoImportSidecar>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Import::PhotoImportSidecar>::type_name);
        return nullptr;
    }

    static void _dealloc_PhotoImportSidecar(py::wrapper::Windows::Media::Import::PhotoImportSidecar* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhotoImportSidecar_get_Date(py::wrapper::Windows::Media::Import::PhotoImportSidecar* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSidecar", L"Date");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Date();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportSidecar_get_Name(py::wrapper::Windows::Media::Import::PhotoImportSidecar* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSidecar", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Name();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportSidecar_get_SizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportSidecar* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSidecar", L"SizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SizeInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhotoImportSidecar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Import::PhotoImportSidecar>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhotoImportSidecar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Import::PhotoImportSidecar>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhotoImportSidecar[] = {
        { "_assign_array_", _assign_array_PhotoImportSidecar, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhotoImportSidecar), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PhotoImportSidecar[] = {
        { "date", reinterpret_cast<getter>(PhotoImportSidecar_get_Date), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(PhotoImportSidecar_get_Name), nullptr, nullptr, nullptr },
        { "size_in_bytes", reinterpret_cast<getter>(PhotoImportSidecar_get_SizeInBytes), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PhotoImportSidecar[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhotoImportSidecar) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhotoImportSidecar) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhotoImportSidecar) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhotoImportSidecar) },
        { }};

    static PyType_Spec type_spec_PhotoImportSidecar = {
        "winrt._winrt_windows_media_import_.PhotoImportSidecar",
        sizeof(py::wrapper::Windows::Media::Import::PhotoImportSidecar),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoImportSidecar};

    // ----- PhotoImportSource class --------------------

    static PyObject* _new_PhotoImportSource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Import::PhotoImportSource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Import::PhotoImportSource>::type_name);
        return nullptr;
    }

    static void _dealloc_PhotoImportSource(py::wrapper::Windows::Media::Import::PhotoImportSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhotoImportSource_CreateImportSession(py::wrapper::Windows::Media::Import::PhotoImportSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Import.PhotoImportSource", L"CreateImportSession", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.CreateImportSession();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhotoImportSource_FromFolderAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Import.PhotoImportSource", L"FromFolderAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Media::Import::PhotoImportSource::FromFolderAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhotoImportSource_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Import.PhotoImportSource", L"FromIdAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Windows::Media::Import::PhotoImportSource::FromIdAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhotoImportSource_get_BatteryLevelPercent(py::wrapper::Windows::Media::Import::PhotoImportSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSource", L"BatteryLevelPercent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.BatteryLevelPercent();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportSource_get_ConnectionProtocol(py::wrapper::Windows::Media::Import::PhotoImportSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSource", L"ConnectionProtocol");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ConnectionProtocol();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportSource_get_ConnectionTransport(py::wrapper::Windows::Media::Import::PhotoImportSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSource", L"ConnectionTransport");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ConnectionTransport();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportSource_get_DateTime(py::wrapper::Windows::Media::Import::PhotoImportSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSource", L"DateTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DateTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportSource_get_Description(py::wrapper::Windows::Media::Import::PhotoImportSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSource", L"Description");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Description();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportSource_get_DisplayName(py::wrapper::Windows::Media::Import::PhotoImportSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSource", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DisplayName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportSource_get_Id(py::wrapper::Windows::Media::Import::PhotoImportSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSource", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportSource_get_IsLocked(py::wrapper::Windows::Media::Import::PhotoImportSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSource", L"IsLocked");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsLocked();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportSource_get_IsMassStorage(py::wrapper::Windows::Media::Import::PhotoImportSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSource", L"IsMassStorage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsMassStorage();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportSource_get_Manufacturer(py::wrapper::Windows::Media::Import::PhotoImportSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSource", L"Manufacturer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Manufacturer();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportSource_get_Model(py::wrapper::Windows::Media::Import::PhotoImportSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSource", L"Model");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Model();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportSource_get_PowerSource(py::wrapper::Windows::Media::Import::PhotoImportSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSource", L"PowerSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PowerSource();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportSource_get_SerialNumber(py::wrapper::Windows::Media::Import::PhotoImportSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSource", L"SerialNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SerialNumber();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportSource_get_StorageMedia(py::wrapper::Windows::Media::Import::PhotoImportSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSource", L"StorageMedia");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.StorageMedia();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportSource_get_Thumbnail(py::wrapper::Windows::Media::Import::PhotoImportSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSource", L"Thumbnail");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Thumbnail();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportSource_get_Type(py::wrapper::Windows::Media::Import::PhotoImportSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSource", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Type();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhotoImportSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Import::PhotoImportSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhotoImportSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Import::PhotoImportSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhotoImportSource[] = {
        { "create_import_session", reinterpret_cast<PyCFunction>(PhotoImportSource_CreateImportSession), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PhotoImportSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhotoImportSource), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PhotoImportSource[] = {
        { "battery_level_percent", reinterpret_cast<getter>(PhotoImportSource_get_BatteryLevelPercent), nullptr, nullptr, nullptr },
        { "connection_protocol", reinterpret_cast<getter>(PhotoImportSource_get_ConnectionProtocol), nullptr, nullptr, nullptr },
        { "connection_transport", reinterpret_cast<getter>(PhotoImportSource_get_ConnectionTransport), nullptr, nullptr, nullptr },
        { "date_time", reinterpret_cast<getter>(PhotoImportSource_get_DateTime), nullptr, nullptr, nullptr },
        { "description", reinterpret_cast<getter>(PhotoImportSource_get_Description), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(PhotoImportSource_get_DisplayName), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(PhotoImportSource_get_Id), nullptr, nullptr, nullptr },
        { "is_locked", reinterpret_cast<getter>(PhotoImportSource_get_IsLocked), nullptr, nullptr, nullptr },
        { "is_mass_storage", reinterpret_cast<getter>(PhotoImportSource_get_IsMassStorage), nullptr, nullptr, nullptr },
        { "manufacturer", reinterpret_cast<getter>(PhotoImportSource_get_Manufacturer), nullptr, nullptr, nullptr },
        { "model", reinterpret_cast<getter>(PhotoImportSource_get_Model), nullptr, nullptr, nullptr },
        { "power_source", reinterpret_cast<getter>(PhotoImportSource_get_PowerSource), nullptr, nullptr, nullptr },
        { "serial_number", reinterpret_cast<getter>(PhotoImportSource_get_SerialNumber), nullptr, nullptr, nullptr },
        { "storage_media", reinterpret_cast<getter>(PhotoImportSource_get_StorageMedia), nullptr, nullptr, nullptr },
        { "thumbnail", reinterpret_cast<getter>(PhotoImportSource_get_Thumbnail), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(PhotoImportSource_get_Type), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PhotoImportSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhotoImportSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhotoImportSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhotoImportSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhotoImportSource) },
        { }};

    static PyType_Spec type_spec_PhotoImportSource = {
        "winrt._winrt_windows_media_import_.PhotoImportSource",
        sizeof(py::wrapper::Windows::Media::Import::PhotoImportSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoImportSource};

    static PyGetSetDef getset_PhotoImportSource_Static[] = {
        { }};

    static PyMethodDef methods_PhotoImportSource_Static[] = {
        { "from_folder_async", reinterpret_cast<PyCFunction>(PhotoImportSource_FromFolderAsync), METH_VARARGS, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(PhotoImportSource_FromIdAsync), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_PhotoImportSource_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PhotoImportSource_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PhotoImportSource_Static) },
        { }
    };

    static PyType_Spec type_spec_PhotoImportSource_Static = {
        "winrt._winrt_windows_media_import_.PhotoImportSource_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PhotoImportSource_Static};

    // ----- PhotoImportStorageMedium class --------------------

    static PyObject* _new_PhotoImportStorageMedium(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Import::PhotoImportStorageMedium>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Import::PhotoImportStorageMedium>::type_name);
        return nullptr;
    }

    static void _dealloc_PhotoImportStorageMedium(py::wrapper::Windows::Media::Import::PhotoImportStorageMedium* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhotoImportStorageMedium_Refresh(py::wrapper::Windows::Media::Import::PhotoImportStorageMedium* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Import.PhotoImportStorageMedium", L"Refresh", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Refresh();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhotoImportStorageMedium_get_AvailableSpaceInBytes(py::wrapper::Windows::Media::Import::PhotoImportStorageMedium* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportStorageMedium", L"AvailableSpaceInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AvailableSpaceInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportStorageMedium_get_CapacityInBytes(py::wrapper::Windows::Media::Import::PhotoImportStorageMedium* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportStorageMedium", L"CapacityInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CapacityInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportStorageMedium_get_Description(py::wrapper::Windows::Media::Import::PhotoImportStorageMedium* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportStorageMedium", L"Description");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Description();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportStorageMedium_get_Name(py::wrapper::Windows::Media::Import::PhotoImportStorageMedium* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportStorageMedium", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Name();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportStorageMedium_get_SerialNumber(py::wrapper::Windows::Media::Import::PhotoImportStorageMedium* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportStorageMedium", L"SerialNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SerialNumber();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportStorageMedium_get_StorageMediumType(py::wrapper::Windows::Media::Import::PhotoImportStorageMedium* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportStorageMedium", L"StorageMediumType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.StorageMediumType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportStorageMedium_get_SupportedAccessMode(py::wrapper::Windows::Media::Import::PhotoImportStorageMedium* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportStorageMedium", L"SupportedAccessMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SupportedAccessMode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhotoImportStorageMedium(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Import::PhotoImportStorageMedium>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhotoImportStorageMedium(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Import::PhotoImportStorageMedium>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhotoImportStorageMedium[] = {
        { "refresh", reinterpret_cast<PyCFunction>(PhotoImportStorageMedium_Refresh), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PhotoImportStorageMedium, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhotoImportStorageMedium), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PhotoImportStorageMedium[] = {
        { "available_space_in_bytes", reinterpret_cast<getter>(PhotoImportStorageMedium_get_AvailableSpaceInBytes), nullptr, nullptr, nullptr },
        { "capacity_in_bytes", reinterpret_cast<getter>(PhotoImportStorageMedium_get_CapacityInBytes), nullptr, nullptr, nullptr },
        { "description", reinterpret_cast<getter>(PhotoImportStorageMedium_get_Description), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(PhotoImportStorageMedium_get_Name), nullptr, nullptr, nullptr },
        { "serial_number", reinterpret_cast<getter>(PhotoImportStorageMedium_get_SerialNumber), nullptr, nullptr, nullptr },
        { "storage_medium_type", reinterpret_cast<getter>(PhotoImportStorageMedium_get_StorageMediumType), nullptr, nullptr, nullptr },
        { "supported_access_mode", reinterpret_cast<getter>(PhotoImportStorageMedium_get_SupportedAccessMode), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PhotoImportStorageMedium[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhotoImportStorageMedium) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhotoImportStorageMedium) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhotoImportStorageMedium) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhotoImportStorageMedium) },
        { }};

    static PyType_Spec type_spec_PhotoImportStorageMedium = {
        "winrt._winrt_windows_media_import_.PhotoImportStorageMedium",
        sizeof(py::wrapper::Windows::Media::Import::PhotoImportStorageMedium),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoImportStorageMedium};

    // ----- PhotoImportVideoSegment class --------------------

    static PyObject* _new_PhotoImportVideoSegment(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Import::PhotoImportVideoSegment>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Import::PhotoImportVideoSegment>::type_name);
        return nullptr;
    }

    static void _dealloc_PhotoImportVideoSegment(py::wrapper::Windows::Media::Import::PhotoImportVideoSegment* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhotoImportVideoSegment_get_Date(py::wrapper::Windows::Media::Import::PhotoImportVideoSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportVideoSegment", L"Date");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Date();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportVideoSegment_get_Name(py::wrapper::Windows::Media::Import::PhotoImportVideoSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportVideoSegment", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Name();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportVideoSegment_get_Sibling(py::wrapper::Windows::Media::Import::PhotoImportVideoSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportVideoSegment", L"Sibling");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Sibling();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportVideoSegment_get_Sidecars(py::wrapper::Windows::Media::Import::PhotoImportVideoSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportVideoSegment", L"Sidecars");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Sidecars();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportVideoSegment_get_SizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportVideoSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportVideoSegment", L"SizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.SizeInBytes();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhotoImportVideoSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Import::PhotoImportVideoSegment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhotoImportVideoSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Import::PhotoImportVideoSegment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhotoImportVideoSegment[] = {
        { "_assign_array_", _assign_array_PhotoImportVideoSegment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhotoImportVideoSegment), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PhotoImportVideoSegment[] = {
        { "date", reinterpret_cast<getter>(PhotoImportVideoSegment_get_Date), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(PhotoImportVideoSegment_get_Name), nullptr, nullptr, nullptr },
        { "sibling", reinterpret_cast<getter>(PhotoImportVideoSegment_get_Sibling), nullptr, nullptr, nullptr },
        { "sidecars", reinterpret_cast<getter>(PhotoImportVideoSegment_get_Sidecars), nullptr, nullptr, nullptr },
        { "size_in_bytes", reinterpret_cast<getter>(PhotoImportVideoSegment_get_SizeInBytes), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PhotoImportVideoSegment[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhotoImportVideoSegment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhotoImportVideoSegment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhotoImportVideoSegment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhotoImportVideoSegment) },
        { }};

    static PyType_Spec type_spec_PhotoImportVideoSegment = {
        "winrt._winrt_windows_media_import_.PhotoImportVideoSegment",
        sizeof(py::wrapper::Windows::Media::Import::PhotoImportVideoSegment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoImportVideoSegment};

    // ----- PhotoImportProgress struct --------------------

    winrt::Windows::Media::Import::PhotoImportProgress PhotoImportProgress_from_tuple(PyObject* tuple)
    {
        if (PyTuple_GET_SIZE(tuple) != 5)
        {
            PyErr_SetString(PyExc_TypeError, "Incorrect number of fields");
            throw python_exception();
        }

        winrt::Windows::Media::Import::PhotoImportProgress result{};

        result.ItemsImported = py::convert_to<uint32_t>(tuple, 0);
        result.TotalItemsToImport = py::convert_to<uint32_t>(tuple, 1);
        result.BytesImported = py::convert_to<uint64_t>(tuple, 2);
        result.TotalBytesToImport = py::convert_to<uint64_t>(tuple, 3);
        result.ImportProgress = py::convert_to<double>(tuple, 4);

        return result;
    }

    PyObject* _new_PhotoImportProgress(PyTypeObject* subclass, PyObject* args, PyObject* kwds) noexcept
    {
        pyobj_handle self_obj{(subclass->tp_alloc(subclass, 0))};
        if (!self_obj)
        {
            return nullptr;
        }

        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Media::Import::PhotoImportProgress>*>(self_obj.get());
        std::construct_at(&self->obj);

        auto tuple_size = PyTuple_Size(args);
        if ((tuple_size == 0) && (!kwds))
        {
            return self_obj.detach();
        }

        uint32_t _ItemsImported{};
        uint32_t _TotalItemsToImport{};
        uint64_t _BytesImported{};
        uint64_t _TotalBytesToImport{};
        double _ImportProgress{};

        static const char* kwlist[] = {"items_imported", "total_items_to_import", "bytes_imported", "total_bytes_to_import", "import_progress", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "|IIKKd", const_cast<char**>(kwlist), &_ItemsImported, &_TotalItemsToImport, &_BytesImported, &_TotalBytesToImport, &_ImportProgress))
        {
            return nullptr;
        }

        try
        {
            self->obj.ItemsImported = _ItemsImported;
            self->obj.TotalItemsToImport = _TotalItemsToImport;
            self->obj.BytesImported = _BytesImported;
            self->obj.TotalBytesToImport = _TotalBytesToImport;
            self->obj.ImportProgress = _ImportProgress;

            return self_obj.detach();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_PhotoImportProgress(py::wrapper::Windows::Media::Import::PhotoImportProgress* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PhotoImportProgress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Import::PhotoImportProgress>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    PyObject* _replace_PhotoImportProgress(py::wrapper::Windows::Media::Import::PhotoImportProgress* self, PyObject* args, PyObject* kwds) noexcept
    {
        try
        {
            uint32_t _ItemsImported{self->obj.ItemsImported};
            uint32_t _TotalItemsToImport{self->obj.TotalItemsToImport};
            uint64_t _BytesImported{self->obj.BytesImported};
            uint64_t _TotalBytesToImport{self->obj.TotalBytesToImport};
            double _ImportProgress{self->obj.ImportProgress};

            static const char* kwlist[] = {"items_imported", "total_items_to_import", "bytes_imported", "total_bytes_to_import", "import_progress", nullptr};
            if (!PyArg_ParseTupleAndKeywords(args, kwds, "|$IIKKd", const_cast<char**>(kwlist), &_ItemsImported, &_TotalItemsToImport, &_BytesImported, &_TotalBytesToImport, &_ImportProgress))
            {
                return nullptr;
            }

            auto copy = self->obj;
            copy.ItemsImported = _ItemsImported;
            copy.TotalItemsToImport = _TotalItemsToImport;
            copy.BytesImported = _BytesImported;
            copy.TotalBytesToImport = _TotalBytesToImport;
            copy.ImportProgress = _ImportProgress;

            return convert(copy);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhotoImportProgress[] = {
        { "_assign_array_", _assign_array_PhotoImportProgress, METH_O | METH_STATIC, nullptr },
        { "__replace__", reinterpret_cast<PyCFunction>(_replace_PhotoImportProgress), METH_VARARGS | METH_KEYWORDS, nullptr },
        { }};

    static PyObject* PhotoImportProgress_get_ItemsImported(py::wrapper::Windows::Media::Import::PhotoImportProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ItemsImported);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportProgress_get_TotalItemsToImport(py::wrapper::Windows::Media::Import::PhotoImportProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TotalItemsToImport);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportProgress_get_BytesImported(py::wrapper::Windows::Media::Import::PhotoImportProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesImported);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportProgress_get_TotalBytesToImport(py::wrapper::Windows::Media::Import::PhotoImportProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TotalBytesToImport);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportProgress_get_ImportProgress(py::wrapper::Windows::Media::Import::PhotoImportProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ImportProgress);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyGetSetDef _getset_PhotoImportProgress[] = {
        { "items_imported", reinterpret_cast<getter>(PhotoImportProgress_get_ItemsImported), nullptr, nullptr, nullptr },
        { "total_items_to_import", reinterpret_cast<getter>(PhotoImportProgress_get_TotalItemsToImport), nullptr, nullptr, nullptr },
        { "bytes_imported", reinterpret_cast<getter>(PhotoImportProgress_get_BytesImported), nullptr, nullptr, nullptr },
        { "total_bytes_to_import", reinterpret_cast<getter>(PhotoImportProgress_get_TotalBytesToImport), nullptr, nullptr, nullptr },
        { "import_progress", reinterpret_cast<getter>(PhotoImportProgress_get_ImportProgress), nullptr, nullptr, nullptr },
        { }};

    static PyObject* _richcompare_PhotoImportProgress(py::wrapper::Windows::Media::Import::PhotoImportProgress* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Windows::Media::Import::PhotoImportProgress>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_PhotoImportProgress(PyObject* self) noexcept
    {
        py::pyobj_handle ItemsImported{PyObject_GetAttrString(self, "items_imported")};
        if (!ItemsImported)
        {
            return nullptr;
        }

        py::pyobj_handle TotalItemsToImport{PyObject_GetAttrString(self, "total_items_to_import")};
        if (!TotalItemsToImport)
        {
            return nullptr;
        }

        py::pyobj_handle BytesImported{PyObject_GetAttrString(self, "bytes_imported")};
        if (!BytesImported)
        {
            return nullptr;
        }

        py::pyobj_handle TotalBytesToImport{PyObject_GetAttrString(self, "total_bytes_to_import")};
        if (!TotalBytesToImport)
        {
            return nullptr;
        }

        py::pyobj_handle ImportProgress{PyObject_GetAttrString(self, "import_progress")};
        if (!ImportProgress)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("PhotoImportProgress(items_imported=%R, total_items_to_import=%R, bytes_imported=%R, total_bytes_to_import=%R, import_progress=%R)", ItemsImported.get(), TotalItemsToImport.get(), BytesImported.get(), TotalBytesToImport.get(), ImportProgress.get());
    }

    static PyType_Slot _type_slots_PhotoImportProgress[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhotoImportProgress) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhotoImportProgress) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhotoImportProgress) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhotoImportProgress) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_PhotoImportProgress) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_PhotoImportProgress) },
        { }};

    static PyType_Spec type_spec_PhotoImportProgress = {
        "winrt._winrt_windows_media_import_.PhotoImportProgress",
        sizeof(py::wrapper::Windows::Media::Import::PhotoImportProgress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoImportProgress};

    // ----- Windows.Media.Import Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Media.Import");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_media_import_",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Media::Import

PyMODINIT_FUNC PyInit__winrt_windows_media_import_(void) noexcept
{
    using namespace py::cpp::Windows::Media::Import;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle PhotoImportDeleteImportedItemsFromSourceResult_type{py::register_python_type(module.get(), &type_spec_PhotoImportDeleteImportedItemsFromSourceResult, object_bases.get(), inspectable_meta_type)};
    if (!PhotoImportDeleteImportedItemsFromSourceResult_type)
    {
        return nullptr;
    }

    py::pytype_handle PhotoImportFindItemsResult_type{py::register_python_type(module.get(), &type_spec_PhotoImportFindItemsResult, object_bases.get(), inspectable_meta_type)};
    if (!PhotoImportFindItemsResult_type)
    {
        return nullptr;
    }

    py::pytype_handle PhotoImportImportItemsResult_type{py::register_python_type(module.get(), &type_spec_PhotoImportImportItemsResult, object_bases.get(), inspectable_meta_type)};
    if (!PhotoImportImportItemsResult_type)
    {
        return nullptr;
    }

    py::pytype_handle PhotoImportItem_type{py::register_python_type(module.get(), &type_spec_PhotoImportItem, object_bases.get(), inspectable_meta_type)};
    if (!PhotoImportItem_type)
    {
        return nullptr;
    }

    py::pytype_handle PhotoImportItemImportedEventArgs_type{py::register_python_type(module.get(), &type_spec_PhotoImportItemImportedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!PhotoImportItemImportedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle PhotoImportManager_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!PhotoImportManager_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PhotoImportManager_Static{PyType_FromSpecWithBases(&type_spec_PhotoImportManager_Static, PhotoImportManager_Static_bases.get())};
    if (!type_PhotoImportManager_Static)
    {
        return nullptr;
    }

    py::pytype_handle PhotoImportManager_type{py::register_python_type(module.get(), &type_spec_PhotoImportManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PhotoImportManager_Static.get()))};
    if (!PhotoImportManager_type)
    {
        return nullptr;
    }

    py::pytype_handle PhotoImportOperation_type{py::register_python_type(module.get(), &type_spec_PhotoImportOperation, object_bases.get(), inspectable_meta_type)};
    if (!PhotoImportOperation_type)
    {
        return nullptr;
    }

    py::pytype_handle PhotoImportSelectionChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_PhotoImportSelectionChangedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!PhotoImportSelectionChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PhotoImportSession_type{py::register_python_type(module.get(), &type_spec_PhotoImportSession, object_bases.get(), inspectable_meta_type)};
    if (!PhotoImportSession_type)
    {
        return nullptr;
    }

    py::pytype_handle PhotoImportSidecar_type{py::register_python_type(module.get(), &type_spec_PhotoImportSidecar, object_bases.get(), inspectable_meta_type)};
    if (!PhotoImportSidecar_type)
    {
        return nullptr;
    }

    py::pyobj_handle PhotoImportSource_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!PhotoImportSource_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PhotoImportSource_Static{PyType_FromSpecWithBases(&type_spec_PhotoImportSource_Static, PhotoImportSource_Static_bases.get())};
    if (!type_PhotoImportSource_Static)
    {
        return nullptr;
    }

    py::pytype_handle PhotoImportSource_type{py::register_python_type(module.get(), &type_spec_PhotoImportSource, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PhotoImportSource_Static.get()))};
    if (!PhotoImportSource_type)
    {
        return nullptr;
    }

    py::pytype_handle PhotoImportStorageMedium_type{py::register_python_type(module.get(), &type_spec_PhotoImportStorageMedium, object_bases.get(), inspectable_meta_type)};
    if (!PhotoImportStorageMedium_type)
    {
        return nullptr;
    }

    py::pytype_handle PhotoImportVideoSegment_type{py::register_python_type(module.get(), &type_spec_PhotoImportVideoSegment, object_bases.get(), inspectable_meta_type)};
    if (!PhotoImportVideoSegment_type)
    {
        return nullptr;
    }

    py::pytype_handle PhotoImportProgress_type{py::register_python_type(module.get(), &type_spec_PhotoImportProgress, nullptr, nullptr)};
    if (!PhotoImportProgress_type)
    {
        return nullptr;
    }

    py::pyobj_handle PhotoImportProgress_from_tuple_capsule{PyCapsule_New(reinterpret_cast<void*>(PhotoImportProgress_from_tuple),"winrt._winrt_windows_media_import_.PhotoImportProgress_from_tuple", nullptr)};
    if (!PhotoImportProgress_from_tuple_capsule)
    {
        return nullptr;
    }

    if (PyModule_AddObjectRef(module.get(), "PhotoImportProgress_from_tuple", PhotoImportProgress_from_tuple_capsule.get()) == -1)
    {
        return nullptr;
    }

    return module.detach();
}
