// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.2.0

#include "py.Windows.Media.Import.h"

namespace py::cpp::Windows::Media::Import
{
    // ----- PhotoImportDeleteImportedItemsFromSourceResult class --------------------

    static PyObject* _new_PhotoImportDeleteImportedItemsFromSourceResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Import::PhotoImportDeleteImportedItemsFromSourceResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Import::PhotoImportDeleteImportedItemsFromSourceResult>::type_name);
        return nullptr;
    }

    static void _dealloc_PhotoImportDeleteImportedItemsFromSourceResult(py::wrapper::Windows::Media::Import::PhotoImportDeleteImportedItemsFromSourceResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhotoImportDeleteImportedItemsFromSourceResult_get_DeletedItems(py::wrapper::Windows::Media::Import::PhotoImportDeleteImportedItemsFromSourceResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult", L"DeletedItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeletedItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportDeleteImportedItemsFromSourceResult_get_HasSucceeded(py::wrapper::Windows::Media::Import::PhotoImportDeleteImportedItemsFromSourceResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult", L"HasSucceeded");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HasSucceeded());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportDeleteImportedItemsFromSourceResult_get_PhotosCount(py::wrapper::Windows::Media::Import::PhotoImportDeleteImportedItemsFromSourceResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult", L"PhotosCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PhotosCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportDeleteImportedItemsFromSourceResult_get_PhotosSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportDeleteImportedItemsFromSourceResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult", L"PhotosSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PhotosSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportDeleteImportedItemsFromSourceResult_get_Session(py::wrapper::Windows::Media::Import::PhotoImportDeleteImportedItemsFromSourceResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult", L"Session");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Session());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportDeleteImportedItemsFromSourceResult_get_SiblingsCount(py::wrapper::Windows::Media::Import::PhotoImportDeleteImportedItemsFromSourceResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult", L"SiblingsCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SiblingsCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportDeleteImportedItemsFromSourceResult_get_SiblingsSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportDeleteImportedItemsFromSourceResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult", L"SiblingsSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SiblingsSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportDeleteImportedItemsFromSourceResult_get_SidecarsCount(py::wrapper::Windows::Media::Import::PhotoImportDeleteImportedItemsFromSourceResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult", L"SidecarsCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SidecarsCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportDeleteImportedItemsFromSourceResult_get_SidecarsSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportDeleteImportedItemsFromSourceResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult", L"SidecarsSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SidecarsSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportDeleteImportedItemsFromSourceResult_get_TotalCount(py::wrapper::Windows::Media::Import::PhotoImportDeleteImportedItemsFromSourceResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult", L"TotalCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TotalCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportDeleteImportedItemsFromSourceResult_get_TotalSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportDeleteImportedItemsFromSourceResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult", L"TotalSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TotalSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportDeleteImportedItemsFromSourceResult_get_VideosCount(py::wrapper::Windows::Media::Import::PhotoImportDeleteImportedItemsFromSourceResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult", L"VideosCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideosCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportDeleteImportedItemsFromSourceResult_get_VideosSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportDeleteImportedItemsFromSourceResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportDeleteImportedItemsFromSourceResult", L"VideosSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideosSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhotoImportDeleteImportedItemsFromSourceResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Import::PhotoImportDeleteImportedItemsFromSourceResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhotoImportDeleteImportedItemsFromSourceResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Import::PhotoImportDeleteImportedItemsFromSourceResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhotoImportDeleteImportedItemsFromSourceResult[] = {
        { "_assign_array_", _assign_array_PhotoImportDeleteImportedItemsFromSourceResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhotoImportDeleteImportedItemsFromSourceResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhotoImportDeleteImportedItemsFromSourceResult[] = {
        { "deleted_items", reinterpret_cast<getter>(PhotoImportDeleteImportedItemsFromSourceResult_get_DeletedItems), nullptr, nullptr, nullptr },
        { "has_succeeded", reinterpret_cast<getter>(PhotoImportDeleteImportedItemsFromSourceResult_get_HasSucceeded), nullptr, nullptr, nullptr },
        { "photos_count", reinterpret_cast<getter>(PhotoImportDeleteImportedItemsFromSourceResult_get_PhotosCount), nullptr, nullptr, nullptr },
        { "photos_size_in_bytes", reinterpret_cast<getter>(PhotoImportDeleteImportedItemsFromSourceResult_get_PhotosSizeInBytes), nullptr, nullptr, nullptr },
        { "session", reinterpret_cast<getter>(PhotoImportDeleteImportedItemsFromSourceResult_get_Session), nullptr, nullptr, nullptr },
        { "siblings_count", reinterpret_cast<getter>(PhotoImportDeleteImportedItemsFromSourceResult_get_SiblingsCount), nullptr, nullptr, nullptr },
        { "siblings_size_in_bytes", reinterpret_cast<getter>(PhotoImportDeleteImportedItemsFromSourceResult_get_SiblingsSizeInBytes), nullptr, nullptr, nullptr },
        { "sidecars_count", reinterpret_cast<getter>(PhotoImportDeleteImportedItemsFromSourceResult_get_SidecarsCount), nullptr, nullptr, nullptr },
        { "sidecars_size_in_bytes", reinterpret_cast<getter>(PhotoImportDeleteImportedItemsFromSourceResult_get_SidecarsSizeInBytes), nullptr, nullptr, nullptr },
        { "total_count", reinterpret_cast<getter>(PhotoImportDeleteImportedItemsFromSourceResult_get_TotalCount), nullptr, nullptr, nullptr },
        { "total_size_in_bytes", reinterpret_cast<getter>(PhotoImportDeleteImportedItemsFromSourceResult_get_TotalSizeInBytes), nullptr, nullptr, nullptr },
        { "videos_count", reinterpret_cast<getter>(PhotoImportDeleteImportedItemsFromSourceResult_get_VideosCount), nullptr, nullptr, nullptr },
        { "videos_size_in_bytes", reinterpret_cast<getter>(PhotoImportDeleteImportedItemsFromSourceResult_get_VideosSizeInBytes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhotoImportDeleteImportedItemsFromSourceResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhotoImportDeleteImportedItemsFromSourceResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhotoImportDeleteImportedItemsFromSourceResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhotoImportDeleteImportedItemsFromSourceResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhotoImportDeleteImportedItemsFromSourceResult) },
        { }
    };

    static PyType_Spec type_spec_PhotoImportDeleteImportedItemsFromSourceResult = {
        "winrt._winrt_windows_media_import_.PhotoImportDeleteImportedItemsFromSourceResult",
        sizeof(py::wrapper::Windows::Media::Import::PhotoImportDeleteImportedItemsFromSourceResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoImportDeleteImportedItemsFromSourceResult};

    // ----- PhotoImportFindItemsResult class --------------------

    static PyObject* _new_PhotoImportFindItemsResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Import::PhotoImportFindItemsResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Import::PhotoImportFindItemsResult>::type_name);
        return nullptr;
    }

    static void _dealloc_PhotoImportFindItemsResult(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhotoImportFindItemsResult_AddItemsInDateRangeToSelection(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"AddItemsInDateRangeToSelection", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                self->obj.AddItemsInDateRangeToSelection(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_ImportItemsAsync(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"ImportItemsAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.ImportItemsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_SelectAll(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SelectAll", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.SelectAll();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_SelectNewAsync(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SelectNewAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.SelectNewAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_SelectNone(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SelectNone", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.SelectNone();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_SetImportMode(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SetImportMode", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Import::PhotoImportImportMode>(args, 0);

                self->obj.SetImportMode(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_FoundItems(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"FoundItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.FoundItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_HasSucceeded(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"HasSucceeded");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HasSucceeded());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_ImportMode(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"ImportMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ImportMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_PhotosCount(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"PhotosCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PhotosCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_PhotosSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"PhotosSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PhotosSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_SelectedPhotosCount(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SelectedPhotosCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedPhotosCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_SelectedPhotosSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SelectedPhotosSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedPhotosSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_SelectedSiblingsCount(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SelectedSiblingsCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedSiblingsCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_SelectedSiblingsSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SelectedSiblingsSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedSiblingsSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_SelectedSidecarsCount(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SelectedSidecarsCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedSidecarsCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_SelectedSidecarsSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SelectedSidecarsSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedSidecarsSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_SelectedTotalCount(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SelectedTotalCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedTotalCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_SelectedTotalSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SelectedTotalSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedTotalSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_SelectedVideosCount(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SelectedVideosCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedVideosCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_SelectedVideosSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SelectedVideosSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SelectedVideosSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_Session(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"Session");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Session());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_SiblingsCount(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SiblingsCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SiblingsCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_SiblingsSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SiblingsSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SiblingsSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_SidecarsCount(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SidecarsCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SidecarsCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_SidecarsSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SidecarsSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SidecarsSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_TotalCount(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"TotalCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TotalCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_TotalSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"TotalSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TotalSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_VideosCount(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"VideosCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideosCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_get_VideosSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"VideosSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideosSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_add_ItemImported(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"ItemImported");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Import::PhotoImportFindItemsResult, winrt::Windows::Media::Import::PhotoImportItemImportedEventArgs>>(arg);

            return py::convert(self->obj.ItemImported(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_remove_ItemImported(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"ItemImported");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ItemImported(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_add_SelectionChanged(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SelectionChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Import::PhotoImportFindItemsResult, winrt::Windows::Media::Import::PhotoImportSelectionChangedEventArgs>>(arg);

            return py::convert(self->obj.SelectionChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportFindItemsResult_remove_SelectionChanged(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Import.PhotoImportFindItemsResult", L"SelectionChanged");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SelectionChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhotoImportFindItemsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Import::PhotoImportFindItemsResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhotoImportFindItemsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Import::PhotoImportFindItemsResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhotoImportFindItemsResult[] = {
        { "add_items_in_date_range_to_selection", reinterpret_cast<PyCFunction>(PhotoImportFindItemsResult_AddItemsInDateRangeToSelection), METH_VARARGS, nullptr },
        { "import_items_async", reinterpret_cast<PyCFunction>(PhotoImportFindItemsResult_ImportItemsAsync), METH_VARARGS, nullptr },
        { "select_all", reinterpret_cast<PyCFunction>(PhotoImportFindItemsResult_SelectAll), METH_VARARGS, nullptr },
        { "select_new_async", reinterpret_cast<PyCFunction>(PhotoImportFindItemsResult_SelectNewAsync), METH_VARARGS, nullptr },
        { "select_none", reinterpret_cast<PyCFunction>(PhotoImportFindItemsResult_SelectNone), METH_VARARGS, nullptr },
        { "set_import_mode", reinterpret_cast<PyCFunction>(PhotoImportFindItemsResult_SetImportMode), METH_VARARGS, nullptr },
        { "add_item_imported", reinterpret_cast<PyCFunction>(PhotoImportFindItemsResult_add_ItemImported), METH_O, nullptr },
        { "remove_item_imported", reinterpret_cast<PyCFunction>(PhotoImportFindItemsResult_remove_ItemImported), METH_O, nullptr },
        { "add_selection_changed", reinterpret_cast<PyCFunction>(PhotoImportFindItemsResult_add_SelectionChanged), METH_O, nullptr },
        { "remove_selection_changed", reinterpret_cast<PyCFunction>(PhotoImportFindItemsResult_remove_SelectionChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_PhotoImportFindItemsResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhotoImportFindItemsResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhotoImportFindItemsResult[] = {
        { "found_items", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_FoundItems), nullptr, nullptr, nullptr },
        { "has_succeeded", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_HasSucceeded), nullptr, nullptr, nullptr },
        { "import_mode", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_ImportMode), nullptr, nullptr, nullptr },
        { "photos_count", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_PhotosCount), nullptr, nullptr, nullptr },
        { "photos_size_in_bytes", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_PhotosSizeInBytes), nullptr, nullptr, nullptr },
        { "selected_photos_count", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_SelectedPhotosCount), nullptr, nullptr, nullptr },
        { "selected_photos_size_in_bytes", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_SelectedPhotosSizeInBytes), nullptr, nullptr, nullptr },
        { "selected_siblings_count", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_SelectedSiblingsCount), nullptr, nullptr, nullptr },
        { "selected_siblings_size_in_bytes", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_SelectedSiblingsSizeInBytes), nullptr, nullptr, nullptr },
        { "selected_sidecars_count", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_SelectedSidecarsCount), nullptr, nullptr, nullptr },
        { "selected_sidecars_size_in_bytes", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_SelectedSidecarsSizeInBytes), nullptr, nullptr, nullptr },
        { "selected_total_count", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_SelectedTotalCount), nullptr, nullptr, nullptr },
        { "selected_total_size_in_bytes", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_SelectedTotalSizeInBytes), nullptr, nullptr, nullptr },
        { "selected_videos_count", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_SelectedVideosCount), nullptr, nullptr, nullptr },
        { "selected_videos_size_in_bytes", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_SelectedVideosSizeInBytes), nullptr, nullptr, nullptr },
        { "session", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_Session), nullptr, nullptr, nullptr },
        { "siblings_count", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_SiblingsCount), nullptr, nullptr, nullptr },
        { "siblings_size_in_bytes", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_SiblingsSizeInBytes), nullptr, nullptr, nullptr },
        { "sidecars_count", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_SidecarsCount), nullptr, nullptr, nullptr },
        { "sidecars_size_in_bytes", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_SidecarsSizeInBytes), nullptr, nullptr, nullptr },
        { "total_count", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_TotalCount), nullptr, nullptr, nullptr },
        { "total_size_in_bytes", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_TotalSizeInBytes), nullptr, nullptr, nullptr },
        { "videos_count", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_VideosCount), nullptr, nullptr, nullptr },
        { "videos_size_in_bytes", reinterpret_cast<getter>(PhotoImportFindItemsResult_get_VideosSizeInBytes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhotoImportFindItemsResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhotoImportFindItemsResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhotoImportFindItemsResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhotoImportFindItemsResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhotoImportFindItemsResult) },
        { }
    };

    static PyType_Spec type_spec_PhotoImportFindItemsResult = {
        "winrt._winrt_windows_media_import_.PhotoImportFindItemsResult",
        sizeof(py::wrapper::Windows::Media::Import::PhotoImportFindItemsResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoImportFindItemsResult};

    // ----- PhotoImportImportItemsResult class --------------------

    static PyObject* _new_PhotoImportImportItemsResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Import::PhotoImportImportItemsResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Import::PhotoImportImportItemsResult>::type_name);
        return nullptr;
    }

    static void _dealloc_PhotoImportImportItemsResult(py::wrapper::Windows::Media::Import::PhotoImportImportItemsResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhotoImportImportItemsResult_DeleteImportedItemsFromSourceAsync(py::wrapper::Windows::Media::Import::PhotoImportImportItemsResult* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Import.PhotoImportImportItemsResult", L"DeleteImportedItemsFromSourceAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.DeleteImportedItemsFromSourceAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhotoImportImportItemsResult_get_HasSucceeded(py::wrapper::Windows::Media::Import::PhotoImportImportItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportImportItemsResult", L"HasSucceeded");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.HasSucceeded());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportImportItemsResult_get_ImportedItems(py::wrapper::Windows::Media::Import::PhotoImportImportItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportImportItemsResult", L"ImportedItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ImportedItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportImportItemsResult_get_PhotosCount(py::wrapper::Windows::Media::Import::PhotoImportImportItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportImportItemsResult", L"PhotosCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PhotosCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportImportItemsResult_get_PhotosSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportImportItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportImportItemsResult", L"PhotosSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PhotosSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportImportItemsResult_get_Session(py::wrapper::Windows::Media::Import::PhotoImportImportItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportImportItemsResult", L"Session");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Session());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportImportItemsResult_get_SiblingsCount(py::wrapper::Windows::Media::Import::PhotoImportImportItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportImportItemsResult", L"SiblingsCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SiblingsCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportImportItemsResult_get_SiblingsSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportImportItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportImportItemsResult", L"SiblingsSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SiblingsSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportImportItemsResult_get_SidecarsCount(py::wrapper::Windows::Media::Import::PhotoImportImportItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportImportItemsResult", L"SidecarsCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SidecarsCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportImportItemsResult_get_SidecarsSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportImportItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportImportItemsResult", L"SidecarsSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SidecarsSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportImportItemsResult_get_TotalCount(py::wrapper::Windows::Media::Import::PhotoImportImportItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportImportItemsResult", L"TotalCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TotalCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportImportItemsResult_get_TotalSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportImportItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportImportItemsResult", L"TotalSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.TotalSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportImportItemsResult_get_VideosCount(py::wrapper::Windows::Media::Import::PhotoImportImportItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportImportItemsResult", L"VideosCount");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideosCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportImportItemsResult_get_VideosSizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportImportItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportImportItemsResult", L"VideosSizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideosSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhotoImportImportItemsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Import::PhotoImportImportItemsResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhotoImportImportItemsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Import::PhotoImportImportItemsResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhotoImportImportItemsResult[] = {
        { "delete_imported_items_from_source_async", reinterpret_cast<PyCFunction>(PhotoImportImportItemsResult_DeleteImportedItemsFromSourceAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PhotoImportImportItemsResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhotoImportImportItemsResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhotoImportImportItemsResult[] = {
        { "has_succeeded", reinterpret_cast<getter>(PhotoImportImportItemsResult_get_HasSucceeded), nullptr, nullptr, nullptr },
        { "imported_items", reinterpret_cast<getter>(PhotoImportImportItemsResult_get_ImportedItems), nullptr, nullptr, nullptr },
        { "photos_count", reinterpret_cast<getter>(PhotoImportImportItemsResult_get_PhotosCount), nullptr, nullptr, nullptr },
        { "photos_size_in_bytes", reinterpret_cast<getter>(PhotoImportImportItemsResult_get_PhotosSizeInBytes), nullptr, nullptr, nullptr },
        { "session", reinterpret_cast<getter>(PhotoImportImportItemsResult_get_Session), nullptr, nullptr, nullptr },
        { "siblings_count", reinterpret_cast<getter>(PhotoImportImportItemsResult_get_SiblingsCount), nullptr, nullptr, nullptr },
        { "siblings_size_in_bytes", reinterpret_cast<getter>(PhotoImportImportItemsResult_get_SiblingsSizeInBytes), nullptr, nullptr, nullptr },
        { "sidecars_count", reinterpret_cast<getter>(PhotoImportImportItemsResult_get_SidecarsCount), nullptr, nullptr, nullptr },
        { "sidecars_size_in_bytes", reinterpret_cast<getter>(PhotoImportImportItemsResult_get_SidecarsSizeInBytes), nullptr, nullptr, nullptr },
        { "total_count", reinterpret_cast<getter>(PhotoImportImportItemsResult_get_TotalCount), nullptr, nullptr, nullptr },
        { "total_size_in_bytes", reinterpret_cast<getter>(PhotoImportImportItemsResult_get_TotalSizeInBytes), nullptr, nullptr, nullptr },
        { "videos_count", reinterpret_cast<getter>(PhotoImportImportItemsResult_get_VideosCount), nullptr, nullptr, nullptr },
        { "videos_size_in_bytes", reinterpret_cast<getter>(PhotoImportImportItemsResult_get_VideosSizeInBytes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhotoImportImportItemsResult[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhotoImportImportItemsResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhotoImportImportItemsResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhotoImportImportItemsResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhotoImportImportItemsResult) },
        { }
    };

    static PyType_Spec type_spec_PhotoImportImportItemsResult = {
        "winrt._winrt_windows_media_import_.PhotoImportImportItemsResult",
        sizeof(py::wrapper::Windows::Media::Import::PhotoImportImportItemsResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoImportImportItemsResult};

    // ----- PhotoImportItem class --------------------

    static PyObject* _new_PhotoImportItem(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Import::PhotoImportItem>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Import::PhotoImportItem>::type_name);
        return nullptr;
    }

    static void _dealloc_PhotoImportItem(py::wrapper::Windows::Media::Import::PhotoImportItem* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhotoImportItem_get_IsSelected(py::wrapper::Windows::Media::Import::PhotoImportItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportItem", L"IsSelected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhotoImportItem_put_IsSelected(py::wrapper::Windows::Media::Import::PhotoImportItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportItem", L"IsSelected");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsSelected(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhotoImportItem_get_ContentType(py::wrapper::Windows::Media::Import::PhotoImportItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportItem", L"ContentType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportItem_get_Date(py::wrapper::Windows::Media::Import::PhotoImportItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportItem", L"Date");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Date());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportItem_get_DeletedFileNames(py::wrapper::Windows::Media::Import::PhotoImportItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportItem", L"DeletedFileNames");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DeletedFileNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportItem_get_ImportedFileNames(py::wrapper::Windows::Media::Import::PhotoImportItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportItem", L"ImportedFileNames");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ImportedFileNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportItem_get_ItemKey(py::wrapper::Windows::Media::Import::PhotoImportItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportItem", L"ItemKey");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ItemKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportItem_get_Name(py::wrapper::Windows::Media::Import::PhotoImportItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportItem", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportItem_get_Sibling(py::wrapper::Windows::Media::Import::PhotoImportItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportItem", L"Sibling");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Sibling());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportItem_get_Sidecars(py::wrapper::Windows::Media::Import::PhotoImportItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportItem", L"Sidecars");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Sidecars());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportItem_get_SizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportItem", L"SizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportItem_get_Thumbnail(py::wrapper::Windows::Media::Import::PhotoImportItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportItem", L"Thumbnail");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Thumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportItem_get_VideoSegments(py::wrapper::Windows::Media::Import::PhotoImportItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportItem", L"VideoSegments");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.VideoSegments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportItem_get_Path(py::wrapper::Windows::Media::Import::PhotoImportItem* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportItem", L"Path");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhotoImportItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Import::PhotoImportItem>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhotoImportItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Import::PhotoImportItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhotoImportItem[] = {
        { "_assign_array_", _assign_array_PhotoImportItem, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhotoImportItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhotoImportItem[] = {
        { "is_selected", reinterpret_cast<getter>(PhotoImportItem_get_IsSelected), reinterpret_cast<setter>(PhotoImportItem_put_IsSelected), nullptr, nullptr },
        { "content_type", reinterpret_cast<getter>(PhotoImportItem_get_ContentType), nullptr, nullptr, nullptr },
        { "date", reinterpret_cast<getter>(PhotoImportItem_get_Date), nullptr, nullptr, nullptr },
        { "deleted_file_names", reinterpret_cast<getter>(PhotoImportItem_get_DeletedFileNames), nullptr, nullptr, nullptr },
        { "imported_file_names", reinterpret_cast<getter>(PhotoImportItem_get_ImportedFileNames), nullptr, nullptr, nullptr },
        { "item_key", reinterpret_cast<getter>(PhotoImportItem_get_ItemKey), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(PhotoImportItem_get_Name), nullptr, nullptr, nullptr },
        { "sibling", reinterpret_cast<getter>(PhotoImportItem_get_Sibling), nullptr, nullptr, nullptr },
        { "sidecars", reinterpret_cast<getter>(PhotoImportItem_get_Sidecars), nullptr, nullptr, nullptr },
        { "size_in_bytes", reinterpret_cast<getter>(PhotoImportItem_get_SizeInBytes), nullptr, nullptr, nullptr },
        { "thumbnail", reinterpret_cast<getter>(PhotoImportItem_get_Thumbnail), nullptr, nullptr, nullptr },
        { "video_segments", reinterpret_cast<getter>(PhotoImportItem_get_VideoSegments), nullptr, nullptr, nullptr },
        { "path", reinterpret_cast<getter>(PhotoImportItem_get_Path), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhotoImportItem[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhotoImportItem) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhotoImportItem) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhotoImportItem) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhotoImportItem) },
        { }
    };

    static PyType_Spec type_spec_PhotoImportItem = {
        "winrt._winrt_windows_media_import_.PhotoImportItem",
        sizeof(py::wrapper::Windows::Media::Import::PhotoImportItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoImportItem};

    // ----- PhotoImportItemImportedEventArgs class --------------------

    static PyObject* _new_PhotoImportItemImportedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Import::PhotoImportItemImportedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Import::PhotoImportItemImportedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PhotoImportItemImportedEventArgs(py::wrapper::Windows::Media::Import::PhotoImportItemImportedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhotoImportItemImportedEventArgs_get_ImportedItem(py::wrapper::Windows::Media::Import::PhotoImportItemImportedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportItemImportedEventArgs", L"ImportedItem");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ImportedItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhotoImportItemImportedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Import::PhotoImportItemImportedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhotoImportItemImportedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Import::PhotoImportItemImportedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhotoImportItemImportedEventArgs[] = {
        { "_assign_array_", _assign_array_PhotoImportItemImportedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhotoImportItemImportedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhotoImportItemImportedEventArgs[] = {
        { "imported_item", reinterpret_cast<getter>(PhotoImportItemImportedEventArgs_get_ImportedItem), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhotoImportItemImportedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhotoImportItemImportedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhotoImportItemImportedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhotoImportItemImportedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhotoImportItemImportedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_PhotoImportItemImportedEventArgs = {
        "winrt._winrt_windows_media_import_.PhotoImportItemImportedEventArgs",
        sizeof(py::wrapper::Windows::Media::Import::PhotoImportItemImportedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoImportItemImportedEventArgs};

    // ----- PhotoImportManager class --------------------

    static PyObject* _new_PhotoImportManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Import::PhotoImportManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Import::PhotoImportManager>::type_name);
        return nullptr;
    }

    static PyObject* PhotoImportManager_FindAllSourcesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Import.PhotoImportManager", L"FindAllSourcesAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Media::Import::PhotoImportManager::FindAllSourcesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhotoImportManager_GetPendingOperations(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Import.PhotoImportManager", L"GetPendingOperations", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Media::Import::PhotoImportManager::GetPendingOperations());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhotoImportManager_IsSupportedAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Import.PhotoImportManager", L"IsSupportedAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(winrt::Windows::Media::Import::PhotoImportManager::IsSupportedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhotoImportManager[] = {
        { }
    };

    static PyGetSetDef _getset_PhotoImportManager[] = {
        { }
    };

    static PyType_Slot _type_slots_PhotoImportManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhotoImportManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhotoImportManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhotoImportManager) },
        { }
    };

    static PyType_Spec type_spec_PhotoImportManager = {
        "winrt._winrt_windows_media_import_.PhotoImportManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoImportManager};

    static PyGetSetDef getset_PhotoImportManager_Static[] = {
        { }
    };

    static PyMethodDef methods_PhotoImportManager_Static[] = {
        { "find_all_sources_async", reinterpret_cast<PyCFunction>(PhotoImportManager_FindAllSourcesAsync), METH_VARARGS, nullptr },
        { "get_pending_operations", reinterpret_cast<PyCFunction>(PhotoImportManager_GetPendingOperations), METH_VARARGS, nullptr },
        { "is_supported_async", reinterpret_cast<PyCFunction>(PhotoImportManager_IsSupportedAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_PhotoImportManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PhotoImportManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PhotoImportManager_Static) },
        { }
    };

    static PyType_Spec type_spec_PhotoImportManager_Static =
    {
        "winrt._winrt_windows_media_import_.PhotoImportManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PhotoImportManager_Static
    };

    // ----- PhotoImportOperation class --------------------

    static PyObject* _new_PhotoImportOperation(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Import::PhotoImportOperation>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Import::PhotoImportOperation>::type_name);
        return nullptr;
    }

    static void _dealloc_PhotoImportOperation(py::wrapper::Windows::Media::Import::PhotoImportOperation* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhotoImportOperation_get_ContinueDeletingImportedItemsFromSourceAsync(py::wrapper::Windows::Media::Import::PhotoImportOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportOperation", L"ContinueDeletingImportedItemsFromSourceAsync");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContinueDeletingImportedItemsFromSourceAsync());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportOperation_get_ContinueFindingItemsAsync(py::wrapper::Windows::Media::Import::PhotoImportOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportOperation", L"ContinueFindingItemsAsync");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContinueFindingItemsAsync());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportOperation_get_ContinueImportingItemsAsync(py::wrapper::Windows::Media::Import::PhotoImportOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportOperation", L"ContinueImportingItemsAsync");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ContinueImportingItemsAsync());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportOperation_get_Session(py::wrapper::Windows::Media::Import::PhotoImportOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportOperation", L"Session");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Session());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportOperation_get_Stage(py::wrapper::Windows::Media::Import::PhotoImportOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportOperation", L"Stage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Stage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhotoImportOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Import::PhotoImportOperation>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhotoImportOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Import::PhotoImportOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhotoImportOperation[] = {
        { "_assign_array_", _assign_array_PhotoImportOperation, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhotoImportOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhotoImportOperation[] = {
        { "continue_deleting_imported_items_from_source_async", reinterpret_cast<getter>(PhotoImportOperation_get_ContinueDeletingImportedItemsFromSourceAsync), nullptr, nullptr, nullptr },
        { "continue_finding_items_async", reinterpret_cast<getter>(PhotoImportOperation_get_ContinueFindingItemsAsync), nullptr, nullptr, nullptr },
        { "continue_importing_items_async", reinterpret_cast<getter>(PhotoImportOperation_get_ContinueImportingItemsAsync), nullptr, nullptr, nullptr },
        { "session", reinterpret_cast<getter>(PhotoImportOperation_get_Session), nullptr, nullptr, nullptr },
        { "stage", reinterpret_cast<getter>(PhotoImportOperation_get_Stage), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhotoImportOperation[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhotoImportOperation) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhotoImportOperation) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhotoImportOperation) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhotoImportOperation) },
        { }
    };

    static PyType_Spec type_spec_PhotoImportOperation = {
        "winrt._winrt_windows_media_import_.PhotoImportOperation",
        sizeof(py::wrapper::Windows::Media::Import::PhotoImportOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoImportOperation};

    // ----- PhotoImportSelectionChangedEventArgs class --------------------

    static PyObject* _new_PhotoImportSelectionChangedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Import::PhotoImportSelectionChangedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Import::PhotoImportSelectionChangedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_PhotoImportSelectionChangedEventArgs(py::wrapper::Windows::Media::Import::PhotoImportSelectionChangedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhotoImportSelectionChangedEventArgs_get_IsSelectionEmpty(py::wrapper::Windows::Media::Import::PhotoImportSelectionChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSelectionChangedEventArgs", L"IsSelectionEmpty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsSelectionEmpty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhotoImportSelectionChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Import::PhotoImportSelectionChangedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhotoImportSelectionChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Import::PhotoImportSelectionChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhotoImportSelectionChangedEventArgs[] = {
        { "_assign_array_", _assign_array_PhotoImportSelectionChangedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhotoImportSelectionChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhotoImportSelectionChangedEventArgs[] = {
        { "is_selection_empty", reinterpret_cast<getter>(PhotoImportSelectionChangedEventArgs_get_IsSelectionEmpty), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhotoImportSelectionChangedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhotoImportSelectionChangedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhotoImportSelectionChangedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhotoImportSelectionChangedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhotoImportSelectionChangedEventArgs) },
        { }
    };

    static PyType_Spec type_spec_PhotoImportSelectionChangedEventArgs = {
        "winrt._winrt_windows_media_import_.PhotoImportSelectionChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Import::PhotoImportSelectionChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoImportSelectionChangedEventArgs};

    // ----- PhotoImportSession class --------------------

    static PyObject* _new_PhotoImportSession(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Import::PhotoImportSession>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Import::PhotoImportSession>::type_name);
        return nullptr;
    }

    static void _dealloc_PhotoImportSession(py::wrapper::Windows::Media::Import::PhotoImportSession* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhotoImportSession_Close(py::wrapper::Windows::Media::Import::PhotoImportSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Import.PhotoImportSession", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhotoImportSession_FindItemsAsync(py::wrapper::Windows::Media::Import::PhotoImportSession* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Import.PhotoImportSession", L"FindItemsAsync", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Media::Import::PhotoImportContentTypeFilter>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Import::PhotoImportItemSelectionMode>(args, 1);

                return py::convert(self->obj.FindItemsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhotoImportSession_get_SubfolderCreationMode(py::wrapper::Windows::Media::Import::PhotoImportSession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSession", L"SubfolderCreationMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SubfolderCreationMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhotoImportSession_put_SubfolderCreationMode(py::wrapper::Windows::Media::Import::PhotoImportSession* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSession", L"SubfolderCreationMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Import::PhotoImportSubfolderCreationMode>(arg);

            self->obj.SubfolderCreationMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhotoImportSession_get_DestinationFolder(py::wrapper::Windows::Media::Import::PhotoImportSession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSession", L"DestinationFolder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DestinationFolder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhotoImportSession_put_DestinationFolder(py::wrapper::Windows::Media::Import::PhotoImportSession* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSession", L"DestinationFolder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(arg);

            self->obj.DestinationFolder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhotoImportSession_get_DestinationFileNamePrefix(py::wrapper::Windows::Media::Import::PhotoImportSession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSession", L"DestinationFileNamePrefix");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DestinationFileNamePrefix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhotoImportSession_put_DestinationFileNamePrefix(py::wrapper::Windows::Media::Import::PhotoImportSession* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSession", L"DestinationFileNamePrefix");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DestinationFileNamePrefix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhotoImportSession_get_AppendSessionDateToDestinationFolder(py::wrapper::Windows::Media::Import::PhotoImportSession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSession", L"AppendSessionDateToDestinationFolder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AppendSessionDateToDestinationFolder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhotoImportSession_put_AppendSessionDateToDestinationFolder(py::wrapper::Windows::Media::Import::PhotoImportSession* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSession", L"AppendSessionDateToDestinationFolder");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.AppendSessionDateToDestinationFolder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhotoImportSession_get_SessionId(py::wrapper::Windows::Media::Import::PhotoImportSession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSession", L"SessionId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SessionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportSession_get_Source(py::wrapper::Windows::Media::Import::PhotoImportSession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSession", L"Source");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportSession_get_SubfolderDateFormat(py::wrapper::Windows::Media::Import::PhotoImportSession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSession", L"SubfolderDateFormat");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SubfolderDateFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhotoImportSession_put_SubfolderDateFormat(py::wrapper::Windows::Media::Import::PhotoImportSession* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSession", L"SubfolderDateFormat");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Media::Import::PhotoImportSubfolderDateFormat>(arg);

            self->obj.SubfolderDateFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhotoImportSession_get_RememberDeselectedItems(py::wrapper::Windows::Media::Import::PhotoImportSession* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSession", L"RememberDeselectedItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.RememberDeselectedItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhotoImportSession_put_RememberDeselectedItems(py::wrapper::Windows::Media::Import::PhotoImportSession* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSession", L"RememberDeselectedItems");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            self->obj.RememberDeselectedItems(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_PhotoImportSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Import::PhotoImportSession>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhotoImportSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Import::PhotoImportSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_PhotoImportSession(py::wrapper::Windows::Media::Import::PhotoImportSession* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_PhotoImportSession(py::wrapper::Windows::Media::Import::PhotoImportSession* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhotoImportSession[] = {
        { "close", reinterpret_cast<PyCFunction>(PhotoImportSession_Close), METH_VARARGS, nullptr },
        { "find_items_async", reinterpret_cast<PyCFunction>(PhotoImportSession_FindItemsAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PhotoImportSession, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhotoImportSession), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_PhotoImportSession), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_PhotoImportSession), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhotoImportSession[] = {
        { "subfolder_creation_mode", reinterpret_cast<getter>(PhotoImportSession_get_SubfolderCreationMode), reinterpret_cast<setter>(PhotoImportSession_put_SubfolderCreationMode), nullptr, nullptr },
        { "destination_folder", reinterpret_cast<getter>(PhotoImportSession_get_DestinationFolder), reinterpret_cast<setter>(PhotoImportSession_put_DestinationFolder), nullptr, nullptr },
        { "destination_file_name_prefix", reinterpret_cast<getter>(PhotoImportSession_get_DestinationFileNamePrefix), reinterpret_cast<setter>(PhotoImportSession_put_DestinationFileNamePrefix), nullptr, nullptr },
        { "append_session_date_to_destination_folder", reinterpret_cast<getter>(PhotoImportSession_get_AppendSessionDateToDestinationFolder), reinterpret_cast<setter>(PhotoImportSession_put_AppendSessionDateToDestinationFolder), nullptr, nullptr },
        { "session_id", reinterpret_cast<getter>(PhotoImportSession_get_SessionId), nullptr, nullptr, nullptr },
        { "source", reinterpret_cast<getter>(PhotoImportSession_get_Source), nullptr, nullptr, nullptr },
        { "subfolder_date_format", reinterpret_cast<getter>(PhotoImportSession_get_SubfolderDateFormat), reinterpret_cast<setter>(PhotoImportSession_put_SubfolderDateFormat), nullptr, nullptr },
        { "remember_deselected_items", reinterpret_cast<getter>(PhotoImportSession_get_RememberDeselectedItems), reinterpret_cast<setter>(PhotoImportSession_put_RememberDeselectedItems), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhotoImportSession[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhotoImportSession) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhotoImportSession) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhotoImportSession) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhotoImportSession) },
        { }
    };

    static PyType_Spec type_spec_PhotoImportSession = {
        "winrt._winrt_windows_media_import_.PhotoImportSession",
        sizeof(py::wrapper::Windows::Media::Import::PhotoImportSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoImportSession};

    // ----- PhotoImportSidecar class --------------------

    static PyObject* _new_PhotoImportSidecar(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Import::PhotoImportSidecar>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Import::PhotoImportSidecar>::type_name);
        return nullptr;
    }

    static void _dealloc_PhotoImportSidecar(py::wrapper::Windows::Media::Import::PhotoImportSidecar* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhotoImportSidecar_get_Date(py::wrapper::Windows::Media::Import::PhotoImportSidecar* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSidecar", L"Date");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Date());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportSidecar_get_Name(py::wrapper::Windows::Media::Import::PhotoImportSidecar* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSidecar", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportSidecar_get_SizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportSidecar* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSidecar", L"SizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhotoImportSidecar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Import::PhotoImportSidecar>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhotoImportSidecar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Import::PhotoImportSidecar>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhotoImportSidecar[] = {
        { "_assign_array_", _assign_array_PhotoImportSidecar, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhotoImportSidecar), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhotoImportSidecar[] = {
        { "date", reinterpret_cast<getter>(PhotoImportSidecar_get_Date), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(PhotoImportSidecar_get_Name), nullptr, nullptr, nullptr },
        { "size_in_bytes", reinterpret_cast<getter>(PhotoImportSidecar_get_SizeInBytes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhotoImportSidecar[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhotoImportSidecar) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhotoImportSidecar) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhotoImportSidecar) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhotoImportSidecar) },
        { }
    };

    static PyType_Spec type_spec_PhotoImportSidecar = {
        "winrt._winrt_windows_media_import_.PhotoImportSidecar",
        sizeof(py::wrapper::Windows::Media::Import::PhotoImportSidecar),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoImportSidecar};

    // ----- PhotoImportSource class --------------------

    static PyObject* _new_PhotoImportSource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Import::PhotoImportSource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Import::PhotoImportSource>::type_name);
        return nullptr;
    }

    static void _dealloc_PhotoImportSource(py::wrapper::Windows::Media::Import::PhotoImportSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhotoImportSource_CreateImportSession(py::wrapper::Windows::Media::Import::PhotoImportSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Import.PhotoImportSource", L"CreateImportSession", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert(self->obj.CreateImportSession());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhotoImportSource_FromFolderAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Import.PhotoImportSource", L"FromFolderAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);

                return py::convert(winrt::Windows::Media::Import::PhotoImportSource::FromFolderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhotoImportSource_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Import.PhotoImportSource", L"FromIdAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Media::Import::PhotoImportSource::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhotoImportSource_get_BatteryLevelPercent(py::wrapper::Windows::Media::Import::PhotoImportSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSource", L"BatteryLevelPercent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.BatteryLevelPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportSource_get_ConnectionProtocol(py::wrapper::Windows::Media::Import::PhotoImportSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSource", L"ConnectionProtocol");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ConnectionProtocol());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportSource_get_ConnectionTransport(py::wrapper::Windows::Media::Import::PhotoImportSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSource", L"ConnectionTransport");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.ConnectionTransport());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportSource_get_DateTime(py::wrapper::Windows::Media::Import::PhotoImportSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSource", L"DateTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DateTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportSource_get_Description(py::wrapper::Windows::Media::Import::PhotoImportSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSource", L"Description");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportSource_get_DisplayName(py::wrapper::Windows::Media::Import::PhotoImportSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSource", L"DisplayName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportSource_get_Id(py::wrapper::Windows::Media::Import::PhotoImportSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSource", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportSource_get_IsLocked(py::wrapper::Windows::Media::Import::PhotoImportSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSource", L"IsLocked");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsLocked());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportSource_get_IsMassStorage(py::wrapper::Windows::Media::Import::PhotoImportSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSource", L"IsMassStorage");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.IsMassStorage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportSource_get_Manufacturer(py::wrapper::Windows::Media::Import::PhotoImportSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSource", L"Manufacturer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Manufacturer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportSource_get_Model(py::wrapper::Windows::Media::Import::PhotoImportSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSource", L"Model");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Model());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportSource_get_PowerSource(py::wrapper::Windows::Media::Import::PhotoImportSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSource", L"PowerSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.PowerSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportSource_get_SerialNumber(py::wrapper::Windows::Media::Import::PhotoImportSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSource", L"SerialNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SerialNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportSource_get_StorageMedia(py::wrapper::Windows::Media::Import::PhotoImportSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSource", L"StorageMedia");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StorageMedia());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportSource_get_Thumbnail(py::wrapper::Windows::Media::Import::PhotoImportSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSource", L"Thumbnail");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Thumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportSource_get_Type(py::wrapper::Windows::Media::Import::PhotoImportSource* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportSource", L"Type");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhotoImportSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Import::PhotoImportSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhotoImportSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Import::PhotoImportSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhotoImportSource[] = {
        { "create_import_session", reinterpret_cast<PyCFunction>(PhotoImportSource_CreateImportSession), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PhotoImportSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhotoImportSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhotoImportSource[] = {
        { "battery_level_percent", reinterpret_cast<getter>(PhotoImportSource_get_BatteryLevelPercent), nullptr, nullptr, nullptr },
        { "connection_protocol", reinterpret_cast<getter>(PhotoImportSource_get_ConnectionProtocol), nullptr, nullptr, nullptr },
        { "connection_transport", reinterpret_cast<getter>(PhotoImportSource_get_ConnectionTransport), nullptr, nullptr, nullptr },
        { "date_time", reinterpret_cast<getter>(PhotoImportSource_get_DateTime), nullptr, nullptr, nullptr },
        { "description", reinterpret_cast<getter>(PhotoImportSource_get_Description), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(PhotoImportSource_get_DisplayName), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(PhotoImportSource_get_Id), nullptr, nullptr, nullptr },
        { "is_locked", reinterpret_cast<getter>(PhotoImportSource_get_IsLocked), nullptr, nullptr, nullptr },
        { "is_mass_storage", reinterpret_cast<getter>(PhotoImportSource_get_IsMassStorage), nullptr, nullptr, nullptr },
        { "manufacturer", reinterpret_cast<getter>(PhotoImportSource_get_Manufacturer), nullptr, nullptr, nullptr },
        { "model", reinterpret_cast<getter>(PhotoImportSource_get_Model), nullptr, nullptr, nullptr },
        { "power_source", reinterpret_cast<getter>(PhotoImportSource_get_PowerSource), nullptr, nullptr, nullptr },
        { "serial_number", reinterpret_cast<getter>(PhotoImportSource_get_SerialNumber), nullptr, nullptr, nullptr },
        { "storage_media", reinterpret_cast<getter>(PhotoImportSource_get_StorageMedia), nullptr, nullptr, nullptr },
        { "thumbnail", reinterpret_cast<getter>(PhotoImportSource_get_Thumbnail), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(PhotoImportSource_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhotoImportSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhotoImportSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhotoImportSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhotoImportSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhotoImportSource) },
        { }
    };

    static PyType_Spec type_spec_PhotoImportSource = {
        "winrt._winrt_windows_media_import_.PhotoImportSource",
        sizeof(py::wrapper::Windows::Media::Import::PhotoImportSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoImportSource};

    static PyGetSetDef getset_PhotoImportSource_Static[] = {
        { }
    };

    static PyMethodDef methods_PhotoImportSource_Static[] = {
        { "from_folder_async", reinterpret_cast<PyCFunction>(PhotoImportSource_FromFolderAsync), METH_VARARGS, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(PhotoImportSource_FromIdAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_PhotoImportSource_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PhotoImportSource_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PhotoImportSource_Static) },
        { }
    };

    static PyType_Spec type_spec_PhotoImportSource_Static =
    {
        "winrt._winrt_windows_media_import_.PhotoImportSource_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PhotoImportSource_Static
    };

    // ----- PhotoImportStorageMedium class --------------------

    static PyObject* _new_PhotoImportStorageMedium(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Import::PhotoImportStorageMedium>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Import::PhotoImportStorageMedium>::type_name);
        return nullptr;
    }

    static void _dealloc_PhotoImportStorageMedium(py::wrapper::Windows::Media::Import::PhotoImportStorageMedium* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhotoImportStorageMedium_Refresh(py::wrapper::Windows::Media::Import::PhotoImportStorageMedium* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Import.PhotoImportStorageMedium", L"Refresh", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                self->obj.Refresh();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhotoImportStorageMedium_get_AvailableSpaceInBytes(py::wrapper::Windows::Media::Import::PhotoImportStorageMedium* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportStorageMedium", L"AvailableSpaceInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.AvailableSpaceInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportStorageMedium_get_CapacityInBytes(py::wrapper::Windows::Media::Import::PhotoImportStorageMedium* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportStorageMedium", L"CapacityInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.CapacityInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportStorageMedium_get_Description(py::wrapper::Windows::Media::Import::PhotoImportStorageMedium* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportStorageMedium", L"Description");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportStorageMedium_get_Name(py::wrapper::Windows::Media::Import::PhotoImportStorageMedium* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportStorageMedium", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportStorageMedium_get_SerialNumber(py::wrapper::Windows::Media::Import::PhotoImportStorageMedium* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportStorageMedium", L"SerialNumber");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SerialNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportStorageMedium_get_StorageMediumType(py::wrapper::Windows::Media::Import::PhotoImportStorageMedium* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportStorageMedium", L"StorageMediumType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.StorageMediumType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportStorageMedium_get_SupportedAccessMode(py::wrapper::Windows::Media::Import::PhotoImportStorageMedium* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportStorageMedium", L"SupportedAccessMode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SupportedAccessMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhotoImportStorageMedium(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Import::PhotoImportStorageMedium>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhotoImportStorageMedium(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Import::PhotoImportStorageMedium>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhotoImportStorageMedium[] = {
        { "refresh", reinterpret_cast<PyCFunction>(PhotoImportStorageMedium_Refresh), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PhotoImportStorageMedium, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhotoImportStorageMedium), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhotoImportStorageMedium[] = {
        { "available_space_in_bytes", reinterpret_cast<getter>(PhotoImportStorageMedium_get_AvailableSpaceInBytes), nullptr, nullptr, nullptr },
        { "capacity_in_bytes", reinterpret_cast<getter>(PhotoImportStorageMedium_get_CapacityInBytes), nullptr, nullptr, nullptr },
        { "description", reinterpret_cast<getter>(PhotoImportStorageMedium_get_Description), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(PhotoImportStorageMedium_get_Name), nullptr, nullptr, nullptr },
        { "serial_number", reinterpret_cast<getter>(PhotoImportStorageMedium_get_SerialNumber), nullptr, nullptr, nullptr },
        { "storage_medium_type", reinterpret_cast<getter>(PhotoImportStorageMedium_get_StorageMediumType), nullptr, nullptr, nullptr },
        { "supported_access_mode", reinterpret_cast<getter>(PhotoImportStorageMedium_get_SupportedAccessMode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhotoImportStorageMedium[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhotoImportStorageMedium) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhotoImportStorageMedium) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhotoImportStorageMedium) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhotoImportStorageMedium) },
        { }
    };

    static PyType_Spec type_spec_PhotoImportStorageMedium = {
        "winrt._winrt_windows_media_import_.PhotoImportStorageMedium",
        sizeof(py::wrapper::Windows::Media::Import::PhotoImportStorageMedium),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoImportStorageMedium};

    // ----- PhotoImportVideoSegment class --------------------

    static PyObject* _new_PhotoImportVideoSegment(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Import::PhotoImportVideoSegment>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Import::PhotoImportVideoSegment>::type_name);
        return nullptr;
    }

    static void _dealloc_PhotoImportVideoSegment(py::wrapper::Windows::Media::Import::PhotoImportVideoSegment* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhotoImportVideoSegment_get_Date(py::wrapper::Windows::Media::Import::PhotoImportVideoSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportVideoSegment", L"Date");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Date());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportVideoSegment_get_Name(py::wrapper::Windows::Media::Import::PhotoImportVideoSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportVideoSegment", L"Name");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportVideoSegment_get_Sibling(py::wrapper::Windows::Media::Import::PhotoImportVideoSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportVideoSegment", L"Sibling");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Sibling());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportVideoSegment_get_Sidecars(py::wrapper::Windows::Media::Import::PhotoImportVideoSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportVideoSegment", L"Sidecars");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.Sidecars());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoImportVideoSegment_get_SizeInBytes(py::wrapper::Windows::Media::Import::PhotoImportVideoSegment* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Import.PhotoImportVideoSegment", L"SizeInBytes");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert(self->obj.SizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PhotoImportVideoSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Import::PhotoImportVideoSegment>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PhotoImportVideoSegment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Import::PhotoImportVideoSegment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhotoImportVideoSegment[] = {
        { "_assign_array_", _assign_array_PhotoImportVideoSegment, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhotoImportVideoSegment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhotoImportVideoSegment[] = {
        { "date", reinterpret_cast<getter>(PhotoImportVideoSegment_get_Date), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(PhotoImportVideoSegment_get_Name), nullptr, nullptr, nullptr },
        { "sibling", reinterpret_cast<getter>(PhotoImportVideoSegment_get_Sibling), nullptr, nullptr, nullptr },
        { "sidecars", reinterpret_cast<getter>(PhotoImportVideoSegment_get_Sidecars), nullptr, nullptr, nullptr },
        { "size_in_bytes", reinterpret_cast<getter>(PhotoImportVideoSegment_get_SizeInBytes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhotoImportVideoSegment[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhotoImportVideoSegment) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhotoImportVideoSegment) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhotoImportVideoSegment) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhotoImportVideoSegment) },
        { }
    };

    static PyType_Spec type_spec_PhotoImportVideoSegment = {
        "winrt._winrt_windows_media_import_.PhotoImportVideoSegment",
        sizeof(py::wrapper::Windows::Media::Import::PhotoImportVideoSegment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoImportVideoSegment};

    // ----- PhotoImportProgress struct --------------------

    winrt_struct_wrapper<winrt::Windows::Media::Import::PhotoImportProgress>* _new_PhotoImportProgress(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Windows::Media::Import::PhotoImportProgress>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_PhotoImportProgress(winrt_struct_wrapper<winrt::Windows::Media::Import::PhotoImportProgress>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        uint32_t _ItemsImported{};
        uint32_t _TotalItemsToImport{};
        uint64_t _BytesImported{};
        uint64_t _TotalBytesToImport{};
        double _ImportProgress{};

        static const char* kwlist[] = {"items_imported", "total_items_to_import", "bytes_imported", "total_bytes_to_import", "import_progress", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "IIKKd", const_cast<char**>(kwlist), &_ItemsImported, &_TotalItemsToImport, &_BytesImported, &_TotalBytesToImport, &_ImportProgress))
        {
            return -1;
        }

        try
        {
            self->obj.ItemsImported = _ItemsImported;
            self->obj.TotalItemsToImport = _TotalItemsToImport;
            self->obj.BytesImported = _BytesImported;
            self->obj.TotalBytesToImport = _TotalBytesToImport;
            self->obj.ImportProgress = _ImportProgress;

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_PhotoImportProgress(py::wrapper::Windows::Media::Import::PhotoImportProgress* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PhotoImportProgress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Import::PhotoImportProgress>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_PhotoImportProgress[] = {
        { "_assign_array_", _assign_array_PhotoImportProgress, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* PhotoImportProgress_get_ItemsImported(py::wrapper::Windows::Media::Import::PhotoImportProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ItemsImported);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhotoImportProgress_set_ItemsImported(py::wrapper::Windows::Media::Import::PhotoImportProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.ItemsImported = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhotoImportProgress_get_TotalItemsToImport(py::wrapper::Windows::Media::Import::PhotoImportProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TotalItemsToImport);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhotoImportProgress_set_TotalItemsToImport(py::wrapper::Windows::Media::Import::PhotoImportProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.TotalItemsToImport = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhotoImportProgress_get_BytesImported(py::wrapper::Windows::Media::Import::PhotoImportProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesImported);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhotoImportProgress_set_BytesImported(py::wrapper::Windows::Media::Import::PhotoImportProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.BytesImported = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhotoImportProgress_get_TotalBytesToImport(py::wrapper::Windows::Media::Import::PhotoImportProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TotalBytesToImport);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhotoImportProgress_set_TotalBytesToImport(py::wrapper::Windows::Media::Import::PhotoImportProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.TotalBytesToImport = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhotoImportProgress_get_ImportProgress(py::wrapper::Windows::Media::Import::PhotoImportProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ImportProgress);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhotoImportProgress_set_ImportProgress(py::wrapper::Windows::Media::Import::PhotoImportProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.ImportProgress = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_PhotoImportProgress[] = {
        { "items_imported", reinterpret_cast<getter>(PhotoImportProgress_get_ItemsImported), reinterpret_cast<setter>(PhotoImportProgress_set_ItemsImported), nullptr, nullptr },
        { "total_items_to_import", reinterpret_cast<getter>(PhotoImportProgress_get_TotalItemsToImport), reinterpret_cast<setter>(PhotoImportProgress_set_TotalItemsToImport), nullptr, nullptr },
        { "bytes_imported", reinterpret_cast<getter>(PhotoImportProgress_get_BytesImported), reinterpret_cast<setter>(PhotoImportProgress_set_BytesImported), nullptr, nullptr },
        { "total_bytes_to_import", reinterpret_cast<getter>(PhotoImportProgress_get_TotalBytesToImport), reinterpret_cast<setter>(PhotoImportProgress_set_TotalBytesToImport), nullptr, nullptr },
        { "import_progress", reinterpret_cast<getter>(PhotoImportProgress_get_ImportProgress), reinterpret_cast<setter>(PhotoImportProgress_set_ImportProgress), nullptr, nullptr },
        { }
    };

    static PyObject* _richcompare_PhotoImportProgress(py::wrapper::Windows::Media::Import::PhotoImportProgress* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::converter<winrt::Windows::Media::Import::PhotoImportProgress>::convert_to(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_PhotoImportProgress(PyObject* self) noexcept
    {
        py::pyobj_handle ItemsImported{PyObject_GetAttrString(self, "items_imported")};
        if (!ItemsImported)
        {
            return nullptr;
        }

        py::pyobj_handle TotalItemsToImport{PyObject_GetAttrString(self, "total_items_to_import")};
        if (!TotalItemsToImport)
        {
            return nullptr;
        }

        py::pyobj_handle BytesImported{PyObject_GetAttrString(self, "bytes_imported")};
        if (!BytesImported)
        {
            return nullptr;
        }

        py::pyobj_handle TotalBytesToImport{PyObject_GetAttrString(self, "total_bytes_to_import")};
        if (!TotalBytesToImport)
        {
            return nullptr;
        }

        py::pyobj_handle ImportProgress{PyObject_GetAttrString(self, "import_progress")};
        if (!ImportProgress)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("PhotoImportProgress(items_imported=%R, total_items_to_import=%R, bytes_imported=%R, total_bytes_to_import=%R, import_progress=%R)", ItemsImported.get(), TotalItemsToImport.get(), BytesImported.get(), TotalBytesToImport.get(), ImportProgress.get());
    }

    static PyType_Slot _type_slots_PhotoImportProgress[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PhotoImportProgress) },
        { Py_tp_init, reinterpret_cast<void*>(_init_PhotoImportProgress) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PhotoImportProgress) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PhotoImportProgress) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PhotoImportProgress) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_PhotoImportProgress) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_PhotoImportProgress) },
        { }
    };

    static PyType_Spec type_spec_PhotoImportProgress = {
        "winrt._winrt_windows_media_import_.PhotoImportProgress",
        sizeof(py::wrapper::Windows::Media::Import::PhotoImportProgress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoImportProgress};

    // ----- Windows.Media.Import Initialization --------------------

    PyDoc_STRVAR(module_doc, "Windows.Media.Import");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winrt_windows_media_import_",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Windows::Media::Import

PyMODINIT_FUNC PyInit__winrt_windows_media_import_(void) noexcept
{
    using namespace py::cpp::Windows::Media::Import;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle PhotoImportDeleteImportedItemsFromSourceResult_type{py::register_python_type(module.get(), &type_spec_PhotoImportDeleteImportedItemsFromSourceResult, object_bases.get(), nullptr)};
    if (!PhotoImportDeleteImportedItemsFromSourceResult_type)
    {
        return nullptr;
    }

    py::pytype_handle PhotoImportFindItemsResult_type{py::register_python_type(module.get(), &type_spec_PhotoImportFindItemsResult, object_bases.get(), nullptr)};
    if (!PhotoImportFindItemsResult_type)
    {
        return nullptr;
    }

    py::pytype_handle PhotoImportImportItemsResult_type{py::register_python_type(module.get(), &type_spec_PhotoImportImportItemsResult, object_bases.get(), nullptr)};
    if (!PhotoImportImportItemsResult_type)
    {
        return nullptr;
    }

    py::pytype_handle PhotoImportItem_type{py::register_python_type(module.get(), &type_spec_PhotoImportItem, object_bases.get(), nullptr)};
    if (!PhotoImportItem_type)
    {
        return nullptr;
    }

    py::pytype_handle PhotoImportItemImportedEventArgs_type{py::register_python_type(module.get(), &type_spec_PhotoImportItemImportedEventArgs, object_bases.get(), nullptr)};
    if (!PhotoImportItemImportedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_PhotoImportManager_Static{PyType_FromSpec(&type_spec_PhotoImportManager_Static)};
    if (!type_PhotoImportManager_Static)
    {
        return nullptr;
    }

    py::pytype_handle PhotoImportManager_type{py::register_python_type(module.get(), &type_spec_PhotoImportManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PhotoImportManager_Static.get()))};
    if (!PhotoImportManager_type)
    {
        return nullptr;
    }

    py::pytype_handle PhotoImportOperation_type{py::register_python_type(module.get(), &type_spec_PhotoImportOperation, object_bases.get(), nullptr)};
    if (!PhotoImportOperation_type)
    {
        return nullptr;
    }

    py::pytype_handle PhotoImportSelectionChangedEventArgs_type{py::register_python_type(module.get(), &type_spec_PhotoImportSelectionChangedEventArgs, object_bases.get(), nullptr)};
    if (!PhotoImportSelectionChangedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle PhotoImportSession_type{py::register_python_type(module.get(), &type_spec_PhotoImportSession, object_bases.get(), nullptr)};
    if (!PhotoImportSession_type)
    {
        return nullptr;
    }

    py::pytype_handle PhotoImportSidecar_type{py::register_python_type(module.get(), &type_spec_PhotoImportSidecar, object_bases.get(), nullptr)};
    if (!PhotoImportSidecar_type)
    {
        return nullptr;
    }

    py::pyobj_handle type_PhotoImportSource_Static{PyType_FromSpec(&type_spec_PhotoImportSource_Static)};
    if (!type_PhotoImportSource_Static)
    {
        return nullptr;
    }

    py::pytype_handle PhotoImportSource_type{py::register_python_type(module.get(), &type_spec_PhotoImportSource, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PhotoImportSource_Static.get()))};
    if (!PhotoImportSource_type)
    {
        return nullptr;
    }

    py::pytype_handle PhotoImportStorageMedium_type{py::register_python_type(module.get(), &type_spec_PhotoImportStorageMedium, object_bases.get(), nullptr)};
    if (!PhotoImportStorageMedium_type)
    {
        return nullptr;
    }

    py::pytype_handle PhotoImportVideoSegment_type{py::register_python_type(module.get(), &type_spec_PhotoImportVideoSegment, object_bases.get(), nullptr)};
    if (!PhotoImportVideoSegment_type)
    {
        return nullptr;
    }

    py::pytype_handle PhotoImportProgress_type{py::register_python_type(module.get(), &type_spec_PhotoImportProgress, nullptr, nullptr)};
    if (!PhotoImportProgress_type)
    {
        return nullptr;
    }


    return module.detach();
}
