// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.1

#include "py.Windows.Media.Audio.h"


namespace py::cpp::Windows::Media::Audio
{
    // ----- AudioDeviceInputNode class --------------------

    static PyObject* _new_AudioDeviceInputNode(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::AudioDeviceInputNode>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::AudioDeviceInputNode>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioDeviceInputNode(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioDeviceInputNode_AddOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"AddOutgoingConnection", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.AddOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"AddOutgoingConnection", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.AddOutgoingConnection(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_Close(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"DisableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"EnableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_RemoveOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"RemoveOutgoingConnection", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.RemoveOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_Reset(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"Reset", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_Start(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_Stop(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_get_Device(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"Device"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Device());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_get_OutgoingConnections(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"OutgoingConnections"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingConnections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_get_Emitter(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"Emitter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Emitter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioDeviceInputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioDeviceInputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioDeviceInputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioDeviceInputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"EffectDefinitions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceInputNode", L"EncodingProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioDeviceInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioDeviceInputNode>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioDeviceInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioDeviceInputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioDeviceInputNode(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_AudioDeviceInputNode(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioDeviceInputNode[] = {
        { "add_outgoing_connection", reinterpret_cast<PyCFunction>(AudioDeviceInputNode_AddOutgoingConnection), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(AudioDeviceInputNode_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioDeviceInputNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioDeviceInputNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "remove_outgoing_connection", reinterpret_cast<PyCFunction>(AudioDeviceInputNode_RemoveOutgoingConnection), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(AudioDeviceInputNode_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(AudioDeviceInputNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(AudioDeviceInputNode_Stop), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AudioDeviceInputNode, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioDeviceInputNode), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioDeviceInputNode), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_AudioDeviceInputNode), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioDeviceInputNode[] = {
        { "device", reinterpret_cast<getter>(AudioDeviceInputNode_get_Device), nullptr, nullptr, nullptr },
        { "outgoing_connections", reinterpret_cast<getter>(AudioDeviceInputNode_get_OutgoingConnections), nullptr, nullptr, nullptr },
        { "emitter", reinterpret_cast<getter>(AudioDeviceInputNode_get_Emitter), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(AudioDeviceInputNode_get_OutgoingGain), reinterpret_cast<setter>(AudioDeviceInputNode_put_OutgoingGain), nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(AudioDeviceInputNode_get_ConsumeInput), reinterpret_cast<setter>(AudioDeviceInputNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(AudioDeviceInputNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(AudioDeviceInputNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioDeviceInputNode[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioDeviceInputNode) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioDeviceInputNode) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioDeviceInputNode) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioDeviceInputNode) },
        { },
    };

    static PyType_Spec type_spec_AudioDeviceInputNode =
    {
        "winrt._winrt_windows_media_audio.AudioDeviceInputNode",
        sizeof(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioDeviceInputNode
    };

    // ----- AudioDeviceOutputNode class --------------------

    static PyObject* _new_AudioDeviceOutputNode(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::AudioDeviceOutputNode>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::AudioDeviceOutputNode>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioDeviceOutputNode(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioDeviceOutputNode_Close(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"DisableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"EnableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_Reset(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"Reset", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_Start(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_Stop(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_get_Device(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"Device"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Device());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioDeviceOutputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioDeviceOutputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioDeviceOutputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioDeviceOutputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"EffectDefinitions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"EncodingProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_get_Listener(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"Listener"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Listener());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioDeviceOutputNode_put_Listener(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioDeviceOutputNode", L"Listener"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeListener>(arg);

            self->obj.Listener(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AudioDeviceOutputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioDeviceOutputNode>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioDeviceOutputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioDeviceOutputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioDeviceOutputNode(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_AudioDeviceOutputNode(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioDeviceOutputNode[] = {
        { "close", reinterpret_cast<PyCFunction>(AudioDeviceOutputNode_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioDeviceOutputNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioDeviceOutputNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(AudioDeviceOutputNode_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(AudioDeviceOutputNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(AudioDeviceOutputNode_Stop), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AudioDeviceOutputNode, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioDeviceOutputNode), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioDeviceOutputNode), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_AudioDeviceOutputNode), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioDeviceOutputNode[] = {
        { "device", reinterpret_cast<getter>(AudioDeviceOutputNode_get_Device), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(AudioDeviceOutputNode_get_OutgoingGain), reinterpret_cast<setter>(AudioDeviceOutputNode_put_OutgoingGain), nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(AudioDeviceOutputNode_get_ConsumeInput), reinterpret_cast<setter>(AudioDeviceOutputNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(AudioDeviceOutputNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(AudioDeviceOutputNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { "listener", reinterpret_cast<getter>(AudioDeviceOutputNode_get_Listener), reinterpret_cast<setter>(AudioDeviceOutputNode_put_Listener), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioDeviceOutputNode[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioDeviceOutputNode) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioDeviceOutputNode) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioDeviceOutputNode) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioDeviceOutputNode) },
        { },
    };

    static PyType_Spec type_spec_AudioDeviceOutputNode =
    {
        "winrt._winrt_windows_media_audio.AudioDeviceOutputNode",
        sizeof(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioDeviceOutputNode
    };

    // ----- AudioFileInputNode class --------------------

    static PyObject* _new_AudioFileInputNode(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::AudioFileInputNode>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::AudioFileInputNode>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioFileInputNode(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioFileInputNode_AddOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileInputNode", L"AddOutgoingConnection", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.AddOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileInputNode", L"AddOutgoingConnection", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.AddOutgoingConnection(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_Close(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileInputNode", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileInputNode", L"DisableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileInputNode", L"EnableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_RemoveOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileInputNode", L"RemoveOutgoingConnection", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.RemoveOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_Reset(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileInputNode", L"Reset", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_Seek(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileInputNode", L"Seek", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                self->obj.Seek(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_Start(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileInputNode", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_Stop(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileInputNode", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_get_PlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"PlaybackSpeedFactor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PlaybackSpeedFactor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileInputNode_put_PlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"PlaybackSpeedFactor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.PlaybackSpeedFactor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileInputNode_get_LoopCount(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"LoopCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LoopCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileInputNode_put_LoopCount(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"LoopCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.LoopCount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileInputNode_get_EndTime(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"EndTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileInputNode_put_EndTime(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"EndTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.EndTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileInputNode_get_StartTime(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"StartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileInputNode_put_StartTime(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"StartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileInputNode_get_Position(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_get_SourceFile(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"SourceFile"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SourceFile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_get_Duration(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_get_OutgoingConnections(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"OutgoingConnections"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingConnections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_get_Emitter(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"Emitter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Emitter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileInputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileInputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileInputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileInputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"EffectDefinitions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileInputNode", L"EncodingProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_add_FileCompleted(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioFileInputNode", L"FileCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioFileInputNode, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.FileCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_remove_FileCompleted(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioFileInputNode", L"FileCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FileCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioFileInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioFileInputNode>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioFileInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioFileInputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioFileInputNode(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_AudioFileInputNode(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioFileInputNode[] = {
        { "add_outgoing_connection", reinterpret_cast<PyCFunction>(AudioFileInputNode_AddOutgoingConnection), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(AudioFileInputNode_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioFileInputNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioFileInputNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "remove_outgoing_connection", reinterpret_cast<PyCFunction>(AudioFileInputNode_RemoveOutgoingConnection), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(AudioFileInputNode_Reset), METH_VARARGS, nullptr },
        { "seek", reinterpret_cast<PyCFunction>(AudioFileInputNode_Seek), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(AudioFileInputNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(AudioFileInputNode_Stop), METH_VARARGS, nullptr },
        { "add_file_completed", reinterpret_cast<PyCFunction>(AudioFileInputNode_add_FileCompleted), METH_O, nullptr },
        { "remove_file_completed", reinterpret_cast<PyCFunction>(AudioFileInputNode_remove_FileCompleted), METH_O, nullptr },
        { "_assign_array_", _assign_array_AudioFileInputNode, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioFileInputNode), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioFileInputNode), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_AudioFileInputNode), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioFileInputNode[] = {
        { "playback_speed_factor", reinterpret_cast<getter>(AudioFileInputNode_get_PlaybackSpeedFactor), reinterpret_cast<setter>(AudioFileInputNode_put_PlaybackSpeedFactor), nullptr, nullptr },
        { "loop_count", reinterpret_cast<getter>(AudioFileInputNode_get_LoopCount), reinterpret_cast<setter>(AudioFileInputNode_put_LoopCount), nullptr, nullptr },
        { "end_time", reinterpret_cast<getter>(AudioFileInputNode_get_EndTime), reinterpret_cast<setter>(AudioFileInputNode_put_EndTime), nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(AudioFileInputNode_get_StartTime), reinterpret_cast<setter>(AudioFileInputNode_put_StartTime), nullptr, nullptr },
        { "position", reinterpret_cast<getter>(AudioFileInputNode_get_Position), nullptr, nullptr, nullptr },
        { "source_file", reinterpret_cast<getter>(AudioFileInputNode_get_SourceFile), nullptr, nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(AudioFileInputNode_get_Duration), nullptr, nullptr, nullptr },
        { "outgoing_connections", reinterpret_cast<getter>(AudioFileInputNode_get_OutgoingConnections), nullptr, nullptr, nullptr },
        { "emitter", reinterpret_cast<getter>(AudioFileInputNode_get_Emitter), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(AudioFileInputNode_get_OutgoingGain), reinterpret_cast<setter>(AudioFileInputNode_put_OutgoingGain), nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(AudioFileInputNode_get_ConsumeInput), reinterpret_cast<setter>(AudioFileInputNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(AudioFileInputNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(AudioFileInputNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioFileInputNode[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioFileInputNode) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioFileInputNode) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioFileInputNode) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioFileInputNode) },
        { },
    };

    static PyType_Spec type_spec_AudioFileInputNode =
    {
        "winrt._winrt_windows_media_audio.AudioFileInputNode",
        sizeof(py::wrapper::Windows::Media::Audio::AudioFileInputNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioFileInputNode
    };

    // ----- AudioFileOutputNode class --------------------

    static PyObject* _new_AudioFileOutputNode(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::AudioFileOutputNode>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::AudioFileOutputNode>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioFileOutputNode(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioFileOutputNode_Close(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"DisableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"EnableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_FinalizeAsync(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"FinalizeAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.FinalizeAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_Reset(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"Reset", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_Start(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_Stop(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_get_File(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"File"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.File());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_get_FileEncodingProfile(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"FileEncodingProfile"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FileEncodingProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileOutputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileOutputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileOutputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileOutputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"EffectDefinitions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFileOutputNode", L"EncodingProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioFileOutputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioFileOutputNode>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioFileOutputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioFileOutputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioFileOutputNode(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_AudioFileOutputNode(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioFileOutputNode[] = {
        { "close", reinterpret_cast<PyCFunction>(AudioFileOutputNode_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioFileOutputNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioFileOutputNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "finalize_async", reinterpret_cast<PyCFunction>(AudioFileOutputNode_FinalizeAsync), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(AudioFileOutputNode_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(AudioFileOutputNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(AudioFileOutputNode_Stop), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AudioFileOutputNode, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioFileOutputNode), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioFileOutputNode), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_AudioFileOutputNode), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioFileOutputNode[] = {
        { "file", reinterpret_cast<getter>(AudioFileOutputNode_get_File), nullptr, nullptr, nullptr },
        { "file_encoding_profile", reinterpret_cast<getter>(AudioFileOutputNode_get_FileEncodingProfile), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(AudioFileOutputNode_get_OutgoingGain), reinterpret_cast<setter>(AudioFileOutputNode_put_OutgoingGain), nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(AudioFileOutputNode_get_ConsumeInput), reinterpret_cast<setter>(AudioFileOutputNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(AudioFileOutputNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(AudioFileOutputNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioFileOutputNode[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioFileOutputNode) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioFileOutputNode) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioFileOutputNode) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioFileOutputNode) },
        { },
    };

    static PyType_Spec type_spec_AudioFileOutputNode =
    {
        "winrt._winrt_windows_media_audio.AudioFileOutputNode",
        sizeof(py::wrapper::Windows::Media::Audio::AudioFileOutputNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioFileOutputNode
    };

    // ----- AudioFrameCompletedEventArgs class --------------------

    static PyObject* _new_AudioFrameCompletedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::AudioFrameCompletedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::AudioFrameCompletedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioFrameCompletedEventArgs(py::wrapper::Windows::Media::Audio::AudioFrameCompletedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioFrameCompletedEventArgs_get_Frame(py::wrapper::Windows::Media::Audio::AudioFrameCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameCompletedEventArgs", L"Frame"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Frame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioFrameCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioFrameCompletedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioFrameCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioFrameCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioFrameCompletedEventArgs[] = {
        { "_assign_array_", _assign_array_AudioFrameCompletedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioFrameCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioFrameCompletedEventArgs[] = {
        { "frame", reinterpret_cast<getter>(AudioFrameCompletedEventArgs_get_Frame), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioFrameCompletedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioFrameCompletedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioFrameCompletedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioFrameCompletedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioFrameCompletedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AudioFrameCompletedEventArgs =
    {
        "winrt._winrt_windows_media_audio.AudioFrameCompletedEventArgs",
        sizeof(py::wrapper::Windows::Media::Audio::AudioFrameCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioFrameCompletedEventArgs
    };

    // ----- AudioFrameInputNode class --------------------

    static PyObject* _new_AudioFrameInputNode(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::AudioFrameInputNode>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::AudioFrameInputNode>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioFrameInputNode(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioFrameInputNode_AddFrame(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"AddFrame", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::AudioFrame>(args, 0);

                self->obj.AddFrame(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_AddOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"AddOutgoingConnection", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.AddOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"AddOutgoingConnection", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.AddOutgoingConnection(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_Close(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"DisableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_DiscardQueuedFrames(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"DiscardQueuedFrames", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.DiscardQueuedFrames();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"EnableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_RemoveOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"RemoveOutgoingConnection", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.RemoveOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_Reset(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"Reset", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_Start(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_Stop(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_get_PlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"PlaybackSpeedFactor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PlaybackSpeedFactor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFrameInputNode_put_PlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"PlaybackSpeedFactor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.PlaybackSpeedFactor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFrameInputNode_get_QueuedSampleCount(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"QueuedSampleCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.QueuedSampleCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_get_OutgoingConnections(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"OutgoingConnections"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingConnections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_get_Emitter(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"Emitter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Emitter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFrameInputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFrameInputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFrameInputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFrameInputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"EffectDefinitions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"EncodingProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_add_AudioFrameCompleted(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"AudioFrameCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioFrameInputNode, winrt::Windows::Media::Audio::AudioFrameCompletedEventArgs>>(arg);

            return py::convert(self->obj.AudioFrameCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_remove_AudioFrameCompleted(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"AudioFrameCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AudioFrameCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_add_QuantumStarted(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"QuantumStarted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioFrameInputNode, winrt::Windows::Media::Audio::FrameInputNodeQuantumStartedEventArgs>>(arg);

            return py::convert(self->obj.QuantumStarted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_remove_QuantumStarted(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioFrameInputNode", L"QuantumStarted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.QuantumStarted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioFrameInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioFrameInputNode>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioFrameInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioFrameInputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioFrameInputNode(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_AudioFrameInputNode(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioFrameInputNode[] = {
        { "add_frame", reinterpret_cast<PyCFunction>(AudioFrameInputNode_AddFrame), METH_VARARGS, nullptr },
        { "add_outgoing_connection", reinterpret_cast<PyCFunction>(AudioFrameInputNode_AddOutgoingConnection), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(AudioFrameInputNode_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioFrameInputNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "discard_queued_frames", reinterpret_cast<PyCFunction>(AudioFrameInputNode_DiscardQueuedFrames), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioFrameInputNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "remove_outgoing_connection", reinterpret_cast<PyCFunction>(AudioFrameInputNode_RemoveOutgoingConnection), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(AudioFrameInputNode_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(AudioFrameInputNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(AudioFrameInputNode_Stop), METH_VARARGS, nullptr },
        { "add_audio_frame_completed", reinterpret_cast<PyCFunction>(AudioFrameInputNode_add_AudioFrameCompleted), METH_O, nullptr },
        { "remove_audio_frame_completed", reinterpret_cast<PyCFunction>(AudioFrameInputNode_remove_AudioFrameCompleted), METH_O, nullptr },
        { "add_quantum_started", reinterpret_cast<PyCFunction>(AudioFrameInputNode_add_QuantumStarted), METH_O, nullptr },
        { "remove_quantum_started", reinterpret_cast<PyCFunction>(AudioFrameInputNode_remove_QuantumStarted), METH_O, nullptr },
        { "_assign_array_", _assign_array_AudioFrameInputNode, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioFrameInputNode), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioFrameInputNode), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_AudioFrameInputNode), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioFrameInputNode[] = {
        { "playback_speed_factor", reinterpret_cast<getter>(AudioFrameInputNode_get_PlaybackSpeedFactor), reinterpret_cast<setter>(AudioFrameInputNode_put_PlaybackSpeedFactor), nullptr, nullptr },
        { "queued_sample_count", reinterpret_cast<getter>(AudioFrameInputNode_get_QueuedSampleCount), nullptr, nullptr, nullptr },
        { "outgoing_connections", reinterpret_cast<getter>(AudioFrameInputNode_get_OutgoingConnections), nullptr, nullptr, nullptr },
        { "emitter", reinterpret_cast<getter>(AudioFrameInputNode_get_Emitter), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(AudioFrameInputNode_get_OutgoingGain), reinterpret_cast<setter>(AudioFrameInputNode_put_OutgoingGain), nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(AudioFrameInputNode_get_ConsumeInput), reinterpret_cast<setter>(AudioFrameInputNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(AudioFrameInputNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(AudioFrameInputNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioFrameInputNode[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioFrameInputNode) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioFrameInputNode) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioFrameInputNode) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioFrameInputNode) },
        { },
    };

    static PyType_Spec type_spec_AudioFrameInputNode =
    {
        "winrt._winrt_windows_media_audio.AudioFrameInputNode",
        sizeof(py::wrapper::Windows::Media::Audio::AudioFrameInputNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioFrameInputNode
    };

    // ----- AudioFrameOutputNode class --------------------

    static PyObject* _new_AudioFrameOutputNode(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::AudioFrameOutputNode>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::AudioFrameOutputNode>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioFrameOutputNode(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioFrameOutputNode_Close(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameOutputNode", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameOutputNode", L"DisableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameOutputNode", L"EnableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_GetFrame(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameOutputNode", L"GetFrame", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.GetFrame());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_Reset(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameOutputNode", L"Reset", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_Start(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameOutputNode", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_Stop(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioFrameOutputNode", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameOutputNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFrameOutputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameOutputNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFrameOutputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameOutputNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFrameOutputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameOutputNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFrameOutputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameOutputNode", L"EffectDefinitions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioFrameOutputNode", L"EncodingProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioFrameOutputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioFrameOutputNode>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioFrameOutputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioFrameOutputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioFrameOutputNode(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_AudioFrameOutputNode(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioFrameOutputNode[] = {
        { "close", reinterpret_cast<PyCFunction>(AudioFrameOutputNode_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioFrameOutputNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioFrameOutputNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "get_frame", reinterpret_cast<PyCFunction>(AudioFrameOutputNode_GetFrame), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(AudioFrameOutputNode_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(AudioFrameOutputNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(AudioFrameOutputNode_Stop), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AudioFrameOutputNode, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioFrameOutputNode), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioFrameOutputNode), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_AudioFrameOutputNode), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioFrameOutputNode[] = {
        { "outgoing_gain", reinterpret_cast<getter>(AudioFrameOutputNode_get_OutgoingGain), reinterpret_cast<setter>(AudioFrameOutputNode_put_OutgoingGain), nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(AudioFrameOutputNode_get_ConsumeInput), reinterpret_cast<setter>(AudioFrameOutputNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(AudioFrameOutputNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(AudioFrameOutputNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioFrameOutputNode[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioFrameOutputNode) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioFrameOutputNode) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioFrameOutputNode) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioFrameOutputNode) },
        { },
    };

    static PyType_Spec type_spec_AudioFrameOutputNode =
    {
        "winrt._winrt_windows_media_audio.AudioFrameOutputNode",
        sizeof(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioFrameOutputNode
    };

    // ----- AudioGraph class --------------------

    static PyObject* _new_AudioGraph(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::AudioGraph>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::AudioGraph>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioGraph(py::wrapper::Windows::Media::Audio::AudioGraph* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioGraph_Close(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioGraphSettings>(args, 0);

                return py::convert(winrt::Windows::Media::Audio::AudioGraph::CreateAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateBatchUpdater(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateBatchUpdater", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateBatchUpdater());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateDeviceInputNodeAsync(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateDeviceInputNodeAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 0);

                return py::convert(self->obj.CreateDeviceInputNodeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateDeviceInputNodeAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 1);

                return py::convert(self->obj.CreateDeviceInputNodeAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateDeviceInputNodeAsync", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformation>(args, 2);

                return py::convert(self->obj.CreateDeviceInputNodeAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateDeviceInputNodeAsync", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformation>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitter>(args, 3);

                return py::convert(self->obj.CreateDeviceInputNodeAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateDeviceOutputNodeAsync(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateDeviceOutputNodeAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateDeviceOutputNodeAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateFileInputNodeAsync(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateFileInputNodeAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(self->obj.CreateFileInputNodeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateFileInputNodeAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitter>(args, 1);

                return py::convert(self->obj.CreateFileInputNodeAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateFileOutputNodeAsync(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateFileOutputNodeAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(self->obj.CreateFileOutputNodeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateFileOutputNodeAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 1);

                return py::convert(self->obj.CreateFileOutputNodeAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateFrameInputNode(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateFrameInputNode", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateFrameInputNode());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateFrameInputNode", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 0);

                return py::convert(self->obj.CreateFrameInputNode(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateFrameInputNode", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitter>(args, 1);

                return py::convert(self->obj.CreateFrameInputNode(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateFrameOutputNode(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateFrameOutputNode", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateFrameOutputNode());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateFrameOutputNode", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 0);

                return py::convert(self->obj.CreateFrameOutputNode(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateMediaSourceAudioInputNodeAsync(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateMediaSourceAudioInputNodeAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MediaSource>(args, 0);

                return py::convert(self->obj.CreateMediaSourceAudioInputNodeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateMediaSourceAudioInputNodeAsync", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MediaSource>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitter>(args, 1);

                return py::convert(self->obj.CreateMediaSourceAudioInputNodeAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateSubmixNode(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateSubmixNode", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.CreateSubmixNode());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateSubmixNode", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 0);

                return py::convert(self->obj.CreateSubmixNode(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"CreateSubmixNode", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitter>(args, 1);

                return py::convert(self->obj.CreateSubmixNode(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_ResetAllNodes(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"ResetAllNodes", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.ResetAllNodes();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_Start(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_Stop(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraph", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_get_CompletedQuantumCount(py::wrapper::Windows::Media::Audio::AudioGraph* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraph", L"CompletedQuantumCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CompletedQuantumCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioGraph* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraph", L"EncodingProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_get_LatencyInSamples(py::wrapper::Windows::Media::Audio::AudioGraph* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraph", L"LatencyInSamples"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LatencyInSamples());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_get_PrimaryRenderDevice(py::wrapper::Windows::Media::Audio::AudioGraph* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraph", L"PrimaryRenderDevice"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PrimaryRenderDevice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_get_RenderDeviceAudioProcessing(py::wrapper::Windows::Media::Audio::AudioGraph* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraph", L"RenderDeviceAudioProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RenderDeviceAudioProcessing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_get_SamplesPerQuantum(py::wrapper::Windows::Media::Audio::AudioGraph* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraph", L"SamplesPerQuantum"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SamplesPerQuantum());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_add_QuantumProcessed(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioGraph", L"QuantumProcessed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioGraph, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.QuantumProcessed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_remove_QuantumProcessed(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioGraph", L"QuantumProcessed"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.QuantumProcessed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_add_QuantumStarted(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioGraph", L"QuantumStarted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioGraph, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.QuantumStarted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_remove_QuantumStarted(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioGraph", L"QuantumStarted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.QuantumStarted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_add_UnrecoverableErrorOccurred(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioGraph", L"UnrecoverableErrorOccurred"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioGraph, winrt::Windows::Media::Audio::AudioGraphUnrecoverableErrorOccurredEventArgs>>(arg);

            return py::convert(self->obj.UnrecoverableErrorOccurred(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_remove_UnrecoverableErrorOccurred(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioGraph", L"UnrecoverableErrorOccurred"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UnrecoverableErrorOccurred(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioGraph(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioGraph>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioGraph(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioGraph>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioGraph(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_AudioGraph(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioGraph[] = {
        { "close", reinterpret_cast<PyCFunction>(AudioGraph_Close), METH_VARARGS, nullptr },
        { "create_batch_updater", reinterpret_cast<PyCFunction>(AudioGraph_CreateBatchUpdater), METH_VARARGS, nullptr },
        { "create_device_input_node_async", reinterpret_cast<PyCFunction>(AudioGraph_CreateDeviceInputNodeAsync), METH_VARARGS, nullptr },
        { "create_device_output_node_async", reinterpret_cast<PyCFunction>(AudioGraph_CreateDeviceOutputNodeAsync), METH_VARARGS, nullptr },
        { "create_file_input_node_async", reinterpret_cast<PyCFunction>(AudioGraph_CreateFileInputNodeAsync), METH_VARARGS, nullptr },
        { "create_file_output_node_async", reinterpret_cast<PyCFunction>(AudioGraph_CreateFileOutputNodeAsync), METH_VARARGS, nullptr },
        { "create_frame_input_node", reinterpret_cast<PyCFunction>(AudioGraph_CreateFrameInputNode), METH_VARARGS, nullptr },
        { "create_frame_output_node", reinterpret_cast<PyCFunction>(AudioGraph_CreateFrameOutputNode), METH_VARARGS, nullptr },
        { "create_media_source_audio_input_node_async", reinterpret_cast<PyCFunction>(AudioGraph_CreateMediaSourceAudioInputNodeAsync), METH_VARARGS, nullptr },
        { "create_submix_node", reinterpret_cast<PyCFunction>(AudioGraph_CreateSubmixNode), METH_VARARGS, nullptr },
        { "reset_all_nodes", reinterpret_cast<PyCFunction>(AudioGraph_ResetAllNodes), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(AudioGraph_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(AudioGraph_Stop), METH_VARARGS, nullptr },
        { "add_quantum_processed", reinterpret_cast<PyCFunction>(AudioGraph_add_QuantumProcessed), METH_O, nullptr },
        { "remove_quantum_processed", reinterpret_cast<PyCFunction>(AudioGraph_remove_QuantumProcessed), METH_O, nullptr },
        { "add_quantum_started", reinterpret_cast<PyCFunction>(AudioGraph_add_QuantumStarted), METH_O, nullptr },
        { "remove_quantum_started", reinterpret_cast<PyCFunction>(AudioGraph_remove_QuantumStarted), METH_O, nullptr },
        { "add_unrecoverable_error_occurred", reinterpret_cast<PyCFunction>(AudioGraph_add_UnrecoverableErrorOccurred), METH_O, nullptr },
        { "remove_unrecoverable_error_occurred", reinterpret_cast<PyCFunction>(AudioGraph_remove_UnrecoverableErrorOccurred), METH_O, nullptr },
        { "_assign_array_", _assign_array_AudioGraph, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioGraph), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioGraph), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_AudioGraph), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioGraph[] = {
        { "completed_quantum_count", reinterpret_cast<getter>(AudioGraph_get_CompletedQuantumCount), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(AudioGraph_get_EncodingProperties), nullptr, nullptr, nullptr },
        { "latency_in_samples", reinterpret_cast<getter>(AudioGraph_get_LatencyInSamples), nullptr, nullptr, nullptr },
        { "primary_render_device", reinterpret_cast<getter>(AudioGraph_get_PrimaryRenderDevice), nullptr, nullptr, nullptr },
        { "render_device_audio_processing", reinterpret_cast<getter>(AudioGraph_get_RenderDeviceAudioProcessing), nullptr, nullptr, nullptr },
        { "samples_per_quantum", reinterpret_cast<getter>(AudioGraph_get_SamplesPerQuantum), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioGraph[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioGraph) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioGraph) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioGraph) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioGraph) },
        { },
    };

    static PyType_Spec type_spec_AudioGraph =
    {
        "winrt._winrt_windows_media_audio.AudioGraph",
        sizeof(py::wrapper::Windows::Media::Audio::AudioGraph),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioGraph
    };

    static PyGetSetDef getset_AudioGraph_Static[] = {
        { }
    };

    static PyMethodDef methods_AudioGraph_Static[] = {
        { "create_async", reinterpret_cast<PyCFunction>(AudioGraph_CreateAsync), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AudioGraph_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AudioGraph_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AudioGraph_Static) },
        { }
    };

    static PyType_Spec type_spec_AudioGraph_Static =
    {
        "winrt._winrt_windows_media_audio.AudioGraph_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AudioGraph_Static
    };

    // ----- AudioGraphBatchUpdater class --------------------

    static PyObject* _new_AudioGraphBatchUpdater(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::AudioGraphBatchUpdater>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::AudioGraphBatchUpdater>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioGraphBatchUpdater(py::wrapper::Windows::Media::Audio::AudioGraphBatchUpdater* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioGraphBatchUpdater_Close(py::wrapper::Windows::Media::Audio::AudioGraphBatchUpdater* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioGraphBatchUpdater", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioGraphBatchUpdater(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioGraphBatchUpdater>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioGraphBatchUpdater(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioGraphBatchUpdater>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioGraphBatchUpdater(py::wrapper::Windows::Media::Audio::AudioGraphBatchUpdater* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_AudioGraphBatchUpdater(py::wrapper::Windows::Media::Audio::AudioGraphBatchUpdater* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioGraphBatchUpdater[] = {
        { "close", reinterpret_cast<PyCFunction>(AudioGraphBatchUpdater_Close), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AudioGraphBatchUpdater, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioGraphBatchUpdater), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioGraphBatchUpdater), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_AudioGraphBatchUpdater), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioGraphBatchUpdater[] = {
        { }
    };

    static PyType_Slot _type_slots_AudioGraphBatchUpdater[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioGraphBatchUpdater) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioGraphBatchUpdater) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioGraphBatchUpdater) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioGraphBatchUpdater) },
        { },
    };

    static PyType_Spec type_spec_AudioGraphBatchUpdater =
    {
        "winrt._winrt_windows_media_audio.AudioGraphBatchUpdater",
        sizeof(py::wrapper::Windows::Media::Audio::AudioGraphBatchUpdater),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioGraphBatchUpdater
    };

    // ----- AudioGraphConnection class --------------------

    static PyObject* _new_AudioGraphConnection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::AudioGraphConnection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::AudioGraphConnection>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioGraphConnection(py::wrapper::Windows::Media::Audio::AudioGraphConnection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioGraphConnection_get_Gain(py::wrapper::Windows::Media::Audio::AudioGraphConnection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphConnection", L"Gain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Gain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphConnection_put_Gain(py::wrapper::Windows::Media::Audio::AudioGraphConnection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphConnection", L"Gain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Gain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioGraphConnection_get_Destination(py::wrapper::Windows::Media::Audio::AudioGraphConnection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphConnection", L"Destination"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Destination());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioGraphConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioGraphConnection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioGraphConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioGraphConnection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioGraphConnection[] = {
        { "_assign_array_", _assign_array_AudioGraphConnection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioGraphConnection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioGraphConnection[] = {
        { "gain", reinterpret_cast<getter>(AudioGraphConnection_get_Gain), reinterpret_cast<setter>(AudioGraphConnection_put_Gain), nullptr, nullptr },
        { "destination", reinterpret_cast<getter>(AudioGraphConnection_get_Destination), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioGraphConnection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioGraphConnection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioGraphConnection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioGraphConnection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioGraphConnection) },
        { },
    };

    static PyType_Spec type_spec_AudioGraphConnection =
    {
        "winrt._winrt_windows_media_audio.AudioGraphConnection",
        sizeof(py::wrapper::Windows::Media::Audio::AudioGraphConnection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioGraphConnection
    };

    // ----- AudioGraphSettings class --------------------

    static PyObject* _new_AudioGraphSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Render::AudioRenderCategory>(args, 0);

                winrt::Windows::Media::Audio::AudioGraphSettings instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AudioGraphSettings(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioGraphSettings_get_QuantumSizeSelectionMode(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"QuantumSizeSelectionMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.QuantumSizeSelectionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphSettings_put_QuantumSizeSelectionMode(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"QuantumSizeSelectionMode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Audio::QuantumSizeSelectionMode>(arg);

            self->obj.QuantumSizeSelectionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioGraphSettings_get_PrimaryRenderDevice(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"PrimaryRenderDevice"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PrimaryRenderDevice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphSettings_put_PrimaryRenderDevice(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"PrimaryRenderDevice"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformation>(arg);

            self->obj.PrimaryRenderDevice(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioGraphSettings_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"EncodingProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphSettings_put_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"EncodingProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(arg);

            self->obj.EncodingProperties(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioGraphSettings_get_DesiredSamplesPerQuantum(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"DesiredSamplesPerQuantum"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DesiredSamplesPerQuantum());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphSettings_put_DesiredSamplesPerQuantum(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"DesiredSamplesPerQuantum"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.DesiredSamplesPerQuantum(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioGraphSettings_get_DesiredRenderDeviceAudioProcessing(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"DesiredRenderDeviceAudioProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DesiredRenderDeviceAudioProcessing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphSettings_put_DesiredRenderDeviceAudioProcessing(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"DesiredRenderDeviceAudioProcessing"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::AudioProcessing>(arg);

            self->obj.DesiredRenderDeviceAudioProcessing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioGraphSettings_get_AudioRenderCategory(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"AudioRenderCategory"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.AudioRenderCategory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphSettings_put_AudioRenderCategory(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"AudioRenderCategory"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Render::AudioRenderCategory>(arg);

            self->obj.AudioRenderCategory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioGraphSettings_get_MaxPlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"MaxPlaybackSpeedFactor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxPlaybackSpeedFactor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphSettings_put_MaxPlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphSettings", L"MaxPlaybackSpeedFactor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.MaxPlaybackSpeedFactor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AudioGraphSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioGraphSettings>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioGraphSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioGraphSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioGraphSettings[] = {
        { "_assign_array_", _assign_array_AudioGraphSettings, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioGraphSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioGraphSettings[] = {
        { "quantum_size_selection_mode", reinterpret_cast<getter>(AudioGraphSettings_get_QuantumSizeSelectionMode), reinterpret_cast<setter>(AudioGraphSettings_put_QuantumSizeSelectionMode), nullptr, nullptr },
        { "primary_render_device", reinterpret_cast<getter>(AudioGraphSettings_get_PrimaryRenderDevice), reinterpret_cast<setter>(AudioGraphSettings_put_PrimaryRenderDevice), nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(AudioGraphSettings_get_EncodingProperties), reinterpret_cast<setter>(AudioGraphSettings_put_EncodingProperties), nullptr, nullptr },
        { "desired_samples_per_quantum", reinterpret_cast<getter>(AudioGraphSettings_get_DesiredSamplesPerQuantum), reinterpret_cast<setter>(AudioGraphSettings_put_DesiredSamplesPerQuantum), nullptr, nullptr },
        { "desired_render_device_audio_processing", reinterpret_cast<getter>(AudioGraphSettings_get_DesiredRenderDeviceAudioProcessing), reinterpret_cast<setter>(AudioGraphSettings_put_DesiredRenderDeviceAudioProcessing), nullptr, nullptr },
        { "audio_render_category", reinterpret_cast<getter>(AudioGraphSettings_get_AudioRenderCategory), reinterpret_cast<setter>(AudioGraphSettings_put_AudioRenderCategory), nullptr, nullptr },
        { "max_playback_speed_factor", reinterpret_cast<getter>(AudioGraphSettings_get_MaxPlaybackSpeedFactor), reinterpret_cast<setter>(AudioGraphSettings_put_MaxPlaybackSpeedFactor), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioGraphSettings[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioGraphSettings) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioGraphSettings) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioGraphSettings) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioGraphSettings) },
        { },
    };

    static PyType_Spec type_spec_AudioGraphSettings =
    {
        "winrt._winrt_windows_media_audio.AudioGraphSettings",
        sizeof(py::wrapper::Windows::Media::Audio::AudioGraphSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioGraphSettings
    };

    // ----- AudioGraphUnrecoverableErrorOccurredEventArgs class --------------------

    static PyObject* _new_AudioGraphUnrecoverableErrorOccurredEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::AudioGraphUnrecoverableErrorOccurredEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::AudioGraphUnrecoverableErrorOccurredEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioGraphUnrecoverableErrorOccurredEventArgs(py::wrapper::Windows::Media::Audio::AudioGraphUnrecoverableErrorOccurredEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioGraphUnrecoverableErrorOccurredEventArgs_get_Error(py::wrapper::Windows::Media::Audio::AudioGraphUnrecoverableErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioGraphUnrecoverableErrorOccurredEventArgs", L"Error"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Error());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioGraphUnrecoverableErrorOccurredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioGraphUnrecoverableErrorOccurredEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioGraphUnrecoverableErrorOccurredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioGraphUnrecoverableErrorOccurredEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioGraphUnrecoverableErrorOccurredEventArgs[] = {
        { "_assign_array_", _assign_array_AudioGraphUnrecoverableErrorOccurredEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioGraphUnrecoverableErrorOccurredEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioGraphUnrecoverableErrorOccurredEventArgs[] = {
        { "error", reinterpret_cast<getter>(AudioGraphUnrecoverableErrorOccurredEventArgs_get_Error), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioGraphUnrecoverableErrorOccurredEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioGraphUnrecoverableErrorOccurredEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioGraphUnrecoverableErrorOccurredEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioGraphUnrecoverableErrorOccurredEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioGraphUnrecoverableErrorOccurredEventArgs) },
        { },
    };

    static PyType_Spec type_spec_AudioGraphUnrecoverableErrorOccurredEventArgs =
    {
        "winrt._winrt_windows_media_audio.AudioGraphUnrecoverableErrorOccurredEventArgs",
        sizeof(py::wrapper::Windows::Media::Audio::AudioGraphUnrecoverableErrorOccurredEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioGraphUnrecoverableErrorOccurredEventArgs
    };

    // ----- AudioNodeEmitter class --------------------

    static PyObject* _new_AudioNodeEmitter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitterShape>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitterDecayModel>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitterSettings>(args, 2);

                winrt::Windows::Media::Audio::AudioNodeEmitter instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Audio::AudioNodeEmitter instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AudioNodeEmitter(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioNodeEmitter_get_Position(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeEmitter_put_Position(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeEmitter_get_Gain(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"Gain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Gain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeEmitter_put_Gain(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"Gain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Gain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeEmitter_get_DopplerVelocity(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"DopplerVelocity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DopplerVelocity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeEmitter_put_DopplerVelocity(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"DopplerVelocity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.DopplerVelocity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeEmitter_get_DopplerScale(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"DopplerScale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DopplerScale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeEmitter_put_DopplerScale(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"DopplerScale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.DopplerScale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeEmitter_get_DistanceScale(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"DistanceScale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DistanceScale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeEmitter_put_DistanceScale(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"DistanceScale"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.DistanceScale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeEmitter_get_Direction(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"Direction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Direction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeEmitter_put_Direction(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"Direction"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.Direction(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeEmitter_get_DecayModel(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"DecayModel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DecayModel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitter_get_IsDopplerDisabled(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"IsDopplerDisabled"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsDopplerDisabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitter_get_Shape(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"Shape"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitter_get_SpatialAudioModel(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"SpatialAudioModel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SpatialAudioModel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeEmitter_put_SpatialAudioModel(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitter", L"SpatialAudioModel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Audio::SpatialAudioModel>(arg);

            self->obj.SpatialAudioModel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AudioNodeEmitter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioNodeEmitter>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioNodeEmitter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioNodeEmitter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioNodeEmitter[] = {
        { "_assign_array_", _assign_array_AudioNodeEmitter, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioNodeEmitter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioNodeEmitter[] = {
        { "position", reinterpret_cast<getter>(AudioNodeEmitter_get_Position), reinterpret_cast<setter>(AudioNodeEmitter_put_Position), nullptr, nullptr },
        { "gain", reinterpret_cast<getter>(AudioNodeEmitter_get_Gain), reinterpret_cast<setter>(AudioNodeEmitter_put_Gain), nullptr, nullptr },
        { "doppler_velocity", reinterpret_cast<getter>(AudioNodeEmitter_get_DopplerVelocity), reinterpret_cast<setter>(AudioNodeEmitter_put_DopplerVelocity), nullptr, nullptr },
        { "doppler_scale", reinterpret_cast<getter>(AudioNodeEmitter_get_DopplerScale), reinterpret_cast<setter>(AudioNodeEmitter_put_DopplerScale), nullptr, nullptr },
        { "distance_scale", reinterpret_cast<getter>(AudioNodeEmitter_get_DistanceScale), reinterpret_cast<setter>(AudioNodeEmitter_put_DistanceScale), nullptr, nullptr },
        { "direction", reinterpret_cast<getter>(AudioNodeEmitter_get_Direction), reinterpret_cast<setter>(AudioNodeEmitter_put_Direction), nullptr, nullptr },
        { "decay_model", reinterpret_cast<getter>(AudioNodeEmitter_get_DecayModel), nullptr, nullptr, nullptr },
        { "is_doppler_disabled", reinterpret_cast<getter>(AudioNodeEmitter_get_IsDopplerDisabled), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(AudioNodeEmitter_get_Shape), nullptr, nullptr, nullptr },
        { "spatial_audio_model", reinterpret_cast<getter>(AudioNodeEmitter_get_SpatialAudioModel), reinterpret_cast<setter>(AudioNodeEmitter_put_SpatialAudioModel), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioNodeEmitter[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioNodeEmitter) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioNodeEmitter) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioNodeEmitter) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioNodeEmitter) },
        { },
    };

    static PyType_Spec type_spec_AudioNodeEmitter =
    {
        "winrt._winrt_windows_media_audio.AudioNodeEmitter",
        sizeof(py::wrapper::Windows::Media::Audio::AudioNodeEmitter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioNodeEmitter
    };

    // ----- AudioNodeEmitterConeProperties class --------------------

    static PyObject* _new_AudioNodeEmitterConeProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::AudioNodeEmitterConeProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::AudioNodeEmitterConeProperties>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioNodeEmitterConeProperties(py::wrapper::Windows::Media::Audio::AudioNodeEmitterConeProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioNodeEmitterConeProperties_get_InnerAngle(py::wrapper::Windows::Media::Audio::AudioNodeEmitterConeProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitterConeProperties", L"InnerAngle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.InnerAngle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterConeProperties_get_OuterAngle(py::wrapper::Windows::Media::Audio::AudioNodeEmitterConeProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitterConeProperties", L"OuterAngle"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OuterAngle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterConeProperties_get_OuterAngleGain(py::wrapper::Windows::Media::Audio::AudioNodeEmitterConeProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitterConeProperties", L"OuterAngleGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OuterAngleGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioNodeEmitterConeProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioNodeEmitterConeProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioNodeEmitterConeProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioNodeEmitterConeProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioNodeEmitterConeProperties[] = {
        { "_assign_array_", _assign_array_AudioNodeEmitterConeProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioNodeEmitterConeProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioNodeEmitterConeProperties[] = {
        { "inner_angle", reinterpret_cast<getter>(AudioNodeEmitterConeProperties_get_InnerAngle), nullptr, nullptr, nullptr },
        { "outer_angle", reinterpret_cast<getter>(AudioNodeEmitterConeProperties_get_OuterAngle), nullptr, nullptr, nullptr },
        { "outer_angle_gain", reinterpret_cast<getter>(AudioNodeEmitterConeProperties_get_OuterAngleGain), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioNodeEmitterConeProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioNodeEmitterConeProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioNodeEmitterConeProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioNodeEmitterConeProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioNodeEmitterConeProperties) },
        { },
    };

    static PyType_Spec type_spec_AudioNodeEmitterConeProperties =
    {
        "winrt._winrt_windows_media_audio.AudioNodeEmitterConeProperties",
        sizeof(py::wrapper::Windows::Media::Audio::AudioNodeEmitterConeProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioNodeEmitterConeProperties
    };

    // ----- AudioNodeEmitterDecayModel class --------------------

    static PyObject* _new_AudioNodeEmitterDecayModel(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::AudioNodeEmitterDecayModel>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::AudioNodeEmitterDecayModel>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioNodeEmitterDecayModel(py::wrapper::Windows::Media::Audio::AudioNodeEmitterDecayModel* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioNodeEmitterDecayModel_CreateCustom(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioNodeEmitterDecayModel", L"CreateCustom", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                return py::convert(winrt::Windows::Media::Audio::AudioNodeEmitterDecayModel::CreateCustom(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterDecayModel_CreateNatural(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioNodeEmitterDecayModel", L"CreateNatural", 4))
            {
                py::set_arg_count_version_error(4);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<double>(args, 2);
                auto param3 = py::convert_to<double>(args, 3);

                return py::convert(winrt::Windows::Media::Audio::AudioNodeEmitterDecayModel::CreateNatural(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterDecayModel_get_Kind(py::wrapper::Windows::Media::Audio::AudioNodeEmitterDecayModel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitterDecayModel", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterDecayModel_get_MaxGain(py::wrapper::Windows::Media::Audio::AudioNodeEmitterDecayModel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitterDecayModel", L"MaxGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MaxGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterDecayModel_get_MinGain(py::wrapper::Windows::Media::Audio::AudioNodeEmitterDecayModel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitterDecayModel", L"MinGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MinGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterDecayModel_get_NaturalProperties(py::wrapper::Windows::Media::Audio::AudioNodeEmitterDecayModel* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitterDecayModel", L"NaturalProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.NaturalProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioNodeEmitterDecayModel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioNodeEmitterDecayModel>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioNodeEmitterDecayModel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioNodeEmitterDecayModel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioNodeEmitterDecayModel[] = {
        { "_assign_array_", _assign_array_AudioNodeEmitterDecayModel, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioNodeEmitterDecayModel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioNodeEmitterDecayModel[] = {
        { "kind", reinterpret_cast<getter>(AudioNodeEmitterDecayModel_get_Kind), nullptr, nullptr, nullptr },
        { "max_gain", reinterpret_cast<getter>(AudioNodeEmitterDecayModel_get_MaxGain), nullptr, nullptr, nullptr },
        { "min_gain", reinterpret_cast<getter>(AudioNodeEmitterDecayModel_get_MinGain), nullptr, nullptr, nullptr },
        { "natural_properties", reinterpret_cast<getter>(AudioNodeEmitterDecayModel_get_NaturalProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioNodeEmitterDecayModel[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioNodeEmitterDecayModel) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioNodeEmitterDecayModel) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioNodeEmitterDecayModel) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioNodeEmitterDecayModel) },
        { },
    };

    static PyType_Spec type_spec_AudioNodeEmitterDecayModel =
    {
        "winrt._winrt_windows_media_audio.AudioNodeEmitterDecayModel",
        sizeof(py::wrapper::Windows::Media::Audio::AudioNodeEmitterDecayModel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioNodeEmitterDecayModel
    };

    static PyGetSetDef getset_AudioNodeEmitterDecayModel_Static[] = {
        { }
    };

    static PyMethodDef methods_AudioNodeEmitterDecayModel_Static[] = {
        { "create_custom", reinterpret_cast<PyCFunction>(AudioNodeEmitterDecayModel_CreateCustom), METH_VARARGS, nullptr },
        { "create_natural", reinterpret_cast<PyCFunction>(AudioNodeEmitterDecayModel_CreateNatural), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AudioNodeEmitterDecayModel_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AudioNodeEmitterDecayModel_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AudioNodeEmitterDecayModel_Static) },
        { }
    };

    static PyType_Spec type_spec_AudioNodeEmitterDecayModel_Static =
    {
        "winrt._winrt_windows_media_audio.AudioNodeEmitterDecayModel_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AudioNodeEmitterDecayModel_Static
    };

    // ----- AudioNodeEmitterNaturalDecayModelProperties class --------------------

    static PyObject* _new_AudioNodeEmitterNaturalDecayModelProperties(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::AudioNodeEmitterNaturalDecayModelProperties>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::AudioNodeEmitterNaturalDecayModelProperties>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioNodeEmitterNaturalDecayModelProperties(py::wrapper::Windows::Media::Audio::AudioNodeEmitterNaturalDecayModelProperties* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioNodeEmitterNaturalDecayModelProperties_get_CutoffDistance(py::wrapper::Windows::Media::Audio::AudioNodeEmitterNaturalDecayModelProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitterNaturalDecayModelProperties", L"CutoffDistance"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.CutoffDistance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterNaturalDecayModelProperties_get_UnityGainDistance(py::wrapper::Windows::Media::Audio::AudioNodeEmitterNaturalDecayModelProperties* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitterNaturalDecayModelProperties", L"UnityGainDistance"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.UnityGainDistance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioNodeEmitterNaturalDecayModelProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioNodeEmitterNaturalDecayModelProperties>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioNodeEmitterNaturalDecayModelProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioNodeEmitterNaturalDecayModelProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioNodeEmitterNaturalDecayModelProperties[] = {
        { "_assign_array_", _assign_array_AudioNodeEmitterNaturalDecayModelProperties, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioNodeEmitterNaturalDecayModelProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioNodeEmitterNaturalDecayModelProperties[] = {
        { "cutoff_distance", reinterpret_cast<getter>(AudioNodeEmitterNaturalDecayModelProperties_get_CutoffDistance), nullptr, nullptr, nullptr },
        { "unity_gain_distance", reinterpret_cast<getter>(AudioNodeEmitterNaturalDecayModelProperties_get_UnityGainDistance), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioNodeEmitterNaturalDecayModelProperties[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioNodeEmitterNaturalDecayModelProperties) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioNodeEmitterNaturalDecayModelProperties) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioNodeEmitterNaturalDecayModelProperties) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioNodeEmitterNaturalDecayModelProperties) },
        { },
    };

    static PyType_Spec type_spec_AudioNodeEmitterNaturalDecayModelProperties =
    {
        "winrt._winrt_windows_media_audio.AudioNodeEmitterNaturalDecayModelProperties",
        sizeof(py::wrapper::Windows::Media::Audio::AudioNodeEmitterNaturalDecayModelProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioNodeEmitterNaturalDecayModelProperties
    };

    // ----- AudioNodeEmitterShape class --------------------

    static PyObject* _new_AudioNodeEmitterShape(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::AudioNodeEmitterShape>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::AudioNodeEmitterShape>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioNodeEmitterShape(py::wrapper::Windows::Media::Audio::AudioNodeEmitterShape* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioNodeEmitterShape_CreateCone(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioNodeEmitterShape", L"CreateCone", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<double>(args, 2);

                return py::convert(winrt::Windows::Media::Audio::AudioNodeEmitterShape::CreateCone(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterShape_CreateOmnidirectional(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioNodeEmitterShape", L"CreateOmnidirectional", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Media::Audio::AudioNodeEmitterShape::CreateOmnidirectional());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterShape_get_ConeProperties(py::wrapper::Windows::Media::Audio::AudioNodeEmitterShape* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitterShape", L"ConeProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConeProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterShape_get_Kind(py::wrapper::Windows::Media::Audio::AudioNodeEmitterShape* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeEmitterShape", L"Kind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioNodeEmitterShape(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioNodeEmitterShape>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioNodeEmitterShape(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioNodeEmitterShape>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioNodeEmitterShape[] = {
        { "_assign_array_", _assign_array_AudioNodeEmitterShape, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioNodeEmitterShape), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioNodeEmitterShape[] = {
        { "cone_properties", reinterpret_cast<getter>(AudioNodeEmitterShape_get_ConeProperties), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(AudioNodeEmitterShape_get_Kind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioNodeEmitterShape[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioNodeEmitterShape) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioNodeEmitterShape) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioNodeEmitterShape) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioNodeEmitterShape) },
        { },
    };

    static PyType_Spec type_spec_AudioNodeEmitterShape =
    {
        "winrt._winrt_windows_media_audio.AudioNodeEmitterShape",
        sizeof(py::wrapper::Windows::Media::Audio::AudioNodeEmitterShape),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioNodeEmitterShape
    };

    static PyGetSetDef getset_AudioNodeEmitterShape_Static[] = {
        { }
    };

    static PyMethodDef methods_AudioNodeEmitterShape_Static[] = {
        { "create_cone", reinterpret_cast<PyCFunction>(AudioNodeEmitterShape_CreateCone), METH_VARARGS, nullptr },
        { "create_omnidirectional", reinterpret_cast<PyCFunction>(AudioNodeEmitterShape_CreateOmnidirectional), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AudioNodeEmitterShape_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AudioNodeEmitterShape_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AudioNodeEmitterShape_Static) },
        { }
    };

    static PyType_Spec type_spec_AudioNodeEmitterShape_Static =
    {
        "winrt._winrt_windows_media_audio.AudioNodeEmitterShape_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AudioNodeEmitterShape_Static
    };

    // ----- AudioNodeListener class --------------------

    static PyObject* _new_AudioNodeListener(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Audio::AudioNodeListener instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AudioNodeListener(py::wrapper::Windows::Media::Audio::AudioNodeListener* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioNodeListener_get_SpeedOfSound(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeListener", L"SpeedOfSound"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SpeedOfSound());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeListener_put_SpeedOfSound(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeListener", L"SpeedOfSound"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.SpeedOfSound(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeListener_get_Position(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeListener", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeListener_put_Position(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeListener", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeListener_get_Orientation(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeListener", L"Orientation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeListener_put_Orientation(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeListener", L"Orientation"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(arg);

            self->obj.Orientation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeListener_get_DopplerVelocity(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeListener", L"DopplerVelocity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DopplerVelocity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeListener_put_DopplerVelocity(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioNodeListener", L"DopplerVelocity"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.DopplerVelocity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AudioNodeListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioNodeListener>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioNodeListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioNodeListener>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioNodeListener[] = {
        { "_assign_array_", _assign_array_AudioNodeListener, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioNodeListener), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioNodeListener[] = {
        { "speed_of_sound", reinterpret_cast<getter>(AudioNodeListener_get_SpeedOfSound), reinterpret_cast<setter>(AudioNodeListener_put_SpeedOfSound), nullptr, nullptr },
        { "position", reinterpret_cast<getter>(AudioNodeListener_get_Position), reinterpret_cast<setter>(AudioNodeListener_put_Position), nullptr, nullptr },
        { "orientation", reinterpret_cast<getter>(AudioNodeListener_get_Orientation), reinterpret_cast<setter>(AudioNodeListener_put_Orientation), nullptr, nullptr },
        { "doppler_velocity", reinterpret_cast<getter>(AudioNodeListener_get_DopplerVelocity), reinterpret_cast<setter>(AudioNodeListener_put_DopplerVelocity), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioNodeListener[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioNodeListener) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioNodeListener) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioNodeListener) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioNodeListener) },
        { },
    };

    static PyType_Spec type_spec_AudioNodeListener =
    {
        "winrt._winrt_windows_media_audio.AudioNodeListener",
        sizeof(py::wrapper::Windows::Media::Audio::AudioNodeListener),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioNodeListener
    };

    // ----- AudioPlaybackConnection class --------------------

    static PyObject* _new_AudioPlaybackConnection(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::AudioPlaybackConnection>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::AudioPlaybackConnection>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioPlaybackConnection(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioPlaybackConnection_Close(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioPlaybackConnection", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioPlaybackConnection", L"GetDeviceSelector", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Media::Audio::AudioPlaybackConnection::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_Open(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioPlaybackConnection", L"Open", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.Open());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_OpenAsync(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioPlaybackConnection", L"OpenAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.OpenAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_Start(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioPlaybackConnection", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_StartAsync(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioPlaybackConnection", L"StartAsync", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.StartAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_TryCreateFromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioPlaybackConnection", L"TryCreateFromId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Media::Audio::AudioPlaybackConnection::TryCreateFromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_get_DeviceId(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioPlaybackConnection", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_get_State(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioPlaybackConnection", L"State"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_add_StateChanged(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioPlaybackConnection", L"StateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioPlaybackConnection, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.StateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_remove_StateChanged(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioPlaybackConnection", L"StateChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioPlaybackConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioPlaybackConnection>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioPlaybackConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioPlaybackConnection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioPlaybackConnection(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_AudioPlaybackConnection(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioPlaybackConnection[] = {
        { "close", reinterpret_cast<PyCFunction>(AudioPlaybackConnection_Close), METH_VARARGS, nullptr },
        { "open", reinterpret_cast<PyCFunction>(AudioPlaybackConnection_Open), METH_VARARGS, nullptr },
        { "open_async", reinterpret_cast<PyCFunction>(AudioPlaybackConnection_OpenAsync), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(AudioPlaybackConnection_Start), METH_VARARGS, nullptr },
        { "start_async", reinterpret_cast<PyCFunction>(AudioPlaybackConnection_StartAsync), METH_VARARGS, nullptr },
        { "add_state_changed", reinterpret_cast<PyCFunction>(AudioPlaybackConnection_add_StateChanged), METH_O, nullptr },
        { "remove_state_changed", reinterpret_cast<PyCFunction>(AudioPlaybackConnection_remove_StateChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_AudioPlaybackConnection, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioPlaybackConnection), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioPlaybackConnection), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_AudioPlaybackConnection), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioPlaybackConnection[] = {
        { "device_id", reinterpret_cast<getter>(AudioPlaybackConnection_get_DeviceId), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(AudioPlaybackConnection_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioPlaybackConnection[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioPlaybackConnection) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioPlaybackConnection) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioPlaybackConnection) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioPlaybackConnection) },
        { },
    };

    static PyType_Spec type_spec_AudioPlaybackConnection =
    {
        "winrt._winrt_windows_media_audio.AudioPlaybackConnection",
        sizeof(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioPlaybackConnection
    };

    static PyGetSetDef getset_AudioPlaybackConnection_Static[] = {
        { }
    };

    static PyMethodDef methods_AudioPlaybackConnection_Static[] = {
        { "get_device_selector", reinterpret_cast<PyCFunction>(AudioPlaybackConnection_GetDeviceSelector), METH_VARARGS, nullptr },
        { "try_create_from_id", reinterpret_cast<PyCFunction>(AudioPlaybackConnection_TryCreateFromId), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AudioPlaybackConnection_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AudioPlaybackConnection_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AudioPlaybackConnection_Static) },
        { }
    };

    static PyType_Spec type_spec_AudioPlaybackConnection_Static =
    {
        "winrt._winrt_windows_media_audio.AudioPlaybackConnection_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AudioPlaybackConnection_Static
    };

    // ----- AudioPlaybackConnectionOpenResult class --------------------

    static PyObject* _new_AudioPlaybackConnectionOpenResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::AudioPlaybackConnectionOpenResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::AudioPlaybackConnectionOpenResult>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioPlaybackConnectionOpenResult(py::wrapper::Windows::Media::Audio::AudioPlaybackConnectionOpenResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioPlaybackConnectionOpenResult_get_ExtendedError(py::wrapper::Windows::Media::Audio::AudioPlaybackConnectionOpenResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioPlaybackConnectionOpenResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnectionOpenResult_get_Status(py::wrapper::Windows::Media::Audio::AudioPlaybackConnectionOpenResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioPlaybackConnectionOpenResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioPlaybackConnectionOpenResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioPlaybackConnectionOpenResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioPlaybackConnectionOpenResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioPlaybackConnectionOpenResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioPlaybackConnectionOpenResult[] = {
        { "_assign_array_", _assign_array_AudioPlaybackConnectionOpenResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioPlaybackConnectionOpenResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioPlaybackConnectionOpenResult[] = {
        { "extended_error", reinterpret_cast<getter>(AudioPlaybackConnectionOpenResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(AudioPlaybackConnectionOpenResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioPlaybackConnectionOpenResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioPlaybackConnectionOpenResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioPlaybackConnectionOpenResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioPlaybackConnectionOpenResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioPlaybackConnectionOpenResult) },
        { },
    };

    static PyType_Spec type_spec_AudioPlaybackConnectionOpenResult =
    {
        "winrt._winrt_windows_media_audio.AudioPlaybackConnectionOpenResult",
        sizeof(py::wrapper::Windows::Media::Audio::AudioPlaybackConnectionOpenResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioPlaybackConnectionOpenResult
    };

    // ----- AudioStateMonitor class --------------------

    static PyObject* _new_AudioStateMonitor(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::AudioStateMonitor>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::AudioStateMonitor>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioStateMonitor(py::wrapper::Windows::Media::Audio::AudioStateMonitor* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioStateMonitor_CreateForCaptureMonitoring(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioStateMonitor", L"CreateForCaptureMonitoring", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Media::Audio::AudioStateMonitor::CreateForCaptureMonitoring());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioStateMonitor", L"CreateForCaptureMonitoring", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 0);

                return py::convert(winrt::Windows::Media::Audio::AudioStateMonitor::CreateForCaptureMonitoring(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioStateMonitor", L"CreateForCaptureMonitoring", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Devices::AudioDeviceRole>(args, 1);

                return py::convert(winrt::Windows::Media::Audio::AudioStateMonitor::CreateForCaptureMonitoring(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioStateMonitor_CreateForCaptureMonitoringWithCategoryAndDeviceId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioStateMonitor", L"CreateForCaptureMonitoringWithCategoryAndDeviceId", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Media::Audio::AudioStateMonitor::CreateForCaptureMonitoringWithCategoryAndDeviceId(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioStateMonitor_CreateForRenderMonitoring(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioStateMonitor", L"CreateForRenderMonitoring", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Media::Audio::AudioStateMonitor::CreateForRenderMonitoring());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioStateMonitor", L"CreateForRenderMonitoring", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Render::AudioRenderCategory>(args, 0);

                return py::convert(winrt::Windows::Media::Audio::AudioStateMonitor::CreateForRenderMonitoring(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioStateMonitor", L"CreateForRenderMonitoring", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Render::AudioRenderCategory>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Devices::AudioDeviceRole>(args, 1);

                return py::convert(winrt::Windows::Media::Audio::AudioStateMonitor::CreateForRenderMonitoring(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioStateMonitor_CreateForRenderMonitoringWithCategoryAndDeviceId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioStateMonitor", L"CreateForRenderMonitoringWithCategoryAndDeviceId", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Render::AudioRenderCategory>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Media::Audio::AudioStateMonitor::CreateForRenderMonitoringWithCategoryAndDeviceId(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioStateMonitor_get_SoundLevel(py::wrapper::Windows::Media::Audio::AudioStateMonitor* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioStateMonitor", L"SoundLevel"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.SoundLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioStateMonitor_add_SoundLevelChanged(py::wrapper::Windows::Media::Audio::AudioStateMonitor* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioStateMonitor", L"SoundLevelChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioStateMonitor, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SoundLevelChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioStateMonitor_remove_SoundLevelChanged(py::wrapper::Windows::Media::Audio::AudioStateMonitor* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.AudioStateMonitor", L"SoundLevelChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SoundLevelChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioStateMonitor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioStateMonitor>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioStateMonitor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioStateMonitor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioStateMonitor[] = {
        { "add_sound_level_changed", reinterpret_cast<PyCFunction>(AudioStateMonitor_add_SoundLevelChanged), METH_O, nullptr },
        { "remove_sound_level_changed", reinterpret_cast<PyCFunction>(AudioStateMonitor_remove_SoundLevelChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_AudioStateMonitor, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioStateMonitor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioStateMonitor[] = {
        { "sound_level", reinterpret_cast<getter>(AudioStateMonitor_get_SoundLevel), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioStateMonitor[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioStateMonitor) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioStateMonitor) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioStateMonitor) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioStateMonitor) },
        { },
    };

    static PyType_Spec type_spec_AudioStateMonitor =
    {
        "winrt._winrt_windows_media_audio.AudioStateMonitor",
        sizeof(py::wrapper::Windows::Media::Audio::AudioStateMonitor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioStateMonitor
    };

    static PyGetSetDef getset_AudioStateMonitor_Static[] = {
        { }
    };

    static PyMethodDef methods_AudioStateMonitor_Static[] = {
        { "create_for_capture_monitoring", reinterpret_cast<PyCFunction>(AudioStateMonitor_CreateForCaptureMonitoring), METH_VARARGS, nullptr },
        { "create_for_capture_monitoring_with_category_and_device_id", reinterpret_cast<PyCFunction>(AudioStateMonitor_CreateForCaptureMonitoringWithCategoryAndDeviceId), METH_VARARGS, nullptr },
        { "create_for_render_monitoring", reinterpret_cast<PyCFunction>(AudioStateMonitor_CreateForRenderMonitoring), METH_VARARGS, nullptr },
        { "create_for_render_monitoring_with_category_and_device_id", reinterpret_cast<PyCFunction>(AudioStateMonitor_CreateForRenderMonitoringWithCategoryAndDeviceId), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_AudioStateMonitor_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_AudioStateMonitor_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_AudioStateMonitor_Static) },
        { }
    };

    static PyType_Spec type_spec_AudioStateMonitor_Static =
    {
        "winrt._winrt_windows_media_audio.AudioStateMonitor_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_AudioStateMonitor_Static
    };

    // ----- AudioSubmixNode class --------------------

    static PyObject* _new_AudioSubmixNode(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::AudioSubmixNode>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::AudioSubmixNode>::type_name);
        return nullptr;
    }

    static void _dealloc_AudioSubmixNode(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioSubmixNode_AddOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioSubmixNode", L"AddOutgoingConnection", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.AddOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioSubmixNode", L"AddOutgoingConnection", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.AddOutgoingConnection(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_Close(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioSubmixNode", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioSubmixNode", L"DisableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioSubmixNode", L"EnableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_RemoveOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioSubmixNode", L"RemoveOutgoingConnection", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.RemoveOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_Reset(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioSubmixNode", L"Reset", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_Start(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioSubmixNode", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_Stop(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.AudioSubmixNode", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_get_OutgoingConnections(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioSubmixNode", L"OutgoingConnections"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingConnections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_get_Emitter(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioSubmixNode", L"Emitter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Emitter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioSubmixNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioSubmixNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioSubmixNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioSubmixNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioSubmixNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioSubmixNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioSubmixNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioSubmixNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioSubmixNode", L"EffectDefinitions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.AudioSubmixNode", L"EncodingProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_AudioSubmixNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::AudioSubmixNode>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AudioSubmixNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioSubmixNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioSubmixNode(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_AudioSubmixNode(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioSubmixNode[] = {
        { "add_outgoing_connection", reinterpret_cast<PyCFunction>(AudioSubmixNode_AddOutgoingConnection), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(AudioSubmixNode_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioSubmixNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioSubmixNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "remove_outgoing_connection", reinterpret_cast<PyCFunction>(AudioSubmixNode_RemoveOutgoingConnection), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(AudioSubmixNode_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(AudioSubmixNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(AudioSubmixNode_Stop), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_AudioSubmixNode, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioSubmixNode), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioSubmixNode), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_AudioSubmixNode), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioSubmixNode[] = {
        { "outgoing_connections", reinterpret_cast<getter>(AudioSubmixNode_get_OutgoingConnections), nullptr, nullptr, nullptr },
        { "emitter", reinterpret_cast<getter>(AudioSubmixNode_get_Emitter), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(AudioSubmixNode_get_OutgoingGain), reinterpret_cast<setter>(AudioSubmixNode_put_OutgoingGain), nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(AudioSubmixNode_get_ConsumeInput), reinterpret_cast<setter>(AudioSubmixNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(AudioSubmixNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(AudioSubmixNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioSubmixNode[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AudioSubmixNode) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AudioSubmixNode) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AudioSubmixNode) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AudioSubmixNode) },
        { },
    };

    static PyType_Spec type_spec_AudioSubmixNode =
    {
        "winrt._winrt_windows_media_audio.AudioSubmixNode",
        sizeof(py::wrapper::Windows::Media::Audio::AudioSubmixNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioSubmixNode
    };

    // ----- CreateAudioDeviceInputNodeResult class --------------------

    static PyObject* _new_CreateAudioDeviceInputNodeResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::CreateAudioDeviceInputNodeResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::CreateAudioDeviceInputNodeResult>::type_name);
        return nullptr;
    }

    static void _dealloc_CreateAudioDeviceInputNodeResult(py::wrapper::Windows::Media::Audio::CreateAudioDeviceInputNodeResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CreateAudioDeviceInputNodeResult_get_DeviceInputNode(py::wrapper::Windows::Media::Audio::CreateAudioDeviceInputNodeResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioDeviceInputNodeResult", L"DeviceInputNode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceInputNode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioDeviceInputNodeResult_get_Status(py::wrapper::Windows::Media::Audio::CreateAudioDeviceInputNodeResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioDeviceInputNodeResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioDeviceInputNodeResult_get_ExtendedError(py::wrapper::Windows::Media::Audio::CreateAudioDeviceInputNodeResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioDeviceInputNodeResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CreateAudioDeviceInputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::CreateAudioDeviceInputNodeResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CreateAudioDeviceInputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::CreateAudioDeviceInputNodeResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CreateAudioDeviceInputNodeResult[] = {
        { "_assign_array_", _assign_array_CreateAudioDeviceInputNodeResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CreateAudioDeviceInputNodeResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CreateAudioDeviceInputNodeResult[] = {
        { "device_input_node", reinterpret_cast<getter>(CreateAudioDeviceInputNodeResult_get_DeviceInputNode), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(CreateAudioDeviceInputNodeResult_get_Status), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(CreateAudioDeviceInputNodeResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CreateAudioDeviceInputNodeResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CreateAudioDeviceInputNodeResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CreateAudioDeviceInputNodeResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CreateAudioDeviceInputNodeResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CreateAudioDeviceInputNodeResult) },
        { },
    };

    static PyType_Spec type_spec_CreateAudioDeviceInputNodeResult =
    {
        "winrt._winrt_windows_media_audio.CreateAudioDeviceInputNodeResult",
        sizeof(py::wrapper::Windows::Media::Audio::CreateAudioDeviceInputNodeResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CreateAudioDeviceInputNodeResult
    };

    // ----- CreateAudioDeviceOutputNodeResult class --------------------

    static PyObject* _new_CreateAudioDeviceOutputNodeResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult>::type_name);
        return nullptr;
    }

    static void _dealloc_CreateAudioDeviceOutputNodeResult(py::wrapper::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CreateAudioDeviceOutputNodeResult_get_DeviceOutputNode(py::wrapper::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioDeviceOutputNodeResult", L"DeviceOutputNode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceOutputNode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioDeviceOutputNodeResult_get_Status(py::wrapper::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioDeviceOutputNodeResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioDeviceOutputNodeResult_get_ExtendedError(py::wrapper::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioDeviceOutputNodeResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CreateAudioDeviceOutputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CreateAudioDeviceOutputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CreateAudioDeviceOutputNodeResult[] = {
        { "_assign_array_", _assign_array_CreateAudioDeviceOutputNodeResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CreateAudioDeviceOutputNodeResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CreateAudioDeviceOutputNodeResult[] = {
        { "device_output_node", reinterpret_cast<getter>(CreateAudioDeviceOutputNodeResult_get_DeviceOutputNode), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(CreateAudioDeviceOutputNodeResult_get_Status), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(CreateAudioDeviceOutputNodeResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CreateAudioDeviceOutputNodeResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CreateAudioDeviceOutputNodeResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CreateAudioDeviceOutputNodeResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CreateAudioDeviceOutputNodeResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CreateAudioDeviceOutputNodeResult) },
        { },
    };

    static PyType_Spec type_spec_CreateAudioDeviceOutputNodeResult =
    {
        "winrt._winrt_windows_media_audio.CreateAudioDeviceOutputNodeResult",
        sizeof(py::wrapper::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CreateAudioDeviceOutputNodeResult
    };

    // ----- CreateAudioFileInputNodeResult class --------------------

    static PyObject* _new_CreateAudioFileInputNodeResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::CreateAudioFileInputNodeResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::CreateAudioFileInputNodeResult>::type_name);
        return nullptr;
    }

    static void _dealloc_CreateAudioFileInputNodeResult(py::wrapper::Windows::Media::Audio::CreateAudioFileInputNodeResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CreateAudioFileInputNodeResult_get_FileInputNode(py::wrapper::Windows::Media::Audio::CreateAudioFileInputNodeResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioFileInputNodeResult", L"FileInputNode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FileInputNode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioFileInputNodeResult_get_Status(py::wrapper::Windows::Media::Audio::CreateAudioFileInputNodeResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioFileInputNodeResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioFileInputNodeResult_get_ExtendedError(py::wrapper::Windows::Media::Audio::CreateAudioFileInputNodeResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioFileInputNodeResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CreateAudioFileInputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::CreateAudioFileInputNodeResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CreateAudioFileInputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::CreateAudioFileInputNodeResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CreateAudioFileInputNodeResult[] = {
        { "_assign_array_", _assign_array_CreateAudioFileInputNodeResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CreateAudioFileInputNodeResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CreateAudioFileInputNodeResult[] = {
        { "file_input_node", reinterpret_cast<getter>(CreateAudioFileInputNodeResult_get_FileInputNode), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(CreateAudioFileInputNodeResult_get_Status), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(CreateAudioFileInputNodeResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CreateAudioFileInputNodeResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CreateAudioFileInputNodeResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CreateAudioFileInputNodeResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CreateAudioFileInputNodeResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CreateAudioFileInputNodeResult) },
        { },
    };

    static PyType_Spec type_spec_CreateAudioFileInputNodeResult =
    {
        "winrt._winrt_windows_media_audio.CreateAudioFileInputNodeResult",
        sizeof(py::wrapper::Windows::Media::Audio::CreateAudioFileInputNodeResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CreateAudioFileInputNodeResult
    };

    // ----- CreateAudioFileOutputNodeResult class --------------------

    static PyObject* _new_CreateAudioFileOutputNodeResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::CreateAudioFileOutputNodeResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::CreateAudioFileOutputNodeResult>::type_name);
        return nullptr;
    }

    static void _dealloc_CreateAudioFileOutputNodeResult(py::wrapper::Windows::Media::Audio::CreateAudioFileOutputNodeResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CreateAudioFileOutputNodeResult_get_FileOutputNode(py::wrapper::Windows::Media::Audio::CreateAudioFileOutputNodeResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioFileOutputNodeResult", L"FileOutputNode"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FileOutputNode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioFileOutputNodeResult_get_Status(py::wrapper::Windows::Media::Audio::CreateAudioFileOutputNodeResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioFileOutputNodeResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioFileOutputNodeResult_get_ExtendedError(py::wrapper::Windows::Media::Audio::CreateAudioFileOutputNodeResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioFileOutputNodeResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CreateAudioFileOutputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::CreateAudioFileOutputNodeResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CreateAudioFileOutputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::CreateAudioFileOutputNodeResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CreateAudioFileOutputNodeResult[] = {
        { "_assign_array_", _assign_array_CreateAudioFileOutputNodeResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CreateAudioFileOutputNodeResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CreateAudioFileOutputNodeResult[] = {
        { "file_output_node", reinterpret_cast<getter>(CreateAudioFileOutputNodeResult_get_FileOutputNode), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(CreateAudioFileOutputNodeResult_get_Status), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(CreateAudioFileOutputNodeResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CreateAudioFileOutputNodeResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CreateAudioFileOutputNodeResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CreateAudioFileOutputNodeResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CreateAudioFileOutputNodeResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CreateAudioFileOutputNodeResult) },
        { },
    };

    static PyType_Spec type_spec_CreateAudioFileOutputNodeResult =
    {
        "winrt._winrt_windows_media_audio.CreateAudioFileOutputNodeResult",
        sizeof(py::wrapper::Windows::Media::Audio::CreateAudioFileOutputNodeResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CreateAudioFileOutputNodeResult
    };

    // ----- CreateAudioGraphResult class --------------------

    static PyObject* _new_CreateAudioGraphResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::CreateAudioGraphResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::CreateAudioGraphResult>::type_name);
        return nullptr;
    }

    static void _dealloc_CreateAudioGraphResult(py::wrapper::Windows::Media::Audio::CreateAudioGraphResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CreateAudioGraphResult_get_Graph(py::wrapper::Windows::Media::Audio::CreateAudioGraphResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioGraphResult", L"Graph"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Graph());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioGraphResult_get_Status(py::wrapper::Windows::Media::Audio::CreateAudioGraphResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioGraphResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioGraphResult_get_ExtendedError(py::wrapper::Windows::Media::Audio::CreateAudioGraphResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateAudioGraphResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CreateAudioGraphResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::CreateAudioGraphResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CreateAudioGraphResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::CreateAudioGraphResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CreateAudioGraphResult[] = {
        { "_assign_array_", _assign_array_CreateAudioGraphResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CreateAudioGraphResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CreateAudioGraphResult[] = {
        { "graph", reinterpret_cast<getter>(CreateAudioGraphResult_get_Graph), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(CreateAudioGraphResult_get_Status), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(CreateAudioGraphResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CreateAudioGraphResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CreateAudioGraphResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CreateAudioGraphResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CreateAudioGraphResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CreateAudioGraphResult) },
        { },
    };

    static PyType_Spec type_spec_CreateAudioGraphResult =
    {
        "winrt._winrt_windows_media_audio.CreateAudioGraphResult",
        sizeof(py::wrapper::Windows::Media::Audio::CreateAudioGraphResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CreateAudioGraphResult
    };

    // ----- CreateMediaSourceAudioInputNodeResult class --------------------

    static PyObject* _new_CreateMediaSourceAudioInputNodeResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult>::type_name);
        return nullptr;
    }

    static void _dealloc_CreateMediaSourceAudioInputNodeResult(py::wrapper::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CreateMediaSourceAudioInputNodeResult_get_Node(py::wrapper::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateMediaSourceAudioInputNodeResult", L"Node"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Node());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateMediaSourceAudioInputNodeResult_get_Status(py::wrapper::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateMediaSourceAudioInputNodeResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateMediaSourceAudioInputNodeResult_get_ExtendedError(py::wrapper::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.CreateMediaSourceAudioInputNodeResult", L"ExtendedError"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_CreateMediaSourceAudioInputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CreateMediaSourceAudioInputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CreateMediaSourceAudioInputNodeResult[] = {
        { "_assign_array_", _assign_array_CreateMediaSourceAudioInputNodeResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CreateMediaSourceAudioInputNodeResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CreateMediaSourceAudioInputNodeResult[] = {
        { "node", reinterpret_cast<getter>(CreateMediaSourceAudioInputNodeResult_get_Node), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(CreateMediaSourceAudioInputNodeResult_get_Status), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(CreateMediaSourceAudioInputNodeResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CreateMediaSourceAudioInputNodeResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CreateMediaSourceAudioInputNodeResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CreateMediaSourceAudioInputNodeResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CreateMediaSourceAudioInputNodeResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CreateMediaSourceAudioInputNodeResult) },
        { },
    };

    static PyType_Spec type_spec_CreateMediaSourceAudioInputNodeResult =
    {
        "winrt._winrt_windows_media_audio.CreateMediaSourceAudioInputNodeResult",
        sizeof(py::wrapper::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CreateMediaSourceAudioInputNodeResult
    };

    // ----- EchoEffectDefinition class --------------------

    static PyObject* _new_EchoEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioGraph>(args, 0);

                winrt::Windows::Media::Audio::EchoEffectDefinition instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EchoEffectDefinition(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EchoEffectDefinition_get_WetDryMix(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EchoEffectDefinition", L"WetDryMix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WetDryMix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EchoEffectDefinition_put_WetDryMix(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EchoEffectDefinition", L"WetDryMix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.WetDryMix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EchoEffectDefinition_get_Feedback(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EchoEffectDefinition", L"Feedback"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Feedback());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EchoEffectDefinition_put_Feedback(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EchoEffectDefinition", L"Feedback"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Feedback(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EchoEffectDefinition_get_Delay(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EchoEffectDefinition", L"Delay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Delay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EchoEffectDefinition_put_Delay(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EchoEffectDefinition", L"Delay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Delay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EchoEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EchoEffectDefinition", L"ActivatableClassId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EchoEffectDefinition_get_Properties(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EchoEffectDefinition", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EchoEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::EchoEffectDefinition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EchoEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::EchoEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EchoEffectDefinition[] = {
        { "_assign_array_", _assign_array_EchoEffectDefinition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EchoEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EchoEffectDefinition[] = {
        { "wet_dry_mix", reinterpret_cast<getter>(EchoEffectDefinition_get_WetDryMix), reinterpret_cast<setter>(EchoEffectDefinition_put_WetDryMix), nullptr, nullptr },
        { "feedback", reinterpret_cast<getter>(EchoEffectDefinition_get_Feedback), reinterpret_cast<setter>(EchoEffectDefinition_put_Feedback), nullptr, nullptr },
        { "delay", reinterpret_cast<getter>(EchoEffectDefinition_get_Delay), reinterpret_cast<setter>(EchoEffectDefinition_put_Delay), nullptr, nullptr },
        { "activatable_class_id", reinterpret_cast<getter>(EchoEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(EchoEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EchoEffectDefinition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EchoEffectDefinition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EchoEffectDefinition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EchoEffectDefinition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EchoEffectDefinition) },
        { },
    };

    static PyType_Spec type_spec_EchoEffectDefinition =
    {
        "winrt._winrt_windows_media_audio.EchoEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Audio::EchoEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EchoEffectDefinition
    };

    // ----- EqualizerBand class --------------------

    static PyObject* _new_EqualizerBand(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::EqualizerBand>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::EqualizerBand>::type_name);
        return nullptr;
    }

    static void _dealloc_EqualizerBand(py::wrapper::Windows::Media::Audio::EqualizerBand* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EqualizerBand_get_Gain(py::wrapper::Windows::Media::Audio::EqualizerBand* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EqualizerBand", L"Gain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Gain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EqualizerBand_put_Gain(py::wrapper::Windows::Media::Audio::EqualizerBand* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EqualizerBand", L"Gain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Gain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EqualizerBand_get_FrequencyCenter(py::wrapper::Windows::Media::Audio::EqualizerBand* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EqualizerBand", L"FrequencyCenter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.FrequencyCenter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EqualizerBand_put_FrequencyCenter(py::wrapper::Windows::Media::Audio::EqualizerBand* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EqualizerBand", L"FrequencyCenter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.FrequencyCenter(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EqualizerBand_get_Bandwidth(py::wrapper::Windows::Media::Audio::EqualizerBand* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EqualizerBand", L"Bandwidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Bandwidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EqualizerBand_put_Bandwidth(py::wrapper::Windows::Media::Audio::EqualizerBand* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EqualizerBand", L"Bandwidth"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Bandwidth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_EqualizerBand(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::EqualizerBand>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EqualizerBand(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::EqualizerBand>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EqualizerBand[] = {
        { "_assign_array_", _assign_array_EqualizerBand, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EqualizerBand), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EqualizerBand[] = {
        { "gain", reinterpret_cast<getter>(EqualizerBand_get_Gain), reinterpret_cast<setter>(EqualizerBand_put_Gain), nullptr, nullptr },
        { "frequency_center", reinterpret_cast<getter>(EqualizerBand_get_FrequencyCenter), reinterpret_cast<setter>(EqualizerBand_put_FrequencyCenter), nullptr, nullptr },
        { "bandwidth", reinterpret_cast<getter>(EqualizerBand_get_Bandwidth), reinterpret_cast<setter>(EqualizerBand_put_Bandwidth), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EqualizerBand[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EqualizerBand) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EqualizerBand) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EqualizerBand) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EqualizerBand) },
        { },
    };

    static PyType_Spec type_spec_EqualizerBand =
    {
        "winrt._winrt_windows_media_audio.EqualizerBand",
        sizeof(py::wrapper::Windows::Media::Audio::EqualizerBand),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EqualizerBand
    };

    // ----- EqualizerEffectDefinition class --------------------

    static PyObject* _new_EqualizerEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioGraph>(args, 0);

                winrt::Windows::Media::Audio::EqualizerEffectDefinition instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EqualizerEffectDefinition(py::wrapper::Windows::Media::Audio::EqualizerEffectDefinition* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EqualizerEffectDefinition_get_Bands(py::wrapper::Windows::Media::Audio::EqualizerEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EqualizerEffectDefinition", L"Bands"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Bands());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EqualizerEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Audio::EqualizerEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EqualizerEffectDefinition", L"ActivatableClassId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EqualizerEffectDefinition_get_Properties(py::wrapper::Windows::Media::Audio::EqualizerEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.EqualizerEffectDefinition", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_EqualizerEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::EqualizerEffectDefinition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_EqualizerEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::EqualizerEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EqualizerEffectDefinition[] = {
        { "_assign_array_", _assign_array_EqualizerEffectDefinition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EqualizerEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EqualizerEffectDefinition[] = {
        { "bands", reinterpret_cast<getter>(EqualizerEffectDefinition_get_Bands), nullptr, nullptr, nullptr },
        { "activatable_class_id", reinterpret_cast<getter>(EqualizerEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(EqualizerEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EqualizerEffectDefinition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_EqualizerEffectDefinition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_EqualizerEffectDefinition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_EqualizerEffectDefinition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_EqualizerEffectDefinition) },
        { },
    };

    static PyType_Spec type_spec_EqualizerEffectDefinition =
    {
        "winrt._winrt_windows_media_audio.EqualizerEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Audio::EqualizerEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EqualizerEffectDefinition
    };

    // ----- FrameInputNodeQuantumStartedEventArgs class --------------------

    static PyObject* _new_FrameInputNodeQuantumStartedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::FrameInputNodeQuantumStartedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::FrameInputNodeQuantumStartedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_FrameInputNodeQuantumStartedEventArgs(py::wrapper::Windows::Media::Audio::FrameInputNodeQuantumStartedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FrameInputNodeQuantumStartedEventArgs_get_RequiredSamples(py::wrapper::Windows::Media::Audio::FrameInputNodeQuantumStartedEventArgs* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.FrameInputNodeQuantumStartedEventArgs", L"RequiredSamples"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RequiredSamples());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_FrameInputNodeQuantumStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::FrameInputNodeQuantumStartedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_FrameInputNodeQuantumStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::FrameInputNodeQuantumStartedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameInputNodeQuantumStartedEventArgs[] = {
        { "_assign_array_", _assign_array_FrameInputNodeQuantumStartedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameInputNodeQuantumStartedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FrameInputNodeQuantumStartedEventArgs[] = {
        { "required_samples", reinterpret_cast<getter>(FrameInputNodeQuantumStartedEventArgs_get_RequiredSamples), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FrameInputNodeQuantumStartedEventArgs[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_FrameInputNodeQuantumStartedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_FrameInputNodeQuantumStartedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_FrameInputNodeQuantumStartedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_FrameInputNodeQuantumStartedEventArgs) },
        { },
    };

    static PyType_Spec type_spec_FrameInputNodeQuantumStartedEventArgs =
    {
        "winrt._winrt_windows_media_audio.FrameInputNodeQuantumStartedEventArgs",
        sizeof(py::wrapper::Windows::Media::Audio::FrameInputNodeQuantumStartedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameInputNodeQuantumStartedEventArgs
    };

    // ----- LimiterEffectDefinition class --------------------

    static PyObject* _new_LimiterEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioGraph>(args, 0);

                winrt::Windows::Media::Audio::LimiterEffectDefinition instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LimiterEffectDefinition(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LimiterEffectDefinition_get_Release(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.LimiterEffectDefinition", L"Release"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LimiterEffectDefinition_put_Release(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.LimiterEffectDefinition", L"Release"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Release(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LimiterEffectDefinition_get_Loudness(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.LimiterEffectDefinition", L"Loudness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Loudness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LimiterEffectDefinition_put_Loudness(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.LimiterEffectDefinition", L"Loudness"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Loudness(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LimiterEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.LimiterEffectDefinition", L"ActivatableClassId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LimiterEffectDefinition_get_Properties(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.LimiterEffectDefinition", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_LimiterEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::LimiterEffectDefinition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_LimiterEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::LimiterEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LimiterEffectDefinition[] = {
        { "_assign_array_", _assign_array_LimiterEffectDefinition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LimiterEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LimiterEffectDefinition[] = {
        { "release", reinterpret_cast<getter>(LimiterEffectDefinition_get_Release), reinterpret_cast<setter>(LimiterEffectDefinition_put_Release), nullptr, nullptr },
        { "loudness", reinterpret_cast<getter>(LimiterEffectDefinition_get_Loudness), reinterpret_cast<setter>(LimiterEffectDefinition_put_Loudness), nullptr, nullptr },
        { "activatable_class_id", reinterpret_cast<getter>(LimiterEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(LimiterEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LimiterEffectDefinition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_LimiterEffectDefinition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_LimiterEffectDefinition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_LimiterEffectDefinition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_LimiterEffectDefinition) },
        { },
    };

    static PyType_Spec type_spec_LimiterEffectDefinition =
    {
        "winrt._winrt_windows_media_audio.LimiterEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LimiterEffectDefinition
    };

    // ----- MediaSourceAudioInputNode class --------------------

    static PyObject* _new_MediaSourceAudioInputNode(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::MediaSourceAudioInputNode>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::MediaSourceAudioInputNode>::type_name);
        return nullptr;
    }

    static void _dealloc_MediaSourceAudioInputNode(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaSourceAudioInputNode_AddOutgoingConnection(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"AddOutgoingConnection", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.AddOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"AddOutgoingConnection", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.AddOutgoingConnection(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_Close(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"DisableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"EnableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_RemoveOutgoingConnection(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"RemoveOutgoingConnection", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.RemoveOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_Reset(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"Reset", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_Seek(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"Seek", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                self->obj.Seek(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_Start(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_Stop(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_OutgoingConnections(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"OutgoingConnections"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingConnections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_Emitter(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"Emitter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Emitter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaSourceAudioInputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaSourceAudioInputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"EffectDefinitions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"EncodingProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_StartTime(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"StartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaSourceAudioInputNode_put_StartTime(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"StartTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_PlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"PlaybackSpeedFactor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PlaybackSpeedFactor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaSourceAudioInputNode_put_PlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"PlaybackSpeedFactor"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.PlaybackSpeedFactor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_LoopCount(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"LoopCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LoopCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaSourceAudioInputNode_put_LoopCount(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"LoopCount"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.LoopCount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_EndTime(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"EndTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EndTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaSourceAudioInputNode_put_EndTime(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"EndTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.EndTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_Duration(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"Duration"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_MediaSource(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"MediaSource"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MediaSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_Position(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"Position"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_add_MediaSourceCompleted(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"MediaSourceCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::MediaSourceAudioInputNode, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.MediaSourceCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_remove_MediaSourceCompleted(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.MediaSourceAudioInputNode", L"MediaSourceCompleted"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MediaSourceCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_MediaSourceAudioInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::MediaSourceAudioInputNode>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_MediaSourceAudioInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::MediaSourceAudioInputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MediaSourceAudioInputNode(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_MediaSourceAudioInputNode(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaSourceAudioInputNode[] = {
        { "add_outgoing_connection", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_AddOutgoingConnection), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "remove_outgoing_connection", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_RemoveOutgoingConnection), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_Reset), METH_VARARGS, nullptr },
        { "seek", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_Seek), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_Stop), METH_VARARGS, nullptr },
        { "add_media_source_completed", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_add_MediaSourceCompleted), METH_O, nullptr },
        { "remove_media_source_completed", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_remove_MediaSourceCompleted), METH_O, nullptr },
        { "_assign_array_", _assign_array_MediaSourceAudioInputNode, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaSourceAudioInputNode), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MediaSourceAudioInputNode), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_MediaSourceAudioInputNode), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaSourceAudioInputNode[] = {
        { "outgoing_connections", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_OutgoingConnections), nullptr, nullptr, nullptr },
        { "emitter", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_Emitter), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_OutgoingGain), reinterpret_cast<setter>(MediaSourceAudioInputNode_put_OutgoingGain), nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_ConsumeInput), reinterpret_cast<setter>(MediaSourceAudioInputNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_StartTime), reinterpret_cast<setter>(MediaSourceAudioInputNode_put_StartTime), nullptr, nullptr },
        { "playback_speed_factor", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_PlaybackSpeedFactor), reinterpret_cast<setter>(MediaSourceAudioInputNode_put_PlaybackSpeedFactor), nullptr, nullptr },
        { "loop_count", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_LoopCount), reinterpret_cast<setter>(MediaSourceAudioInputNode_put_LoopCount), nullptr, nullptr },
        { "end_time", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_EndTime), reinterpret_cast<setter>(MediaSourceAudioInputNode_put_EndTime), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_Duration), nullptr, nullptr, nullptr },
        { "media_source", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_MediaSource), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaSourceAudioInputNode[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_MediaSourceAudioInputNode) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_MediaSourceAudioInputNode) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_MediaSourceAudioInputNode) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_MediaSourceAudioInputNode) },
        { },
    };

    static PyType_Spec type_spec_MediaSourceAudioInputNode =
    {
        "winrt._winrt_windows_media_audio.MediaSourceAudioInputNode",
        sizeof(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaSourceAudioInputNode
    };

    // ----- ReverbEffectDefinition class --------------------

    static PyObject* _new_ReverbEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioGraph>(args, 0);

                winrt::Windows::Media::Audio::ReverbEffectDefinition instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ReverbEffectDefinition(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ReverbEffectDefinition_get_HighEQGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"HighEQGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HighEQGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_HighEQGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"HighEQGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.HighEQGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_HighEQCutoff(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"HighEQCutoff"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.HighEQCutoff());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_HighEQCutoff(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"HighEQCutoff"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.HighEQCutoff(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_DisableLateField(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"DisableLateField"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DisableLateField());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_DisableLateField(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"DisableLateField"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.DisableLateField(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_Density(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"Density"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Density());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_Density(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"Density"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Density(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_PositionRight(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"PositionRight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PositionRight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_PositionRight(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"PositionRight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.PositionRight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_DecayTime(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"DecayTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DecayTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_DecayTime(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"DecayTime"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.DecayTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_LateDiffusion(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"LateDiffusion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LateDiffusion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_LateDiffusion(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"LateDiffusion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.LateDiffusion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_PositionMatrixRight(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"PositionMatrixRight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PositionMatrixRight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_PositionMatrixRight(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"PositionMatrixRight"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.PositionMatrixRight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_PositionMatrixLeft(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"PositionMatrixLeft"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PositionMatrixLeft());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_PositionMatrixLeft(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"PositionMatrixLeft"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.PositionMatrixLeft(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_PositionLeft(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"PositionLeft"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PositionLeft());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_PositionLeft(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"PositionLeft"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.PositionLeft(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_LowEQGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"LowEQGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LowEQGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_LowEQGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"LowEQGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.LowEQGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_LowEQCutoff(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"LowEQCutoff"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LowEQCutoff());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_LowEQCutoff(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"LowEQCutoff"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.LowEQCutoff(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_RoomFilterFreq(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"RoomFilterFreq"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RoomFilterFreq());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_RoomFilterFreq(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"RoomFilterFreq"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.RoomFilterFreq(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_ReverbGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"ReverbGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReverbGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_ReverbGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"ReverbGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.ReverbGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_ReverbDelay(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"ReverbDelay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReverbDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_ReverbDelay(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"ReverbDelay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.ReverbDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_ReflectionsGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"ReflectionsGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReflectionsGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_ReflectionsGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"ReflectionsGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.ReflectionsGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_ReflectionsDelay(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"ReflectionsDelay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ReflectionsDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_ReflectionsDelay(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"ReflectionsDelay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReflectionsDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_RearDelay(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"RearDelay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RearDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_RearDelay(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"RearDelay"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.RearDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_WetDryMix(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"WetDryMix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.WetDryMix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_WetDryMix(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"WetDryMix"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.WetDryMix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_EarlyDiffusion(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"EarlyDiffusion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EarlyDiffusion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_EarlyDiffusion(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"EarlyDiffusion"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.EarlyDiffusion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_RoomSize(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"RoomSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RoomSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_RoomSize(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"RoomSize"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.RoomSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_RoomFilterMain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"RoomFilterMain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RoomFilterMain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_RoomFilterMain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"RoomFilterMain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.RoomFilterMain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_RoomFilterHF(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"RoomFilterHF"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.RoomFilterHF());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_RoomFilterHF(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"RoomFilterHF"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.RoomFilterHF(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"ActivatableClassId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReverbEffectDefinition_get_Properties(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.ReverbEffectDefinition", L"Properties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_ReverbEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::ReverbEffectDefinition>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_ReverbEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::ReverbEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ReverbEffectDefinition[] = {
        { "_assign_array_", _assign_array_ReverbEffectDefinition, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ReverbEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ReverbEffectDefinition[] = {
        { "high_e_q_gain", reinterpret_cast<getter>(ReverbEffectDefinition_get_HighEQGain), reinterpret_cast<setter>(ReverbEffectDefinition_put_HighEQGain), nullptr, nullptr },
        { "high_e_q_cutoff", reinterpret_cast<getter>(ReverbEffectDefinition_get_HighEQCutoff), reinterpret_cast<setter>(ReverbEffectDefinition_put_HighEQCutoff), nullptr, nullptr },
        { "disable_late_field", reinterpret_cast<getter>(ReverbEffectDefinition_get_DisableLateField), reinterpret_cast<setter>(ReverbEffectDefinition_put_DisableLateField), nullptr, nullptr },
        { "density", reinterpret_cast<getter>(ReverbEffectDefinition_get_Density), reinterpret_cast<setter>(ReverbEffectDefinition_put_Density), nullptr, nullptr },
        { "position_right", reinterpret_cast<getter>(ReverbEffectDefinition_get_PositionRight), reinterpret_cast<setter>(ReverbEffectDefinition_put_PositionRight), nullptr, nullptr },
        { "decay_time", reinterpret_cast<getter>(ReverbEffectDefinition_get_DecayTime), reinterpret_cast<setter>(ReverbEffectDefinition_put_DecayTime), nullptr, nullptr },
        { "late_diffusion", reinterpret_cast<getter>(ReverbEffectDefinition_get_LateDiffusion), reinterpret_cast<setter>(ReverbEffectDefinition_put_LateDiffusion), nullptr, nullptr },
        { "position_matrix_right", reinterpret_cast<getter>(ReverbEffectDefinition_get_PositionMatrixRight), reinterpret_cast<setter>(ReverbEffectDefinition_put_PositionMatrixRight), nullptr, nullptr },
        { "position_matrix_left", reinterpret_cast<getter>(ReverbEffectDefinition_get_PositionMatrixLeft), reinterpret_cast<setter>(ReverbEffectDefinition_put_PositionMatrixLeft), nullptr, nullptr },
        { "position_left", reinterpret_cast<getter>(ReverbEffectDefinition_get_PositionLeft), reinterpret_cast<setter>(ReverbEffectDefinition_put_PositionLeft), nullptr, nullptr },
        { "low_e_q_gain", reinterpret_cast<getter>(ReverbEffectDefinition_get_LowEQGain), reinterpret_cast<setter>(ReverbEffectDefinition_put_LowEQGain), nullptr, nullptr },
        { "low_e_q_cutoff", reinterpret_cast<getter>(ReverbEffectDefinition_get_LowEQCutoff), reinterpret_cast<setter>(ReverbEffectDefinition_put_LowEQCutoff), nullptr, nullptr },
        { "room_filter_freq", reinterpret_cast<getter>(ReverbEffectDefinition_get_RoomFilterFreq), reinterpret_cast<setter>(ReverbEffectDefinition_put_RoomFilterFreq), nullptr, nullptr },
        { "reverb_gain", reinterpret_cast<getter>(ReverbEffectDefinition_get_ReverbGain), reinterpret_cast<setter>(ReverbEffectDefinition_put_ReverbGain), nullptr, nullptr },
        { "reverb_delay", reinterpret_cast<getter>(ReverbEffectDefinition_get_ReverbDelay), reinterpret_cast<setter>(ReverbEffectDefinition_put_ReverbDelay), nullptr, nullptr },
        { "reflections_gain", reinterpret_cast<getter>(ReverbEffectDefinition_get_ReflectionsGain), reinterpret_cast<setter>(ReverbEffectDefinition_put_ReflectionsGain), nullptr, nullptr },
        { "reflections_delay", reinterpret_cast<getter>(ReverbEffectDefinition_get_ReflectionsDelay), reinterpret_cast<setter>(ReverbEffectDefinition_put_ReflectionsDelay), nullptr, nullptr },
        { "rear_delay", reinterpret_cast<getter>(ReverbEffectDefinition_get_RearDelay), reinterpret_cast<setter>(ReverbEffectDefinition_put_RearDelay), nullptr, nullptr },
        { "wet_dry_mix", reinterpret_cast<getter>(ReverbEffectDefinition_get_WetDryMix), reinterpret_cast<setter>(ReverbEffectDefinition_put_WetDryMix), nullptr, nullptr },
        { "early_diffusion", reinterpret_cast<getter>(ReverbEffectDefinition_get_EarlyDiffusion), reinterpret_cast<setter>(ReverbEffectDefinition_put_EarlyDiffusion), nullptr, nullptr },
        { "room_size", reinterpret_cast<getter>(ReverbEffectDefinition_get_RoomSize), reinterpret_cast<setter>(ReverbEffectDefinition_put_RoomSize), nullptr, nullptr },
        { "room_filter_main", reinterpret_cast<getter>(ReverbEffectDefinition_get_RoomFilterMain), reinterpret_cast<setter>(ReverbEffectDefinition_put_RoomFilterMain), nullptr, nullptr },
        { "room_filter_h_f", reinterpret_cast<getter>(ReverbEffectDefinition_get_RoomFilterHF), reinterpret_cast<setter>(ReverbEffectDefinition_put_RoomFilterHF), nullptr, nullptr },
        { "activatable_class_id", reinterpret_cast<getter>(ReverbEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(ReverbEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ReverbEffectDefinition[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_ReverbEffectDefinition) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_ReverbEffectDefinition) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_ReverbEffectDefinition) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_ReverbEffectDefinition) },
        { },
    };

    static PyType_Spec type_spec_ReverbEffectDefinition =
    {
        "winrt._winrt_windows_media_audio.ReverbEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ReverbEffectDefinition
    };

    // ----- SetDefaultSpatialAudioFormatResult class --------------------

    static PyObject* _new_SetDefaultSpatialAudioFormatResult(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::SetDefaultSpatialAudioFormatResult>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::SetDefaultSpatialAudioFormatResult>::type_name);
        return nullptr;
    }

    static void _dealloc_SetDefaultSpatialAudioFormatResult(py::wrapper::Windows::Media::Audio::SetDefaultSpatialAudioFormatResult* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SetDefaultSpatialAudioFormatResult_get_Status(py::wrapper::Windows::Media::Audio::SetDefaultSpatialAudioFormatResult* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SetDefaultSpatialAudioFormatResult", L"Status"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SetDefaultSpatialAudioFormatResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::SetDefaultSpatialAudioFormatResult>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SetDefaultSpatialAudioFormatResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::SetDefaultSpatialAudioFormatResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SetDefaultSpatialAudioFormatResult[] = {
        { "_assign_array_", _assign_array_SetDefaultSpatialAudioFormatResult, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SetDefaultSpatialAudioFormatResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SetDefaultSpatialAudioFormatResult[] = {
        { "status", reinterpret_cast<getter>(SetDefaultSpatialAudioFormatResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SetDefaultSpatialAudioFormatResult[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SetDefaultSpatialAudioFormatResult) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SetDefaultSpatialAudioFormatResult) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SetDefaultSpatialAudioFormatResult) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SetDefaultSpatialAudioFormatResult) },
        { },
    };

    static PyType_Spec type_spec_SetDefaultSpatialAudioFormatResult =
    {
        "winrt._winrt_windows_media_audio.SetDefaultSpatialAudioFormatResult",
        sizeof(py::wrapper::Windows::Media::Audio::SetDefaultSpatialAudioFormatResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SetDefaultSpatialAudioFormatResult
    };

    // ----- SpatialAudioDeviceConfiguration class --------------------

    static PyObject* _new_SpatialAudioDeviceConfiguration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::SpatialAudioDeviceConfiguration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::SpatialAudioDeviceConfiguration>::type_name);
        return nullptr;
    }

    static void _dealloc_SpatialAudioDeviceConfiguration(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialAudioDeviceConfiguration_GetForDeviceId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.SpatialAudioDeviceConfiguration", L"GetForDeviceId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Media::Audio::SpatialAudioDeviceConfiguration::GetForDeviceId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_IsSpatialAudioFormatSupported(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.SpatialAudioDeviceConfiguration", L"IsSpatialAudioFormatSupported", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.IsSpatialAudioFormatSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_SetDefaultSpatialAudioFormatAsync(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.SpatialAudioDeviceConfiguration", L"SetDefaultSpatialAudioFormatAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.SetDefaultSpatialAudioFormatAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_get_ActiveSpatialAudioFormat(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SpatialAudioDeviceConfiguration", L"ActiveSpatialAudioFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ActiveSpatialAudioFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_get_DefaultSpatialAudioFormat(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SpatialAudioDeviceConfiguration", L"DefaultSpatialAudioFormat"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DefaultSpatialAudioFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_get_DeviceId(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SpatialAudioDeviceConfiguration", L"DeviceId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_get_IsSpatialAudioSupported(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SpatialAudioDeviceConfiguration", L"IsSpatialAudioSupported"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.IsSpatialAudioSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_add_ConfigurationChanged(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.SpatialAudioDeviceConfiguration", L"ConfigurationChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::SpatialAudioDeviceConfiguration, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ConfigurationChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_remove_ConfigurationChanged(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, PyObject* arg) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Windows.Media.Audio.SpatialAudioDeviceConfiguration", L"ConfigurationChanged"))
        {
            PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ConfigurationChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SpatialAudioDeviceConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::SpatialAudioDeviceConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialAudioDeviceConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::SpatialAudioDeviceConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialAudioDeviceConfiguration[] = {
        { "is_spatial_audio_format_supported", reinterpret_cast<PyCFunction>(SpatialAudioDeviceConfiguration_IsSpatialAudioFormatSupported), METH_VARARGS, nullptr },
        { "set_default_spatial_audio_format_async", reinterpret_cast<PyCFunction>(SpatialAudioDeviceConfiguration_SetDefaultSpatialAudioFormatAsync), METH_VARARGS, nullptr },
        { "add_configuration_changed", reinterpret_cast<PyCFunction>(SpatialAudioDeviceConfiguration_add_ConfigurationChanged), METH_O, nullptr },
        { "remove_configuration_changed", reinterpret_cast<PyCFunction>(SpatialAudioDeviceConfiguration_remove_ConfigurationChanged), METH_O, nullptr },
        { "_assign_array_", _assign_array_SpatialAudioDeviceConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialAudioDeviceConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialAudioDeviceConfiguration[] = {
        { "active_spatial_audio_format", reinterpret_cast<getter>(SpatialAudioDeviceConfiguration_get_ActiveSpatialAudioFormat), nullptr, nullptr, nullptr },
        { "default_spatial_audio_format", reinterpret_cast<getter>(SpatialAudioDeviceConfiguration_get_DefaultSpatialAudioFormat), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(SpatialAudioDeviceConfiguration_get_DeviceId), nullptr, nullptr, nullptr },
        { "is_spatial_audio_supported", reinterpret_cast<getter>(SpatialAudioDeviceConfiguration_get_IsSpatialAudioSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialAudioDeviceConfiguration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialAudioDeviceConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialAudioDeviceConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialAudioDeviceConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialAudioDeviceConfiguration) },
        { },
    };

    static PyType_Spec type_spec_SpatialAudioDeviceConfiguration =
    {
        "winrt._winrt_windows_media_audio.SpatialAudioDeviceConfiguration",
        sizeof(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialAudioDeviceConfiguration
    };

    static PyGetSetDef getset_SpatialAudioDeviceConfiguration_Static[] = {
        { }
    };

    static PyMethodDef methods_SpatialAudioDeviceConfiguration_Static[] = {
        { "get_for_device_id", reinterpret_cast<PyCFunction>(SpatialAudioDeviceConfiguration_GetForDeviceId), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_SpatialAudioDeviceConfiguration_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SpatialAudioDeviceConfiguration_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SpatialAudioDeviceConfiguration_Static) },
        { }
    };

    static PyType_Spec type_spec_SpatialAudioDeviceConfiguration_Static =
    {
        "winrt._winrt_windows_media_audio.SpatialAudioDeviceConfiguration_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SpatialAudioDeviceConfiguration_Static
    };

    // ----- SpatialAudioFormatConfiguration class --------------------

    static PyObject* _new_SpatialAudioFormatConfiguration(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::SpatialAudioFormatConfiguration>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::SpatialAudioFormatConfiguration>::type_name);
        return nullptr;
    }

    static void _dealloc_SpatialAudioFormatConfiguration(py::wrapper::Windows::Media::Audio::SpatialAudioFormatConfiguration* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpatialAudioFormatConfiguration_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.SpatialAudioFormatConfiguration", L"GetDefault", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(winrt::Windows::Media::Audio::SpatialAudioFormatConfiguration::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatConfiguration_ReportConfigurationChangedAsync(py::wrapper::Windows::Media::Audio::SpatialAudioFormatConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.SpatialAudioFormatConfiguration", L"ReportConfigurationChangedAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ReportConfigurationChangedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatConfiguration_ReportLicenseChangedAsync(py::wrapper::Windows::Media::Audio::SpatialAudioFormatConfiguration* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.SpatialAudioFormatConfiguration", L"ReportLicenseChangedAsync", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ReportLicenseChangedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatConfiguration_get_MixedRealityExclusiveModePolicy(py::wrapper::Windows::Media::Audio::SpatialAudioFormatConfiguration* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SpatialAudioFormatConfiguration", L"MixedRealityExclusiveModePolicy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.MixedRealityExclusiveModePolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpatialAudioFormatConfiguration_put_MixedRealityExclusiveModePolicy(py::wrapper::Windows::Media::Audio::SpatialAudioFormatConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SpatialAudioFormatConfiguration", L"MixedRealityExclusiveModePolicy"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Audio::MixedRealitySpatialAudioFormatPolicy>(arg);

            self->obj.MixedRealityExclusiveModePolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_SpatialAudioFormatConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::SpatialAudioFormatConfiguration>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SpatialAudioFormatConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::SpatialAudioFormatConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialAudioFormatConfiguration[] = {
        { "report_configuration_changed_async", reinterpret_cast<PyCFunction>(SpatialAudioFormatConfiguration_ReportConfigurationChangedAsync), METH_VARARGS, nullptr },
        { "report_license_changed_async", reinterpret_cast<PyCFunction>(SpatialAudioFormatConfiguration_ReportLicenseChangedAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SpatialAudioFormatConfiguration, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialAudioFormatConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialAudioFormatConfiguration[] = {
        { "mixed_reality_exclusive_mode_policy", reinterpret_cast<getter>(SpatialAudioFormatConfiguration_get_MixedRealityExclusiveModePolicy), reinterpret_cast<setter>(SpatialAudioFormatConfiguration_put_MixedRealityExclusiveModePolicy), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialAudioFormatConfiguration[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialAudioFormatConfiguration) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SpatialAudioFormatConfiguration) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialAudioFormatConfiguration) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialAudioFormatConfiguration) },
        { },
    };

    static PyType_Spec type_spec_SpatialAudioFormatConfiguration =
    {
        "winrt._winrt_windows_media_audio.SpatialAudioFormatConfiguration",
        sizeof(py::wrapper::Windows::Media::Audio::SpatialAudioFormatConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialAudioFormatConfiguration
    };

    static PyGetSetDef getset_SpatialAudioFormatConfiguration_Static[] = {
        { }
    };

    static PyMethodDef methods_SpatialAudioFormatConfiguration_Static[] = {
        { "get_default", reinterpret_cast<PyCFunction>(SpatialAudioFormatConfiguration_GetDefault), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_SpatialAudioFormatConfiguration_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SpatialAudioFormatConfiguration_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SpatialAudioFormatConfiguration_Static) },
        { }
    };

    static PyType_Spec type_spec_SpatialAudioFormatConfiguration_Static =
    {
        "winrt._winrt_windows_media_audio.SpatialAudioFormatConfiguration_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SpatialAudioFormatConfiguration_Static
    };

    // ----- SpatialAudioFormatSubtype class --------------------

    static PyObject* _new_SpatialAudioFormatSubtype(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::SpatialAudioFormatSubtype>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::SpatialAudioFormatSubtype>::type_name);
        return nullptr;
    }

    static PyObject* SpatialAudioFormatSubtype_get_DTSHeadphoneX(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SpatialAudioFormatSubtype", L"DTSHeadphoneX"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Audio::SpatialAudioFormatSubtype::DTSHeadphoneX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatSubtype_get_DTSXUltra(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SpatialAudioFormatSubtype", L"DTSXUltra"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Audio::SpatialAudioFormatSubtype::DTSXUltra());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatSubtype_get_DolbyAtmosForHeadphones(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SpatialAudioFormatSubtype", L"DolbyAtmosForHeadphones"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Audio::SpatialAudioFormatSubtype::DolbyAtmosForHeadphones());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatSubtype_get_DolbyAtmosForHomeTheater(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SpatialAudioFormatSubtype", L"DolbyAtmosForHomeTheater"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Audio::SpatialAudioFormatSubtype::DolbyAtmosForHomeTheater());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatSubtype_get_DolbyAtmosForSpeakers(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SpatialAudioFormatSubtype", L"DolbyAtmosForSpeakers"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Audio::SpatialAudioFormatSubtype::DolbyAtmosForSpeakers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatSubtype_get_WindowsSonic(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SpatialAudioFormatSubtype", L"WindowsSonic"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Audio::SpatialAudioFormatSubtype::WindowsSonic());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatSubtype_get_DTSXForHomeTheater(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.SpatialAudioFormatSubtype", L"DTSXForHomeTheater"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Windows::Media::Audio::SpatialAudioFormatSubtype::DTSXForHomeTheater());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialAudioFormatSubtype[] = {
        { }
    };

    static PyGetSetDef _getset_SpatialAudioFormatSubtype[] = {
        { }
    };

    static PyType_Slot _type_slots_SpatialAudioFormatSubtype[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_SpatialAudioFormatSubtype) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SpatialAudioFormatSubtype) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SpatialAudioFormatSubtype) },
        { },
    };

    static PyType_Spec type_spec_SpatialAudioFormatSubtype =
    {
        "winrt._winrt_windows_media_audio.SpatialAudioFormatSubtype",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialAudioFormatSubtype
    };

    static PyGetSetDef getset_SpatialAudioFormatSubtype_Static[] = {
        { "d_t_s_headphone_x", reinterpret_cast<getter>(SpatialAudioFormatSubtype_get_DTSHeadphoneX), nullptr, nullptr, nullptr },
        { "d_t_s_x_ultra", reinterpret_cast<getter>(SpatialAudioFormatSubtype_get_DTSXUltra), nullptr, nullptr, nullptr },
        { "dolby_atmos_for_headphones", reinterpret_cast<getter>(SpatialAudioFormatSubtype_get_DolbyAtmosForHeadphones), nullptr, nullptr, nullptr },
        { "dolby_atmos_for_home_theater", reinterpret_cast<getter>(SpatialAudioFormatSubtype_get_DolbyAtmosForHomeTheater), nullptr, nullptr, nullptr },
        { "dolby_atmos_for_speakers", reinterpret_cast<getter>(SpatialAudioFormatSubtype_get_DolbyAtmosForSpeakers), nullptr, nullptr, nullptr },
        { "windows_sonic", reinterpret_cast<getter>(SpatialAudioFormatSubtype_get_WindowsSonic), nullptr, nullptr, nullptr },
        { "d_t_s_x_for_home_theater", reinterpret_cast<getter>(SpatialAudioFormatSubtype_get_DTSXForHomeTheater), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_SpatialAudioFormatSubtype_Static[] = {
        { }
    };

    static PyType_Slot type_slots_SpatialAudioFormatSubtype_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SpatialAudioFormatSubtype_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SpatialAudioFormatSubtype_Static) },
        { }
    };

    static PyType_Spec type_spec_SpatialAudioFormatSubtype_Static =
    {
        "winrt._winrt_windows_media_audio.SpatialAudioFormatSubtype_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_SpatialAudioFormatSubtype_Static
    };

    // ----- IAudioInputNode interface --------------------

    static PyObject* _new_IAudioInputNode(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::IAudioInputNode>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::IAudioInputNode>::type_name);
        return nullptr;
    }

    static void _dealloc_IAudioInputNode(py::wrapper::Windows::Media::Audio::IAudioInputNode* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAudioInputNode_AddOutgoingConnection(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioInputNode", L"AddOutgoingConnection", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.AddOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioInputNode", L"AddOutgoingConnection", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.AddOutgoingConnection(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_Close(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"DisableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"EnableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_RemoveOutgoingConnection(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioInputNode", L"RemoveOutgoingConnection", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.RemoveOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_Reset(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"Reset", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_Start(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_Stop(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_get_OutgoingConnections(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioInputNode", L"OutgoingConnections"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingConnections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioInputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAudioInputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"EffectDefinitions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"EncodingProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioInputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IAudioInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::IAudioInputNode>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAudioInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::IAudioInputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IAudioInputNode(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_IAudioInputNode(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAudioInputNode[] = {
        { "add_outgoing_connection", reinterpret_cast<PyCFunction>(IAudioInputNode_AddOutgoingConnection), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(IAudioInputNode_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(IAudioInputNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(IAudioInputNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "remove_outgoing_connection", reinterpret_cast<PyCFunction>(IAudioInputNode_RemoveOutgoingConnection), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(IAudioInputNode_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(IAudioInputNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(IAudioInputNode_Stop), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IAudioInputNode, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAudioInputNode), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IAudioInputNode), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_IAudioInputNode), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAudioInputNode[] = {
        { "outgoing_connections", reinterpret_cast<getter>(IAudioInputNode_get_OutgoingConnections), nullptr, nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(IAudioInputNode_get_ConsumeInput), reinterpret_cast<setter>(IAudioInputNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(IAudioInputNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(IAudioInputNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(IAudioInputNode_get_OutgoingGain), reinterpret_cast<setter>(IAudioInputNode_put_OutgoingGain), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAudioInputNode[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IAudioInputNode) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAudioInputNode) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAudioInputNode) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAudioInputNode) },
        { },
    };

    static PyType_Spec type_spec_IAudioInputNode =
    {
        "winrt._winrt_windows_media_audio.IAudioInputNode",
        sizeof(py::wrapper::Windows::Media::Audio::IAudioInputNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAudioInputNode
    };

    // ----- IAudioInputNode2 interface --------------------

    static PyObject* _new_IAudioInputNode2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::IAudioInputNode2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::IAudioInputNode2>::type_name);
        return nullptr;
    }

    static void _dealloc_IAudioInputNode2(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAudioInputNode2_AddOutgoingConnection(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioInputNode", L"AddOutgoingConnection", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.AddOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioInputNode", L"AddOutgoingConnection", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.AddOutgoingConnection(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_Close(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"DisableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"EnableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_RemoveOutgoingConnection(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioInputNode", L"RemoveOutgoingConnection", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.RemoveOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_Reset(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"Reset", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_Start(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_Stop(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_get_Emitter(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioInputNode2", L"Emitter"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Emitter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_get_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioInputNode2_put_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAudioInputNode2_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"EffectDefinitions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_get_EncodingProperties(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"EncodingProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_get_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioInputNode2_put_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAudioInputNode2_get_OutgoingConnections(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioInputNode", L"OutgoingConnections"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingConnections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_IAudioInputNode2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::IAudioInputNode2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAudioInputNode2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::IAudioInputNode2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IAudioInputNode2(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_IAudioInputNode2(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAudioInputNode2[] = {
        { "add_outgoing_connection", reinterpret_cast<PyCFunction>(IAudioInputNode2_AddOutgoingConnection), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(IAudioInputNode2_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(IAudioInputNode2_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(IAudioInputNode2_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "remove_outgoing_connection", reinterpret_cast<PyCFunction>(IAudioInputNode2_RemoveOutgoingConnection), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(IAudioInputNode2_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(IAudioInputNode2_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(IAudioInputNode2_Stop), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IAudioInputNode2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAudioInputNode2), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IAudioInputNode2), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_IAudioInputNode2), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAudioInputNode2[] = {
        { "emitter", reinterpret_cast<getter>(IAudioInputNode2_get_Emitter), nullptr, nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(IAudioInputNode2_get_ConsumeInput), reinterpret_cast<setter>(IAudioInputNode2_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(IAudioInputNode2_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(IAudioInputNode2_get_EncodingProperties), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(IAudioInputNode2_get_OutgoingGain), reinterpret_cast<setter>(IAudioInputNode2_put_OutgoingGain), nullptr, nullptr },
        { "outgoing_connections", reinterpret_cast<getter>(IAudioInputNode2_get_OutgoingConnections), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAudioInputNode2[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IAudioInputNode2) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAudioInputNode2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAudioInputNode2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAudioInputNode2) },
        { },
    };

    static PyType_Spec type_spec_IAudioInputNode2 =
    {
        "winrt._winrt_windows_media_audio.IAudioInputNode2",
        sizeof(py::wrapper::Windows::Media::Audio::IAudioInputNode2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAudioInputNode2
    };

    // ----- IAudioNode interface --------------------

    static PyObject* _new_IAudioNode(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::IAudioNode>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::IAudioNode>::type_name);
        return nullptr;
    }

    static void _dealloc_IAudioNode(py::wrapper::Windows::Media::Audio::IAudioNode* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAudioNode_Close(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"DisableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"EnableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNode_Reset(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"Reset", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNode_Start(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNode_Stop(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAudioNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::IAudioNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"EffectDefinitions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::IAudioNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"EncodingProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioNode* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IAudioNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::IAudioNode>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAudioNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::IAudioNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IAudioNode(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_IAudioNode(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAudioNode[] = {
        { "close", reinterpret_cast<PyCFunction>(IAudioNode_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(IAudioNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(IAudioNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(IAudioNode_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(IAudioNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(IAudioNode_Stop), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IAudioNode, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAudioNode), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IAudioNode), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_IAudioNode), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAudioNode[] = {
        { "consume_input", reinterpret_cast<getter>(IAudioNode_get_ConsumeInput), reinterpret_cast<setter>(IAudioNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(IAudioNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(IAudioNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(IAudioNode_get_OutgoingGain), reinterpret_cast<setter>(IAudioNode_put_OutgoingGain), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAudioNode[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IAudioNode) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAudioNode) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAudioNode) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAudioNode) },
        { },
    };

    static PyType_Spec type_spec_IAudioNode =
    {
        "winrt._winrt_windows_media_audio.IAudioNode",
        sizeof(py::wrapper::Windows::Media::Audio::IAudioNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAudioNode
    };

    // ----- IAudioNodeWithListener interface --------------------

    static PyObject* _new_IAudioNodeWithListener(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Windows::Media::Audio::IAudioNodeWithListener>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Windows::Media::Audio::IAudioNodeWithListener>::type_name);
        return nullptr;
    }

    static void _dealloc_IAudioNodeWithListener(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAudioNodeWithListener_Close(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Foundation.IClosable", L"Close", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"DisableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"EnableEffectsByDefinition", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_Reset(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"Reset", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_Start(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"Start", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_Stop(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Windows.Media.Audio.IAudioNode", L"Stop", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_get_Listener(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNodeWithListener", L"Listener"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Listener());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioNodeWithListener_put_Listener(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNodeWithListener", L"Listener"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeListener>(arg);

            self->obj.Listener(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAudioNodeWithListener_get_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioNodeWithListener_put_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"ConsumeInput"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAudioNodeWithListener_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"EffectDefinitions"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_get_EncodingProperties(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"EncodingProperties"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_get_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioNodeWithListener_put_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Windows.Media.Audio.IAudioNode", L"OutgoingGain"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_IAudioNodeWithListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Windows::Media::Audio::IAudioNodeWithListener>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IAudioNodeWithListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::IAudioNodeWithListener>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IAudioNodeWithListener(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_IAudioNodeWithListener(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAudioNodeWithListener[] = {
        { "close", reinterpret_cast<PyCFunction>(IAudioNodeWithListener_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(IAudioNodeWithListener_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(IAudioNodeWithListener_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(IAudioNodeWithListener_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(IAudioNodeWithListener_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(IAudioNodeWithListener_Stop), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_IAudioNodeWithListener, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAudioNodeWithListener), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IAudioNodeWithListener), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_IAudioNodeWithListener), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAudioNodeWithListener[] = {
        { "listener", reinterpret_cast<getter>(IAudioNodeWithListener_get_Listener), reinterpret_cast<setter>(IAudioNodeWithListener_put_Listener), nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(IAudioNodeWithListener_get_ConsumeInput), reinterpret_cast<setter>(IAudioNodeWithListener_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(IAudioNodeWithListener_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(IAudioNodeWithListener_get_EncodingProperties), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(IAudioNodeWithListener_get_OutgoingGain), reinterpret_cast<setter>(IAudioNodeWithListener_put_OutgoingGain), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAudioNodeWithListener[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_IAudioNodeWithListener) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IAudioNodeWithListener) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IAudioNodeWithListener) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IAudioNodeWithListener) },
        { },
    };

    static PyType_Spec type_spec_IAudioNodeWithListener =
    {
        "winrt._winrt_windows_media_audio.IAudioNodeWithListener",
        sizeof(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAudioNodeWithListener
    };

    // ----- Windows.Media.Audio Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Media::Audio");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_windows_media_audio",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Windows::Media::Audio

PyMODINIT_FUNC PyInit__winrt_windows_media_audio(void) noexcept
{
    using namespace py::cpp::Windows::Media::Audio;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AudioDeviceInputNode, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AudioDeviceOutputNode, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AudioFileInputNode, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AudioFileOutputNode, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AudioFrameCompletedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AudioFrameInputNode, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AudioFrameOutputNode, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_AudioGraph_Static{PyType_FromSpec(&type_spec_AudioGraph_Static)};
    if (!type_AudioGraph_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AudioGraph, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AudioGraph_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AudioGraphBatchUpdater, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AudioGraphConnection, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AudioGraphSettings, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AudioGraphUnrecoverableErrorOccurredEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AudioNodeEmitter, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AudioNodeEmitterConeProperties, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_AudioNodeEmitterDecayModel_Static{PyType_FromSpec(&type_spec_AudioNodeEmitterDecayModel_Static)};
    if (!type_AudioNodeEmitterDecayModel_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AudioNodeEmitterDecayModel, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AudioNodeEmitterDecayModel_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AudioNodeEmitterNaturalDecayModelProperties, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_AudioNodeEmitterShape_Static{PyType_FromSpec(&type_spec_AudioNodeEmitterShape_Static)};
    if (!type_AudioNodeEmitterShape_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AudioNodeEmitterShape, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AudioNodeEmitterShape_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AudioNodeListener, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_AudioPlaybackConnection_Static{PyType_FromSpec(&type_spec_AudioPlaybackConnection_Static)};
    if (!type_AudioPlaybackConnection_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AudioPlaybackConnection, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AudioPlaybackConnection_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AudioPlaybackConnectionOpenResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_AudioStateMonitor_Static{PyType_FromSpec(&type_spec_AudioStateMonitor_Static)};
    if (!type_AudioStateMonitor_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AudioStateMonitor, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_AudioStateMonitor_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AudioSubmixNode, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CreateAudioDeviceInputNodeResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CreateAudioDeviceOutputNodeResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CreateAudioFileInputNodeResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CreateAudioFileOutputNodeResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CreateAudioGraphResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CreateMediaSourceAudioInputNodeResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EchoEffectDefinition, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EqualizerBand, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_EqualizerEffectDefinition, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_FrameInputNodeQuantumStartedEventArgs, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_LimiterEffectDefinition, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_MediaSourceAudioInputNode, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_ReverbEffectDefinition, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SetDefaultSpatialAudioFormatResult, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_SpatialAudioDeviceConfiguration_Static{PyType_FromSpec(&type_spec_SpatialAudioDeviceConfiguration_Static)};
    if (!type_SpatialAudioDeviceConfiguration_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SpatialAudioDeviceConfiguration, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SpatialAudioDeviceConfiguration_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_SpatialAudioFormatConfiguration_Static{PyType_FromSpec(&type_spec_SpatialAudioFormatConfiguration_Static)};
    if (!type_SpatialAudioFormatConfiguration_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SpatialAudioFormatConfiguration, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SpatialAudioFormatConfiguration_Static.get())) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_SpatialAudioFormatSubtype_Static{PyType_FromSpec(&type_spec_SpatialAudioFormatSubtype_Static)};
    if (!type_SpatialAudioFormatSubtype_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_SpatialAudioFormatSubtype, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_SpatialAudioFormatSubtype_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IAudioInputNode, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IAudioInputNode2, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IAudioNode, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_IAudioNodeWithListener, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
