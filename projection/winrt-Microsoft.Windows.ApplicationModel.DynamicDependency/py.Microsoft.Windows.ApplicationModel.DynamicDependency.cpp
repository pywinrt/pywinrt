// WARNING: Please don't edit this file. It was generated by Python/WinRT v2.0.0-beta.2

#include "py.Microsoft.Windows.ApplicationModel.DynamicDependency.h"


namespace py::cpp::Microsoft::Windows::ApplicationModel::DynamicDependency
{
    // ----- AddPackageDependencyOptions class --------------------

    static PyObject* _new_AddPackageDependencyOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::AddPackageDependencyOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AddPackageDependencyOptions(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::AddPackageDependencyOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AddPackageDependencyOptions_get_Rank(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::AddPackageDependencyOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.AddPackageDependencyOptions", L"Rank"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Rank());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageDependencyOptions_put_Rank(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::AddPackageDependencyOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.AddPackageDependencyOptions", L"Rank"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Rank(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageDependencyOptions_get_PrependIfRankCollision(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::AddPackageDependencyOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.AddPackageDependencyOptions", L"PrependIfRankCollision"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PrependIfRankCollision());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageDependencyOptions_put_PrependIfRankCollision(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::AddPackageDependencyOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.AddPackageDependencyOptions", L"PrependIfRankCollision"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.PrependIfRankCollision(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AddPackageDependencyOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::AddPackageDependencyOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AddPackageDependencyOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::AddPackageDependencyOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AddPackageDependencyOptions[] = {
        { "_assign_array_", _assign_array_AddPackageDependencyOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AddPackageDependencyOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AddPackageDependencyOptions[] = {
        { "rank", reinterpret_cast<getter>(AddPackageDependencyOptions_get_Rank), reinterpret_cast<setter>(AddPackageDependencyOptions_put_Rank), nullptr, nullptr },
        { "prepend_if_rank_collision", reinterpret_cast<getter>(AddPackageDependencyOptions_get_PrependIfRankCollision), reinterpret_cast<setter>(AddPackageDependencyOptions_put_PrependIfRankCollision), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AddPackageDependencyOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_AddPackageDependencyOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AddPackageDependencyOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AddPackageDependencyOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AddPackageDependencyOptions) },
        { },
    };

    static PyType_Spec type_spec_AddPackageDependencyOptions =
    {
        "winrt._winrt_microsoft_windows_applicationmodel_dynamicdependency.AddPackageDependencyOptions",
        sizeof(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::AddPackageDependencyOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AddPackageDependencyOptions
    };

    // ----- CreatePackageDependencyOptions class --------------------

    static PyObject* _new_CreatePackageDependencyOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CreatePackageDependencyOptions(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CreatePackageDependencyOptions_get_VerifyDependencyResolution(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.CreatePackageDependencyOptions", L"VerifyDependencyResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.VerifyDependencyResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CreatePackageDependencyOptions_put_VerifyDependencyResolution(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.CreatePackageDependencyOptions", L"VerifyDependencyResolution"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.VerifyDependencyResolution(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CreatePackageDependencyOptions_get_LifetimeArtifactKind(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.CreatePackageDependencyOptions", L"LifetimeArtifactKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LifetimeArtifactKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CreatePackageDependencyOptions_put_LifetimeArtifactKind(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.CreatePackageDependencyOptions", L"LifetimeArtifactKind"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyLifetimeArtifactKind>(arg);

            self->obj.LifetimeArtifactKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CreatePackageDependencyOptions_get_LifetimeArtifact(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.CreatePackageDependencyOptions", L"LifetimeArtifact"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.LifetimeArtifact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CreatePackageDependencyOptions_put_LifetimeArtifact(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.CreatePackageDependencyOptions", L"LifetimeArtifact"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.LifetimeArtifact(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CreatePackageDependencyOptions_get_Architectures(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.CreatePackageDependencyOptions", L"Architectures"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Architectures());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CreatePackageDependencyOptions_put_Architectures(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.CreatePackageDependencyOptions", L"Architectures"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return -1;
        }

        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyProcessorArchitectures>(arg);

            self->obj.Architectures(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CreatePackageDependencyOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CreatePackageDependencyOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CreatePackageDependencyOptions[] = {
        { "_assign_array_", _assign_array_CreatePackageDependencyOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CreatePackageDependencyOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CreatePackageDependencyOptions[] = {
        { "verify_dependency_resolution", reinterpret_cast<getter>(CreatePackageDependencyOptions_get_VerifyDependencyResolution), reinterpret_cast<setter>(CreatePackageDependencyOptions_put_VerifyDependencyResolution), nullptr, nullptr },
        { "lifetime_artifact_kind", reinterpret_cast<getter>(CreatePackageDependencyOptions_get_LifetimeArtifactKind), reinterpret_cast<setter>(CreatePackageDependencyOptions_put_LifetimeArtifactKind), nullptr, nullptr },
        { "lifetime_artifact", reinterpret_cast<getter>(CreatePackageDependencyOptions_get_LifetimeArtifact), reinterpret_cast<setter>(CreatePackageDependencyOptions_put_LifetimeArtifact), nullptr, nullptr },
        { "architectures", reinterpret_cast<getter>(CreatePackageDependencyOptions_get_Architectures), reinterpret_cast<setter>(CreatePackageDependencyOptions_put_Architectures), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CreatePackageDependencyOptions[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_CreatePackageDependencyOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CreatePackageDependencyOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CreatePackageDependencyOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CreatePackageDependencyOptions) },
        { },
    };

    static PyType_Spec type_spec_CreatePackageDependencyOptions =
    {
        "winrt._winrt_microsoft_windows_applicationmodel_dynamicdependency.CreatePackageDependencyOptions",
        sizeof(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CreatePackageDependencyOptions
    };

    // ----- PackageDependency class --------------------

    static PyObject* _new_PackageDependency(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency>::type_name);
        return nullptr;
    }

    static void _dealloc_PackageDependency(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageDependency_Add(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.PackageDependency", L"Add", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                return py::convert(self->obj.Add());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.PackageDependency", L"Add", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::AddPackageDependencyOptions>(args, 0);

                return py::convert(self->obj.Add(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDependency_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.PackageDependency", L"Create", 2))
            {
                py::set_arg_count_version_error(2);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::PackageVersion>(args, 1);

                return py::convert(winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency::Create(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.PackageDependency", L"Create", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::PackageVersion>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions>(args, 2);

                return py::convert(winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency::Create(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDependency_CreateForSystem(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.PackageDependency", L"CreateForSystem", 3))
            {
                py::set_arg_count_version_error(3);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::PackageVersion>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions>(args, 2);

                return py::convert(winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency::CreateForSystem(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDependency_Delete(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.PackageDependency", L"Delete", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Delete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDependency_GetFromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.PackageDependency", L"GetFromId", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency::GetFromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDependency_GetFromIdForSystem(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.PackageDependency", L"GetFromIdForSystem", 1))
            {
                py::set_arg_count_version_error(1);
                return nullptr;
            }

            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency::GetFromIdForSystem(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDependency_get_Id(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.PackageDependency", L"Id"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageDependency_get_GenerationId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.PackageDependency", L"GenerationId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency::GenerationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageDependency_get_PackageGraphRevisionId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.PackageDependency", L"PackageGraphRevisionId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency::PackageGraphRevisionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageDependency(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageDependency(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageDependency[] = {
        { "add", reinterpret_cast<PyCFunction>(PackageDependency_Add), METH_VARARGS, nullptr },
        { "delete", reinterpret_cast<PyCFunction>(PackageDependency_Delete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PackageDependency, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageDependency), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageDependency[] = {
        { "id", reinterpret_cast<getter>(PackageDependency_get_Id), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageDependency[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageDependency) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageDependency) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageDependency) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageDependency) },
        { },
    };

    static PyType_Spec type_spec_PackageDependency =
    {
        "winrt._winrt_microsoft_windows_applicationmodel_dynamicdependency.PackageDependency",
        sizeof(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageDependency
    };

    static PyGetSetDef getset_PackageDependency_Static[] = {
        { "generation_id", reinterpret_cast<getter>(PackageDependency_get_GenerationId), nullptr, nullptr, nullptr },
        { "package_graph_revision_id", reinterpret_cast<getter>(PackageDependency_get_PackageGraphRevisionId), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_PackageDependency_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(PackageDependency_Create), METH_VARARGS, nullptr },
        { "create_for_system", reinterpret_cast<PyCFunction>(PackageDependency_CreateForSystem), METH_VARARGS, nullptr },
        { "get_from_id", reinterpret_cast<PyCFunction>(PackageDependency_GetFromId), METH_VARARGS, nullptr },
        { "get_from_id_for_system", reinterpret_cast<PyCFunction>(PackageDependency_GetFromIdForSystem), METH_VARARGS, nullptr },
        { }
    };

    static PyType_Slot type_slots_PackageDependency_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PackageDependency_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PackageDependency_Static) },
        { }
    };

    static PyType_Spec type_spec_PackageDependency_Static =
    {
        "winrt._winrt_microsoft_windows_applicationmodel_dynamicdependency.PackageDependency_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PackageDependency_Static
    };

    // ----- PackageDependencyContext class --------------------

    static PyObject* _new_PackageDependencyContext(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContextId>(args, 0);

                winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContext instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PackageDependencyContext(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContext* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageDependencyContext_Remove(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.PackageDependencyContext", L"Remove", 0))
            {
                py::set_arg_count_version_error(0);
                return nullptr;
            }

            try
            {
                self->obj.Remove();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDependencyContext_get_ContextId(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.PackageDependencyContext", L"ContextId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.ContextId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageDependencyContext_get_PackageDependencyId(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.PackageDependencyContext", L"PackageDependencyId"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PackageDependencyId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageDependencyContext_get_PackageFullName(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContext* self, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.PackageDependencyContext", L"PackageFullName"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(self->obj.PackageFullName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageDependencyContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContext>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageDependencyContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageDependencyContext[] = {
        { "remove", reinterpret_cast<PyCFunction>(PackageDependencyContext_Remove), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PackageDependencyContext, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageDependencyContext), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageDependencyContext[] = {
        { "context_id", reinterpret_cast<getter>(PackageDependencyContext_get_ContextId), nullptr, nullptr, nullptr },
        { "package_dependency_id", reinterpret_cast<getter>(PackageDependencyContext_get_PackageDependencyId), nullptr, nullptr, nullptr },
        { "package_full_name", reinterpret_cast<getter>(PackageDependencyContext_get_PackageFullName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageDependencyContext[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageDependencyContext) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageDependencyContext) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageDependencyContext) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageDependencyContext) },
        { },
    };

    static PyType_Spec type_spec_PackageDependencyContext =
    {
        "winrt._winrt_microsoft_windows_applicationmodel_dynamicdependency.PackageDependencyContext",
        sizeof(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageDependencyContext
    };

    // ----- PackageDependencyRank class --------------------

    static PyObject* _new_PackageDependencyRank(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyRank>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyRank>::type_name);
        return nullptr;
    }

    static PyObject* PackageDependencyRank_get_Default(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        if (!winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.PackageDependencyRank", L"Default"))
        {
            PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
            return nullptr;
        }

        try
        {
            return py::convert(winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyRank::Default());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageDependencyRank[] = {
        { }
    };

    static PyGetSetDef _getset_PackageDependencyRank[] = {
        { }
    };

    static PyType_Slot _type_slots_PackageDependencyRank[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageDependencyRank) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageDependencyRank) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageDependencyRank) },
        { },
    };

    static PyType_Spec type_spec_PackageDependencyRank =
    {
        "winrt._winrt_microsoft_windows_applicationmodel_dynamicdependency.PackageDependencyRank",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageDependencyRank
    };

    static PyGetSetDef getset_PackageDependencyRank_Static[] = {
        { "default", reinterpret_cast<getter>(PackageDependencyRank_get_Default), nullptr, nullptr, nullptr },
        { }
    };

    static PyMethodDef methods_PackageDependencyRank_Static[] = {
        { }
    };

    static PyType_Slot type_slots_PackageDependencyRank_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PackageDependencyRank_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PackageDependencyRank_Static) },
        { }
    };

    static PyType_Spec type_spec_PackageDependencyRank_Static =
    {
        "winrt._winrt_microsoft_windows_applicationmodel_dynamicdependency.PackageDependencyRank_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PackageDependencyRank_Static
    };

    // ----- PackageDependencyContextId struct --------------------

    winrt_struct_wrapper<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContextId>* _new_PackageDependencyContextId(PyTypeObject* subclass, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContextId>*>(subclass->tp_alloc(subclass, 0));

        if (!self)
        {
            return nullptr;
        }

        std::construct_at(&self->obj);

        return self;
    }

    int _init_PackageDependencyContextId(winrt_struct_wrapper<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContextId>* self, PyObject* args, PyObject* kwds) noexcept
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            self->obj = {};
            return 0;
        }

        uint64_t _Id{};

        static const char* kwlist[] = {"id", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "K", const_cast<char**>(kwlist), &_Id))
        {
            return -1;
        }

        try
        {
            self->obj = {_Id};
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static void _dealloc_PackageDependencyContextId(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContextId* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PackageDependencyContextId(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContextId>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyMethodDef _methods_PackageDependencyContextId[] = {
        { "_assign_array_", _assign_array_PackageDependencyContextId, METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyObject* PackageDependencyContextId_get_Id(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContextId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PackageDependencyContextId_set_Id(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContextId* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            self->obj.Id = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_PackageDependencyContextId[] = {
        { "id", reinterpret_cast<getter>(PackageDependencyContextId_get_Id), reinterpret_cast<setter>(PackageDependencyContextId_set_Id), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageDependencyContextId[] = 
    {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageDependencyContextId) },
        { Py_tp_init, reinterpret_cast<void*>(_init_PackageDependencyContextId) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageDependencyContextId) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageDependencyContextId) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageDependencyContextId) },
        { },
    };

    static PyType_Spec type_spec_PackageDependencyContextId =
    {
        "winrt._winrt_microsoft_windows_applicationmodel_dynamicdependency.PackageDependencyContextId",
        sizeof(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContextId),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageDependencyContextId
    };

    // ----- Microsoft.Windows.ApplicationModel.DynamicDependency Initialization --------------------
    PyDoc_STRVAR(module_doc, "Microsoft::Windows::ApplicationModel::DynamicDependency");


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winrt_microsoft_windows_applicationmodel_dynamicdependency",
           module_doc,
           0,
           nullptr,
           nullptr,
           nullptr,
           nullptr,
           nullptr};

} // py::cpp::Microsoft::Windows::ApplicationModel::DynamicDependency

PyMODINIT_FUNC PyInit__winrt_microsoft_windows_applicationmodel_dynamicdependency(void) noexcept
{
    using namespace py::cpp::Microsoft::Windows::ApplicationModel::DynamicDependency;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_AddPackageDependencyOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_CreatePackageDependencyOptions, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_PackageDependency_Static{PyType_FromSpec(&type_spec_PackageDependency_Static)};
    if (!type_PackageDependency_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PackageDependency, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PackageDependency_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PackageDependencyContext, object_bases.get(), nullptr) == -1)
    {
        return nullptr;
    }

    py::pyobj_handle type_PackageDependencyRank_Static{PyType_FromSpec(&type_spec_PackageDependencyRank_Static)};
    if (!type_PackageDependencyRank_Static)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PackageDependencyRank, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PackageDependencyRank_Static.get())) == -1)
    {
        return nullptr;
    }

    if (py::register_python_type(module.get(), &type_spec_PackageDependencyContextId, nullptr, nullptr) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
