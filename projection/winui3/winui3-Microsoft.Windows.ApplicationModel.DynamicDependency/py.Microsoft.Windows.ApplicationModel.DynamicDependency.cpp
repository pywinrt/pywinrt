// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.2.1

#include "py.Microsoft.Windows.ApplicationModel.DynamicDependency.h"

namespace py::cpp::Microsoft::Windows::ApplicationModel::DynamicDependency
{
    // ----- AddPackageDependencyOptions class --------------------

    static PyObject* _new_AddPackageDependencyOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::AddPackageDependencyOptions instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AddPackageDependencyOptions(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::AddPackageDependencyOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AddPackageDependencyOptions_get_Rank(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::AddPackageDependencyOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.AddPackageDependencyOptions", L"Rank");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Rank();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageDependencyOptions_put_Rank(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::AddPackageDependencyOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.AddPackageDependencyOptions", L"Rank");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.Rank(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageDependencyOptions_get_PrependIfRankCollision(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::AddPackageDependencyOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.AddPackageDependencyOptions", L"PrependIfRankCollision");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PrependIfRankCollision();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageDependencyOptions_put_PrependIfRankCollision(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::AddPackageDependencyOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.AddPackageDependencyOptions", L"PrependIfRankCollision");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.PrependIfRankCollision(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_AddPackageDependencyOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::AddPackageDependencyOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_AddPackageDependencyOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::AddPackageDependencyOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AddPackageDependencyOptions[] = {
        { "_assign_array_", _assign_array_AddPackageDependencyOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AddPackageDependencyOptions), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_AddPackageDependencyOptions[] = {
        { "rank", reinterpret_cast<getter>(AddPackageDependencyOptions_get_Rank), reinterpret_cast<setter>(AddPackageDependencyOptions_put_Rank), nullptr, nullptr },
        { "prepend_if_rank_collision", reinterpret_cast<getter>(AddPackageDependencyOptions_get_PrependIfRankCollision), reinterpret_cast<setter>(AddPackageDependencyOptions_put_PrependIfRankCollision), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_AddPackageDependencyOptions[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_AddPackageDependencyOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_AddPackageDependencyOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_AddPackageDependencyOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_AddPackageDependencyOptions) },
        { }};

    static PyType_Spec type_spec_AddPackageDependencyOptions = {
        "winui3._winui3_microsoft_windows_applicationmodel_dynamicdependency.AddPackageDependencyOptions",
        sizeof(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::AddPackageDependencyOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AddPackageDependencyOptions};

    // ----- CreatePackageDependencyOptions class --------------------

    static PyObject* _new_CreatePackageDependencyOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CreatePackageDependencyOptions(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CreatePackageDependencyOptions_get_VerifyDependencyResolution(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.CreatePackageDependencyOptions", L"VerifyDependencyResolution");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.VerifyDependencyResolution();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CreatePackageDependencyOptions_put_VerifyDependencyResolution(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.CreatePackageDependencyOptions", L"VerifyDependencyResolution");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.VerifyDependencyResolution(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CreatePackageDependencyOptions_get_LifetimeArtifactKind(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.CreatePackageDependencyOptions", L"LifetimeArtifactKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LifetimeArtifactKind();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CreatePackageDependencyOptions_put_LifetimeArtifactKind(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.CreatePackageDependencyOptions", L"LifetimeArtifactKind");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyLifetimeArtifactKind>(arg);

            {
                auto _gil = release_gil();
                self->obj.LifetimeArtifactKind(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CreatePackageDependencyOptions_get_LifetimeArtifact(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.CreatePackageDependencyOptions", L"LifetimeArtifact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LifetimeArtifact();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CreatePackageDependencyOptions_put_LifetimeArtifact(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.CreatePackageDependencyOptions", L"LifetimeArtifact");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.LifetimeArtifact(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CreatePackageDependencyOptions_get_Architectures(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.CreatePackageDependencyOptions", L"Architectures");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Architectures();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CreatePackageDependencyOptions_put_Architectures(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.CreatePackageDependencyOptions", L"Architectures");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyProcessorArchitectures>(arg);

            {
                auto _gil = release_gil();
                self->obj.Architectures(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_CreatePackageDependencyOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_CreatePackageDependencyOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CreatePackageDependencyOptions[] = {
        { "_assign_array_", _assign_array_CreatePackageDependencyOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CreatePackageDependencyOptions), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_CreatePackageDependencyOptions[] = {
        { "verify_dependency_resolution", reinterpret_cast<getter>(CreatePackageDependencyOptions_get_VerifyDependencyResolution), reinterpret_cast<setter>(CreatePackageDependencyOptions_put_VerifyDependencyResolution), nullptr, nullptr },
        { "lifetime_artifact_kind", reinterpret_cast<getter>(CreatePackageDependencyOptions_get_LifetimeArtifactKind), reinterpret_cast<setter>(CreatePackageDependencyOptions_put_LifetimeArtifactKind), nullptr, nullptr },
        { "lifetime_artifact", reinterpret_cast<getter>(CreatePackageDependencyOptions_get_LifetimeArtifact), reinterpret_cast<setter>(CreatePackageDependencyOptions_put_LifetimeArtifact), nullptr, nullptr },
        { "architectures", reinterpret_cast<getter>(CreatePackageDependencyOptions_get_Architectures), reinterpret_cast<setter>(CreatePackageDependencyOptions_put_Architectures), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_CreatePackageDependencyOptions[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_CreatePackageDependencyOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_CreatePackageDependencyOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_CreatePackageDependencyOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_CreatePackageDependencyOptions) },
        { }};

    static PyType_Spec type_spec_CreatePackageDependencyOptions = {
        "winui3._winui3_microsoft_windows_applicationmodel_dynamicdependency.CreatePackageDependencyOptions",
        sizeof(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CreatePackageDependencyOptions};

    // ----- PackageDependency class --------------------

    static PyObject* _new_PackageDependency(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency>::type_name);
        return nullptr;
    }

    static void _dealloc_PackageDependency(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageDependency_Add(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.PackageDependency", L"Add", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Add();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDependency_Add2(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.PackageDependency", L"Add", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::AddPackageDependencyOptions>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.Add(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDependency_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.PackageDependency", L"Create", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::PackageVersion>(args, 1);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency::Create(param0, param1);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDependency_Create2(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.PackageDependency", L"Create", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::PackageVersion>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency::Create(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDependency_CreateForSystem(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.PackageDependency", L"CreateForSystem", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::PackageVersion>(args, 1);
                auto param2 = py::convert_to<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::CreatePackageDependencyOptions>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency::CreateForSystem(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDependency_Delete(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.PackageDependency", L"Delete", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Delete();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDependency_GetFromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.PackageDependency", L"GetFromId", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency::GetFromId(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDependency_GetFromIdForSystem(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.PackageDependency", L"GetFromIdForSystem", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency::GetFromIdForSystem(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDependency_get_Id(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.PackageDependency", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageDependency_get_GenerationId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.PackageDependency", L"GenerationId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency::GenerationId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageDependency_get_PackageGraphRevisionId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.PackageDependency", L"PackageGraphRevisionId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency::PackageGraphRevisionId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageDependency(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageDependency(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageDependency[] = {
        { "add", reinterpret_cast<PyCFunction>(PackageDependency_Add), METH_VARARGS, nullptr },
        { "add2", reinterpret_cast<PyCFunction>(PackageDependency_Add2), METH_VARARGS, nullptr },
        { "delete", reinterpret_cast<PyCFunction>(PackageDependency_Delete), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PackageDependency, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageDependency), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PackageDependency[] = {
        { "id", reinterpret_cast<getter>(PackageDependency_get_Id), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PackageDependency[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageDependency) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageDependency) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageDependency) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageDependency) },
        { }};

    static PyType_Spec type_spec_PackageDependency = {
        "winui3._winui3_microsoft_windows_applicationmodel_dynamicdependency.PackageDependency",
        sizeof(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependency),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageDependency};

    static PyGetSetDef getset_PackageDependency_Static[] = {
        { "generation_id", reinterpret_cast<getter>(PackageDependency_get_GenerationId), nullptr, nullptr, nullptr },
        { "package_graph_revision_id", reinterpret_cast<getter>(PackageDependency_get_PackageGraphRevisionId), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_PackageDependency_Static[] = {
        { "create", reinterpret_cast<PyCFunction>(PackageDependency_Create), METH_VARARGS, nullptr },
        { "create2", reinterpret_cast<PyCFunction>(PackageDependency_Create2), METH_VARARGS, nullptr },
        { "create_for_system", reinterpret_cast<PyCFunction>(PackageDependency_CreateForSystem), METH_VARARGS, nullptr },
        { "get_from_id", reinterpret_cast<PyCFunction>(PackageDependency_GetFromId), METH_VARARGS, nullptr },
        { "get_from_id_for_system", reinterpret_cast<PyCFunction>(PackageDependency_GetFromIdForSystem), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_PackageDependency_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PackageDependency_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PackageDependency_Static) },
        { }
    };

    static PyType_Spec type_spec_PackageDependency_Static = {
        "winui3._winui3_microsoft_windows_applicationmodel_dynamicdependency.PackageDependency_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PackageDependency_Static};

    // ----- PackageDependencyContext class --------------------

    static PyObject* _new_PackageDependencyContext(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContextId>(args, 0);

                winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContext instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PackageDependencyContext(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContext* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PackageDependencyContext_Remove(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContext* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.PackageDependencyContext", L"Remove", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Remove();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageDependencyContext_get_ContextId(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContext* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.PackageDependencyContext", L"ContextId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ContextId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageDependencyContext_get_PackageDependencyId(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContext* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.PackageDependencyContext", L"PackageDependencyId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PackageDependencyId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageDependencyContext_get_PackageFullName(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContext* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.PackageDependencyContext", L"PackageFullName");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PackageFullName();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_PackageDependencyContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContext>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_PackageDependencyContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageDependencyContext[] = {
        { "remove", reinterpret_cast<PyCFunction>(PackageDependencyContext_Remove), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_PackageDependencyContext, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageDependencyContext), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_PackageDependencyContext[] = {
        { "context_id", reinterpret_cast<getter>(PackageDependencyContext_get_ContextId), nullptr, nullptr, nullptr },
        { "package_dependency_id", reinterpret_cast<getter>(PackageDependencyContext_get_PackageDependencyId), nullptr, nullptr, nullptr },
        { "package_full_name", reinterpret_cast<getter>(PackageDependencyContext_get_PackageFullName), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_PackageDependencyContext[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageDependencyContext) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageDependencyContext) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageDependencyContext) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageDependencyContext) },
        { }};

    static PyType_Spec type_spec_PackageDependencyContext = {
        "winui3._winui3_microsoft_windows_applicationmodel_dynamicdependency.PackageDependencyContext",
        sizeof(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageDependencyContext};

    // ----- PackageDependencyRank class --------------------

    static PyObject* _new_PackageDependencyRank(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyRank>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyRank>::type_name);
        return nullptr;
    }

    static PyObject* PackageDependencyRank_get_Default(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.ApplicationModel.DynamicDependency.PackageDependencyRank", L"Default");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyRank::Default();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageDependencyRank[] = {
        { }};

    static PyGetSetDef _getset_PackageDependencyRank[] = {
        { }};

    static PyType_Slot _type_slots_PackageDependencyRank[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageDependencyRank) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageDependencyRank) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageDependencyRank) },
        { }};

    static PyType_Spec type_spec_PackageDependencyRank = {
        "winui3._winui3_microsoft_windows_applicationmodel_dynamicdependency.PackageDependencyRank",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageDependencyRank};

    static PyGetSetDef getset_PackageDependencyRank_Static[] = {
        { "default", reinterpret_cast<getter>(PackageDependencyRank_get_Default), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_PackageDependencyRank_Static[] = {
        { }};

    static PyType_Slot type_slots_PackageDependencyRank_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_PackageDependencyRank_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_PackageDependencyRank_Static) },
        { }
    };

    static PyType_Spec type_spec_PackageDependencyRank_Static = {
        "winui3._winui3_microsoft_windows_applicationmodel_dynamicdependency.PackageDependencyRank_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_PackageDependencyRank_Static};

    // ----- PackageDependencyContextId struct --------------------

    winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContextId PackageDependencyContextId_from_tuple(PyObject* tuple)
    {
        if (PyTuple_GET_SIZE(tuple) != 1)
        {
            PyErr_SetString(PyExc_TypeError, "Incorrect number of fields");
            throw python_exception();
        }

        winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContextId result{};

        result.Id = py::convert_to<uint64_t>(tuple, 0);

        return result;
    }

    PyObject* _new_PackageDependencyContextId(PyTypeObject* subclass, PyObject* args, PyObject* kwds) noexcept
    {
        pyobj_handle self_obj{(subclass->tp_alloc(subclass, 0))};
        if (!self_obj)
        {
            return nullptr;
        }

        auto self = reinterpret_cast<winrt_struct_wrapper<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContextId>*>(self_obj.get());
        std::construct_at(&self->obj);

        auto tuple_size = PyTuple_GET_SIZE(args);
        if ((tuple_size == 0) && (!kwds))
        {
            return self_obj.detach();
        }

        uint64_t _Id{};

        static const char* kwlist[] = {"id", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "|K", const_cast<char**>(kwlist), &_Id))
        {
            return nullptr;
        }

        try
        {
            self->obj.Id = _Id;

            return self_obj.detach();
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_PackageDependencyContextId(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContextId* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_PackageDependencyContextId(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContextId>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    PyObject* _replace_PackageDependencyContextId(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContextId* self, PyObject* args, PyObject* kwds) noexcept
    {
        try
        {
            uint64_t _Id{self->obj.Id};

            static const char* kwlist[] = {"id", nullptr};
            if (!PyArg_ParseTupleAndKeywords(args, kwds, "|$K", const_cast<char**>(kwlist), &_Id))
            {
                return nullptr;
            }

            auto copy = self->obj;
            copy.Id = _Id;

            return convert(copy);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageDependencyContextId[] = {
        { "_assign_array_", _assign_array_PackageDependencyContextId, METH_O | METH_STATIC, nullptr },
        { "__replace__", reinterpret_cast<PyCFunction>(reinterpret_cast<void*>(_replace_PackageDependencyContextId)), METH_VARARGS | METH_KEYWORDS, nullptr },
        { }};

    static PyObject* PackageDependencyContextId_get_Id(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContextId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyGetSetDef _getset_PackageDependencyContextId[] = {
        { "id", reinterpret_cast<getter>(PackageDependencyContextId_get_Id), nullptr, nullptr, nullptr },
        { }};

    static PyObject* _richcompare_PackageDependencyContextId(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContextId* self, PyObject* other, int op) noexcept
    {
        try
        {
            auto _other = py::convert_to<winrt::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContextId>(other);

            if (op == Py_EQ)
            {
                if (self->obj == _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            if (op == Py_NE)
            {
                if (self->obj != _other)
                {
                    Py_RETURN_TRUE;
                }

                Py_RETURN_FALSE;
            }

            Py_RETURN_NOTIMPLEMENTED;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _repr_PackageDependencyContextId(PyObject* self) noexcept
    {
        py::pyobj_handle Id{PyObject_GetAttrString(self, "id")};
        if (!Id)
        {
            return nullptr;
        }

        return PyUnicode_FromFormat("PackageDependencyContextId(id=%R)", Id.get());
    }

    static PyType_Slot _type_slots_PackageDependencyContextId[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_PackageDependencyContextId) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_PackageDependencyContextId) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_PackageDependencyContextId) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_PackageDependencyContextId) },
        { Py_tp_richcompare, reinterpret_cast<void*>(_richcompare_PackageDependencyContextId) },
        { Py_tp_repr, reinterpret_cast<void*>(_repr_PackageDependencyContextId) },
        { }};

    static PyType_Spec type_spec_PackageDependencyContextId = {
        "winui3._winui3_microsoft_windows_applicationmodel_dynamicdependency.PackageDependencyContextId",
        sizeof(py::wrapper::Microsoft::Windows::ApplicationModel::DynamicDependency::PackageDependencyContextId),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageDependencyContextId};

    // ----- Microsoft.Windows.ApplicationModel.DynamicDependency Initialization --------------------

    PyDoc_STRVAR(module_doc, "Microsoft.Windows.ApplicationModel.DynamicDependency");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winui3_microsoft_windows_applicationmodel_dynamicdependency",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Microsoft::Windows::ApplicationModel::DynamicDependency

PyMODINIT_FUNC PyInit__winui3_microsoft_windows_applicationmodel_dynamicdependency(void) noexcept
{
    using namespace py::cpp::Microsoft::Windows::ApplicationModel::DynamicDependency;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle AddPackageDependencyOptions_type{py::register_python_type(module.get(), &type_spec_AddPackageDependencyOptions, object_bases.get(), inspectable_meta_type)};
    if (!AddPackageDependencyOptions_type)
    {
        return nullptr;
    }

    py::pytype_handle CreatePackageDependencyOptions_type{py::register_python_type(module.get(), &type_spec_CreatePackageDependencyOptions, object_bases.get(), inspectable_meta_type)};
    if (!CreatePackageDependencyOptions_type)
    {
        return nullptr;
    }

    py::pyobj_handle PackageDependency_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!PackageDependency_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PackageDependency_Static{PyType_FromSpecWithBases(&type_spec_PackageDependency_Static, PackageDependency_Static_bases.get())};
    if (!type_PackageDependency_Static)
    {
        return nullptr;
    }

    py::pytype_handle PackageDependency_type{py::register_python_type(module.get(), &type_spec_PackageDependency, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PackageDependency_Static.get()))};
    if (!PackageDependency_type)
    {
        return nullptr;
    }

    py::pytype_handle PackageDependencyContext_type{py::register_python_type(module.get(), &type_spec_PackageDependencyContext, object_bases.get(), inspectable_meta_type)};
    if (!PackageDependencyContext_type)
    {
        return nullptr;
    }

    py::pyobj_handle PackageDependencyRank_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!PackageDependencyRank_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_PackageDependencyRank_Static{PyType_FromSpecWithBases(&type_spec_PackageDependencyRank_Static, PackageDependencyRank_Static_bases.get())};
    if (!type_PackageDependencyRank_Static)
    {
        return nullptr;
    }

    py::pytype_handle PackageDependencyRank_type{py::register_python_type(module.get(), &type_spec_PackageDependencyRank, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_PackageDependencyRank_Static.get()))};
    if (!PackageDependencyRank_type)
    {
        return nullptr;
    }

    py::pytype_handle PackageDependencyContextId_type{py::register_python_type(module.get(), &type_spec_PackageDependencyContextId, nullptr, nullptr)};
    if (!PackageDependencyContextId_type)
    {
        return nullptr;
    }

    py::pyobj_handle PackageDependencyContextId_from_tuple_capsule{PyCapsule_New(reinterpret_cast<void*>(PackageDependencyContextId_from_tuple),"winui3._winui3_microsoft_windows_applicationmodel_dynamicdependency.PackageDependencyContextId_from_tuple", nullptr)};
    if (!PackageDependencyContextId_from_tuple_capsule)
    {
        return nullptr;
    }

    if (PyModule_AddObjectRef(module.get(), "PackageDependencyContextId_from_tuple", PackageDependencyContextId_from_tuple_capsule.get()) == -1)
    {
        return nullptr;
    }

    return module.detach();
}
