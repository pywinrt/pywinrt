// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.2.1

#include "py.Microsoft.Windows.Widgets.Providers.h"

namespace py::cpp::Microsoft::Windows::Widgets::Providers
{
    // ----- WidgetActionInvokedArgs class --------------------

    static PyObject* _new_WidgetActionInvokedArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::WidgetActionInvokedArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::WidgetActionInvokedArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WidgetActionInvokedArgs(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetActionInvokedArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WidgetActionInvokedArgs_get_CustomState(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetActionInvokedArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetActionInvokedArgs", L"CustomState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CustomState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WidgetActionInvokedArgs_get_Data(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetActionInvokedArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetActionInvokedArgs", L"Data");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Data();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WidgetActionInvokedArgs_get_Verb(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetActionInvokedArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetActionInvokedArgs", L"Verb");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Verb();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WidgetActionInvokedArgs_get_WidgetContext(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetActionInvokedArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetActionInvokedArgs", L"WidgetContext");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WidgetContext();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WidgetActionInvokedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Widgets::Providers::WidgetActionInvokedArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WidgetActionInvokedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Widgets::Providers::WidgetActionInvokedArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WidgetActionInvokedArgs[] = {
        { "_assign_array_", _assign_array_WidgetActionInvokedArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WidgetActionInvokedArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WidgetActionInvokedArgs[] = {
        { "custom_state", reinterpret_cast<getter>(WidgetActionInvokedArgs_get_CustomState), nullptr, nullptr, nullptr },
        { "data", reinterpret_cast<getter>(WidgetActionInvokedArgs_get_Data), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(WidgetActionInvokedArgs_get_Verb), nullptr, nullptr, nullptr },
        { "widget_context", reinterpret_cast<getter>(WidgetActionInvokedArgs_get_WidgetContext), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WidgetActionInvokedArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WidgetActionInvokedArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WidgetActionInvokedArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WidgetActionInvokedArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WidgetActionInvokedArgs) },
        { }};

    static PyType_Spec type_spec_WidgetActionInvokedArgs = {
        "winui3._winui3_microsoft_windows_widgets_providers.WidgetActionInvokedArgs",
        sizeof(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetActionInvokedArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WidgetActionInvokedArgs};

    // ----- WidgetAnalyticsInfoReportedArgs class --------------------

    static PyObject* _new_WidgetAnalyticsInfoReportedArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::WidgetAnalyticsInfoReportedArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::WidgetAnalyticsInfoReportedArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WidgetAnalyticsInfoReportedArgs(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetAnalyticsInfoReportedArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WidgetAnalyticsInfoReportedArgs_get_AnalyticsJson(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetAnalyticsInfoReportedArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetAnalyticsInfoReportedArgs", L"AnalyticsJson");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AnalyticsJson();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WidgetAnalyticsInfoReportedArgs_get_WidgetContext(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetAnalyticsInfoReportedArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetAnalyticsInfoReportedArgs", L"WidgetContext");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WidgetContext();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WidgetAnalyticsInfoReportedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Widgets::Providers::WidgetAnalyticsInfoReportedArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WidgetAnalyticsInfoReportedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Widgets::Providers::WidgetAnalyticsInfoReportedArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WidgetAnalyticsInfoReportedArgs[] = {
        { "_assign_array_", _assign_array_WidgetAnalyticsInfoReportedArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WidgetAnalyticsInfoReportedArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WidgetAnalyticsInfoReportedArgs[] = {
        { "analytics_json", reinterpret_cast<getter>(WidgetAnalyticsInfoReportedArgs_get_AnalyticsJson), nullptr, nullptr, nullptr },
        { "widget_context", reinterpret_cast<getter>(WidgetAnalyticsInfoReportedArgs_get_WidgetContext), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WidgetAnalyticsInfoReportedArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WidgetAnalyticsInfoReportedArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WidgetAnalyticsInfoReportedArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WidgetAnalyticsInfoReportedArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WidgetAnalyticsInfoReportedArgs) },
        { }};

    static PyType_Spec type_spec_WidgetAnalyticsInfoReportedArgs = {
        "winui3._winui3_microsoft_windows_widgets_providers.WidgetAnalyticsInfoReportedArgs",
        sizeof(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetAnalyticsInfoReportedArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WidgetAnalyticsInfoReportedArgs};

    // ----- WidgetContext class --------------------

    static PyObject* _new_WidgetContext(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::WidgetContext>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::WidgetContext>::type_name);
        return nullptr;
    }

    static void _dealloc_WidgetContext(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetContext* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WidgetContext_get_DefinitionId(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetContext* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetContext", L"DefinitionId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DefinitionId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WidgetContext_get_Id(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetContext* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetContext", L"Id");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Id();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WidgetContext_get_IsActive(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetContext* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetContext", L"IsActive");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsActive();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WidgetContext_get_Size(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetContext* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetContext", L"Size");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Size();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WidgetContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Widgets::Providers::WidgetContext>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WidgetContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Widgets::Providers::WidgetContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WidgetContext[] = {
        { "_assign_array_", _assign_array_WidgetContext, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WidgetContext), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WidgetContext[] = {
        { "definition_id", reinterpret_cast<getter>(WidgetContext_get_DefinitionId), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(WidgetContext_get_Id), nullptr, nullptr, nullptr },
        { "is_active", reinterpret_cast<getter>(WidgetContext_get_IsActive), nullptr, nullptr, nullptr },
        { "size", reinterpret_cast<getter>(WidgetContext_get_Size), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WidgetContext[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WidgetContext) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WidgetContext) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WidgetContext) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WidgetContext) },
        { }};

    static PyType_Spec type_spec_WidgetContext = {
        "winui3._winui3_microsoft_windows_widgets_providers.WidgetContext",
        sizeof(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WidgetContext};

    // ----- WidgetContextChangedArgs class --------------------

    static PyObject* _new_WidgetContextChangedArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::WidgetContextChangedArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::WidgetContextChangedArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WidgetContextChangedArgs(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetContextChangedArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WidgetContextChangedArgs_get_WidgetContext(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetContextChangedArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetContextChangedArgs", L"WidgetContext");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WidgetContext();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WidgetContextChangedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Widgets::Providers::WidgetContextChangedArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WidgetContextChangedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Widgets::Providers::WidgetContextChangedArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WidgetContextChangedArgs[] = {
        { "_assign_array_", _assign_array_WidgetContextChangedArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WidgetContextChangedArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WidgetContextChangedArgs[] = {
        { "widget_context", reinterpret_cast<getter>(WidgetContextChangedArgs_get_WidgetContext), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WidgetContextChangedArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WidgetContextChangedArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WidgetContextChangedArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WidgetContextChangedArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WidgetContextChangedArgs) },
        { }};

    static PyType_Spec type_spec_WidgetContextChangedArgs = {
        "winui3._winui3_microsoft_windows_widgets_providers.WidgetContextChangedArgs",
        sizeof(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetContextChangedArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WidgetContextChangedArgs};

    // ----- WidgetCustomizationRequestedArgs class --------------------

    static PyObject* _new_WidgetCustomizationRequestedArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::WidgetCustomizationRequestedArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::WidgetCustomizationRequestedArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WidgetCustomizationRequestedArgs(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetCustomizationRequestedArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WidgetCustomizationRequestedArgs_get_CustomState(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetCustomizationRequestedArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetCustomizationRequestedArgs", L"CustomState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CustomState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WidgetCustomizationRequestedArgs_get_WidgetContext(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetCustomizationRequestedArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetCustomizationRequestedArgs", L"WidgetContext");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WidgetContext();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WidgetCustomizationRequestedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Widgets::Providers::WidgetCustomizationRequestedArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WidgetCustomizationRequestedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Widgets::Providers::WidgetCustomizationRequestedArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WidgetCustomizationRequestedArgs[] = {
        { "_assign_array_", _assign_array_WidgetCustomizationRequestedArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WidgetCustomizationRequestedArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WidgetCustomizationRequestedArgs[] = {
        { "custom_state", reinterpret_cast<getter>(WidgetCustomizationRequestedArgs_get_CustomState), nullptr, nullptr, nullptr },
        { "widget_context", reinterpret_cast<getter>(WidgetCustomizationRequestedArgs_get_WidgetContext), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WidgetCustomizationRequestedArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WidgetCustomizationRequestedArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WidgetCustomizationRequestedArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WidgetCustomizationRequestedArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WidgetCustomizationRequestedArgs) },
        { }};

    static PyType_Spec type_spec_WidgetCustomizationRequestedArgs = {
        "winui3._winui3_microsoft_windows_widgets_providers.WidgetCustomizationRequestedArgs",
        sizeof(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetCustomizationRequestedArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WidgetCustomizationRequestedArgs};

    // ----- WidgetErrorInfoReportedArgs class --------------------

    static PyObject* _new_WidgetErrorInfoReportedArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::WidgetErrorInfoReportedArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::WidgetErrorInfoReportedArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WidgetErrorInfoReportedArgs(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetErrorInfoReportedArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WidgetErrorInfoReportedArgs_get_ErrorJson(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetErrorInfoReportedArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetErrorInfoReportedArgs", L"ErrorJson");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ErrorJson();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WidgetErrorInfoReportedArgs_get_WidgetContext(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetErrorInfoReportedArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetErrorInfoReportedArgs", L"WidgetContext");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WidgetContext();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WidgetErrorInfoReportedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Widgets::Providers::WidgetErrorInfoReportedArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WidgetErrorInfoReportedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Widgets::Providers::WidgetErrorInfoReportedArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WidgetErrorInfoReportedArgs[] = {
        { "_assign_array_", _assign_array_WidgetErrorInfoReportedArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WidgetErrorInfoReportedArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WidgetErrorInfoReportedArgs[] = {
        { "error_json", reinterpret_cast<getter>(WidgetErrorInfoReportedArgs_get_ErrorJson), nullptr, nullptr, nullptr },
        { "widget_context", reinterpret_cast<getter>(WidgetErrorInfoReportedArgs_get_WidgetContext), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WidgetErrorInfoReportedArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WidgetErrorInfoReportedArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WidgetErrorInfoReportedArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WidgetErrorInfoReportedArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WidgetErrorInfoReportedArgs) },
        { }};

    static PyType_Spec type_spec_WidgetErrorInfoReportedArgs = {
        "winui3._winui3_microsoft_windows_widgets_providers.WidgetErrorInfoReportedArgs",
        sizeof(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetErrorInfoReportedArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WidgetErrorInfoReportedArgs};

    // ----- WidgetInfo class --------------------

    static PyObject* _new_WidgetInfo(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::WidgetInfo>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::WidgetInfo>::type_name);
        return nullptr;
    }

    static void _dealloc_WidgetInfo(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetInfo* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WidgetInfo_get_CustomState(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetInfo", L"CustomState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CustomState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WidgetInfo_get_Data(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetInfo", L"Data");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Data();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WidgetInfo_get_LastUpdateTime(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetInfo", L"LastUpdateTime");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.LastUpdateTime();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WidgetInfo_get_Template(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetInfo", L"Template");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Template();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WidgetInfo_get_WidgetContext(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetInfo", L"WidgetContext");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WidgetContext();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WidgetInfo_get_IsPlaceholderContent(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetInfo", L"IsPlaceholderContent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsPlaceholderContent();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WidgetInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Widgets::Providers::WidgetInfo>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WidgetInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Widgets::Providers::WidgetInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WidgetInfo[] = {
        { "_assign_array_", _assign_array_WidgetInfo, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WidgetInfo), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WidgetInfo[] = {
        { "custom_state", reinterpret_cast<getter>(WidgetInfo_get_CustomState), nullptr, nullptr, nullptr },
        { "data", reinterpret_cast<getter>(WidgetInfo_get_Data), nullptr, nullptr, nullptr },
        { "last_update_time", reinterpret_cast<getter>(WidgetInfo_get_LastUpdateTime), nullptr, nullptr, nullptr },
        { "template", reinterpret_cast<getter>(WidgetInfo_get_Template), nullptr, nullptr, nullptr },
        { "widget_context", reinterpret_cast<getter>(WidgetInfo_get_WidgetContext), nullptr, nullptr, nullptr },
        { "is_placeholder_content", reinterpret_cast<getter>(WidgetInfo_get_IsPlaceholderContent), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WidgetInfo[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WidgetInfo) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WidgetInfo) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WidgetInfo) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WidgetInfo) },
        { }};

    static PyType_Spec type_spec_WidgetInfo = {
        "winui3._winui3_microsoft_windows_widgets_providers.WidgetInfo",
        sizeof(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WidgetInfo};

    // ----- WidgetManager class --------------------

    static PyObject* _new_WidgetManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::WidgetManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::WidgetManager>::type_name);
        return nullptr;
    }

    static void _dealloc_WidgetManager(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WidgetManager_DeleteWidget(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.WidgetManager", L"DeleteWidget", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.DeleteWidget(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WidgetManager_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.WidgetManager", L"GetDefault", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return winrt::Microsoft::Windows::Widgets::Providers::WidgetManager::GetDefault();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WidgetManager_GetWidgetIds(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.WidgetManager", L"GetWidgetIds", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetWidgetIds();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WidgetManager_GetWidgetInfo(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.WidgetManager", L"GetWidgetInfo", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetWidgetInfo(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WidgetManager_GetWidgetInfos(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.WidgetManager", L"GetWidgetInfos", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetWidgetInfos();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WidgetManager_SendMessageToContent(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.WidgetManager", L"SendMessageToContent", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.SendMessageToContent(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WidgetManager_UpdateWidget(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.WidgetManager", L"UpdateWidget", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::Windows::Widgets::Providers::WidgetUpdateRequestOptions>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.UpdateWidget(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_WidgetManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Widgets::Providers::WidgetManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WidgetManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Widgets::Providers::WidgetManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WidgetManager[] = {
        { "delete_widget", reinterpret_cast<PyCFunction>(WidgetManager_DeleteWidget), METH_VARARGS, nullptr },
        { "get_widget_ids", reinterpret_cast<PyCFunction>(WidgetManager_GetWidgetIds), METH_VARARGS, nullptr },
        { "get_widget_info", reinterpret_cast<PyCFunction>(WidgetManager_GetWidgetInfo), METH_VARARGS, nullptr },
        { "get_widget_infos", reinterpret_cast<PyCFunction>(WidgetManager_GetWidgetInfos), METH_VARARGS, nullptr },
        { "send_message_to_content", reinterpret_cast<PyCFunction>(WidgetManager_SendMessageToContent), METH_VARARGS, nullptr },
        { "update_widget", reinterpret_cast<PyCFunction>(WidgetManager_UpdateWidget), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_WidgetManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WidgetManager), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WidgetManager[] = {
        { }};

    static PyType_Slot _type_slots_WidgetManager[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WidgetManager) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WidgetManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WidgetManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WidgetManager) },
        { }};

    static PyType_Spec type_spec_WidgetManager = {
        "winui3._winui3_microsoft_windows_widgets_providers.WidgetManager",
        sizeof(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WidgetManager};

    static PyGetSetDef getset_WidgetManager_Static[] = {
        { }};

    static PyMethodDef methods_WidgetManager_Static[] = {
        { "get_default", reinterpret_cast<PyCFunction>(WidgetManager_GetDefault), METH_VARARGS, nullptr },
        { }};

    static PyType_Slot type_slots_WidgetManager_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_WidgetManager_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_WidgetManager_Static) },
        { }
    };

    static PyType_Spec type_spec_WidgetManager_Static = {
        "winui3._winui3_microsoft_windows_widgets_providers.WidgetManager_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_WidgetManager_Static};

    // ----- WidgetMessageReceivedArgs class --------------------

    static PyObject* _new_WidgetMessageReceivedArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::WidgetMessageReceivedArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::WidgetMessageReceivedArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WidgetMessageReceivedArgs(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetMessageReceivedArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WidgetMessageReceivedArgs_get_Message(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetMessageReceivedArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetMessageReceivedArgs", L"Message");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Message();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WidgetMessageReceivedArgs_get_WidgetContext(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetMessageReceivedArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetMessageReceivedArgs", L"WidgetContext");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WidgetContext();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WidgetMessageReceivedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Widgets::Providers::WidgetMessageReceivedArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WidgetMessageReceivedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Widgets::Providers::WidgetMessageReceivedArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WidgetMessageReceivedArgs[] = {
        { "_assign_array_", _assign_array_WidgetMessageReceivedArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WidgetMessageReceivedArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WidgetMessageReceivedArgs[] = {
        { "message", reinterpret_cast<getter>(WidgetMessageReceivedArgs_get_Message), nullptr, nullptr, nullptr },
        { "widget_context", reinterpret_cast<getter>(WidgetMessageReceivedArgs_get_WidgetContext), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WidgetMessageReceivedArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WidgetMessageReceivedArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WidgetMessageReceivedArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WidgetMessageReceivedArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WidgetMessageReceivedArgs) },
        { }};

    static PyType_Spec type_spec_WidgetMessageReceivedArgs = {
        "winui3._winui3_microsoft_windows_widgets_providers.WidgetMessageReceivedArgs",
        sizeof(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetMessageReceivedArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WidgetMessageReceivedArgs};

    // ----- WidgetResourceRequest class --------------------

    static PyObject* _new_WidgetResourceRequest(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::WidgetResourceRequest>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::WidgetResourceRequest>::type_name);
        return nullptr;
    }

    static void _dealloc_WidgetResourceRequest(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetResourceRequest* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WidgetResourceRequest_get_Method(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetResourceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetResourceRequest", L"Method");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Method();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WidgetResourceRequest_put_Method(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetResourceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetResourceRequest", L"Method");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Method(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WidgetResourceRequest_get_Content(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetResourceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetResourceRequest", L"Content");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Content();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WidgetResourceRequest_put_Content(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetResourceRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetResourceRequest", L"Content");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            {
                auto _gil = release_gil();
                self->obj.Content(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WidgetResourceRequest_get_Headers(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetResourceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetResourceRequest", L"Headers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Headers();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WidgetResourceRequest_get_Uri(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetResourceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetResourceRequest", L"Uri");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Uri();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WidgetResourceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Widgets::Providers::WidgetResourceRequest>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WidgetResourceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Widgets::Providers::WidgetResourceRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WidgetResourceRequest[] = {
        { "_assign_array_", _assign_array_WidgetResourceRequest, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WidgetResourceRequest), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WidgetResourceRequest[] = {
        { "method", reinterpret_cast<getter>(WidgetResourceRequest_get_Method), reinterpret_cast<setter>(WidgetResourceRequest_put_Method), nullptr, nullptr },
        { "content", reinterpret_cast<getter>(WidgetResourceRequest_get_Content), reinterpret_cast<setter>(WidgetResourceRequest_put_Content), nullptr, nullptr },
        { "headers", reinterpret_cast<getter>(WidgetResourceRequest_get_Headers), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(WidgetResourceRequest_get_Uri), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WidgetResourceRequest[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WidgetResourceRequest) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WidgetResourceRequest) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WidgetResourceRequest) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WidgetResourceRequest) },
        { }};

    static PyType_Spec type_spec_WidgetResourceRequest = {
        "winui3._winui3_microsoft_windows_widgets_providers.WidgetResourceRequest",
        sizeof(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetResourceRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WidgetResourceRequest};

    // ----- WidgetResourceRequestedArgs class --------------------

    static PyObject* _new_WidgetResourceRequestedArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::WidgetResourceRequestedArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::WidgetResourceRequestedArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_WidgetResourceRequestedArgs(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetResourceRequestedArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WidgetResourceRequestedArgs_GetDeferral(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetResourceRequestedArgs* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.WidgetResourceRequestedArgs", L"GetDeferral", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetDeferral();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WidgetResourceRequestedArgs_get_Response(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetResourceRequestedArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetResourceRequestedArgs", L"Response");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Response();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WidgetResourceRequestedArgs_put_Response(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetResourceRequestedArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetResourceRequestedArgs", L"Response");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::Windows::Widgets::Providers::WidgetResourceResponse>(arg);

            {
                auto _gil = release_gil();
                self->obj.Response(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WidgetResourceRequestedArgs_get_Request(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetResourceRequestedArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetResourceRequestedArgs", L"Request");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Request();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WidgetResourceRequestedArgs_get_WidgetContext(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetResourceRequestedArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetResourceRequestedArgs", L"WidgetContext");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WidgetContext();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WidgetResourceRequestedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Widgets::Providers::WidgetResourceRequestedArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WidgetResourceRequestedArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Widgets::Providers::WidgetResourceRequestedArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WidgetResourceRequestedArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(WidgetResourceRequestedArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_WidgetResourceRequestedArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WidgetResourceRequestedArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WidgetResourceRequestedArgs[] = {
        { "response", reinterpret_cast<getter>(WidgetResourceRequestedArgs_get_Response), reinterpret_cast<setter>(WidgetResourceRequestedArgs_put_Response), nullptr, nullptr },
        { "request", reinterpret_cast<getter>(WidgetResourceRequestedArgs_get_Request), nullptr, nullptr, nullptr },
        { "widget_context", reinterpret_cast<getter>(WidgetResourceRequestedArgs_get_WidgetContext), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WidgetResourceRequestedArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WidgetResourceRequestedArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WidgetResourceRequestedArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WidgetResourceRequestedArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WidgetResourceRequestedArgs) },
        { }};

    static PyType_Spec type_spec_WidgetResourceRequestedArgs = {
        "winui3._winui3_microsoft_windows_widgets_providers.WidgetResourceRequestedArgs",
        sizeof(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetResourceRequestedArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WidgetResourceRequestedArgs};

    // ----- WidgetResourceResponse class --------------------

    static PyObject* _new_WidgetResourceResponse(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);

                winrt::Microsoft::Windows::Widgets::Providers::WidgetResourceResponse instance{param0, param1, param2};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WidgetResourceResponse(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetResourceResponse* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WidgetResourceResponse_get_Content(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetResourceResponse* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetResourceResponse", L"Content");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Content();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WidgetResourceResponse_get_Headers(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetResourceResponse* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetResourceResponse", L"Headers");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Headers();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WidgetResourceResponse_get_ReasonPhrase(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetResourceResponse* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetResourceResponse", L"ReasonPhrase");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ReasonPhrase();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WidgetResourceResponse_get_StatusCode(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetResourceResponse* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetResourceResponse", L"StatusCode");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.StatusCode();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WidgetResourceResponse(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Widgets::Providers::WidgetResourceResponse>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WidgetResourceResponse(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Widgets::Providers::WidgetResourceResponse>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WidgetResourceResponse[] = {
        { "_assign_array_", _assign_array_WidgetResourceResponse, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WidgetResourceResponse), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WidgetResourceResponse[] = {
        { "content", reinterpret_cast<getter>(WidgetResourceResponse_get_Content), nullptr, nullptr, nullptr },
        { "headers", reinterpret_cast<getter>(WidgetResourceResponse_get_Headers), nullptr, nullptr, nullptr },
        { "reason_phrase", reinterpret_cast<getter>(WidgetResourceResponse_get_ReasonPhrase), nullptr, nullptr, nullptr },
        { "status_code", reinterpret_cast<getter>(WidgetResourceResponse_get_StatusCode), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WidgetResourceResponse[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WidgetResourceResponse) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WidgetResourceResponse) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WidgetResourceResponse) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WidgetResourceResponse) },
        { }};

    static PyType_Spec type_spec_WidgetResourceResponse = {
        "winui3._winui3_microsoft_windows_widgets_providers.WidgetResourceResponse",
        sizeof(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetResourceResponse),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WidgetResourceResponse};

    // ----- WidgetUpdateRequestOptions class --------------------

    static PyObject* _new_WidgetUpdateRequestOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Microsoft::Windows::Widgets::Providers::WidgetUpdateRequestOptions instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WidgetUpdateRequestOptions(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetUpdateRequestOptions* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WidgetUpdateRequestOptions_get_Template(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetUpdateRequestOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetUpdateRequestOptions", L"Template");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Template();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WidgetUpdateRequestOptions_put_Template(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetUpdateRequestOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetUpdateRequestOptions", L"Template");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Template(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WidgetUpdateRequestOptions_get_Data(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetUpdateRequestOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetUpdateRequestOptions", L"Data");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Data();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WidgetUpdateRequestOptions_put_Data(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetUpdateRequestOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetUpdateRequestOptions", L"Data");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.Data(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WidgetUpdateRequestOptions_get_CustomState(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetUpdateRequestOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetUpdateRequestOptions", L"CustomState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CustomState();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WidgetUpdateRequestOptions_put_CustomState(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetUpdateRequestOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetUpdateRequestOptions", L"CustomState");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::hstring>(arg);

            {
                auto _gil = release_gil();
                self->obj.CustomState(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WidgetUpdateRequestOptions_get_WidgetId(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetUpdateRequestOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetUpdateRequestOptions", L"WidgetId");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.WidgetId();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WidgetUpdateRequestOptions_get_IsPlaceholderContent(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetUpdateRequestOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetUpdateRequestOptions", L"IsPlaceholderContent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsPlaceholderContent();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WidgetUpdateRequestOptions_put_IsPlaceholderContent(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetUpdateRequestOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetUpdateRequestOptions", L"IsPlaceholderContent");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<bool>>(arg);

            {
                auto _gil = release_gil();
                self->obj.IsPlaceholderContent(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WidgetUpdateRequestOptions_get_UnsetValue(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.Windows.Widgets.Providers.WidgetUpdateRequestOptions", L"UnsetValue");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::Windows::Widgets::Providers::WidgetUpdateRequestOptions::UnsetValue();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WidgetUpdateRequestOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Widgets::Providers::WidgetUpdateRequestOptions>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WidgetUpdateRequestOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Widgets::Providers::WidgetUpdateRequestOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WidgetUpdateRequestOptions[] = {
        { "_assign_array_", _assign_array_WidgetUpdateRequestOptions, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WidgetUpdateRequestOptions), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WidgetUpdateRequestOptions[] = {
        { "template", reinterpret_cast<getter>(WidgetUpdateRequestOptions_get_Template), reinterpret_cast<setter>(WidgetUpdateRequestOptions_put_Template), nullptr, nullptr },
        { "data", reinterpret_cast<getter>(WidgetUpdateRequestOptions_get_Data), reinterpret_cast<setter>(WidgetUpdateRequestOptions_put_Data), nullptr, nullptr },
        { "custom_state", reinterpret_cast<getter>(WidgetUpdateRequestOptions_get_CustomState), reinterpret_cast<setter>(WidgetUpdateRequestOptions_put_CustomState), nullptr, nullptr },
        { "widget_id", reinterpret_cast<getter>(WidgetUpdateRequestOptions_get_WidgetId), nullptr, nullptr, nullptr },
        { "is_placeholder_content", reinterpret_cast<getter>(WidgetUpdateRequestOptions_get_IsPlaceholderContent), reinterpret_cast<setter>(WidgetUpdateRequestOptions_put_IsPlaceholderContent), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WidgetUpdateRequestOptions[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WidgetUpdateRequestOptions) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WidgetUpdateRequestOptions) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WidgetUpdateRequestOptions) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WidgetUpdateRequestOptions) },
        { }};

    static PyType_Spec type_spec_WidgetUpdateRequestOptions = {
        "winui3._winui3_microsoft_windows_widgets_providers.WidgetUpdateRequestOptions",
        sizeof(py::wrapper::Microsoft::Windows::Widgets::Providers::WidgetUpdateRequestOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WidgetUpdateRequestOptions};

    static PyGetSetDef getset_WidgetUpdateRequestOptions_Static[] = {
        { "unset_value", reinterpret_cast<getter>(WidgetUpdateRequestOptions_get_UnsetValue), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_WidgetUpdateRequestOptions_Static[] = {
        { }};

    static PyType_Slot type_slots_WidgetUpdateRequestOptions_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_WidgetUpdateRequestOptions_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_WidgetUpdateRequestOptions_Static) },
        { }
    };

    static PyType_Spec type_spec_WidgetUpdateRequestOptions_Static = {
        "winui3._winui3_microsoft_windows_widgets_providers.WidgetUpdateRequestOptions_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_WidgetUpdateRequestOptions_Static};

    // ----- IWidgetManager interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IWidgetManager(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::IWidgetManager>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::IWidgetManager>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IWidgetManager(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetManager* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWidgetManager_DeleteWidget(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.IWidgetManager", L"DeleteWidget", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.DeleteWidget(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWidgetManager_GetWidgetIds(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.IWidgetManager", L"GetWidgetIds", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetWidgetIds();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWidgetManager_GetWidgetInfo(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.IWidgetManager", L"GetWidgetInfo", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetWidgetInfo(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWidgetManager_GetWidgetInfos(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.IWidgetManager", L"GetWidgetInfos", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetWidgetInfos();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWidgetManager_UpdateWidget(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetManager* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.IWidgetManager", L"UpdateWidget", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::Windows::Widgets::Providers::WidgetUpdateRequestOptions>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.UpdateWidget(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWidgetManager[] = {
        { "delete_widget", reinterpret_cast<PyCFunction>(IWidgetManager_DeleteWidget), METH_VARARGS, nullptr },
        { "get_widget_ids", reinterpret_cast<PyCFunction>(IWidgetManager_GetWidgetIds), METH_VARARGS, nullptr },
        { "get_widget_info", reinterpret_cast<PyCFunction>(IWidgetManager_GetWidgetInfo), METH_VARARGS, nullptr },
        { "get_widget_infos", reinterpret_cast<PyCFunction>(IWidgetManager_GetWidgetInfos), METH_VARARGS, nullptr },
        { "update_widget", reinterpret_cast<PyCFunction>(IWidgetManager_UpdateWidget), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IWidgetManager[] = {
        { }};

    static PyType_Slot _type_slots_IWidgetManager[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IWidgetManager) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWidgetManager) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWidgetManager) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWidgetManager) },
        { }};

    static PyType_Spec type_spec_IWidgetManager = {
        "winui3._winui3_microsoft_windows_widgets_providers._IWidgetManager",
        sizeof(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetManager),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IWidgetManager};

    struct ImplementsIWidgetManager : py::ImplementsInterfaceT<ImplementsIWidgetManager, winrt::Microsoft::Windows::Widgets::Providers::IWidgetManager>
    {
        ImplementsIWidgetManager() = delete;
        ImplementsIWidgetManager(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIWidgetManager, winrt::Microsoft::Windows::Widgets::Providers::IWidgetManager>(py_obj, runtime_class)
        {
        }

        auto DeleteWidget(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "delete_widget")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetWidgetIds()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_widget_ids")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto return_buf = py::convert_to<py::pybuf_view<winrt::hstring, false>>(return_value.get());
                return winrt::com_array<winrt::hstring>{return_buf.begin(), return_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetWidgetInfo(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_widget_info")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                return py::convert_to<winrt::Microsoft::Windows::Widgets::Providers::WidgetInfo>(return_value.get());
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto GetWidgetInfos()
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "get_widget_infos")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallNoArgs(method.get())};
                if (!return_value)
                {
                    throw python_exception();
                }

                auto return_buf = py::convert_to<py::pybuf_view<winrt::Microsoft::Windows::Widgets::Providers::WidgetInfo, false>>(return_value.get());
                return winrt::com_array<winrt::Microsoft::Windows::Widgets::Providers::WidgetInfo>{return_buf.begin(), return_buf.end()};
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto UpdateWidget(winrt::Microsoft::Windows::Widgets::Providers::WidgetUpdateRequestOptions const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "update_widget")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IWidgetManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Widgets::Providers::IWidgetManager>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWidgetManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Widgets::Providers::IWidgetManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIWidgetManager(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Microsoft::Windows::Widgets::Providers::IWidgetManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIWidgetManager(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIWidgetManager>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIWidgetManager[] = {
        { "_assign_array_", _assign_array_IWidgetManager, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWidgetManager), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIWidgetManager), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIWidgetManager), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIWidgetManager[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIWidgetManager) },
        { }};

    static PyType_Spec type_spec_ImplementsIWidgetManager = {
        "winui3._winui3_microsoft_windows_widgets_providers.IWidgetManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIWidgetManager};

    // ----- IWidgetManager2 interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IWidgetManager2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::IWidgetManager2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::IWidgetManager2>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IWidgetManager2(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetManager2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWidgetManager2_SendMessageToContent(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetManager2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.IWidgetManager2", L"SendMessageToContent", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.SendMessageToContent(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWidgetManager2[] = {
        { "send_message_to_content", reinterpret_cast<PyCFunction>(IWidgetManager2_SendMessageToContent), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IWidgetManager2[] = {
        { }};

    static PyType_Slot _type_slots_IWidgetManager2[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IWidgetManager2) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWidgetManager2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWidgetManager2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWidgetManager2) },
        { }};

    static PyType_Spec type_spec_IWidgetManager2 = {
        "winui3._winui3_microsoft_windows_widgets_providers._IWidgetManager2",
        sizeof(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetManager2),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IWidgetManager2};

    struct ImplementsIWidgetManager2 : py::ImplementsInterfaceT<ImplementsIWidgetManager2, winrt::Microsoft::Windows::Widgets::Providers::IWidgetManager2>
    {
        ImplementsIWidgetManager2() = delete;
        ImplementsIWidgetManager2(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIWidgetManager2, winrt::Microsoft::Windows::Widgets::Providers::IWidgetManager2>(py_obj, runtime_class)
        {
        }

        auto SendMessageToContent(winrt::hstring const& param0, winrt::hstring const& param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "send_message_to_content")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IWidgetManager2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Widgets::Providers::IWidgetManager2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWidgetManager2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Widgets::Providers::IWidgetManager2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIWidgetManager2(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Microsoft::Windows::Widgets::Providers::IWidgetManager2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIWidgetManager2(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIWidgetManager2>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIWidgetManager2[] = {
        { "_assign_array_", _assign_array_IWidgetManager2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWidgetManager2), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIWidgetManager2), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIWidgetManager2), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIWidgetManager2[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIWidgetManager2) },
        { }};

    static PyType_Spec type_spec_ImplementsIWidgetManager2 = {
        "winui3._winui3_microsoft_windows_widgets_providers.IWidgetManager2",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIWidgetManager2};

    // ----- IWidgetProvider interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IWidgetProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProvider>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IWidgetProvider(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWidgetProvider_Activate(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.IWidgetProvider", L"Activate", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::Windows::Widgets::Providers::WidgetContext>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.Activate(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWidgetProvider_CreateWidget(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.IWidgetProvider", L"CreateWidget", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::Windows::Widgets::Providers::WidgetContext>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.CreateWidget(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWidgetProvider_Deactivate(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.IWidgetProvider", L"Deactivate", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.Deactivate(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWidgetProvider_DeleteWidget(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 2)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.IWidgetProvider", L"DeleteWidget", 2);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(2);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                {
                    auto _gil = release_gil();
                    self->obj.DeleteWidget(param0, param1);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWidgetProvider_OnActionInvoked(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.IWidgetProvider", L"OnActionInvoked", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::Windows::Widgets::Providers::WidgetActionInvokedArgs>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.OnActionInvoked(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWidgetProvider_OnWidgetContextChanged(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.IWidgetProvider", L"OnWidgetContextChanged", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::Windows::Widgets::Providers::WidgetContextChangedArgs>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.OnWidgetContextChanged(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWidgetProvider[] = {
        { "activate", reinterpret_cast<PyCFunction>(IWidgetProvider_Activate), METH_VARARGS, nullptr },
        { "create_widget", reinterpret_cast<PyCFunction>(IWidgetProvider_CreateWidget), METH_VARARGS, nullptr },
        { "deactivate", reinterpret_cast<PyCFunction>(IWidgetProvider_Deactivate), METH_VARARGS, nullptr },
        { "delete_widget", reinterpret_cast<PyCFunction>(IWidgetProvider_DeleteWidget), METH_VARARGS, nullptr },
        { "on_action_invoked", reinterpret_cast<PyCFunction>(IWidgetProvider_OnActionInvoked), METH_VARARGS, nullptr },
        { "on_widget_context_changed", reinterpret_cast<PyCFunction>(IWidgetProvider_OnWidgetContextChanged), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IWidgetProvider[] = {
        { }};

    static PyType_Slot _type_slots_IWidgetProvider[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IWidgetProvider) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWidgetProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWidgetProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWidgetProvider) },
        { }};

    static PyType_Spec type_spec_IWidgetProvider = {
        "winui3._winui3_microsoft_windows_widgets_providers._IWidgetProvider",
        sizeof(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetProvider),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IWidgetProvider};

    struct ImplementsIWidgetProvider : py::ImplementsInterfaceT<ImplementsIWidgetProvider, winrt::Microsoft::Windows::Widgets::Providers::IWidgetProvider>
    {
        ImplementsIWidgetProvider() = delete;
        ImplementsIWidgetProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIWidgetProvider, winrt::Microsoft::Windows::Widgets::Providers::IWidgetProvider>(py_obj, runtime_class)
        {
        }

        auto Activate(winrt::Microsoft::Windows::Widgets::Providers::WidgetContext const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "activate")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto CreateWidget(winrt::Microsoft::Windows::Widgets::Providers::WidgetContext const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "create_widget")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto Deactivate(winrt::hstring const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "deactivate")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto DeleteWidget(winrt::hstring const& param0, winrt::hstring const& param1)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "delete_widget")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param1{py::convert(param1)};
                if (!py_param1)
                {
                    throw python_exception();
                }

                py::pyobj_handle args{PyTuple_Pack(2, py_param0.get(), py_param1.get())};
                if (!args)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallObject(method.get(), args.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto OnActionInvoked(winrt::Microsoft::Windows::Widgets::Providers::WidgetActionInvokedArgs const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "on_action_invoked")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }

        auto OnWidgetContextChanged(winrt::Microsoft::Windows::Widgets::Providers::WidgetContextChangedArgs const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "on_widget_context_changed")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IWidgetProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWidgetProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIWidgetProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIWidgetProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIWidgetProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIWidgetProvider[] = {
        { "_assign_array_", _assign_array_IWidgetProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWidgetProvider), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIWidgetProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIWidgetProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIWidgetProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIWidgetProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsIWidgetProvider = {
        "winui3._winui3_microsoft_windows_widgets_providers.IWidgetProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIWidgetProvider};

    // ----- IWidgetProvider2 interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IWidgetProvider2(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProvider2>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProvider2>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IWidgetProvider2(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetProvider2* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWidgetProvider2_OnCustomizationRequested(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetProvider2* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.IWidgetProvider2", L"OnCustomizationRequested", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::Windows::Widgets::Providers::WidgetCustomizationRequestedArgs>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.OnCustomizationRequested(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWidgetProvider2[] = {
        { "on_customization_requested", reinterpret_cast<PyCFunction>(IWidgetProvider2_OnCustomizationRequested), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IWidgetProvider2[] = {
        { }};

    static PyType_Slot _type_slots_IWidgetProvider2[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IWidgetProvider2) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWidgetProvider2) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWidgetProvider2) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWidgetProvider2) },
        { }};

    static PyType_Spec type_spec_IWidgetProvider2 = {
        "winui3._winui3_microsoft_windows_widgets_providers._IWidgetProvider2",
        sizeof(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetProvider2),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IWidgetProvider2};

    struct ImplementsIWidgetProvider2 : py::ImplementsInterfaceT<ImplementsIWidgetProvider2, winrt::Microsoft::Windows::Widgets::Providers::IWidgetProvider2>
    {
        ImplementsIWidgetProvider2() = delete;
        ImplementsIWidgetProvider2(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIWidgetProvider2, winrt::Microsoft::Windows::Widgets::Providers::IWidgetProvider2>(py_obj, runtime_class)
        {
        }

        auto OnCustomizationRequested(winrt::Microsoft::Windows::Widgets::Providers::WidgetCustomizationRequestedArgs const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "on_customization_requested")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IWidgetProvider2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProvider2>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWidgetProvider2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProvider2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIWidgetProvider2(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProvider2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIWidgetProvider2(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIWidgetProvider2>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIWidgetProvider2[] = {
        { "_assign_array_", _assign_array_IWidgetProvider2, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWidgetProvider2), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIWidgetProvider2), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIWidgetProvider2), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIWidgetProvider2[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIWidgetProvider2) },
        { }};

    static PyType_Spec type_spec_ImplementsIWidgetProvider2 = {
        "winui3._winui3_microsoft_windows_widgets_providers.IWidgetProvider2",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIWidgetProvider2};

    // ----- IWidgetProviderAnalytics interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IWidgetProviderAnalytics(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProviderAnalytics>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProviderAnalytics>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IWidgetProviderAnalytics(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetProviderAnalytics* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWidgetProviderAnalytics_OnAnalyticsInfoReported(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetProviderAnalytics* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.IWidgetProviderAnalytics", L"OnAnalyticsInfoReported", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::Windows::Widgets::Providers::WidgetAnalyticsInfoReportedArgs>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.OnAnalyticsInfoReported(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWidgetProviderAnalytics[] = {
        { "on_analytics_info_reported", reinterpret_cast<PyCFunction>(IWidgetProviderAnalytics_OnAnalyticsInfoReported), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IWidgetProviderAnalytics[] = {
        { }};

    static PyType_Slot _type_slots_IWidgetProviderAnalytics[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IWidgetProviderAnalytics) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWidgetProviderAnalytics) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWidgetProviderAnalytics) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWidgetProviderAnalytics) },
        { }};

    static PyType_Spec type_spec_IWidgetProviderAnalytics = {
        "winui3._winui3_microsoft_windows_widgets_providers._IWidgetProviderAnalytics",
        sizeof(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetProviderAnalytics),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IWidgetProviderAnalytics};

    struct ImplementsIWidgetProviderAnalytics : py::ImplementsInterfaceT<ImplementsIWidgetProviderAnalytics, winrt::Microsoft::Windows::Widgets::Providers::IWidgetProviderAnalytics>
    {
        ImplementsIWidgetProviderAnalytics() = delete;
        ImplementsIWidgetProviderAnalytics(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIWidgetProviderAnalytics, winrt::Microsoft::Windows::Widgets::Providers::IWidgetProviderAnalytics>(py_obj, runtime_class)
        {
        }

        auto OnAnalyticsInfoReported(winrt::Microsoft::Windows::Widgets::Providers::WidgetAnalyticsInfoReportedArgs const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "on_analytics_info_reported")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IWidgetProviderAnalytics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProviderAnalytics>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWidgetProviderAnalytics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProviderAnalytics>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIWidgetProviderAnalytics(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProviderAnalytics>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIWidgetProviderAnalytics(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIWidgetProviderAnalytics>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIWidgetProviderAnalytics[] = {
        { "_assign_array_", _assign_array_IWidgetProviderAnalytics, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWidgetProviderAnalytics), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIWidgetProviderAnalytics), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIWidgetProviderAnalytics), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIWidgetProviderAnalytics[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIWidgetProviderAnalytics) },
        { }};

    static PyType_Spec type_spec_ImplementsIWidgetProviderAnalytics = {
        "winui3._winui3_microsoft_windows_widgets_providers.IWidgetProviderAnalytics",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIWidgetProviderAnalytics};

    // ----- IWidgetProviderErrors interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IWidgetProviderErrors(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProviderErrors>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProviderErrors>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IWidgetProviderErrors(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetProviderErrors* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWidgetProviderErrors_OnErrorInfoReported(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetProviderErrors* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.IWidgetProviderErrors", L"OnErrorInfoReported", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::Windows::Widgets::Providers::WidgetErrorInfoReportedArgs>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.OnErrorInfoReported(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWidgetProviderErrors[] = {
        { "on_error_info_reported", reinterpret_cast<PyCFunction>(IWidgetProviderErrors_OnErrorInfoReported), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IWidgetProviderErrors[] = {
        { }};

    static PyType_Slot _type_slots_IWidgetProviderErrors[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IWidgetProviderErrors) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWidgetProviderErrors) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWidgetProviderErrors) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWidgetProviderErrors) },
        { }};

    static PyType_Spec type_spec_IWidgetProviderErrors = {
        "winui3._winui3_microsoft_windows_widgets_providers._IWidgetProviderErrors",
        sizeof(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetProviderErrors),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IWidgetProviderErrors};

    struct ImplementsIWidgetProviderErrors : py::ImplementsInterfaceT<ImplementsIWidgetProviderErrors, winrt::Microsoft::Windows::Widgets::Providers::IWidgetProviderErrors>
    {
        ImplementsIWidgetProviderErrors() = delete;
        ImplementsIWidgetProviderErrors(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIWidgetProviderErrors, winrt::Microsoft::Windows::Widgets::Providers::IWidgetProviderErrors>(py_obj, runtime_class)
        {
        }

        auto OnErrorInfoReported(winrt::Microsoft::Windows::Widgets::Providers::WidgetErrorInfoReportedArgs const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "on_error_info_reported")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IWidgetProviderErrors(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProviderErrors>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWidgetProviderErrors(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProviderErrors>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIWidgetProviderErrors(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProviderErrors>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIWidgetProviderErrors(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIWidgetProviderErrors>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIWidgetProviderErrors[] = {
        { "_assign_array_", _assign_array_IWidgetProviderErrors, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWidgetProviderErrors), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIWidgetProviderErrors), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIWidgetProviderErrors), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIWidgetProviderErrors[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIWidgetProviderErrors) },
        { }};

    static PyType_Spec type_spec_ImplementsIWidgetProviderErrors = {
        "winui3._winui3_microsoft_windows_widgets_providers.IWidgetProviderErrors",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIWidgetProviderErrors};

    // ----- IWidgetProviderMessage interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IWidgetProviderMessage(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProviderMessage>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProviderMessage>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IWidgetProviderMessage(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetProviderMessage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWidgetProviderMessage_OnMessageReceived(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetProviderMessage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.IWidgetProviderMessage", L"OnMessageReceived", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::Windows::Widgets::Providers::WidgetMessageReceivedArgs>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.OnMessageReceived(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWidgetProviderMessage[] = {
        { "on_message_received", reinterpret_cast<PyCFunction>(IWidgetProviderMessage_OnMessageReceived), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IWidgetProviderMessage[] = {
        { }};

    static PyType_Slot _type_slots_IWidgetProviderMessage[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IWidgetProviderMessage) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWidgetProviderMessage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWidgetProviderMessage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWidgetProviderMessage) },
        { }};

    static PyType_Spec type_spec_IWidgetProviderMessage = {
        "winui3._winui3_microsoft_windows_widgets_providers._IWidgetProviderMessage",
        sizeof(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetProviderMessage),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IWidgetProviderMessage};

    struct ImplementsIWidgetProviderMessage : py::ImplementsInterfaceT<ImplementsIWidgetProviderMessage, winrt::Microsoft::Windows::Widgets::Providers::IWidgetProviderMessage>
    {
        ImplementsIWidgetProviderMessage() = delete;
        ImplementsIWidgetProviderMessage(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIWidgetProviderMessage, winrt::Microsoft::Windows::Widgets::Providers::IWidgetProviderMessage>(py_obj, runtime_class)
        {
        }

        auto OnMessageReceived(winrt::Microsoft::Windows::Widgets::Providers::WidgetMessageReceivedArgs const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "on_message_received")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IWidgetProviderMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProviderMessage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWidgetProviderMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProviderMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIWidgetProviderMessage(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Microsoft::Windows::Widgets::Providers::IWidgetProviderMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIWidgetProviderMessage(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIWidgetProviderMessage>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIWidgetProviderMessage[] = {
        { "_assign_array_", _assign_array_IWidgetProviderMessage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWidgetProviderMessage), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIWidgetProviderMessage), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIWidgetProviderMessage), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIWidgetProviderMessage[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIWidgetProviderMessage) },
        { }};

    static PyType_Spec type_spec_ImplementsIWidgetProviderMessage = {
        "winui3._winui3_microsoft_windows_widgets_providers.IWidgetProviderMessage",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIWidgetProviderMessage};

    // ----- IWidgetResourceProvider interface --------------------

    #if PY_VERSION_HEX < 0x030A0000
    static PyObject* _new_IWidgetResourceProvider(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::IWidgetResourceProvider>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::Windows::Widgets::Providers::IWidgetResourceProvider>::type_name);
        return nullptr;
    }
    #endif

    static void _dealloc_IWidgetResourceProvider(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetResourceProvider* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWidgetResourceProvider_OnResourceRequested(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetResourceProvider* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.Windows.Widgets.Providers.IWidgetResourceProvider", L"OnResourceRequested", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::Windows::Widgets::Providers::WidgetResourceRequestedArgs>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.OnResourceRequested(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWidgetResourceProvider[] = {
        { "on_resource_requested", reinterpret_cast<PyCFunction>(IWidgetResourceProvider_OnResourceRequested), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_IWidgetResourceProvider[] = {
        { }};

    static PyType_Slot _type_slots_IWidgetResourceProvider[] = {
        #if PY_VERSION_HEX < 0x030A0000
        { Py_tp_new, reinterpret_cast<void*>(_new_IWidgetResourceProvider) },
        #endif
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_IWidgetResourceProvider) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_IWidgetResourceProvider) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_IWidgetResourceProvider) },
        { }};

    static PyType_Spec type_spec_IWidgetResourceProvider = {
        "winui3._winui3_microsoft_windows_widgets_providers._IWidgetResourceProvider",
        sizeof(py::wrapper::Microsoft::Windows::Widgets::Providers::IWidgetResourceProvider),
        0,
        Py_TPFLAGS_DEFAULT
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        _type_slots_IWidgetResourceProvider};

    struct ImplementsIWidgetResourceProvider : py::ImplementsInterfaceT<ImplementsIWidgetResourceProvider, winrt::Microsoft::Windows::Widgets::Providers::IWidgetResourceProvider>
    {
        ImplementsIWidgetResourceProvider() = delete;
        ImplementsIWidgetResourceProvider(PyObject* py_obj, winrt::impl::inspectable_abi* runtime_class) : py::ImplementsInterfaceT<ImplementsIWidgetResourceProvider, winrt::Microsoft::Windows::Widgets::Providers::IWidgetResourceProvider>(py_obj, runtime_class)
        {
        }

        auto OnResourceRequested(winrt::Microsoft::Windows::Widgets::Providers::WidgetResourceRequestedArgs const& param0)
        {
            try
            {
                py::pyobj_handle self{this->get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "on_resource_requested")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _assign_array_IWidgetResourceProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::Windows::Widgets::Providers::IWidgetResourceProvider>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_IWidgetResourceProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::Windows::Widgets::Providers::IWidgetResourceProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _guid_ImplementsIWidgetResourceProvider(PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::guid_of<winrt::Microsoft::Windows::Widgets::Providers::IWidgetResourceProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _make_ImplementsIWidgetResourceProvider(PyObject* /*unused*/, PyObject* args) noexcept
    {
        try
        {
            PyObject* py_obj;
            winrt::impl::inspectable_abi* runtime_class;

            if (!PyArg_ParseTuple(args, "On", &py_obj, &runtime_class))
            {
                return nullptr;
            }

            auto iface{std::make_unique<ImplementsIWidgetResourceProvider>(py_obj, runtime_class)};

            return PyLong_FromVoidPtr(iface.release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef methods_ImplementsIWidgetResourceProvider[] = {
        { "_assign_array_", _assign_array_IWidgetResourceProvider, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWidgetResourceProvider), METH_O | METH_STATIC, nullptr },
        { "_guid_", reinterpret_cast<PyCFunction>(_guid_ImplementsIWidgetResourceProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "_make_", reinterpret_cast<PyCFunction>(_make_ImplementsIWidgetResourceProvider), METH_VARARGS | METH_STATIC, nullptr },
        { }};

    static PyType_Slot type_slots_ImplementsIWidgetResourceProvider[] = {
        { Py_tp_methods, reinterpret_cast<void*>(methods_ImplementsIWidgetResourceProvider) },
        { }};

    static PyType_Spec type_spec_ImplementsIWidgetResourceProvider = {
        "winui3._winui3_microsoft_windows_widgets_providers.IWidgetResourceProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE
        #if PY_VERSION_HEX >= 0x030A0000
        | Py_TPFLAGS_DISALLOW_INSTANTIATION
        #endif
        ,
        type_slots_ImplementsIWidgetResourceProvider};

    // ----- Microsoft.Windows.Widgets.Providers Initialization --------------------

    PyDoc_STRVAR(module_doc, "Microsoft.Windows.Widgets.Providers");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winui3_microsoft_windows_widgets_providers",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Microsoft::Windows::Widgets::Providers

PyMODINIT_FUNC PyInit__winui3_microsoft_windows_widgets_providers(void) noexcept
{
    using namespace py::cpp::Microsoft::Windows::Widgets::Providers;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pytype_handle WidgetActionInvokedArgs_type{py::register_python_type(module.get(), &type_spec_WidgetActionInvokedArgs, object_bases.get(), inspectable_meta_type)};
    if (!WidgetActionInvokedArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WidgetAnalyticsInfoReportedArgs_type{py::register_python_type(module.get(), &type_spec_WidgetAnalyticsInfoReportedArgs, object_bases.get(), inspectable_meta_type)};
    if (!WidgetAnalyticsInfoReportedArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WidgetContext_type{py::register_python_type(module.get(), &type_spec_WidgetContext, object_bases.get(), inspectable_meta_type)};
    if (!WidgetContext_type)
    {
        return nullptr;
    }

    py::pytype_handle WidgetContextChangedArgs_type{py::register_python_type(module.get(), &type_spec_WidgetContextChangedArgs, object_bases.get(), inspectable_meta_type)};
    if (!WidgetContextChangedArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WidgetCustomizationRequestedArgs_type{py::register_python_type(module.get(), &type_spec_WidgetCustomizationRequestedArgs, object_bases.get(), inspectable_meta_type)};
    if (!WidgetCustomizationRequestedArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WidgetErrorInfoReportedArgs_type{py::register_python_type(module.get(), &type_spec_WidgetErrorInfoReportedArgs, object_bases.get(), inspectable_meta_type)};
    if (!WidgetErrorInfoReportedArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WidgetInfo_type{py::register_python_type(module.get(), &type_spec_WidgetInfo, object_bases.get(), inspectable_meta_type)};
    if (!WidgetInfo_type)
    {
        return nullptr;
    }

    py::pyobj_handle WidgetManager_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!WidgetManager_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_WidgetManager_Static{PyType_FromSpecWithBases(&type_spec_WidgetManager_Static, WidgetManager_Static_bases.get())};
    if (!type_WidgetManager_Static)
    {
        return nullptr;
    }

    py::pytype_handle WidgetManager_type{py::register_python_type(module.get(), &type_spec_WidgetManager, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_WidgetManager_Static.get()))};
    if (!WidgetManager_type)
    {
        return nullptr;
    }

    py::pytype_handle WidgetMessageReceivedArgs_type{py::register_python_type(module.get(), &type_spec_WidgetMessageReceivedArgs, object_bases.get(), inspectable_meta_type)};
    if (!WidgetMessageReceivedArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WidgetResourceRequest_type{py::register_python_type(module.get(), &type_spec_WidgetResourceRequest, object_bases.get(), inspectable_meta_type)};
    if (!WidgetResourceRequest_type)
    {
        return nullptr;
    }

    py::pytype_handle WidgetResourceRequestedArgs_type{py::register_python_type(module.get(), &type_spec_WidgetResourceRequestedArgs, object_bases.get(), inspectable_meta_type)};
    if (!WidgetResourceRequestedArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle WidgetResourceResponse_type{py::register_python_type(module.get(), &type_spec_WidgetResourceResponse, object_bases.get(), inspectable_meta_type)};
    if (!WidgetResourceResponse_type)
    {
        return nullptr;
    }

    py::pyobj_handle WidgetUpdateRequestOptions_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!WidgetUpdateRequestOptions_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_WidgetUpdateRequestOptions_Static{PyType_FromSpecWithBases(&type_spec_WidgetUpdateRequestOptions_Static, WidgetUpdateRequestOptions_Static_bases.get())};
    if (!type_WidgetUpdateRequestOptions_Static)
    {
        return nullptr;
    }

    py::pytype_handle WidgetUpdateRequestOptions_type{py::register_python_type(module.get(), &type_spec_WidgetUpdateRequestOptions, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_WidgetUpdateRequestOptions_Static.get()))};
    if (!WidgetUpdateRequestOptions_type)
    {
        return nullptr;
    }

    py::pytype_handle IWidgetManager_type{py::register_python_type(module.get(), &type_spec_IWidgetManager, object_bases.get(), nullptr)};
    if (!IWidgetManager_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIWidgetManager_type{py::register_python_type(module.get(), &type_spec_ImplementsIWidgetManager, nullptr, inspectable_meta_type)};
    if (!ImplementsIWidgetManager_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIWidgetManager_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IWidgetManager2_type{py::register_python_type(module.get(), &type_spec_IWidgetManager2, object_bases.get(), nullptr)};
    if (!IWidgetManager2_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIWidgetManager2_type{py::register_python_type(module.get(), &type_spec_ImplementsIWidgetManager2, nullptr, inspectable_meta_type)};
    if (!ImplementsIWidgetManager2_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIWidgetManager2_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IWidgetProvider_type{py::register_python_type(module.get(), &type_spec_IWidgetProvider, object_bases.get(), nullptr)};
    if (!IWidgetProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIWidgetProvider_type{py::register_python_type(module.get(), &type_spec_ImplementsIWidgetProvider, nullptr, inspectable_meta_type)};
    if (!ImplementsIWidgetProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIWidgetProvider_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IWidgetProvider2_type{py::register_python_type(module.get(), &type_spec_IWidgetProvider2, object_bases.get(), nullptr)};
    if (!IWidgetProvider2_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIWidgetProvider2_type{py::register_python_type(module.get(), &type_spec_ImplementsIWidgetProvider2, nullptr, inspectable_meta_type)};
    if (!ImplementsIWidgetProvider2_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIWidgetProvider2_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IWidgetProviderAnalytics_type{py::register_python_type(module.get(), &type_spec_IWidgetProviderAnalytics, object_bases.get(), nullptr)};
    if (!IWidgetProviderAnalytics_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIWidgetProviderAnalytics_type{py::register_python_type(module.get(), &type_spec_ImplementsIWidgetProviderAnalytics, nullptr, inspectable_meta_type)};
    if (!ImplementsIWidgetProviderAnalytics_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIWidgetProviderAnalytics_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IWidgetProviderErrors_type{py::register_python_type(module.get(), &type_spec_IWidgetProviderErrors, object_bases.get(), nullptr)};
    if (!IWidgetProviderErrors_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIWidgetProviderErrors_type{py::register_python_type(module.get(), &type_spec_ImplementsIWidgetProviderErrors, nullptr, inspectable_meta_type)};
    if (!ImplementsIWidgetProviderErrors_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIWidgetProviderErrors_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IWidgetProviderMessage_type{py::register_python_type(module.get(), &type_spec_IWidgetProviderMessage, object_bases.get(), nullptr)};
    if (!IWidgetProviderMessage_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIWidgetProviderMessage_type{py::register_python_type(module.get(), &type_spec_ImplementsIWidgetProviderMessage, nullptr, inspectable_meta_type)};
    if (!ImplementsIWidgetProviderMessage_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIWidgetProviderMessage_type.get()) == -1)
    {
        return nullptr;
    }

    py::pytype_handle IWidgetResourceProvider_type{py::register_python_type(module.get(), &type_spec_IWidgetResourceProvider, object_bases.get(), nullptr)};
    if (!IWidgetResourceProvider_type)
    {
        return nullptr;
    }

    py::pytype_handle ImplementsIWidgetResourceProvider_type{py::register_python_type(module.get(), &type_spec_ImplementsIWidgetResourceProvider, nullptr, inspectable_meta_type)};
    if (!ImplementsIWidgetResourceProvider_type)
    {
        return nullptr;
    }

    if (PyModule_AddType(module.get(), ImplementsIWidgetResourceProvider_type.get()) == -1)
    {
        return nullptr;
    }


    return module.detach();
}
