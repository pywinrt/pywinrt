// WARNING: Please don't edit this file. It was generated by Python/WinRT v3.2.1

#include "py.Microsoft.UI.Xaml.Media.Imaging.h"

namespace py::cpp::Microsoft::UI::Xaml::Media::Imaging
{
    // ----- BitmapImage class --------------------

    static PyObject* _new_BitmapImage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                winrt::Microsoft::UI::Xaml::Media::Imaging::BitmapImage instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::Imaging::BitmapImage instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BitmapImage(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::BitmapImage* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BitmapImage_Play(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::BitmapImage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.Imaging.BitmapImage", L"Play", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Play();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapImage_Stop(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::BitmapImage* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.Imaging.BitmapImage", L"Stop", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Stop();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapImage_get_UriSource(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::BitmapImage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.BitmapImage", L"UriSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.UriSource();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapImage_put_UriSource(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::BitmapImage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.BitmapImage", L"UriSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            {
                auto _gil = release_gil();
                self->obj.UriSource(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapImage_get_DecodePixelWidth(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::BitmapImage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.BitmapImage", L"DecodePixelWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DecodePixelWidth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapImage_put_DecodePixelWidth(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::BitmapImage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.BitmapImage", L"DecodePixelWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.DecodePixelWidth(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapImage_get_DecodePixelType(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::BitmapImage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.BitmapImage", L"DecodePixelType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DecodePixelType();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapImage_put_DecodePixelType(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::BitmapImage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.BitmapImage", L"DecodePixelType");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Imaging::DecodePixelType>(arg);

            {
                auto _gil = release_gil();
                self->obj.DecodePixelType(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapImage_get_DecodePixelHeight(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::BitmapImage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.BitmapImage", L"DecodePixelHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DecodePixelHeight();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapImage_put_DecodePixelHeight(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::BitmapImage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.BitmapImage", L"DecodePixelHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.DecodePixelHeight(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapImage_get_CreateOptions(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::BitmapImage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.BitmapImage", L"CreateOptions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.CreateOptions();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapImage_put_CreateOptions(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::BitmapImage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.BitmapImage", L"CreateOptions");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Imaging::BitmapCreateOptions>(arg);

            {
                auto _gil = release_gil();
                self->obj.CreateOptions(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapImage_get_AutoPlay(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::BitmapImage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.BitmapImage", L"AutoPlay");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.AutoPlay();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapImage_put_AutoPlay(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::BitmapImage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.BitmapImage", L"AutoPlay");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<bool>(arg);

            {
                auto _gil = release_gil();
                self->obj.AutoPlay(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapImage_get_IsAnimatedBitmap(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::BitmapImage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.BitmapImage", L"IsAnimatedBitmap");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsAnimatedBitmap();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapImage_get_IsPlaying(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::BitmapImage* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.BitmapImage", L"IsPlaying");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.IsPlaying();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapImage_get_AutoPlayProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.BitmapImage", L"AutoPlayProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Media::Imaging::BitmapImage::AutoPlayProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapImage_get_CreateOptionsProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.BitmapImage", L"CreateOptionsProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Media::Imaging::BitmapImage::CreateOptionsProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapImage_get_DecodePixelHeightProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.BitmapImage", L"DecodePixelHeightProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Media::Imaging::BitmapImage::DecodePixelHeightProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapImage_get_DecodePixelTypeProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.BitmapImage", L"DecodePixelTypeProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Media::Imaging::BitmapImage::DecodePixelTypeProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapImage_get_DecodePixelWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.BitmapImage", L"DecodePixelWidthProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Media::Imaging::BitmapImage::DecodePixelWidthProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapImage_get_IsAnimatedBitmapProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.BitmapImage", L"IsAnimatedBitmapProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Media::Imaging::BitmapImage::IsAnimatedBitmapProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapImage_get_IsPlayingProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.BitmapImage", L"IsPlayingProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Media::Imaging::BitmapImage::IsPlayingProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapImage_get_UriSourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.BitmapImage", L"UriSourceProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Media::Imaging::BitmapImage::UriSourceProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapImage_add_DownloadProgress(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::BitmapImage* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Media.Imaging.BitmapImage", L"DownloadProgress");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::Media::Imaging::DownloadProgressEventHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.DownloadProgress(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapImage_remove_DownloadProgress(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::BitmapImage* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Media.Imaging.BitmapImage", L"DownloadProgress");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.DownloadProgress(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapImage_add_ImageFailed(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::BitmapImage* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Media.Imaging.BitmapImage", L"ImageFailed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::ExceptionRoutedEventHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ImageFailed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapImage_remove_ImageFailed(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::BitmapImage* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Media.Imaging.BitmapImage", L"ImageFailed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ImageFailed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapImage_add_ImageOpened(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::BitmapImage* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Media.Imaging.BitmapImage", L"ImageOpened");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::RoutedEventHandler>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.ImageOpened(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapImage_remove_ImageOpened(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::BitmapImage* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Media.Imaging.BitmapImage", L"ImageOpened");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.ImageOpened(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BitmapImage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::Imaging::BitmapImage>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BitmapImage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::Imaging::BitmapImage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BitmapImage[] = {
        { "play", reinterpret_cast<PyCFunction>(BitmapImage_Play), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(BitmapImage_Stop), METH_VARARGS, nullptr },
        { "add_download_progress", reinterpret_cast<PyCFunction>(BitmapImage_add_DownloadProgress), METH_O, nullptr },
        { "remove_download_progress", reinterpret_cast<PyCFunction>(BitmapImage_remove_DownloadProgress), METH_O, nullptr },
        { "add_image_failed", reinterpret_cast<PyCFunction>(BitmapImage_add_ImageFailed), METH_O, nullptr },
        { "remove_image_failed", reinterpret_cast<PyCFunction>(BitmapImage_remove_ImageFailed), METH_O, nullptr },
        { "add_image_opened", reinterpret_cast<PyCFunction>(BitmapImage_add_ImageOpened), METH_O, nullptr },
        { "remove_image_opened", reinterpret_cast<PyCFunction>(BitmapImage_remove_ImageOpened), METH_O, nullptr },
        { "_assign_array_", _assign_array_BitmapImage, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BitmapImage), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_BitmapImage[] = {
        { "uri_source", reinterpret_cast<getter>(BitmapImage_get_UriSource), reinterpret_cast<setter>(BitmapImage_put_UriSource), nullptr, nullptr },
        { "decode_pixel_width", reinterpret_cast<getter>(BitmapImage_get_DecodePixelWidth), reinterpret_cast<setter>(BitmapImage_put_DecodePixelWidth), nullptr, nullptr },
        { "decode_pixel_type", reinterpret_cast<getter>(BitmapImage_get_DecodePixelType), reinterpret_cast<setter>(BitmapImage_put_DecodePixelType), nullptr, nullptr },
        { "decode_pixel_height", reinterpret_cast<getter>(BitmapImage_get_DecodePixelHeight), reinterpret_cast<setter>(BitmapImage_put_DecodePixelHeight), nullptr, nullptr },
        { "create_options", reinterpret_cast<getter>(BitmapImage_get_CreateOptions), reinterpret_cast<setter>(BitmapImage_put_CreateOptions), nullptr, nullptr },
        { "auto_play", reinterpret_cast<getter>(BitmapImage_get_AutoPlay), reinterpret_cast<setter>(BitmapImage_put_AutoPlay), nullptr, nullptr },
        { "is_animated_bitmap", reinterpret_cast<getter>(BitmapImage_get_IsAnimatedBitmap), nullptr, nullptr, nullptr },
        { "is_playing", reinterpret_cast<getter>(BitmapImage_get_IsPlaying), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_BitmapImage[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BitmapImage) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BitmapImage) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BitmapImage) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BitmapImage) },
        { }};

    static PyType_Spec type_spec_BitmapImage = {
        "winui3._winui3_microsoft_ui_xaml_media_imaging.BitmapImage",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::BitmapImage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapImage};

    static PyGetSetDef getset_BitmapImage_Static[] = {
        { "auto_play_property", reinterpret_cast<getter>(BitmapImage_get_AutoPlayProperty), nullptr, nullptr, nullptr },
        { "create_options_property", reinterpret_cast<getter>(BitmapImage_get_CreateOptionsProperty), nullptr, nullptr, nullptr },
        { "decode_pixel_height_property", reinterpret_cast<getter>(BitmapImage_get_DecodePixelHeightProperty), nullptr, nullptr, nullptr },
        { "decode_pixel_type_property", reinterpret_cast<getter>(BitmapImage_get_DecodePixelTypeProperty), nullptr, nullptr, nullptr },
        { "decode_pixel_width_property", reinterpret_cast<getter>(BitmapImage_get_DecodePixelWidthProperty), nullptr, nullptr, nullptr },
        { "is_animated_bitmap_property", reinterpret_cast<getter>(BitmapImage_get_IsAnimatedBitmapProperty), nullptr, nullptr, nullptr },
        { "is_playing_property", reinterpret_cast<getter>(BitmapImage_get_IsPlayingProperty), nullptr, nullptr, nullptr },
        { "uri_source_property", reinterpret_cast<getter>(BitmapImage_get_UriSourceProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_BitmapImage_Static[] = {
        { }};

    static PyType_Slot type_slots_BitmapImage_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BitmapImage_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BitmapImage_Static) },
        { }
    };

    static PyType_Spec type_spec_BitmapImage_Static = {
        "winui3._winui3_microsoft_ui_xaml_media_imaging.BitmapImage_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_BitmapImage_Static};

    // ----- BitmapSource class --------------------

    struct PyWinrtBitmapSource;
    using BasePyWinrtBitmapSource = winrt::Microsoft::UI::Xaml::Media::Imaging::BitmapSourceT<PyWinrtBitmapSource, py::IPywinrtObject>;

    struct PyWinrtBitmapSource : py::py_obj_ref, BasePyWinrtBitmapSource
    {

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtBitmapSource* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_BitmapSource(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Media::Imaging::BitmapSource>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Media::Imaging::BitmapSource>::type_name);
        return nullptr;
    }

    static void _dealloc_BitmapSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BitmapSource_SetSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.Imaging.BitmapSource", L"SetSource", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);

                {
                    auto _gil = release_gil();
                    self->obj.try_as<winrt::Microsoft::UI::Xaml::Media::Imaging::BitmapSource>().SetSource(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapSource_SetSourceAsync(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.Imaging.BitmapSource", L"SetSourceAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Media::Imaging::BitmapSource>().SetSourceAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapSource_get_PixelHeight(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.BitmapSource", L"PixelHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Media::Imaging::BitmapSource>().PixelHeight();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapSource_get_PixelWidth(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.BitmapSource", L"PixelWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Media::Imaging::BitmapSource>().PixelWidth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapSource_get_PixelHeightProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.BitmapSource", L"PixelHeightProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Media::Imaging::BitmapSource::PixelHeightProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapSource_get_PixelWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.BitmapSource", L"PixelWidthProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Media::Imaging::BitmapSource::PixelWidthProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_BitmapSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::Imaging::BitmapSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_BitmapSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::Imaging::BitmapSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BitmapSource[] = {
        { "set_source", reinterpret_cast<PyCFunction>(BitmapSource_SetSource), METH_VARARGS, nullptr },
        { "set_source_async", reinterpret_cast<PyCFunction>(BitmapSource_SetSourceAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_BitmapSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BitmapSource), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_BitmapSource[] = {
        { "pixel_height", reinterpret_cast<getter>(BitmapSource_get_PixelHeight), nullptr, nullptr, nullptr },
        { "pixel_width", reinterpret_cast<getter>(BitmapSource_get_PixelWidth), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_BitmapSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_BitmapSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_BitmapSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_BitmapSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_BitmapSource) },
        { }};

    static PyType_Spec type_spec_BitmapSource = {
        "winui3._winui3_microsoft_ui_xaml_media_imaging.BitmapSource",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_BitmapSource};

    static PyGetSetDef getset_BitmapSource_Static[] = {
        { "pixel_height_property", reinterpret_cast<getter>(BitmapSource_get_PixelHeightProperty), nullptr, nullptr, nullptr },
        { "pixel_width_property", reinterpret_cast<getter>(BitmapSource_get_PixelWidthProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_BitmapSource_Static[] = {
        { }};

    static PyType_Slot type_slots_BitmapSource_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_BitmapSource_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_BitmapSource_Static) },
        { }
    };

    static PyType_Spec type_spec_BitmapSource_Static = {
        "winui3._winui3_microsoft_ui_xaml_media_imaging.BitmapSource_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_BitmapSource_Static};

    // ----- DownloadProgressEventArgs class --------------------

    static PyObject* _new_DownloadProgressEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Media::Imaging::DownloadProgressEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Media::Imaging::DownloadProgressEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_DownloadProgressEventArgs(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::DownloadProgressEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DownloadProgressEventArgs_get_Progress(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::DownloadProgressEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.DownloadProgressEventArgs", L"Progress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Progress();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DownloadProgressEventArgs_put_Progress(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::DownloadProgressEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.DownloadProgressEventArgs", L"Progress");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<int32_t>(arg);

            {
                auto _gil = release_gil();
                self->obj.Progress(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _assign_array_DownloadProgressEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::Imaging::DownloadProgressEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_DownloadProgressEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::Imaging::DownloadProgressEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DownloadProgressEventArgs[] = {
        { "_assign_array_", _assign_array_DownloadProgressEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DownloadProgressEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_DownloadProgressEventArgs[] = {
        { "progress", reinterpret_cast<getter>(DownloadProgressEventArgs_get_Progress), reinterpret_cast<setter>(DownloadProgressEventArgs_put_Progress), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_DownloadProgressEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_DownloadProgressEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_DownloadProgressEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_DownloadProgressEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_DownloadProgressEventArgs) },
        { }};

    static PyType_Spec type_spec_DownloadProgressEventArgs = {
        "winui3._winui3_microsoft_ui_xaml_media_imaging.DownloadProgressEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::DownloadProgressEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DownloadProgressEventArgs};

    // ----- RenderTargetBitmap class --------------------

    static PyObject* _new_RenderTargetBitmap(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::Imaging::RenderTargetBitmap instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RenderTargetBitmap(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::RenderTargetBitmap* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RenderTargetBitmap_GetPixelsAsync(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::RenderTargetBitmap* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.Imaging.RenderTargetBitmap", L"GetPixelsAsync", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.GetPixelsAsync();
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RenderTargetBitmap_RenderAsync(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::RenderTargetBitmap* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.Imaging.RenderTargetBitmap", L"RenderAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RenderAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RenderTargetBitmap_RenderToSizeAsync(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::RenderTargetBitmap* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 3)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.Imaging.RenderTargetBitmap", L"RenderAsync", 3);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(3);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Microsoft::UI::Xaml::UIElement>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.RenderAsync(param0, param1, param2);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RenderTargetBitmap_get_PixelHeight(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::RenderTargetBitmap* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.RenderTargetBitmap", L"PixelHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PixelHeight();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RenderTargetBitmap_get_PixelWidth(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::RenderTargetBitmap* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.RenderTargetBitmap", L"PixelWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PixelWidth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RenderTargetBitmap_get_PixelHeightProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.RenderTargetBitmap", L"PixelHeightProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Media::Imaging::RenderTargetBitmap::PixelHeightProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RenderTargetBitmap_get_PixelWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.RenderTargetBitmap", L"PixelWidthProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Media::Imaging::RenderTargetBitmap::PixelWidthProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_RenderTargetBitmap(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::Imaging::RenderTargetBitmap>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_RenderTargetBitmap(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::Imaging::RenderTargetBitmap>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RenderTargetBitmap[] = {
        { "get_pixels_async", reinterpret_cast<PyCFunction>(RenderTargetBitmap_GetPixelsAsync), METH_VARARGS, nullptr },
        { "render_async", reinterpret_cast<PyCFunction>(RenderTargetBitmap_RenderAsync), METH_VARARGS, nullptr },
        { "render_to_size_async", reinterpret_cast<PyCFunction>(RenderTargetBitmap_RenderToSizeAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_RenderTargetBitmap, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RenderTargetBitmap), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_RenderTargetBitmap[] = {
        { "pixel_height", reinterpret_cast<getter>(RenderTargetBitmap_get_PixelHeight), nullptr, nullptr, nullptr },
        { "pixel_width", reinterpret_cast<getter>(RenderTargetBitmap_get_PixelWidth), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_RenderTargetBitmap[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_RenderTargetBitmap) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_RenderTargetBitmap) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_RenderTargetBitmap) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_RenderTargetBitmap) },
        { }};

    static PyType_Spec type_spec_RenderTargetBitmap = {
        "winui3._winui3_microsoft_ui_xaml_media_imaging.RenderTargetBitmap",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::RenderTargetBitmap),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RenderTargetBitmap};

    static PyGetSetDef getset_RenderTargetBitmap_Static[] = {
        { "pixel_height_property", reinterpret_cast<getter>(RenderTargetBitmap_get_PixelHeightProperty), nullptr, nullptr, nullptr },
        { "pixel_width_property", reinterpret_cast<getter>(RenderTargetBitmap_get_PixelWidthProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_RenderTargetBitmap_Static[] = {
        { }};

    static PyType_Slot type_slots_RenderTargetBitmap_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_RenderTargetBitmap_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_RenderTargetBitmap_Static) },
        { }
    };

    static PyType_Spec type_spec_RenderTargetBitmap_Static = {
        "winui3._winui3_microsoft_ui_xaml_media_imaging.RenderTargetBitmap_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT,
        type_slots_RenderTargetBitmap_Static};

    // ----- SoftwareBitmapSource class --------------------

    static PyObject* _new_SoftwareBitmapSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Microsoft::UI::Xaml::Media::Imaging::SoftwareBitmapSource instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SoftwareBitmapSource(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::SoftwareBitmapSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SoftwareBitmapSource_Close(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::SoftwareBitmapSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.Imaging.SoftwareBitmapSource", L"Close", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Close();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmapSource_SetBitmapAsync(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::SoftwareBitmapSource* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.Imaging.SoftwareBitmapSource", L"SetBitmapAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.SetBitmapAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_SoftwareBitmapSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::Imaging::SoftwareBitmapSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SoftwareBitmapSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::Imaging::SoftwareBitmapSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_SoftwareBitmapSource(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::SoftwareBitmapSource* self, PyObject* /*unused*/) noexcept
    {
        return Py_NewRef(self);
    }

    static PyObject* _exit_SoftwareBitmapSource(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::SoftwareBitmapSource* self, PyObject* /*unused*/) noexcept
    {
        try
        {
            {
                auto _gil = py::release_gil();
                self->obj.Close();
            }

            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SoftwareBitmapSource[] = {
        { "close", reinterpret_cast<PyCFunction>(SoftwareBitmapSource_Close), METH_VARARGS, nullptr },
        { "set_bitmap_async", reinterpret_cast<PyCFunction>(SoftwareBitmapSource_SetBitmapAsync), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_SoftwareBitmapSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SoftwareBitmapSource), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_SoftwareBitmapSource), METH_NOARGS, nullptr },
        { "__exit__", reinterpret_cast<PyCFunction>(_exit_SoftwareBitmapSource), METH_VARARGS, nullptr },
        { }};

    static PyGetSetDef _getset_SoftwareBitmapSource[] = {
        { }};

    static PyType_Slot _type_slots_SoftwareBitmapSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SoftwareBitmapSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SoftwareBitmapSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SoftwareBitmapSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SoftwareBitmapSource) },
        { }};

    static PyType_Spec type_spec_SoftwareBitmapSource = {
        "winui3._winui3_microsoft_ui_xaml_media_imaging.SoftwareBitmapSource",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::SoftwareBitmapSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SoftwareBitmapSource};

    // ----- SurfaceImageSource class --------------------

    struct PyWinrtSurfaceImageSource;
    using BasePyWinrtSurfaceImageSource = winrt::Microsoft::UI::Xaml::Media::Imaging::SurfaceImageSourceT<PyWinrtSurfaceImageSource, py::IPywinrtObject>;

    struct PyWinrtSurfaceImageSource : py::py_obj_ref, BasePyWinrtSurfaceImageSource
    {
        PyWinrtSurfaceImageSource(PyObject* py_obj, int32_t pixelWidth, int32_t pixelHeight) : py::py_obj_ref(py_obj), BasePyWinrtSurfaceImageSource(pixelWidth, pixelHeight) {}
        PyWinrtSurfaceImageSource(PyObject* py_obj, int32_t pixelWidth, int32_t pixelHeight, bool isOpaque) : py::py_obj_ref(py_obj), BasePyWinrtSurfaceImageSource(pixelWidth, pixelHeight, isOpaque) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtSurfaceImageSource* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_SurfaceImageSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Media::Imaging::SurfaceImageSource>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtSurfaceImageSource>(self.get(), param0, param1);

                    auto obj = py::make_py_obj<PyWinrtSurfaceImageSource>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Media::Imaging::SurfaceImageSource instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtSurfaceImageSource>(self.get(), param0, param1, param2);

                    auto obj = py::make_py_obj<PyWinrtSurfaceImageSource>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Media::Imaging::SurfaceImageSource instance{param0, param1, param2};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SurfaceImageSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SurfaceImageSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::Imaging::SurfaceImageSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SurfaceImageSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::Imaging::SurfaceImageSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SurfaceImageSource[] = {
        { "_assign_array_", _assign_array_SurfaceImageSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SurfaceImageSource), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SurfaceImageSource[] = {
        { }};

    static PyType_Slot _type_slots_SurfaceImageSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SurfaceImageSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SurfaceImageSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SurfaceImageSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SurfaceImageSource) },
        { }};

    static PyType_Spec type_spec_SurfaceImageSource = {
        "winui3._winui3_microsoft_ui_xaml_media_imaging.SurfaceImageSource",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_SurfaceImageSource};

    static PyGetSetDef getset_SurfaceImageSource_Static[] = {
        { }};

    static PyMethodDef methods_SurfaceImageSource_Static[] = {
        { }};

    static PyType_Slot type_slots_SurfaceImageSource_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SurfaceImageSource_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SurfaceImageSource_Static) },
        { }
    };

    static PyType_Spec type_spec_SurfaceImageSource_Static = {
        "winui3._winui3_microsoft_ui_xaml_media_imaging.SurfaceImageSource_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_SurfaceImageSource_Static};

    // ----- SvgImageSource class --------------------

    struct PyWinrtSvgImageSource;
    using BasePyWinrtSvgImageSource = winrt::Microsoft::UI::Xaml::Media::Imaging::SvgImageSourceT<PyWinrtSvgImageSource, py::IPywinrtObject>;

    struct PyWinrtSvgImageSource : py::py_obj_ref, BasePyWinrtSvgImageSource
    {
        PyWinrtSvgImageSource(PyObject* py_obj) : py::py_obj_ref(py_obj), BasePyWinrtSvgImageSource() {}
        PyWinrtSvgImageSource(PyObject* py_obj, winrt::Windows::Foundation::Uri uriSource) : py::py_obj_ref(py_obj), BasePyWinrtSvgImageSource(uriSource) {}

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtSvgImageSource* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }
    };

    static PyObject* _new_SvgImageSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);

        auto self_type = get_python_type_for<winrt::Microsoft::UI::Xaml::Media::Imaging::SvgImageSource>();
        if (!self_type)
        {
            return nullptr;
        }

        if (arg_count == 0)
        {
            try
            {
                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtSvgImageSource>(self.get());

                    auto obj = py::make_py_obj<PyWinrtSvgImageSource>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Media::Imaging::SvgImageSource instance{};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                if (type != self_type)
                {
                    py::pyobj_handle self{type->tp_alloc(type, 0)};
                    if (!self)
                    {
                        return nullptr;
                    }

                    std::construct_at(&reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj, nullptr);

                    auto obj_impl = winrt::make_self<PyWinrtSvgImageSource>(self.get(), param0);

                    auto obj = py::make_py_obj<PyWinrtSvgImageSource>(obj_impl, type, self.get());
                    if (!obj)
                    {
                        return nullptr;
                    }

                    reinterpret_cast<py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>*>(self.get())->obj = std::move(obj);

                    return self.detach();
                }

                winrt::Microsoft::UI::Xaml::Media::Imaging::SvgImageSource instance{param0};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SvgImageSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SvgImageSource_SetSourceAsync(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.Imaging.SvgImageSource", L"SetSourceAsync", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);

                return py::convert([&]()
                {
                    auto _gil = release_gil();
                    return self->obj.try_as<winrt::Microsoft::UI::Xaml::Media::Imaging::SvgImageSource>().SetSourceAsync(param0);
                }());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SvgImageSource_get_UriSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.SvgImageSource", L"UriSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Media::Imaging::SvgImageSource>().UriSource();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SvgImageSource_put_UriSource(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.SvgImageSource", L"UriSource");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Media::Imaging::SvgImageSource>().UriSource(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SvgImageSource_get_RasterizePixelWidth(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.SvgImageSource", L"RasterizePixelWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Media::Imaging::SvgImageSource>().RasterizePixelWidth();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SvgImageSource_put_RasterizePixelWidth(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.SvgImageSource", L"RasterizePixelWidth");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Media::Imaging::SvgImageSource>().RasterizePixelWidth(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SvgImageSource_get_RasterizePixelHeight(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.SvgImageSource", L"RasterizePixelHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Media::Imaging::SvgImageSource>().RasterizePixelHeight();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SvgImageSource_put_RasterizePixelHeight(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (!arg)
        {
            PyErr_SetString(PyExc_AttributeError, "can't delete attribute");
            return -1;
        }

        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.SvgImageSource", L"RasterizePixelHeight");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return -1;
            }

            auto param0 = py::convert_to<double>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Media::Imaging::SvgImageSource>().RasterizePixelHeight(param0);
            }

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SvgImageSource_get_RasterizePixelHeightProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.SvgImageSource", L"RasterizePixelHeightProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Media::Imaging::SvgImageSource::RasterizePixelHeightProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SvgImageSource_get_RasterizePixelWidthProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.SvgImageSource", L"RasterizePixelWidthProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Media::Imaging::SvgImageSource::RasterizePixelWidthProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SvgImageSource_get_UriSourceProperty(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.SvgImageSource", L"UriSourceProperty");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return winrt::Microsoft::UI::Xaml::Media::Imaging::SvgImageSource::UriSourceProperty();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SvgImageSource_add_OpenFailed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Media.Imaging.SvgImageSource", L"OpenFailed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Media::Imaging::SvgImageSource, winrt::Microsoft::UI::Xaml::Media::Imaging::SvgImageSourceFailedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Media::Imaging::SvgImageSource>().OpenFailed(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SvgImageSource_remove_OpenFailed(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Media.Imaging.SvgImageSource", L"OpenFailed");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Media::Imaging::SvgImageSource>().OpenFailed(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SvgImageSource_add_Opened(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Media.Imaging.SvgImageSource", L"Opened");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::UI::Xaml::Media::Imaging::SvgImageSource, winrt::Microsoft::UI::Xaml::Media::Imaging::SvgImageSourceOpenedEventArgs>>(arg);

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.try_as<winrt::Microsoft::UI::Xaml::Media::Imaging::SvgImageSource>().Opened(param0);
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SvgImageSource_remove_Opened(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* arg) noexcept
    {
        try
        {
            static std::optional<bool> is_event_present{};

            if (!is_event_present.has_value())
            {
                is_event_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsEventPresent(L"Microsoft.UI.Xaml.Media.Imaging.SvgImageSource", L"Opened");
            }

            if (!is_event_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "event is not available in this version of Windows");
                return nullptr;
            }

            auto param0 = py::convert_to<winrt::event_token>(arg);

            {
                auto _gil = release_gil();
                self->obj.try_as<winrt::Microsoft::UI::Xaml::Media::Imaging::SvgImageSource>().Opened(param0);
            }

            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SvgImageSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::Imaging::SvgImageSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SvgImageSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::Imaging::SvgImageSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SvgImageSource[] = {
        { "set_source_async", reinterpret_cast<PyCFunction>(SvgImageSource_SetSourceAsync), METH_VARARGS, nullptr },
        { "add_open_failed", reinterpret_cast<PyCFunction>(SvgImageSource_add_OpenFailed), METH_O, nullptr },
        { "remove_open_failed", reinterpret_cast<PyCFunction>(SvgImageSource_remove_OpenFailed), METH_O, nullptr },
        { "add_opened", reinterpret_cast<PyCFunction>(SvgImageSource_add_Opened), METH_O, nullptr },
        { "remove_opened", reinterpret_cast<PyCFunction>(SvgImageSource_remove_Opened), METH_O, nullptr },
        { "_assign_array_", _assign_array_SvgImageSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SvgImageSource), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SvgImageSource[] = {
        { "uri_source", reinterpret_cast<getter>(SvgImageSource_get_UriSource), reinterpret_cast<setter>(SvgImageSource_put_UriSource), nullptr, nullptr },
        { "rasterize_pixel_width", reinterpret_cast<getter>(SvgImageSource_get_RasterizePixelWidth), reinterpret_cast<setter>(SvgImageSource_put_RasterizePixelWidth), nullptr, nullptr },
        { "rasterize_pixel_height", reinterpret_cast<getter>(SvgImageSource_get_RasterizePixelHeight), reinterpret_cast<setter>(SvgImageSource_put_RasterizePixelHeight), nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SvgImageSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SvgImageSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SvgImageSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SvgImageSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SvgImageSource) },
        { }};

    static PyType_Spec type_spec_SvgImageSource = {
        "winui3._winui3_microsoft_ui_xaml_media_imaging.SvgImageSource",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_SvgImageSource};

    static PyGetSetDef getset_SvgImageSource_Static[] = {
        { "rasterize_pixel_height_property", reinterpret_cast<getter>(SvgImageSource_get_RasterizePixelHeightProperty), nullptr, nullptr, nullptr },
        { "rasterize_pixel_width_property", reinterpret_cast<getter>(SvgImageSource_get_RasterizePixelWidthProperty), nullptr, nullptr, nullptr },
        { "uri_source_property", reinterpret_cast<getter>(SvgImageSource_get_UriSourceProperty), nullptr, nullptr, nullptr },
        { }};

    static PyMethodDef methods_SvgImageSource_Static[] = {
        { }};

    static PyType_Slot type_slots_SvgImageSource_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_SvgImageSource_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_SvgImageSource_Static) },
        { }
    };

    static PyType_Spec type_spec_SvgImageSource_Static = {
        "winui3._winui3_microsoft_ui_xaml_media_imaging.SvgImageSource_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_SvgImageSource_Static};

    // ----- SvgImageSourceFailedEventArgs class --------------------

    static PyObject* _new_SvgImageSourceFailedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Media::Imaging::SvgImageSourceFailedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Media::Imaging::SvgImageSourceFailedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SvgImageSourceFailedEventArgs(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::SvgImageSourceFailedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SvgImageSourceFailedEventArgs_get_Status(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::SvgImageSourceFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.SvgImageSourceFailedEventArgs", L"Status");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.Status();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_SvgImageSourceFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::Imaging::SvgImageSourceFailedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SvgImageSourceFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::Imaging::SvgImageSourceFailedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SvgImageSourceFailedEventArgs[] = {
        { "_assign_array_", _assign_array_SvgImageSourceFailedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SvgImageSourceFailedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SvgImageSourceFailedEventArgs[] = {
        { "status", reinterpret_cast<getter>(SvgImageSourceFailedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_SvgImageSourceFailedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SvgImageSourceFailedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SvgImageSourceFailedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SvgImageSourceFailedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SvgImageSourceFailedEventArgs) },
        { }};

    static PyType_Spec type_spec_SvgImageSourceFailedEventArgs = {
        "winui3._winui3_microsoft_ui_xaml_media_imaging.SvgImageSourceFailedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::SvgImageSourceFailedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SvgImageSourceFailedEventArgs};

    // ----- SvgImageSourceOpenedEventArgs class --------------------

    static PyObject* _new_SvgImageSourceOpenedEventArgs(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Media::Imaging::SvgImageSourceOpenedEventArgs>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Media::Imaging::SvgImageSourceOpenedEventArgs>::type_name);
        return nullptr;
    }

    static void _dealloc_SvgImageSourceOpenedEventArgs(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::SvgImageSourceOpenedEventArgs* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_SvgImageSourceOpenedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::Imaging::SvgImageSourceOpenedEventArgs>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_SvgImageSourceOpenedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::Imaging::SvgImageSourceOpenedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SvgImageSourceOpenedEventArgs[] = {
        { "_assign_array_", _assign_array_SvgImageSourceOpenedEventArgs, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SvgImageSourceOpenedEventArgs), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_SvgImageSourceOpenedEventArgs[] = {
        { }};

    static PyType_Slot _type_slots_SvgImageSourceOpenedEventArgs[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_SvgImageSourceOpenedEventArgs) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_SvgImageSourceOpenedEventArgs) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_SvgImageSourceOpenedEventArgs) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_SvgImageSourceOpenedEventArgs) },
        { }};

    static PyType_Spec type_spec_SvgImageSourceOpenedEventArgs = {
        "winui3._winui3_microsoft_ui_xaml_media_imaging.SvgImageSourceOpenedEventArgs",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::SvgImageSourceOpenedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SvgImageSourceOpenedEventArgs};

    // ----- VirtualSurfaceImageSource class --------------------

    static PyObject* _new_VirtualSurfaceImageSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                winrt::Microsoft::UI::Xaml::Media::Imaging::VirtualSurfaceImageSource instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                winrt::Microsoft::UI::Xaml::Media::Imaging::VirtualSurfaceImageSource instance{param0, param1, param2};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VirtualSurfaceImageSource(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::VirtualSurfaceImageSource* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _assign_array_VirtualSurfaceImageSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::Imaging::VirtualSurfaceImageSource>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_VirtualSurfaceImageSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::Imaging::VirtualSurfaceImageSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VirtualSurfaceImageSource[] = {
        { "_assign_array_", _assign_array_VirtualSurfaceImageSource, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VirtualSurfaceImageSource), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_VirtualSurfaceImageSource[] = {
        { }};

    static PyType_Slot _type_slots_VirtualSurfaceImageSource[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_VirtualSurfaceImageSource) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_VirtualSurfaceImageSource) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_VirtualSurfaceImageSource) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_VirtualSurfaceImageSource) },
        { }};

    static PyType_Spec type_spec_VirtualSurfaceImageSource = {
        "winui3._winui3_microsoft_ui_xaml_media_imaging.VirtualSurfaceImageSource",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::VirtualSurfaceImageSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VirtualSurfaceImageSource};

    // ----- WriteableBitmap class --------------------

    static PyObject* _new_WriteableBitmap(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        auto arg_count = PyTuple_GET_SIZE(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                winrt::Microsoft::UI::Xaml::Media::Imaging::WriteableBitmap instance{param0, param1};
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WriteableBitmap(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::WriteableBitmap* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WriteableBitmap_Invalidate(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::WriteableBitmap* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 0)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.Imaging.WriteableBitmap", L"Invalidate", 0);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(0);
                    return nullptr;
                }

                {
                    auto _gil = release_gil();
                    self->obj.Invalidate();
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WriteableBitmap_get_PixelBuffer(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::WriteableBitmap* self, void* /*unused*/) noexcept
    {
        try
        {
            static std::optional<bool> is_property_present{};

            if (!is_property_present.has_value())
            {
                is_property_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsPropertyPresent(L"Microsoft.UI.Xaml.Media.Imaging.WriteableBitmap", L"PixelBuffer");
            }

            if (!is_property_present.value())
            {
                PyErr_SetString(PyExc_AttributeError, "property is not available in this version of Windows");
                return nullptr;
            }

            return py::convert([&]()
            {
                auto _gil = release_gil();
                return self->obj.PixelBuffer();
            }());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _assign_array_WriteableBitmap(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::Imaging::WriteableBitmap>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_WriteableBitmap(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::Imaging::WriteableBitmap>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WriteableBitmap[] = {
        { "invalidate", reinterpret_cast<PyCFunction>(WriteableBitmap_Invalidate), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_WriteableBitmap, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WriteableBitmap), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_WriteableBitmap[] = {
        { "pixel_buffer", reinterpret_cast<getter>(WriteableBitmap_get_PixelBuffer), nullptr, nullptr, nullptr },
        { }};

    static PyType_Slot _type_slots_WriteableBitmap[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_WriteableBitmap) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_WriteableBitmap) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_WriteableBitmap) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_WriteableBitmap) },
        { }};

    static PyType_Spec type_spec_WriteableBitmap = {
        "winui3._winui3_microsoft_ui_xaml_media_imaging.WriteableBitmap",
        sizeof(py::wrapper::Microsoft::UI::Xaml::Media::Imaging::WriteableBitmap),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WriteableBitmap};

    // ----- XamlRenderingBackgroundTask class --------------------

    struct PyWinrtXamlRenderingBackgroundTask;
    using BasePyWinrtXamlRenderingBackgroundTask = winrt::Microsoft::UI::Xaml::Media::Imaging::XamlRenderingBackgroundTaskT<PyWinrtXamlRenderingBackgroundTask, py::IPywinrtObject>;

    struct PyWinrtXamlRenderingBackgroundTask : py::py_obj_ref, BasePyWinrtXamlRenderingBackgroundTask
    {

        int32_t __stdcall GetPyObject(PyObject*& obj) override
        {
            obj = py::py_obj_ref::get_py_obj();
            return 0;
        }

        int32_t __stdcall GetComposableInner(winrt::Windows::Foundation::IInspectable& inner) override
        {
            inner = m_inner;
            return winrt::impl::error_ok;
        }

        static void toggle_reference(PyWinrtXamlRenderingBackgroundTask* instance, bool is_last_reference)
        {
            py::py_obj_ref::toggle_reference(instance, is_last_reference);
        }

        int32_t query_interface_tearoff(winrt::guid const& id, void** result) const noexcept override
        {
            return py::py_obj_ref::query_interface_tearoff(id, result);
        }

        std::vector<winrt::guid> get_iids_tearoff() const noexcept override
        {
            return py::py_obj_ref::get_iids_tearoff();
        }

        void OnRun(winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance const& param0)
        {
            auto gil = py::ensure_gil();

            try
            {
                py::pyobj_handle self{get_py_obj()};

                py::pyobj_handle method{PyObject_GetAttrString(self.get(), "_on_run")};
                if (!method)
                {
                    throw python_exception();
                }

                py::pyobj_handle py_param0{py::convert(param0)};
                if (!py_param0)
                {
                    throw python_exception();
                }

                py::pyobj_handle return_value{PyObject_CallOneArg(method.get(), py_param0.get())};
                if (!return_value)
                {
                    throw python_exception();
                }
            }
            catch (python_exception)
            {
                py::write_unraisable_and_throw();
            }
        }
    };

    static PyObject* _new_XamlRenderingBackgroundTask(PyTypeObject* /*unused*/, PyObject* /*unused*/, PyObject* /*unused*/) noexcept
    {
        static_assert(py::py_type<winrt::Microsoft::UI::Xaml::Media::Imaging::XamlRenderingBackgroundTask>::type_name);
        py::set_invalid_activation_error(py::py_type<winrt::Microsoft::UI::Xaml::Media::Imaging::XamlRenderingBackgroundTask>::type_name);
        return nullptr;
    }

    static void _dealloc_XamlRenderingBackgroundTask(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self) noexcept
    {
        auto tp = Py_TYPE(self);
        std::destroy_at(&self->obj);
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* XamlRenderingBackgroundTask_OnRun(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>* self, PyObject* args) noexcept
    {
        auto arg_count = PyTuple_GET_SIZE(args);

        if (arg_count == 1)
        {
            try
            {
                static std::optional<bool> is_overload_present{};

                if (!is_overload_present.has_value())
                {
                    is_overload_present = winrt::Windows::Foundation::Metadata::ApiInformation::IsMethodPresent(L"Microsoft.UI.Xaml.Media.Imaging.XamlRenderingBackgroundTask", L"OnRun", 1);
                }

                if (!is_overload_present.value())
                {
                    py::set_arg_count_version_error(1);
                    return nullptr;
                }

                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance>(args, 0);

                {
                    auto _gil = release_gil();
                    py::get_inner_or_self(self->obj).try_as<winrt::Microsoft::UI::Xaml::Media::Imaging::IXamlRenderingBackgroundTaskOverrides>().OnRun(param0);
                }

                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _assign_array_XamlRenderingBackgroundTask(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        auto array = std::make_unique<py::ComArray<winrt::Microsoft::UI::Xaml::Media::Imaging::XamlRenderingBackgroundTask>>();
        if (!py::cpp::_winrt::Array_Assign(arg, std::move(array)))
        {
            return nullptr;
        }
        Py_RETURN_NONE;
    }

    static PyObject* _from_XamlRenderingBackgroundTask(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Microsoft::UI::Xaml::Media::Imaging::XamlRenderingBackgroundTask>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XamlRenderingBackgroundTask[] = {
        { "_on_run", reinterpret_cast<PyCFunction>(XamlRenderingBackgroundTask_OnRun), METH_VARARGS, nullptr },
        { "_assign_array_", _assign_array_XamlRenderingBackgroundTask, METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XamlRenderingBackgroundTask), METH_O | METH_STATIC, nullptr },
        { }};

    static PyGetSetDef _getset_XamlRenderingBackgroundTask[] = {
        { }};

    static PyType_Slot _type_slots_XamlRenderingBackgroundTask[] = {
        { Py_tp_new, reinterpret_cast<void*>(_new_XamlRenderingBackgroundTask) },
        { Py_tp_dealloc, reinterpret_cast<void*>(_dealloc_XamlRenderingBackgroundTask) },
        { Py_tp_methods, reinterpret_cast<void*>(_methods_XamlRenderingBackgroundTask) },
        { Py_tp_getset, reinterpret_cast<void*>(_getset_XamlRenderingBackgroundTask) },
        { }};

    static PyType_Spec type_spec_XamlRenderingBackgroundTask = {
        "winui3._winui3_microsoft_ui_xaml_media_imaging.XamlRenderingBackgroundTask",
        sizeof(py::winrt_wrapper<winrt::Windows::Foundation::IInspectable>),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        _type_slots_XamlRenderingBackgroundTask};

    static PyGetSetDef getset_XamlRenderingBackgroundTask_Static[] = {
        { }};

    static PyMethodDef methods_XamlRenderingBackgroundTask_Static[] = {
        { }};

    static PyType_Slot type_slots_XamlRenderingBackgroundTask_Static[] = 
    {
        { Py_tp_base, reinterpret_cast<void*>(&PyType_Type) },
        { Py_tp_getset, reinterpret_cast<void*>(getset_XamlRenderingBackgroundTask_Static) },
        { Py_tp_methods, reinterpret_cast<void*>(methods_XamlRenderingBackgroundTask_Static) },
        { }
    };

    static PyType_Spec type_spec_XamlRenderingBackgroundTask_Static = {
        "winui3._winui3_microsoft_ui_xaml_media_imaging.XamlRenderingBackgroundTask_Static",
        static_cast<int>(PyType_Type.tp_basicsize),
        static_cast<int>(PyType_Type.tp_itemsize),
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        type_slots_XamlRenderingBackgroundTask_Static};

    // ----- Microsoft.UI.Xaml.Media.Imaging Initialization --------------------

    PyDoc_STRVAR(module_doc, "Microsoft.UI.Xaml.Media.Imaging");

    static PyModuleDef module_def = {
        PyModuleDef_HEAD_INIT,
        "_winui3_microsoft_ui_xaml_media_imaging",
        module_doc,
        0,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
        nullptr};
} // py::cpp::Microsoft::UI::Xaml::Media::Imaging

PyMODINIT_FUNC PyInit__winui3_microsoft_ui_xaml_media_imaging(void) noexcept
{
    using namespace py::cpp::Microsoft::UI::Xaml::Media::Imaging;

    if (py::import_winrt_runtime() == -1)
    {
        return nullptr;
    }

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto inspectable_meta_type = py::get_inspectable_meta_type();
    if (!inspectable_meta_type)
    {
        return nullptr;
    }

    auto object_type = py::get_object_type();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle object_bases{PyTuple_Pack(1, object_type)};

    if (!object_bases)
    {
        return nullptr;
    }

    py::pyobj_handle microsoft_ui_xaml_media_module{PyImport_ImportModule("winui3._winui3_microsoft_ui_xaml_media")};
    if (!microsoft_ui_xaml_media_module)
    {
        return nullptr;
    }

    py::pyobj_handle microsoft_ui_xaml_media_ImageSource_type{PyObject_GetAttrString(microsoft_ui_xaml_media_module.get(), "ImageSource")};
    if (!microsoft_ui_xaml_media_ImageSource_type)
    {
        return nullptr;
    }

    py::pyobj_handle BitmapSource_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_xaml_media_ImageSource_type.get())))};
    if (!BitmapSource_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_BitmapSource_Static{PyType_FromSpecWithBases(&type_spec_BitmapSource_Static, BitmapSource_Static_bases.get())};
    if (!type_BitmapSource_Static)
    {
        return nullptr;
    }

    py::pyobj_handle BitmapSource_bases{PyTuple_Pack(1, microsoft_ui_xaml_media_ImageSource_type.get())};
    if (!BitmapSource_bases)
    {
        return nullptr;
    }

    py::pytype_handle BitmapSource_type{py::register_python_type(module.get(), &type_spec_BitmapSource, BitmapSource_bases.get(), reinterpret_cast<PyTypeObject*>(type_BitmapSource_Static.get()))};
    if (!BitmapSource_type)
    {
        return nullptr;
    }

    py::pyobj_handle BitmapImage_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(BitmapSource_type.get())))};
    if (!BitmapImage_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_BitmapImage_Static{PyType_FromSpecWithBases(&type_spec_BitmapImage_Static, BitmapImage_Static_bases.get())};
    if (!type_BitmapImage_Static)
    {
        return nullptr;
    }

    py::pyobj_handle BitmapImage_bases{PyTuple_Pack(1, BitmapSource_type.get())};
    if (!BitmapImage_bases)
    {
        return nullptr;
    }

    py::pytype_handle BitmapImage_type{py::register_python_type(module.get(), &type_spec_BitmapImage, BitmapImage_bases.get(), reinterpret_cast<PyTypeObject*>(type_BitmapImage_Static.get()))};
    if (!BitmapImage_type)
    {
        return nullptr;
    }

    py::pytype_handle DownloadProgressEventArgs_type{py::register_python_type(module.get(), &type_spec_DownloadProgressEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!DownloadProgressEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle RenderTargetBitmap_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_xaml_media_ImageSource_type.get())))};
    if (!RenderTargetBitmap_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_RenderTargetBitmap_Static{PyType_FromSpecWithBases(&type_spec_RenderTargetBitmap_Static, RenderTargetBitmap_Static_bases.get())};
    if (!type_RenderTargetBitmap_Static)
    {
        return nullptr;
    }

    py::pyobj_handle RenderTargetBitmap_bases{PyTuple_Pack(1, microsoft_ui_xaml_media_ImageSource_type.get())};
    if (!RenderTargetBitmap_bases)
    {
        return nullptr;
    }

    py::pytype_handle RenderTargetBitmap_type{py::register_python_type(module.get(), &type_spec_RenderTargetBitmap, RenderTargetBitmap_bases.get(), reinterpret_cast<PyTypeObject*>(type_RenderTargetBitmap_Static.get()))};
    if (!RenderTargetBitmap_type)
    {
        return nullptr;
    }

    py::pyobj_handle SoftwareBitmapSource_bases{PyTuple_Pack(1, microsoft_ui_xaml_media_ImageSource_type.get())};
    if (!SoftwareBitmapSource_bases)
    {
        return nullptr;
    }

    py::pytype_handle SoftwareBitmapSource_type{py::register_python_type(module.get(), &type_spec_SoftwareBitmapSource, SoftwareBitmapSource_bases.get(), inspectable_meta_type)};
    if (!SoftwareBitmapSource_type)
    {
        return nullptr;
    }

    py::pyobj_handle SurfaceImageSource_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_xaml_media_ImageSource_type.get())))};
    if (!SurfaceImageSource_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SurfaceImageSource_Static{PyType_FromSpecWithBases(&type_spec_SurfaceImageSource_Static, SurfaceImageSource_Static_bases.get())};
    if (!type_SurfaceImageSource_Static)
    {
        return nullptr;
    }

    py::pyobj_handle SurfaceImageSource_bases{PyTuple_Pack(1, microsoft_ui_xaml_media_ImageSource_type.get())};
    if (!SurfaceImageSource_bases)
    {
        return nullptr;
    }

    py::pytype_handle SurfaceImageSource_type{py::register_python_type(module.get(), &type_spec_SurfaceImageSource, SurfaceImageSource_bases.get(), reinterpret_cast<PyTypeObject*>(type_SurfaceImageSource_Static.get()))};
    if (!SurfaceImageSource_type)
    {
        return nullptr;
    }

    py::pyobj_handle SvgImageSource_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(Py_TYPE(microsoft_ui_xaml_media_ImageSource_type.get())))};
    if (!SvgImageSource_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_SvgImageSource_Static{PyType_FromSpecWithBases(&type_spec_SvgImageSource_Static, SvgImageSource_Static_bases.get())};
    if (!type_SvgImageSource_Static)
    {
        return nullptr;
    }

    py::pyobj_handle SvgImageSource_bases{PyTuple_Pack(1, microsoft_ui_xaml_media_ImageSource_type.get())};
    if (!SvgImageSource_bases)
    {
        return nullptr;
    }

    py::pytype_handle SvgImageSource_type{py::register_python_type(module.get(), &type_spec_SvgImageSource, SvgImageSource_bases.get(), reinterpret_cast<PyTypeObject*>(type_SvgImageSource_Static.get()))};
    if (!SvgImageSource_type)
    {
        return nullptr;
    }

    py::pytype_handle SvgImageSourceFailedEventArgs_type{py::register_python_type(module.get(), &type_spec_SvgImageSourceFailedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!SvgImageSourceFailedEventArgs_type)
    {
        return nullptr;
    }

    py::pytype_handle SvgImageSourceOpenedEventArgs_type{py::register_python_type(module.get(), &type_spec_SvgImageSourceOpenedEventArgs, object_bases.get(), inspectable_meta_type)};
    if (!SvgImageSourceOpenedEventArgs_type)
    {
        return nullptr;
    }

    py::pyobj_handle VirtualSurfaceImageSource_bases{PyTuple_Pack(1, SurfaceImageSource_type.get())};
    if (!VirtualSurfaceImageSource_bases)
    {
        return nullptr;
    }

    py::pytype_handle VirtualSurfaceImageSource_type{py::register_python_type(module.get(), &type_spec_VirtualSurfaceImageSource, VirtualSurfaceImageSource_bases.get(), inspectable_meta_type)};
    if (!VirtualSurfaceImageSource_type)
    {
        return nullptr;
    }

    py::pyobj_handle WriteableBitmap_bases{PyTuple_Pack(1, BitmapSource_type.get())};
    if (!WriteableBitmap_bases)
    {
        return nullptr;
    }

    py::pytype_handle WriteableBitmap_type{py::register_python_type(module.get(), &type_spec_WriteableBitmap, WriteableBitmap_bases.get(), inspectable_meta_type)};
    if (!WriteableBitmap_type)
    {
        return nullptr;
    }

    py::pyobj_handle XamlRenderingBackgroundTask_Static_bases{PyTuple_Pack(1, reinterpret_cast<PyObject*>(inspectable_meta_type))};
    if (!XamlRenderingBackgroundTask_Static_bases)
    {
        return nullptr;
    }

    py::pyobj_handle type_XamlRenderingBackgroundTask_Static{PyType_FromSpecWithBases(&type_spec_XamlRenderingBackgroundTask_Static, XamlRenderingBackgroundTask_Static_bases.get())};
    if (!type_XamlRenderingBackgroundTask_Static)
    {
        return nullptr;
    }

    py::pytype_handle XamlRenderingBackgroundTask_type{py::register_python_type(module.get(), &type_spec_XamlRenderingBackgroundTask, object_bases.get(), reinterpret_cast<PyTypeObject*>(type_XamlRenderingBackgroundTask_Static.get()))};
    if (!XamlRenderingBackgroundTask_type)
    {
        return nullptr;
    }


    return module.detach();
}
